# JavaScript Interview Questions



## Fundamentals & Basics



<details><summary>1. What is JavaScript?</summary>






**Answer:**

JavaScript is a high-level, interpreted, dynamically-typed programming language that is one of the core technologies of the web, alongside HTML and CSS. Originally created for client-side scripting in web browsers, it has evolved into a full-stack language with Node.js enabling server-side development.



**Key Characteristics:**

- **Multi-paradigm:** Supports procedural, object-oriented, and functional programming styles

- **Single-threaded:** Executes code in a single call stack, but achieves concurrency through the event loop and asynchronous operations

- **Just-in-Time (JIT) compiled:** Modern JavaScript engines compile code to machine code at runtime for better performance

- **Prototype-based:** Objects inherit directly from other objects, rather than from classes (though ES6+ added class syntax as syntactic sugar)



**Production Use Cases:**

- Frontend web applications (React, Angular, Vue.js)

- Backend services (Node.js, Express, NestJS)

- Mobile applications (React Native, Ionic)

- Desktop applications (Electron)

- IoT and embedded systems





</details>
<details><summary>2. What are the different data types in JavaScript?</summary>






**Answer:**

JavaScript has **8 data types** divided into two categories:



**Primitive Types (7):**


1. **String:** Textual data (`"hello"`, `'world'`, `` `template` ``)



2. **Number:** Integers and floating-point numbers (`42`, `3.14`, `Infinity`, `NaN`)



3. **BigInt:** Integers larger than 2^53 - 1 (`123n`, `BigInt(123)`)



4. **Boolean:** Logical values (`true`, `false`)



5. **Undefined:** Variable declared but not assigned a value



6. **Null:** Intentional absence of any value



7. **Symbol:** Unique and immutable identifier, often used for object property keys (`Symbol('id')`)




**Non-Primitive Type (1):**


8. **Object:** Collections of key-value pairs, including arrays, functions, dates, maps, sets, etc.




**Type Checking:**

```javascript

typeof "hello"        // "string"

typeof 42             // "number"

typeof true           // "boolean"

typeof undefined      // "undefined"

typeof null           // "object" (historical bug in JavaScript)

typeof Symbol()       // "symbol"

typeof {}             // "object"

typeof []             // "object" (arrays are objects)

typeof function(){}   // "function" (special case)

```



**Production Note:** Always use proper type checking. For arrays, use `Array.isArray()`. For null, check explicitly with `value === null`.





</details>
<details><summary>3. What is the difference between `var`, `let`, and `const`?</summary>






**Answer:**



| Feature | var | let | const |

|---------|-----|-----|-------|

| **Scope** | Function-scoped | Block-scoped | Block-scoped |

| **Hoisting** | Yes (initialized as undefined) | Yes (not initialized - TDZ) | Yes (not initialized - TDZ) |

| **Re-declaration** | Allowed | Not allowed | Not allowed |

| **Re-assignment** | Allowed | Allowed | Not allowed (for primitives) |

| **Global Object Property** | Yes (in browser) | No | No |



**Detailed Explanation:**



**var (legacy):**

```javascript

function varExample() {

  console.log(x); // undefined (hoisted)

  var x = 10;

  

  if (true) {

    var x = 20; // Same variable!

    console.log(x); // 20

  }

  console.log(x); // 20 (not block-scoped)

}

```



**let (modern, reassignable):**

```javascript

function letExample() {

  // console.log(y); // ReferenceError: Cannot access before initialization

  let y = 10;

  

  if (true) {

    let y = 20; // Different variable (block-scoped)

    console.log(y); // 20

  }

  console.log(y); // 10

}

```



**const (modern, constant):**

```javascript

const PI = 3.14159;

// PI = 3.14; // TypeError: Assignment to constant variable



const user = { name: "John" };

user.name = "Jane"; // Allowed! Object properties can change

user = {}; // TypeError: Assignment to constant variable

```



**Production Best Practice:**

- Use `const` by default

- Use `let` only when you need to reassign

- Never use `var` in modern code (causes bugs in large applications)





</details>
<details><summary>4. What is hoisting in JavaScript?</summary>






**Answer:**

Hoisting is JavaScript's default behavior of moving **declarations** (not initializations) to the top of their scope during the compilation phase, before code execution.



**How It Works:**

JavaScript engine processes code in two phases:


1. **Creation Phase:** Memory is allocated for variables and functions



2. **Execution Phase:** Code runs line by line




**Function Hoisting (Full Hoisting):**

```javascript

// This works because function declarations are fully hoisted

greet(); // "Hello!"



function greet() {

  console.log("Hello!");

}

```



**var Hoisting (Declaration Only):**

```javascript

console.log(name); // undefined (not ReferenceError)

var name = "John";

console.log(name); // "John"



// Behind the scenes:

// var name; // declaration hoisted

// console.log(name); // undefined

// name = "John"; // initialization stays in place

```



**let/const Hoisting (Temporal Dead Zone):**

```javascript

// console.log(age); // ReferenceError: Cannot access before initialization

let age = 25;



// Behind the scenes:

// let age; // hoisted but in TDZ

// console.log(age); // ReferenceError

// age = 25; // initialization

```



**Function Expressions vs Declarations:**

```javascript

// Function declaration - fully hoisted

foo(); // Works

function foo() { console.log("foo"); }



// Function expression - only variable is hoisted

// bar(); // TypeError: bar is not a function

var bar = function() { console.log("bar"); };

```



**Production Implications:**

- Always declare variables at the top of their scope for clarity

- Use function declarations when you need hoisting (e.g., mutual recursion)

- Prefer `let`/`const` to avoid hoisting confusion





</details>
<details><summary>5. What is the difference between `==` and `===`?</summary>






**Answer:**



| Operator | Name | Type Coercion | Use Case |

|----------|------|---------------|----------|

| `==` | Loose/Abstract Equality | Yes | Rarely used in production |

| `===` | Strict Equality | No | Default choice |



**`==` (Loose Equality) - Performs Type Coercion:**

```javascript

5 == "5"        // true (string "5" converted to number)

null == undefined  // true (special case)

0 == false      // true (false converted to 0)

"" == false     // true (both converted to 0)

[] == false     // true (array converted to 0)

[1] == 1        // true (array converted to number)

```



**`===` (Strict Equality) - No Type Coercion:**

```javascript

5 === "5"       // false (different types)

null === undefined  // false (different types)

0 === false     // false

"" === false    // false

[] === []       // false (different object references)

NaN === NaN     // false (NaN is not equal to itself)

```



**Type Coercion Rules (for `==`):**



</details>
<details><summary>1. If types are the same, compare like `===`</summary>






</details>
<details><summary>2. `null == undefined` (and vice versa)</summary>






</details>
<details><summary>3. String and Number: convert string to number</summary>






</details>
<details><summary>4. Boolean: convert to number (true→1, false→0)</summary>






</details>
<details><summary>5. Object and primitive: call `valueOf()` or `toString()` on object</summary>






**Production Best Practice:**

```javascript

// ❌ Bad - unpredictable

if (value == null) { } // checks both null and undefined



// ✅ Good - explicit

if (value === null || value === undefined) { }

// or

if (value == null) { } // Only acceptable use case



// ✅ Better - modern approach

if (value ?? defaultValue) { } // nullish coalescing

```



**ESLint Rule:** Most style guides enforce `eqeqeq` rule requiring `===` always.





</details>
<details><summary>6. What is the difference between `null` and `undefined`?</summary>






**Answer:**



| Aspect | undefined | null |

|--------|-----------|------|

| **Type** | `undefined` | `object` (historical bug) |

| **Meaning** | Variable declared but not assigned | Intentional absence of value |

| **Assignment** | JavaScript sets it automatically | Developer explicitly assigns it |

| **Function Return** | Default return value | Must be explicitly returned |



**undefined - Absence of Assignment:**

```javascript

let x;

console.log(x); // undefined



function test(param) {

  console.log(param); // undefined if not passed

}

test();



const obj = { name: "John" };

console.log(obj.age); // undefined (property doesn't exist)



function noReturn() {}

console.log(noReturn()); // undefined

```



**null - Intentional Absence:**

```javascript

let user = null; // Explicitly saying "no user"



function findUser(id) {

  const user = database.find(id);

  return user || null; // Explicitly return null if not found

}



// Clearing references

let data = { large: "object" };

data = null; // Help garbage collector

```



**Comparison:**

```javascript

null == undefined   // true (loose equality)

null === undefined  // false (different types)



typeof null         // "object" (JavaScript bug)

typeof undefined    // "undefined"



Boolean(null)       // false

Boolean(undefined)  // false

```



**Production Best Practice:**

```javascript

// ✅ Use null for intentional "empty" state

let selectedUser = null; // No user selected yet



// ✅ Check for both when dealing with optional values

function processData(data) {

  if (data === null || data === undefined) {

    return defaultData;

  }

  // or using nullish coalescing

  const result = data ?? defaultData;

}



// ✅ Destructuring with defaults

const { name = "Guest" } = user ?? {};

```





</details>
<details><summary>7. What are falsy values in JavaScript?</summary>






**Answer:**

Falsy values are values that are coerced to `false` when evaluated in a Boolean context. JavaScript has **exactly 8 falsy values**:





</details>
<details><summary>1. `false` - The boolean false</summary>






</details>
<details><summary>2. `0` - Zero (number)</summary>






</details>
<details><summary>3. `-0` - Negative zero</summary>






</details>
<details><summary>4. `0n` - BigInt zero</summary>






</details>
<details><summary>5. `""` - Empty string</summary>






</details>
<details><summary>6. `null` - Absence of value</summary>






</details>
<details><summary>7. `undefined` - Uninitialized value</summary>






</details>
<details><summary>8. `NaN` - Not a Number</summary>






**Everything else is truthy**, including:

```javascript

// Truthy values (often confusing)

true            // boolean true

{}              // empty object

[]              // empty array

"false"         // non-empty string

"0"             // non-empty string

42              // non-zero number

-42             // negative number

Infinity        // infinity

new Date()      // date object

function(){}    // function

```



**Common Pitfalls:**

```javascript

// ❌ These are truthy but might seem falsy

if ([]) {

  console.log("Empty array is truthy!"); // This runs

}



if ({}) {

  console.log("Empty object is truthy!"); // This runs

}



// ❌ String "false" is truthy

const value = "false";

if (value) {

  console.log("This runs!"); // Truthy

}



// ❌ Zero checks

const count = 0;

if (count) {

  // Won't run, but 0 might be a valid value

}

```



**Production Best Practices:**

```javascript

// ✅ Explicit checks for meaningful values

if (array.length > 0) { } // Instead of if (array)

if (Object.keys(obj).length > 0) { } // Instead of if (obj)

if (value !== null && value !== undefined) { } // Be explicit



// ✅ Use nullish coalescing for defaults

const count = userInput ?? 0; // Only replaces null/undefined

const count = userInput || 0; // Replaces all falsy (might replace valid 0!)



// ✅ Explicit boolean conversion when needed

const hasData = Boolean(data); // or !!data

```



**Type Coercion Examples:**

```javascript

Boolean(false)       // false

Boolean(0)           // false

Boolean("")          // false

Boolean(null)        // false

Boolean(undefined)   // false

Boolean(NaN)         // false



!!false              // false (double NOT operator)

!!0                  // false

!!"hello"            // true

```





</details>
<details><summary>8. What is type coercion?</summary>






**Answer:**

Type coercion is the automatic or implicit conversion of values from one data type to another by JavaScript. It happens when operators or functions expect a specific type but receive a different type.



**Types of Coercion:**


1. **Implicit Coercion:** JavaScript automatically converts types



2. **Explicit Coercion:** Developer intentionally converts types




**String Coercion:**

```javascript

// Implicit - using + operator

"5" + 3          // "53" (number to string)

"Hello" + true   // "Hellotrue"

"Value: " + null // "Value: null"



// Explicit

String(123)      // "123"

(123).toString() // "123"

"" + 123         // "123" (trick)

```



**Number Coercion:**

```javascript

// Implicit - using -, *, /, % operators

"5" - 2          // 3 (string to number)

"5" * "2"        // 10

"10" / "2"       // 5

"5" - true       // 4 (true becomes 1)



// + doesn't coerce to number if any operand is a string

"5" + 2          // "52" (number to string instead!)



// Explicit

Number("123")    // 123

Number("12.5")   // 12.5

Number("abc")    // NaN

parseInt("123")  // 123

parseFloat("12.5") // 12.5

+"123"           // 123 (unary plus trick)

```



**Boolean Coercion:**

```javascript

// Implicit - in conditions

if (value) { }

value ? "yes" : "no"

!value

value && otherValue

value || defaultValue



// Explicit

Boolean(1)       // true

Boolean(0)       // false

!!value          // double NOT trick

```



**Complex Coercion Examples:**

```javascript

// Array coercion

[1, 2] + [3, 4]  // "1,23,4" (arrays to strings, then concat)

[] + []          // "" (empty strings)

[] + {}          // "[object Object]"

{} + []          // 0 (depends on context!)



// Object coercion

const obj = {

  valueOf() { return 42; },

  toString() { return "hello"; }

};

obj + 1          // 43 (valueOf called)

String(obj)      // "hello" (toString called)



// Comparison coercion

"2" > "12"       // true (string comparison, not numeric)

"2" > 1          // true (coerced to numbers: 2 > 1)

```



**Production Pitfalls & Solutions:**

```javascript

// ❌ Problem: Unexpected concatenation

const total = "5" + 10;  // "510"



// ✅ Solution: Explicit conversion

const total = Number("5") + 10;  // 15

const total = parseInt("5") + 10; // 15



// ❌ Problem: Falsy number 0

const count = 0;

const result = count || 10;  // 10 (0 is falsy!)



// ✅ Solution: Nullish coalescing

const result = count ?? 10;  // 0 (only null/undefined replaced)



// ❌ Problem: Array/Object in conditions

if ([]) { /* always runs */ }



// ✅ Solution: Explicit checks

if (array.length > 0) { /* correct */ }



// ❌ Problem: NaN comparisons

NaN == NaN       // false

NaN === NaN      // false



// ✅ Solution: Use proper check

Number.isNaN(value)  // true if NaN

```



**Best Practices:**

- Always use explicit type conversion in production code for clarity

- Use `===` instead of `==` to avoid coercion issues

- Be cautious with `+` operator (use template literals instead)

- Validate and sanitize user input explicitly





</details>
<details><summary>9. What is the difference between primitive and non-primitive data types?</summary>






**Answer:**



**Primitive Types (Immutable, Pass by Value):**

- String, Number, BigInt, Boolean, Undefined, Null, Symbol

- Stored directly in the **stack**

- Immutable (cannot be changed, only replaced)

- Compared by **value**

- Each variable holds its own copy



**Non-Primitive Types (Mutable, Pass by Reference):**

- Object, Array, Function, Date, RegExp, Map, Set, etc.

- Stored in the **heap**, reference stored in stack

- Mutable (can be modified)

- Compared by **reference** (memory address)

- Variables hold references to the same object



**Memory & Mutability:**

```javascript

// Primitives - Immutable

let x = 10;

let y = x;     // Copy of value

y = 20;

console.log(x); // 10 (unchanged)



let str = "hello";

str[0] = "H";  // No effect (strings are immutable)

console.log(str); // "hello"

str = "Hello"; // Must create new string



// Objects - Mutable

let obj1 = { name: "John" };

let obj2 = obj1;  // Copy of reference

obj2.name = "Jane";

console.log(obj1.name); // "Jane" (both point to same object)



let arr1 = [1, 2, 3];

let arr2 = arr1;

arr2.push(4);

console.log(arr1); // [1, 2, 3, 4]

```



**Comparison:**

```javascript

// Primitives - Value comparison

10 === 10        // true

"hello" === "hello"  // true



// Objects - Reference comparison

{} === {}        // false (different references)

[] === []        // false

const a = { x: 1 };

const b = { x: 1 };

a === b          // false (different objects)



const c = a;

c === a          // true (same reference)

```



**Function Parameters:**

```javascript

// Primitive - Pass by Value

function changePrimitive(num) {

  num = 100; // Local copy changed

}

let x = 10;

changePrimitive(x);

console.log(x); // 10 (unchanged)



// Object - Pass by Reference

function changeObject(obj) {

  obj.name = "Changed"; // Original object modified

}

let user = { name: "John" };

changeObject(user);

console.log(user.name); // "Changed"



// Reassignment doesn't affect original

function reassignObject(obj) {

  obj = { name: "New" }; // Local reference changed

}

let person = { name: "John" };

reassignObject(person);

console.log(person.name); // "John" (unchanged)

```



**Production Implications:**

```javascript

// ❌ Problem: Unintended mutations

function addUser(users, user) {

  users.push(user); // Mutates original array!

  return users;

}



// ✅ Solution: Create copies

function addUser(users, user) {

  return [...users, user]; // New array

}



// ✅ Deep cloning objects

const original = { user: { name: "John" } };

const shallow = { ...original }; // Shallow copy

shallow.user.name = "Jane"; // Mutates original!



const deep = JSON.parse(JSON.stringify(original)); // Deep copy

// or use structuredClone() (modern)

const deep = structuredClone(original);



// ✅ Freezing objects (immutability)

const config = Object.freeze({ apiUrl: "..." });

// config.apiUrl = "new"; // TypeError in strict mode

```



**Memory Efficiency:**

```javascript

// Primitives - Small, fast

let a = 1;

let b = 1; // New value in stack



// Objects - Reference sharing

let user1 = { name: "John", age: 30 };

let user2 = user1; // No copy, just reference

// More memory efficient for large data

```





</details>
<details><summary>10. What is the temporal dead zone?</summary>






**Answer:**

The Temporal Dead Zone (TDZ) is the period between entering a scope and the actual declaration of a variable, during which the variable cannot be accessed. It applies to `let`, `const`, and `class` declarations.



**How It Works:**

```javascript

// TDZ starts here for 'x'

console.log(x); // ReferenceError: Cannot access 'x' before initialization

let x = 10;     // TDZ ends here

console.log(x); // 10

```



**Behind the Scenes:**

```javascript

{

  // TDZ for 'name' starts at block entry

  // Hoisted but not initialized

  

  // console.log(name); // ReferenceError

  // const temp = name; // ReferenceError

  // name = "value";    // ReferenceError

  

  let name = "John"; // TDZ ends - initialization occurs

  console.log(name); // "John" - now accessible

}

```



**Comparison with var:**

```javascript

// var - No TDZ (initialized as undefined)

console.log(varVariable); // undefined

var varVariable = "value";



// let - TDZ exists

console.log(letVariable); // ReferenceError

let letVariable = "value";



// const - TDZ exists (and must be initialized)

// const constVariable; // SyntaxError: Missing initializer

const constVariable = "value";

```



**TDZ in Different Scopes:**

```javascript

// Function parameters TDZ

function example(a = b, b = 2) {

  // 'b' is in TDZ when 'a' is initialized

  return [a, b];

}

// example(); // ReferenceError: Cannot access 'b' before initialization



function correct(a = 2, b = a) {

  return [a, b]; // Works: 'a' is initialized when 'b' needs it

}

correct(); // [2, 2]



// Block scope TDZ

{

  // TDZ for x starts

  const func = () => console.log(x); // Defined but not called

  // func(); // ReferenceError if called here

  let x = 10; // TDZ ends

  func(); // 10 - now works

}

```



**typeof and TDZ:**

```javascript

// var - typeof works

console.log(typeof varVar); // "undefined"

var varVar = 10;



// let - typeof causes ReferenceError in TDZ

console.log(typeof letVar); // ReferenceError (not "undefined")

let letVar = 10;



// Variable that doesn't exist - typeof returns "undefined"

console.log(typeof nonExistent); // "undefined" (no error)

```



**Production Benefits:**

```javascript

// ✅ Catches typos and wrong order bugs

function calculatePrice(quantity) {

  const total = quantity * price; // ReferenceError: good!

  // ... 100 lines of code ...

  let price = 10; // Caught immediately

}



// ❌ With var, this silently fails

function calculatePriceVar(quantity) {

  var total = quantity * price; // undefined * quantity = NaN

  // ... 100 lines of code ...

  var price = 10; // Bug found much later

}



// ✅ Prevents use before declaration

class Dog {

  constructor() {

    this.bark(); // ReferenceError if bark is let/const below

  }

}



// ✅ Enforces initialization order

const config = {

  apiUrl: API_BASE_URL, // Must be declared before

  timeout: 5000

};

const API_BASE_URL = "https://api.example.com";

```



**Best Practices:**

- Declare variables at the top of their scope for clarity

- Initialize `const` immediately when declared

- Use linters (ESLint) to catch TDZ issues: `no-use-before-define` rule

- The TDZ is a feature that helps catch bugs early in development



## Functions





</details>
<details><summary>11. What is a function declaration vs function expression?</summary>






**Answer:**



**Function Declaration:**

```javascript

// Named function that is hoisted

function greet(name) {

  return `Hello, ${name}!`;

}

```



**Function Expression:**

```javascript

// Function assigned to a variable (not hoisted)

const greet = function(name) {

  return `Hello, ${name}!`;

};



// Named function expression (useful for recursion/debugging)

const factorial = function fact(n) {

  return n <= 1 ? 1 : n * fact(n - 1);

};

```



**Key Differences:**



| Aspect | Function Declaration | Function Expression |

|--------|---------------------|---------------------|

| **Hoisting** | Fully hoisted | Only variable hoisted (not function) |

| **When Available** | Before declaration in code | Only after assignment |

| **Name Required** | Yes | Optional (can be anonymous) |

| **Usage Context** | Statement | Can be part of expression |



**Hoisting Behavior:**

```javascript

// ✅ Works - function declaration hoisted

console.log(declared()); // "I'm declared"

function declared() {

  return "I'm declared";

}



// ❌ Error - function expression not hoisted

console.log(expressed()); // TypeError: expressed is not a function

const expressed = function() {

  return "I'm expressed";

};

```



**Use Cases:**



**Function Declaration - When you need hoisting:**

```javascript

// Mutual recursion (functions call each other)

function isEven(n) {

  return n === 0 ? true : isOdd(n - 1);

}



function isOdd(n) {

  return n === 0 ? false : isEven(n - 1);

}

```



**Function Expression - More flexible:**

```javascript

// Conditional function definition

const operation = condition ? 

  function(a, b) { return a + b; } : 

  function(a, b) { return a - b; };



// Callback functions

setTimeout(function() {

  console.log("Timeout");

}, 1000);



// IIFE (Immediately Invoked)

(function() {

  console.log("Running immediately");

})();

```



**Production Best Practices:**

```javascript

// ✅ Use function declarations for top-level functions

function processPayment(amount) {

  // Public API functions

}



// ✅ Use function expressions for callbacks/handlers

button.addEventListener('click', function handleClick(e) {

  // Named for better stack traces

});



// ✅ Arrow functions for short callbacks (covered next)

array.map(item => item * 2);



// ✅ Named function expressions for recursion

const traverse = function walk(node) {

  if (!node) return;

  walk(node.left);

  walk(node.right);

};

```





</details>
<details><summary>12. What are arrow functions and how are they different from regular functions?</summary>






**Answer:**

Arrow functions are a concise syntax for writing function expressions introduced in ES6. They have significant differences from regular functions, particularly regarding `this` binding.



**Syntax Variations:**

```javascript

// Traditional function

const add = function(a, b) {

  return a + b;

};



// Arrow function - full syntax

const add = (a, b) => {

  return a + b;

};



// Implicit return (single expression)

const add = (a, b) => a + b;



// Single parameter (no parentheses needed)

const square = x => x * x;



// No parameters

const greet = () => "Hello!";



// Returning object literal (wrap in parentheses)

const makePerson = (name, age) => ({ name, age });

```



**Key Differences:**



| Feature | Regular Function | Arrow Function |

|---------|-----------------|----------------|

| **`this` binding** | Dynamic (depends on call) | Lexical (from enclosing scope) |

| **`arguments` object** | Yes | No (use rest parameters) |

| **Constructor** | Can use `new` | Cannot use `new` |

| **`prototype` property** | Yes | No |

| **Method syntax** | Works well | Not recommended |

| **Hoisting** | Declaration: yes | No (expression) |



**1. `this` Binding (Most Important Difference):**

```javascript

// Regular function - 'this' depends on how it's called

const person = {

  name: "John",

  regularGreet: function() {

    console.log(`Hello, ${this.name}`);

  },

  arrowGreet: () => {

    console.log(`Hello, ${this.name}`);

  }

};



person.regularGreet(); // "Hello, John" (this = person)

person.arrowGreet();   // "Hello, undefined" (this = global/window)



// Common use case: Event handlers

class Button {

  constructor() {

    this.clicks = 0;

  }

  

  // ❌ Regular function loses context

  handleClickBad() {

    setTimeout(function() {

      this.clicks++; // 'this' is undefined or window

    }, 100);

  }

  

  // ✅ Arrow function preserves context

  handleClickGood() {

    setTimeout(() => {

      this.clicks++; // 'this' is Button instance

    }, 100);

  }

}

```



**2. No `arguments` Object:**

```javascript

// Regular function

function regularSum() {

  return Array.from(arguments).reduce((a, b) => a + b, 0);

}

regularSum(1, 2, 3); // 6



// Arrow function - use rest parameters

const arrowSum = (...args) => args.reduce((a, b) => a + b, 0);

arrowSum(1, 2, 3); // 6

```



**3. Cannot be Used as Constructors:**

```javascript

// Regular function

function Person(name) {

  this.name = name;

}

const john = new Person("John"); // ✅ Works



// Arrow function

const PersonArrow = (name) => {

  this.name = name;

};

// const jane = new PersonArrow("Jane"); // ❌ TypeError: not a constructor

```



**Production Use Cases:**



**✅ When to Use Arrow Functions:**

```javascript

// 1. Array methods

const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(n => n * 2);

const evens = numbers.filter(n => n % 2 === 0);

const sum = numbers.reduce((acc, n) => acc + n, 0);



// 2. Callbacks with context preservation

class DataFetcher {

  constructor() {

    this.data = [];

  }

  

  fetchData() {

    fetch('/api/data')

      .then(response => response.json())

      .then(data => {

        this.data = data; // 'this' correctly refers to DataFetcher

      });

  }

}



// 3. Short, simple functions

const isEven = n => n % 2 === 0;

const double = x => x * 2;



// 4. Event listeners in classes

class Component {

  mount() {

    button.addEventListener('click', () => {

      this.handleClick(); // 'this' is Component instance

    });

  }

}

```



**❌ When NOT to Use Arrow Functions:**

```javascript

// 1. Object methods

const person = {

  name: "John",

  // ❌ Bad - 'this' doesn't refer to person

  greet: () => {

    console.log(`Hello, ${this.name}`); // undefined

  },

  // ✅ Good - use method shorthand or regular function

  greet() {

    console.log(`Hello, ${this.name}`); // "John"

  }

};



// 2. Prototype methods

// ❌ Bad

Person.prototype.getName = () => this.name; // Won't work



// ✅ Good

Person.prototype.getName = function() { return this.name; };



// 3. Event handlers needing 'this' to be the element

// ❌ Bad

button.addEventListener('click', () => {

  this.classList.toggle('active'); // 'this' is not the button

});



// ✅ Good

button.addEventListener('click', function() {

  this.classList.toggle('active'); // 'this' is the button

});



// 4. Functions needing 'arguments'

// ❌ Bad - no arguments object

const logAll = () => console.log(arguments); // ReferenceError



// ✅ Good - use rest parameters

const logAll = (...args) => console.log(args);

```





</details>
<details><summary>13. What is the difference between call, apply, and bind?</summary>






**Answer:**

`call`, `apply`, and `bind` are methods on function objects that allow you to explicitly set the `this` context and pass arguments. They are essential for controlling function execution context.



**call() - Immediate invocation with individual arguments:**

```javascript

function.call(thisArg, arg1, arg2, ...)

```



**apply() - Immediate invocation with array of arguments:**

```javascript

function.apply(thisArg, [arg1, arg2, ...])

```



**bind() - Returns new function with bound context (delayed invocation):**

```javascript

const boundFunction = function.bind(thisArg, arg1, arg2, ...)

```



**Detailed Examples:**



**call() - Execute immediately with comma-separated args:**

```javascript

function greet(greeting, punctuation) {

  return `${greeting}, ${this.name}${punctuation}`;

}



const person = { name: "John" };



greet.call(person, "Hello", "!");  // "Hello, John!"

greet.call(person, "Hi", ".");     // "Hi, John."

```



**apply() - Execute immediately with array of args:**

```javascript

function greet(greeting, punctuation) {

  return `${greeting}, ${this.name}${punctuation}`;

}



const person = { name: "John" };

const args = ["Hello", "!"];



greet.apply(person, args);  // "Hello, John!"

greet.apply(person, ["Hi", "."]); // "Hi, John."

```



**bind() - Create bound function for later:**

```javascript

function greet(greeting, punctuation) {

  return `${greeting}, ${this.name}${punctuation}`;

}



const person = { name: "John" };



// Create bound function

const greetJohn = greet.bind(person, "Hello");

greetJohn("!");  // "Hello, John!"

greetJohn(".");  // "Hello, John."



// Fully bound

const sayHelloJohn = greet.bind(person, "Hello", "!");

sayHelloJohn();  // "Hello, John!"

```



**Comparison Table:**



| Method | Invocation | Arguments Format | Returns | Use Case |

|--------|-----------|------------------|---------|----------|

| **call** | Immediate | Individual (comma-separated) | Function result | One-time execution |

| **apply** | Immediate | Array | Function result | Dynamic arg count |

| **bind** | Delayed | Individual (comma-separated) | New function | Event handlers, callbacks |



**Production Use Cases:**



**1. Borrowing Methods:**

```javascript

// Array methods on array-like objects

const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };



// Using call

const arr = Array.prototype.slice.call(arrayLike);

console.log(arr); // ['a', 'b', 'c']



// Modern alternative

const arr2 = Array.from(arrayLike);



// NodeList to Array

const divs = document.querySelectorAll('div');

const divArray = Array.prototype.map.call(divs, div => div.textContent);

```



**2. Finding Min/Max with apply:**

```javascript

const numbers = [5, 6, 2, 3, 7];



// apply is useful when you have an array

const max = Math.max.apply(null, numbers); // 7

const min = Math.min.apply(null, numbers); // 2



// Modern alternative with spread

const max2 = Math.max(...numbers);

```



**3. Function Composition with bind:**

```javascript

function multiply(a, b) {

  return a * b;

}



// Create specialized functions

const double = multiply.bind(null, 2);

const triple = multiply.bind(null, 3);



console.log(double(5));  // 10

console.log(triple(5));  // 15

```



**4. Event Handlers (Most Common use of bind):**

```javascript

class Counter {

  constructor() {

    this.count = 0;

    // ❌ Without bind, 'this' would be the button

    // button.onclick = this.increment; 

    

    // ✅ bind preserves 'this' context

    button.onclick = this.increment.bind(this);

  }

  

  increment() {

    this.count++;

    console.log(this.count);

  }

}



// Modern alternative: Arrow functions in constructor

class CounterModern {

  constructor() {

    this.count = 0;

    button.onclick = () => this.increment();

  }

  

  increment() {

    this.count++;

  }

}

```



**5. Partial Application (Currying):**

```javascript

function log(level, message, timestamp) {

  console.log(`[${timestamp}] ${level}: ${message}`);

}



// Create specialized loggers

const errorLog = log.bind(null, 'ERROR');

const infoLog = log.bind(null, 'INFO');



errorLog('Database connection failed', Date.now());

infoLog('User logged in', Date.now());

```



**6. Inheritance and Super Calls:**

```javascript

function Animal(name) {

  this.name = name;

}



function Dog(name, breed) {

  // Call parent constructor with current context

  Animal.call(this, name);

  this.breed = breed;

}



const myDog = new Dog('Buddy', 'Golden Retriever');

console.log(myDog.name); // 'Buddy'

```



**Performance & Modern Considerations:**

```javascript

// bind creates a new function each time (memory overhead)

// ❌ Bad in React - creates new function on every render

class Component {

  render() {

    return <button onClick={this.handleClick.bind(this)}>Click</button>;

  }

}



// ✅ Good - bind once in constructor

class Component {

  constructor() {

    this.handleClick = this.handleClick.bind(this);

  }

  render() {

    return <button onClick={this.handleClick}>Click</button>;

  }

}



// ✅ Better - use arrow function (lexical this)

class Component {

  handleClick = () => {

    // 'this' is automatically bound

  }

}

```



**Key Takeaways:**

- Use `call` when you know the exact arguments to pass

- Use `apply` when arguments are in an array (less common with ES6 spread)

- Use `bind` when you need a function with fixed context for later use

- Arrow functions often replace `bind` in modern code

- Remember: You can't rebind arrow functions (they ignore call/apply/bind for `this`)





</details>
<details><summary>14. What are higher-order functions?</summary>






**Answer:**

A higher-order function is a function that either:


1. **Takes one or more functions as arguments** (callbacks), OR



2. **Returns a function as its result**




This concept is fundamental to functional programming and makes JavaScript code more modular, reusable, and expressive.



**Type 1: Functions that Accept Functions (Callbacks):**



```javascript

// Built-in higher-order functions

const numbers = [1, 2, 3, 4, 5];



// map: transforms each element

numbers.map(n => n * 2);  // [2, 4, 6, 8, 10]



// filter: selects elements

numbers.filter(n => n > 3);  // [4, 5]



// reduce: accumulates values

numbers.reduce((sum, n) => sum + n, 0);  // 15



// sort: orders elements

numbers.sort((a, b) => b - a);  // [5, 4, 3, 2, 1]



// forEach: iterates

numbers.forEach(n => console.log(n));

```



**Type 2: Functions that Return Functions:**



```javascript

// Function factory

function createMultiplier(multiplier) {

  return function(number) {

    return number * multiplier;

  };

}



const double = createMultiplier(2);

const triple = createMultiplier(3);



double(5);  // 10

triple(5);  // 15



// Arrow function version

const createMultiplier = (multiplier) => (number) => number * multiplier;

```



**Production Use Cases:**



**1. Data Transformation Pipelines:**

```javascript

// Complex data processing

const users = [

  { name: 'John', age: 25, active: true },

  { name: 'Jane', age: 30, active: false },

  { name: 'Bob', age: 35, active: true }

];



const activeUserNames = users

  .filter(user => user.active)           // Select active users

  .map(user => user.name)                // Extract names

  .map(name => name.toUpperCase());      // Transform to uppercase



// ['JOHN', 'BOB']

```



**2. Custom Higher-Order Functions:**

```javascript

// Retry mechanism

function retry(fn, maxAttempts = 3, delay = 1000) {

  return async function(...args) {

    for (let i = 0; i < maxAttempts; i++) {

      try {

        return await fn(...args);

      } catch (error) {

        if (i === maxAttempts - 1) throw error;

        await new Promise(resolve => setTimeout(resolve, delay));

      }

    }

  };

}



const fetchWithRetry = retry(fetch, 3, 2000);

await fetchWithRetry('/api/data');



// Logging decorator

function withLogging(fn) {

  return function(...args) {

    console.log(`Calling ${fn.name} with`, args);

    const result = fn(...args);

    console.log(`${fn.name} returned`, result);

    return result;

  };

}



const add = (a, b) => a + b;

const addWithLog = withLogging(add);

addWithLog(2, 3); // Logs and returns 5

```



**3. Event Handler Composition:**

```javascript

// Composing middleware-like handlers

function compose(...functions) {

  return function(value) {

    return functions.reduceRight((acc, fn) => fn(acc), value);

  };

}



const addTax = price => price * 1.1;

const addShipping = price => price + 5;

const round = price => Math.round(price * 100) / 100;



const calculateTotal = compose(round, addShipping, addTax);

calculateTotal(100); // 115

```



**4. Authorization & Validation:**

```javascript

// Higher-order function for access control

function requireAuth(handler) {

  return function(req, res) {

    if (!req.user) {

      return res.status(401).json({ error: 'Unauthorized' });

    }

    return handler(req, res);

  };

}



function requireRole(role) {

  return function(handler) {

    return function(req, res) {

      if (req.user.role !== role) {

        return res.status(403).json({ error: 'Forbidden' });

      }

      return handler(req, res);

    };

  };

}



// Usage

const getAdminData = requireRole('admin')(requireAuth(handler));

```



**5. Memoization (Caching):**

```javascript

function memoize(fn) {

  const cache = new Map();

  return function(...args) {

    const key = JSON.stringify(args);

    if (cache.has(key)) {

      console.log('Cache hit');

      return cache.get(key);

    }

    const result = fn(...args);

    cache.set(key, result);

    return result;

  };

}



// Expensive calculation

function fibonacci(n) {

  if (n <= 1) return n;

  return fibonacci(n - 1) + fibonacci(n - 2);

}



const fastFib = memoize(fibonacci);

fastFib(40); // Slow first time

fastFib(40); // Instant second time

```



**6. Debounce & Throttle (Covered in detail later):**

```javascript

// Debounce - delay execution until quiet period

function debounce(fn, delay) {

  let timeoutId;

  return function(...args) {

    clearTimeout(timeoutId);

    timeoutId = setTimeout(() => fn(...args), delay);

  };

}



const searchAPI = debounce(query => {

  fetch(`/api/search?q=${query}`);

}, 300);



input.addEventListener('input', e => searchAPI(e.target.value));

```



**Benefits in Production:**

- **Code Reusability:** Write generic behavior once, apply anywhere

- **Separation of Concerns:** Business logic separate from cross-cutting concerns (logging, auth, caching)

- **Composition:** Build complex behavior from simple functions

- **Testability:** Each function can be tested in isolation

- **Declarative Code:** Express "what" not "how"



**Common Patterns:**

```javascript

// Pipe (left to right composition)

const pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);



// Curry (partial application)

const curry = (fn) => {

  return function curried(...args) {

    if (args.length >= fn.length) {

      return fn.apply(this, args);

    }

    return (...moreArgs) => curried(...args, ...moreArgs);

  };

};



// Once (execute only once)

function once(fn) {

  let called = false;

  let result;

  return function(...args) {

    if (!called) {

      called = true;

      result = fn(...args);

    }

    return result;

  };

}



const initializeApp = once(() => {

  console.log('App initialized');

  return { initialized: true };

});

```





</details>
<details><summary>15. What is a callback function?</summary>






**Answer:**

A callback function is a function passed as an argument to another function, to be executed at a later time. Callbacks are the foundation of asynchronous programming in JavaScript and enable event-driven architecture.



**Basic Concept:**

```javascript

// Simple callback example

function greet(name, callback) {

  const message = `Hello, ${name}!`;

  callback(message);

}



greet('John', (msg) => {

  console.log(msg);  // "Hello, John!"

});

```



**Types of Callbacks:**



**1. Synchronous Callbacks:**

Executed immediately in the current call stack.



```javascript

// Array methods use synchronous callbacks

const numbers = [1, 2, 3, 4, 5];



numbers.forEach((num) => {

  console.log(num);  // Executes immediately

});



const doubled = numbers.map((num) => num * 2);



// Custom synchronous callback

function processArray(arr, callback) {

  const result = [];

  for (let item of arr) {

    result.push(callback(item));

  }

  return result;

}



processArray([1, 2, 3], x => x * 2);  // [2, 4, 6]

```



**2. Asynchronous Callbacks:**

Executed later, outside the current call stack (via event loop).



```javascript

// setTimeout - executes callback after delay

setTimeout(() => {

  console.log('Delayed message');

}, 1000);



// Event listeners

button.addEventListener('click', (event) => {

  console.log('Button clicked');

});



// File operations (Node.js)

const fs = require('fs');

fs.readFile('file.txt', 'utf8', (error, data) => {

  if (error) {

    console.error(error);

    return;

  }

  console.log(data);

});



// HTTP requests

fetch('/api/data')

  .then(response => response.json())

  .then(data => console.log(data))

  .catch(error => console.error(error));

```



**Error-First Callback Pattern (Node.js Convention):**

```javascript

// Convention: First parameter is error, second is result

function readUserData(userId, callback) {

  database.query('SELECT * FROM users WHERE id = ?', [userId], (error, results) => {

    if (error) {

      return callback(error, null);  // Pass error, null data

    }

    callback(null, results);  // Pass null error, actual data

  });

}



// Usage

readUserData(123, (error, user) => {

  if (error) {

    console.error('Failed to fetch user:', error);

    return;

  }

  console.log('User:', user);

});

```



**Callback Hell (Pyramid of Doom):**

The main problem with callbacks is nesting, which leads to hard-to-read code.



```javascript

// ❌ Bad - Deeply nested callbacks

getData((error, data) => {

  if (error) {

    handleError(error);

  } else {

    processData(data, (error, processed) => {

      if (error) {

        handleError(error);

      } else {

        saveData(processed, (error, result) => {

          if (error) {

            handleError(error);

          } else {

            sendNotification(result, (error, sent) => {

              if (error) {

                handleError(error);

              } else {

                console.log('All done!');

              }

            });

          }

        });

      }

    });

  }

});

```



**Solutions to Callback Hell:**



**1. Named Functions:**

```javascript

// ✅ Better - Extract functions

function handleGetData(error, data) {

  if (error) return handleError(error);

  processData(data, handleProcessData);

}



function handleProcessData(error, processed) {

  if (error) return handleError(error);

  saveData(processed, handleSaveData);

}



function handleSaveData(error, result) {

  if (error) return handleError(error);

  sendNotification(result, handleNotification);

}



getData(handleGetData);

```



**2. Promises (Modern Solution):**

```javascript

// ✅ Best - Use Promises

getData()

  .then(data => processData(data))

  .then(processed => saveData(processed))

  .then(result => sendNotification(result))

  .then(() => console.log('All done!'))

  .catch(error => handleError(error));



// Even better - async/await

async function performOperations() {

  try {

    const data = await getData();

    const processed = await processData(data);

    const result = await saveData(processed);

    await sendNotification(result);

    console.log('All done!');

  } catch (error) {

    handleError(error);

  }

}

```



**Production Use Cases:**



**1. Event Handling:**

```javascript

// DOM events

document.getElementById('btn').addEventListener('click', function(e) {

  e.preventDefault();

  console.log('Clicked at:', e.clientX, e.clientY);

});



// Custom events

class EventEmitter {

  constructor() {

    this.events = {};

  }

  

  on(event, callback) {

    if (!this.events[event]) {

      this.events[event] = [];

    }

    this.events[event].push(callback);

  }

  

  emit(event, data) {

    if (this.events[event]) {

      this.events[event].forEach(callback => callback(data));

    }

  }

}



const emitter = new EventEmitter();

emitter.on('user:login', (user) => {

  console.log(`${user.name} logged in`);

});

```



**2. Array Iteration:**

```javascript

// Data transformation

const users = [

  { name: 'John', age: 25 },

  { name: 'Jane', age: 30 }

];



// Callback for filtering

const adults = users.filter(user => user.age >= 18);



// Callback for mapping

const names = users.map(user => user.name);



// Callback for sorting

const sorted = users.sort((a, b) => a.age - b.age);

```



**3. Middleware Pattern:**

```javascript

// Express.js style middleware

function logger(req, res, next) {

  console.log(`${req.method} ${req.url}`);

  next();  // Call next callback in chain

}



function authenticate(req, res, next) {

  if (req.headers.authorization) {

    next();  // Continue

  } else {

    res.status(401).send('Unauthorized');

  }

}



app.use(logger);

app.use(authenticate);

app.get('/api/data', (req, res) => {

  res.json({ data: 'Protected' });

});

```



**Best Practices:**

- Always handle errors in async callbacks

- Avoid deep nesting (use Promises/async-await)

- Use named functions for better stack traces

- Follow error-first callback convention in Node.js

- Consider using Promises or async/await for complex async flows

- Be mindful of `this` binding in callbacks (use arrow functions when needed)



**Memory Considerations:**

```javascript

// ⚠️ Memory leak - callback holds reference to large data

function processLargeData() {

  const largeArray = new Array(1000000).fill('data');

  

  setTimeout(() => {

    // largeArray is still in memory due to closure

    console.log(largeArray[0]);

  }, 5000);

}



// ✅ Better - clear reference when done

function processLargeData() {

  let largeArray = new Array(1000000).fill('data');

  

  setTimeout(() => {

    console.log(largeArray[0]);

    largeArray = null;  // Allow garbage collection

  }, 5000);

}

```





</details>
<details><summary>16. What is function currying?</summary>






**Answer:**

Currying is a functional programming technique where a function with multiple arguments is transformed into a sequence of functions, each taking a single argument. Instead of calling `f(a, b, c)`, you call `f(a)(b)(c)`.



**Basic Example:**

```javascript

// Regular function

function add(a, b, c) {

  return a + b + c;

}

add(1, 2, 3); // 6



// Curried version

function curriedAdd(a) {

  return function(b) {

    return function(c) {

      return a + b + c;

    };

  };

}

curriedAdd(1)(2)(3); // 6



// Arrow function syntax (more concise)

const curriedAdd = a => b => c => a + b + c;

curriedAdd(1)(2)(3); // 6

```



**How It Works:**

Each function returns another function until all arguments are collected, then the final computation is performed.



```javascript

const step1 = curriedAdd(1);    // Returns function expecting b

const step2 = step1(2);         // Returns function expecting c

const result = step2(3);        // Returns final result: 6

```



**Generic Curry Function:**

```javascript

// Converts any function into a curried version

function curry(fn) {

  return function curried(...args) {

    // If we have all arguments, call the function

    if (args.length >= fn.length) {

      return fn.apply(this, args);

    }

    // Otherwise, return a function that collects more arguments

    return function(...nextArgs) {

      return curried(...args, ...nextArgs);

    };

  };

}



// Usage

function multiply(a, b, c) {

  return a * b * c;

}



const curriedMultiply = curry(multiply);

curriedMultiply(2)(3)(4);        // 24

curriedMultiply(2, 3)(4);        // 24 (can pass multiple args)

curriedMultiply(2)(3, 4);        // 24

```



**Production Use Cases:**



**1. Configuration Functions:**

```javascript

// API request builder

const makeRequest = method => url => data => headers => {

  return fetch(url, {

    method,

    body: JSON.stringify(data),

    headers: {

      'Content-Type': 'application/json',

      ...headers

    }

  });

};



// Create specialized request functions

const get = makeRequest('GET');

const post = makeRequest('POST');

const put = makeRequest('PUT');



// Create API endpoint functions

const getUsersAPI = get('/api/users');

const createUserAPI = post('/api/users');



// Use with specific data

getUsersAPI(null)({ 'Authorization': 'Bearer token' });

createUserAPI({ name: 'John' })({ 'Authorization': 'Bearer token' });

```



**2. Event Handlers:**

```javascript

// Generic event handler creator

const handleEvent = eventType => element => callback => {

  element.addEventListener(eventType, callback);

};



const onClick = handleEvent('click');

const onSubmit = handleEvent('submit');



// Create specific handlers

const handleButtonClick = onClick(document.getElementById('btn'));

const handleFormSubmit = onSubmit(document.getElementById('form'));



// Apply callbacks

handleButtonClick(e => console.log('Button clicked'));

handleFormSubmit(e => e.preventDefault());

```



**3. Validation Pipeline:**

```javascript

// Validator factory

const validate = rules => data => {

  const errors = [];

  rules.forEach(rule => {

    const error = rule(data);

    if (error) errors.push(error);

  });

  return errors.length > 0 ? errors : null;

};



// Validation rules

const required = field => data => 

  !data[field] ? `${field} is required` : null;



const minLength = field => length => data =>

  data[field] && data[field].length < length 

    ? `${field} must be at least ${length} characters` 

    : null;



const email = field => data =>

  data[field] && !/@/.test(data[field])

    ? `${field} must be a valid email`

    : null;



// Create validator

const validateUser = validate([

  required('username'),

  minLength('username')(3),

  required('email'),

  email('email')

]);



const errors = validateUser({ username: 'ab', email: 'invalid' });

// ['username must be at least 3 characters', 'email must be a valid email']

```



**4. Partial Application (Related Pattern):**

```javascript

// Logging with different levels

const log = level => message => timestamp => {

  console.log(`[${timestamp}] ${level}: ${message}`);

};



const info = log('INFO');

const error = log('ERROR');

const warn = log('WARN');



// Use throughout application

info('User logged in')(Date.now());

error('Database connection failed')(Date.now());



// With automatic timestamp

const logNow = level => message => log(level)(message)(Date.now());

const infoNow = logNow('INFO');

infoNow('Application started');

```



**5. Functional Composition:**

```javascript

// Composing transformations

const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);



const addTax = rate => price => price * (1 + rate);

const addShipping = cost => price => price + cost;

const round = decimals => value => 

  Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals);



// Create price calculators for different regions

const calculateUSPrice = compose(

  round(2),

  addShipping(10),

  addTax(0.08)

);



const calculateEUPrice = compose(

  round(2),

  addShipping(15),

  addTax(0.20)

);



calculateUSPrice(100);  // 118.00

calculateEUPrice(100);  // 135.00

```



**6. React/Redux Pattern:**

```javascript

// Redux connect-style HOC

const connect = mapStateToProps => mapDispatchToProps => Component => {

  return function ConnectedComponent(props) {

    const stateProps = mapStateToProps(store.getState());

    const dispatchProps = mapDispatchToProps(store.dispatch);

    return Component({ ...props, ...stateProps, ...dispatchProps });

  };

};



// Usage

const mapState = state => ({ user: state.user });

const mapDispatch = dispatch => ({ login: () => dispatch(loginAction()) });

const ConnectedUserProfile = connect(mapState)(mapDispatch)(UserProfile);

```



**Benefits:**

- **Reusability:** Create specialized functions from generic ones

- **Composability:** Combine functions easily

- **Partial Application:** Fix some arguments, vary others

- **Delayed Execution:** Build up function gradually

- **Testability:** Test each curry stage independently



**When to Use vs When Not to Use:**



**✅ Use Currying When:**

```javascript

// Building configuration functions

const createAPIClient = baseURL => timeout => headers => { /* ... */ };



// Creating specialized variations

const buildQueryString = params => url => `${url}?${new URLSearchParams(params)}`;



// Function composition pipelines

const processData = compose(transform, validate, parse);

```



**❌ Avoid Currying When:**

```javascript

// Simple, straightforward operations (overengineering)

// ❌ Unnecessary

const add = x => y => x + y;

// ✅ Better

const add = (x, y) => x + y;



// Frequently changing all parameters together

// ❌ Awkward

calculateArea(width)(height);

// ✅ Better

calculateArea(width, height);



// Callback functions (confusing)

// ❌ Confusing

array.map(transform(config)(options));

// ✅ Better

array.map(item => transform(item, config, options));

```



**Performance Considerations:**

```javascript

// Currying creates additional function calls (slight overhead)

// For performance-critical code, measure before optimizing



// ❌ In tight loops (potential overhead)

for (let i = 0; i < 1000000; i++) {

  curriedFunction(a)(b)(c);

}



// ✅ Pre-bind if possible

const boundFunction = curriedFunction(a)(b);

for (let i = 0; i < 1000000; i++) {

  boundFunction(c);

}

```





</details>
<details><summary>17. What is an IIFE (Immediately Invoked Function Expression)?</summary>






**Answer:**

An IIFE (Immediately Invoked Function Expression) is a function that is executed immediately after it's created. It's a design pattern that creates a new scope to avoid polluting the global namespace.



**Syntax:**

```javascript

// Basic IIFE

(function() {

  console.log('Executed immediately!');

})();



// Arrow function IIFE

(() => {

  console.log('Arrow IIFE!');

})();



// With parameters

(function(name) {

  console.log(`Hello, ${name}!`);

})('John');



// Alternative syntax (less common)

(function() {

  console.log('Alternative syntax');

}());

```



**Why the Parentheses?**

```javascript

// ❌ Syntax Error - function declaration can't be immediately invoked

function() {

  console.log('Error');

}();



// ✅ Parentheses make it a function expression

(function() {

  console.log('Works!');

})();



// Alternative ways to force expression context

!function() { console.log('Works'); }();

+function() { console.log('Works'); }();

-function() { console.log('Works'); }();

~function() { console.log('Works'); }();

void function() { console.log('Works'); }();

```



**Classic Use Cases (Pre-ES6):**



**1. Module Pattern - Private Variables:**

```javascript

// Before ES6 modules, this was the standard pattern

const calculator = (function() {

  // Private variables

  let result = 0;

  

  // Private function

  function log(message) {

    console.log(`Calculator: ${message}`);

  }

  

  // Public API

  return {

    add(n) {

      result += n;

      log(`Added ${n}`);

      return this;

    },

    subtract(n) {

      result -= n;

      log(`Subtracted ${n}`);

      return this;

    },

    getResult() {

      return result;

    }

  };

})();



calculator.add(5).subtract(2).getResult(); // 3

// calculator.result // undefined - private!

// calculator.log('test') // undefined - private!

```



**2. Avoiding Global Pollution:**

```javascript

// Without IIFE - pollutes global scope

var counter = 0;

var increment = function() { counter++; };

var getCount = function() { return counter; };



// With IIFE - clean global scope

(function() {

  var counter = 0;

  window.myApp = {

    increment: function() { counter++; },

    getCount: function() { return counter; }

  };

})();



// Only myApp is in global scope

```



**3. Loop Variable Problem (Classic Interview Question):**

```javascript

// ❌ Problem with var (pre-ES6)

for (var i = 0; i < 5; i++) {

  setTimeout(function() {

    console.log(i); // 5, 5, 5, 5, 5 (all same reference)

  }, i * 100);

}



// ✅ Solution 1: IIFE creates new scope for each iteration

for (var i = 0; i < 5; i++) {

  (function(j) {

    setTimeout(function() {

      console.log(j); // 0, 1, 2, 3, 4 (captured value)

    }, j * 100);

  })(i);

}



// ✅ Solution 2: Modern approach with let (ES6+)

for (let i = 0; i < 5; i++) {

  setTimeout(function() {

    console.log(i); // 0, 1, 2, 3, 4 (block scoped)

  }, i * 100);

}

```



**Modern Use Cases (Still Relevant):**



**1. Isolated Initialization Code:**

```javascript

// Run setup code without polluting scope

(async function() {

  const config = await fetch('/api/config').then(r => r.json());

  const app = initializeApp(config);

  app.start();

})();



// config and app don't leak to global scope

```



**2. Library/Plugin Initialization:**

```javascript

// jQuery plugin pattern

(function($) {

  $.fn.myPlugin = function(options) {

    // Plugin code with access to private variables

    const settings = $.extend({

      color: 'blue',

      size: 'medium'

    }, options);

    

    return this.each(function() {

      // Plugin logic

    });

  };

})(jQuery);

```



**3. Configuration Objects:**

```javascript

const config = (function() {

  const environment = process.env.NODE_ENV || 'development';

  

  const configs = {

    development: {

      apiUrl: 'http://localhost:3000',

      debug: true

    },

    production: {

      apiUrl: 'https://api.example.com',

      debug: false

    }

  };

  

  return configs[environment];

})();



// config contains only the relevant environment settings

```



**4. Async IIFE (Top-level await alternative):**

```javascript

// Before top-level await, used for async initialization

(async function() {

  try {

    const user = await fetchUser();

    const posts = await fetchPosts(user.id);

    renderUI(user, posts);

  } catch (error) {

    console.error('Initialization failed:', error);

  }

})();



// Modern alternative (ES2022+)

// await fetchUser(); // Top-level await

```



**5. Polyfill Pattern:**

```javascript

// Adding missing browser features safely

(function() {

  if (!Array.prototype.includes) {

    Array.prototype.includes = function(element) {

      return this.indexOf(element) !== -1;

    };

  }

})();

```



**With Return Values:**

```javascript

// IIFE can return values

const result = (function(a, b) {

  return a + b;

})(5, 10);



console.log(result); // 15



// Factory pattern

const createCounter = (function() {

  let id = 0;

  return function() {

    return {

      id: ++id,

      count: 0,

      increment() { this.count++; }

    };

  };

})();



const counter1 = createCounter(); // { id: 1, count: 0, ... }

const counter2 = createCounter(); // { id: 2, count: 0, ... }

```



**Modern Alternatives:**



**ES6 Modules (Preferred for Encapsulation):**

```javascript

// module.js

let privateVar = 0;



export function increment() {

  privateVar++;

}



export function getValue() {

  return privateVar;

}



// main.js

import { increment, getValue } from './module.js';

// privateVar is not accessible

```



**Block Scope with let/const:**

```javascript

{

  const temp = expensiveOperation();

  doSomething(temp);

}

// temp is not accessible here

```



**When to Still Use IIFE:**

- Quick scripts without module system

- Browser console experimentation

- Legacy codebases

- Avoiding global scope in inline scripts

- Creating immediate scopes in non-module contexts





</details>
<details><summary>18. What is the arguments object?</summary>






**Answer:**

The `arguments` object is an array-like object available inside all non-arrow functions that contains the values of the arguments passed to that function. It allows functions to accept any number of arguments.



**Basic Usage:**

```javascript

function sum() {

  console.log(arguments); // [Arguments] { '0': 1, '1': 2, '2': 3 }

  console.log(arguments.length); // 3

  console.log(arguments[0]); // 1

  console.log(arguments[1]); // 2

  

  let total = 0;

  for (let i = 0; i < arguments.length; i++) {

    total += arguments[i];

  }

  return total;

}



sum(1, 2, 3); // 6

sum(1, 2, 3, 4, 5); // 15

```



**Array-Like, Not Array:**

```javascript

function test() {

  console.log(typeof arguments); // "object"

  console.log(Array.isArray(arguments)); // false

  

  // Has length property

  console.log(arguments.length);

  

  // Can access by index

  console.log(arguments[0]);

  

  // ❌ No array methods

  // arguments.forEach(x => console.log(x)); // TypeError

  // arguments.map(x => x * 2); // TypeError

  

  // ✅ Convert to array first

  const args = Array.from(arguments);

  args.forEach(x => console.log(x));

  

  // Or use spread

  const args2 = [...arguments];

  

  // Or Array.prototype.slice

  const args3 = Array.prototype.slice.call(arguments);

}



test(1, 2, 3);

```



**Properties:**



**1. Length Property:**

```javascript

function checkArgs() {

  console.log(`Received ${arguments.length} arguments`);

  console.log(`Function expects ${checkArgs.length} parameters`);

}



checkArgs(1, 2, 3); // Received 3 arguments, Function expects 0 parameters

```



**2. Callee Property (Deprecated in Strict Mode):**

```javascript

// Reference to the currently executing function

function factorial(n) {

  if (n <= 1) return 1;

  return n * arguments.callee(n - 1); // Recursive call

}



// ⚠️ Deprecated - use named function instead

function factorial(n) {

  if (n <= 1) return 1;

  return n * factorial(n - 1);

}

```



**Accessing Extra Arguments:**

```javascript

function greet(firstName, lastName) {

  console.log(`Parameters: ${firstName} ${lastName}`);

  

  // Access additional arguments

  if (arguments.length > 2) {

    console.log('Extra arguments:');

    for (let i = 2; i < arguments.length; i++) {

      console.log(arguments[i]);

    }

  }

}



greet('John', 'Doe', 'Engineer', 30);

// Parameters: John Doe

// Extra arguments:

// Engineer

// 30

```



**Modifying Arguments:**

```javascript

function modify(x) {

  console.log('Initial:', x, arguments[0]); // 10, 10

  

  x = 20;

  console.log('After x change:', x, arguments[0]); // 20, 20 (linked in non-strict)

  

  arguments[0] = 30;

  console.log('After arguments change:', x, arguments[0]); // 30, 30

}



modify(10);



// In strict mode, they're not linked

'use strict';

function modifyStrict(x) {

  x = 20;

  console.log(x, arguments[0]); // 20, 10 (independent)

}

```



**Classic Use Cases:**



**1. Variable Argument Functions:**

```javascript

function max() {

  if (arguments.length === 0) return -Infinity;

  

  let maxValue = arguments[0];

  for (let i = 1; i < arguments.length; i++) {

    if (arguments[i] > maxValue) {

      maxValue = arguments[i];

    }

  }

  return maxValue;

}



max(1, 5, 3, 9, 2); // 9



// Modern alternative

const max = (...nums) => nums.length ? Math.max(...nums) : -Infinity;

```



**2. Function Overloading (Simulation):**

```javascript

function createPerson() {

  if (arguments.length === 1) {

    // Single object parameter

    return { name: arguments[0].name, age: arguments[0].age };

  } else if (arguments.length === 2) {

    // Two separate parameters

    return { name: arguments[0], age: arguments[1] };

  }

}



createPerson({ name: 'John', age: 30 });

createPerson('John', 30);

```



**3. Wrapper Functions:**

```javascript

// Logging wrapper

function logAndCall(fn) {

  return function() {

    console.log('Arguments:', arguments);

    return fn.apply(this, arguments);

  };

}



function add(a, b) {

  return a + b;

}



const loggedAdd = logAndCall(add);

loggedAdd(2, 3); // Logs arguments, returns 5

```



**Arrow Functions Don't Have arguments:**

```javascript

// ❌ Arrow functions don't have arguments object

const arrowSum = () => {

  console.log(arguments); // ReferenceError (or outer scope arguments)

};



// ✅ Use rest parameters instead

const arrowSum = (...args) => {

  return args.reduce((sum, n) => sum + n, 0);

};



// Nested arrow function accesses outer arguments

function outer() {

  const inner = () => {

    console.log(arguments); // Refers to outer's arguments

  };

  inner();

}



outer(1, 2, 3); // Logs outer's arguments

```



**Modern Alternative: Rest Parameters (Preferred):**

```javascript

// ❌ Old way with arguments

function sum() {

  return Array.from(arguments).reduce((a, b) => a + b, 0);

}



// ✅ Modern way with rest parameters

function sum(...numbers) {

  return numbers.reduce((a, b) => a + b, 0);

}



// Benefits of rest parameters:

// 1. Real array (has all array methods)

// 2. Works with arrow functions

// 3. More explicit and readable

// 4. Can mix with named parameters



function multiply(multiplier, ...numbers) {

  return numbers.map(n => n * multiplier);

}



multiply(2, 1, 2, 3); // [2, 4, 6]

```



**Performance Considerations:**

```javascript

// ⚠️ arguments object prevents optimizations in V8

function slow() {

  return arguments[0] + arguments[1]; // Harder to optimize

}



// ✅ Named parameters allow better optimization

function fast(a, b) {

  return a + b;

}



// ✅ Rest parameters also well-optimized

function fastest(...args) {

  return args[0] + args[1];

}

```



**Best Practices:**

- Prefer rest parameters (`...args`) over `arguments` in modern code

- Use `arguments` only when maintaining legacy code

- Convert to array immediately if you need array methods

- Be aware `arguments` doesn't exist in arrow functions

- Avoid `arguments.callee` (deprecated, forbidden in strict mode)





</details>
<details><summary>19. What are default parameters in JavaScript?</summary>






**Answer:**

Default parameters allow you to specify default values for function parameters if no argument is passed or if `undefined` is passed. Introduced in ES6, they provide a clean way to handle optional parameters.



**Basic Syntax:**

```javascript

// ES6 default parameters

function greet(name = 'Guest') {

  return `Hello, ${name}!`;

}



greet('John');    // "Hello, John!"

greet();          // "Hello, Guest!"

greet(undefined); // "Hello, Guest!" (undefined triggers default)

greet(null);      // "Hello, null!" (null doesn't trigger default)

```



**Multiple Default Parameters:**

```javascript

function createUser(name = 'Anonymous', age = 0, role = 'user') {

  return { name, age, role };

}



createUser();                           // { name: 'Anonymous', age: 0, role: 'user' }

createUser('John');                     // { name: 'John', age: 0, role: 'user' }

createUser('John', 25);                 // { name: 'John', age: 25, role: 'user' }

createUser('John', 25, 'admin');        // { name: 'John', age: 25, role: 'admin' }

createUser('John', undefined, 'admin'); // { name: 'John', age: 0, role: 'admin' }

```



**Default Values Can Be Expressions:**

```javascript

// Function calls as defaults

function getDefaultName() {

  console.log('Getting default name...');

  return 'Guest';

}



function greet(name = getDefaultName()) {

  return `Hello, ${name}!`;

}



greet('John'); // "Hello, John!" (getDefaultName not called)

greet();       // "Hello, Guest!" (getDefaultName called)



// Using other parameters

function createRectangle(width, height = width) {

  return { width, height };

}



createRectangle(10);      // { width: 10, height: 10 }

createRectangle(10, 20);  // { width: 10, height: 20 }



// Calculations

function discount(price, rate = 0.1) {

  return price * (1 - rate);

}



discount(100);      // 90 (10% off)

discount(100, 0.2); // 80 (20% off)

```



**Referencing Earlier Parameters:**

```javascript

// Later defaults can reference earlier parameters

function buildUrl(protocol = 'https', domain, path = `/${domain}`) {

  return `${protocol}://${domain}${path}`;

}



buildUrl(undefined, 'example.com');           // "https://example.com/example.com"

buildUrl('http', 'example.com', '/about');    // "http://example.com/about"



// ❌ Cannot reference later parameters (TDZ)

function invalid(a = b, b = 1) { // ReferenceError

  return a + b;

}

```



**undefined vs null:**

```javascript

function test(a = 5) {

  console.log(a);

}



test();          // 5 (no argument = undefined)

test(undefined); // 5 (undefined triggers default)

test(null);      // null (null does NOT trigger default)

test(0);         // 0 (0 is a valid value)

test('');        // '' (empty string is valid)

test(false);     // false (false is valid)

```



**Pre-ES6 Pattern (Legacy):**

```javascript

// Old way - manual checking

function greet(name) {

  name = name || 'Guest'; // ⚠️ Bug: 0, '', false also trigger default!

  return `Hello, ${name}!`;

}



// Better old way

function greet(name) {

  name = name !== undefined ? name : 'Guest';

  return `Hello, ${name}!`;

}



// Or

function greet(name) {

  if (name === undefined) {

    name = 'Guest';

  }

  return `Hello, ${name}!`;

}



// Modern way (ES6+)

function greet(name = 'Guest') {

  return `Hello, ${name}!`;

}

```



**Production Use Cases:**



**1. Configuration Objects:**

```javascript

function fetchData(url, options = {}) {

  const {

    method = 'GET',

    headers = {},

    timeout = 5000,

    retries = 3

  } = options;

  

  return fetch(url, {

    method,

    headers: {

      'Content-Type': 'application/json',

      ...headers

    },

    timeout,

    retries

  });

}



// Usage

fetchData('/api/users');

fetchData('/api/users', { method: 'POST' });

fetchData('/api/users', { timeout: 10000, retries: 5 });

```



**2. Pagination:**

```javascript

function getUsers(page = 1, limit = 10, sortBy = 'created_at') {

  const offset = (page - 1) * limit;

  return database.query(

    `SELECT * FROM users ORDER BY ${sortBy} LIMIT ${limit} OFFSET ${offset}`

  );

}



getUsers();         // page 1, 10 items, sorted by created_at

getUsers(2);        // page 2, 10 items, sorted by created_at

getUsers(1, 20);    // page 1, 20 items, sorted by created_at

```



**3. Logging Utility:**

```javascript

function log(message, level = 'info', timestamp = new Date()) {

  const formatted = `[${timestamp.toISOString()}] ${level.toUpperCase()}: ${message}`;

  console.log(formatted);

}



log('Application started');                    // Uses defaults

log('Error occurred', 'error');                // Custom level

log('Custom time', 'warn', new Date('2024')); // All custom

```



**4. Array/String Utilities:**

```javascript

function chunk(array, size = 1) {

  const chunks = [];

  for (let i = 0; i < array.length; i += size) {

    chunks.push(array.slice(i, i + size));

  }

  return chunks;

}



chunk([1, 2, 3, 4, 5]);      // [[1], [2], [3], [4], [5]]

chunk([1, 2, 3, 4, 5], 2);   // [[1, 2], [3, 4], [5]]



function truncate(str, maxLength = 50, suffix = '...') {

  return str.length > maxLength 

    ? str.slice(0, maxLength - suffix.length) + suffix 

    : str;

}



truncate('Long text here');                    // Truncates to 50 chars

truncate('Long text here', 10);                // Truncates to 10 chars

truncate('Long text here', 10, '...');         // Custom suffix

```



**5. API Client:**

```javascript

class APIClient {

  constructor(baseURL, timeout = 5000, retries = 3) {

    this.baseURL = baseURL;

    this.timeout = timeout;

    this.retries = retries;

  }

  

  async request(endpoint, method = 'GET', body = null, headers = {}) {

    const url = `${this.baseURL}${endpoint}`;

    const options = {

      method,

      headers: {

        'Content-Type': 'application/json',

        ...headers

      }

    };

    

    if (body) {

      options.body = JSON.stringify(body);

    }

    

    return fetch(url, options);

  }

}



const api = new APIClient('https://api.example.com');

api.request('/users');                    // GET with defaults

api.request('/users', 'POST', { name: 'John' });

```



**With Destructuring:**

```javascript

// Combining default parameters with destructuring

function createProduct({

  name,

  price = 0,

  category = 'General',

  inStock = true,

  tags = []

} = {}) {

  return { name, price, category, inStock, tags };

}



createProduct({ name: 'Laptop', price: 999 });

// { name: 'Laptop', price: 999, category: 'General', inStock: true, tags: [] }



createProduct();

// { name: undefined, price: 0, category: 'General', inStock: true, tags: [] }



// Better - required parameter

function createProduct({

  name,  // Required (no default)

  price = 0,

  category = 'General'

} = {}) {

  if (!name) throw new Error('name is required');

  return { name, price, category };

}

```



**Arrow Functions:**

```javascript

// Default parameters work with arrow functions

const greet = (name = 'Guest') => `Hello, ${name}!`;



const multiply = (a, b = 1) => a * b;



const createArray = (length = 0, fill = 0) => new Array(length).fill(fill);



createArray();         // []

createArray(3);        // [0, 0, 0]

createArray(3, 5);     // [5, 5, 5]

```



**Best Practices:**

- Use default parameters instead of manual undefined checks

- Remember: only `undefined` triggers defaults, not `null`, `0`, `''`, or `false`

- Place required parameters before optional ones

- Don't overuse - sometimes an options object is clearer

- Default values are evaluated at call time (fresh each call)

- Can reference earlier parameters but not later ones





</details>
<details><summary>20. What is the rest parameter?</summary>






**Answer:**

The rest parameter syntax (`...`) allows a function to accept an indefinite number of arguments as an array. It collects all remaining arguments into a real array, unlike the `arguments` object.



**Basic Syntax:**

```javascript

function sum(...numbers) {

  console.log(numbers); // Real array: [1, 2, 3, 4, 5]

  console.log(Array.isArray(numbers)); // true

  return numbers.reduce((total, n) => total + n, 0);

}



sum(1, 2, 3, 4, 5); // 15

```



**Key Differences from arguments Object:**



| Feature | arguments | Rest Parameter |

|---------|-----------|----------------|

| **Type** | Array-like object | Real array |

| **Array methods** | No (must convert) | Yes (all methods) |

| **Arrow functions** | No | Yes |

| **Named** | Always `arguments` | Any name you choose |

| **Partial collection** | No | Yes (after named params) |



**Combining with Named Parameters:**

```javascript

// Rest parameter must be last

function multiply(multiplier, ...numbers) {

  return numbers.map(n => n * multiplier);

}



multiply(2, 1, 2, 3, 4); // [2, 4, 6, 8]



// Multiple named + rest

function formatMessage(template, level, ...values) {

  console.log(`[${level}] ${template}`, ...values);

}



formatMessage('User %s logged in at %s', 'INFO', 'John', '10:30 AM');

// [INFO] User %s logged in at %s John 10:30 AM

```



**Rules and Limitations:**

```javascript

// ✅ Rest parameter must be last

function valid(a, b, ...rest) { }



// ❌ Cannot have parameters after rest

// function invalid(a, ...rest, b) { } // SyntaxError



// ❌ Only one rest parameter allowed

// function invalid(...rest1, ...rest2) { } // SyntaxError



// ✅ Can have no other parameters

function allArgs(...args) { }

```



**With Arrow Functions:**

```javascript

// Works perfectly with arrow functions (unlike arguments)

const sum = (...numbers) => numbers.reduce((a, b) => a + b, 0);



const max = (...numbers) => Math.max(...numbers);



const concat = (...arrays) => [].concat(...arrays);



// Example usage

sum(1, 2, 3);              // 6

max(5, 2, 9, 1);          // 9

concat([1, 2], [3, 4]);   // [1, 2, 3, 4]

```



**Production Use Cases:**



**1. Flexible API Functions:**

```javascript

// Logger accepting any number of messages

function log(level, ...messages) {

  const timestamp = new Date().toISOString();

  console.log(`[${timestamp}] ${level}:`, ...messages);

}



log('INFO', 'Application started');

log('ERROR', 'Connection failed', 'Retrying...', 'Attempt 3');

log('DEBUG', 'User data:', { id: 1, name: 'John' }, 'Role:', 'admin');



// Database query builder

function query(table, ...conditions) {

  const where = conditions

    .map(([field, value]) => `${field} = '${value}'`)

    .join(' AND ');

  return `SELECT * FROM ${table} WHERE ${where}`;

}



query('users', ['age', 18], ['status', 'active']);

// "SELECT * FROM users WHERE age = '18' AND status = 'active'"

```



**2. Math Operations:**

```javascript

function average(...numbers) {

  if (numbers.length === 0) return 0;

  return numbers.reduce((sum, n) => sum + n, 0) / numbers.length;

}



average(10, 20, 30, 40); // 25



function range(start, end, ...values) {

  return values.filter(v => v >= start && v <= end);

}



range(5, 15, 1, 7, 10, 20, 12, 3); // [7, 10, 12]

```



**3. Event Emitter Pattern:**

```javascript

class EventEmitter {

  constructor() {

    this.events = {};

  }

  

  on(event, callback) {

    if (!this.events[event]) {

      this.events[event] = [];

    }

    this.events[event].push(callback);

  }

  

  emit(event, ...args) {

    if (this.events[event]) {

      this.events[event].forEach(callback => callback(...args));

    }

  }

}



const emitter = new EventEmitter();



emitter.on('user:login', (username, timestamp, ip) => {

  console.log(`${username} logged in at ${timestamp} from ${ip}`);

});



emitter.emit('user:login', 'john_doe', Date.now(), '192.168.1.1');

```



**4. Function Composition:**

```javascript

// Compose multiple functions

function compose(...functions) {

  return function(input) {

    return functions.reduceRight((value, fn) => fn(value), input);

  };

}



const addTen = x => x + 10;

const multiplyByTwo = x => x * 2;

const square = x => x * x;



const calculate = compose(square, multiplyByTwo, addTen);

calculate(5); // ((5 + 10) * 2) ^ 2 = 900



// Pipe (left to right)

function pipe(...functions) {

  return function(input) {

    return functions.reduce((value, fn) => fn(value), input);

  };

}



const process = pipe(addTen, multiplyByTwo, square);

process(5); // ((5 + 10) * 2) ^ 2 = 900

```



**5. Middleware Pattern:**

```javascript

class RequestHandler {

  constructor() {

    this.middlewares = [];

  }

  

  use(...fns) {

    this.middlewares.push(...fns);

    return this;

  }

  

  async handle(req, res) {

    for (const middleware of this.middlewares) {

      await middleware(req, res);

    }

  }

}



const handler = new RequestHandler();

handler

  .use(logger, authenticate, authorize)

  .use(validateInput, sanitize);

```



**6. Array Operations:**

```javascript

// Merge multiple arrays

function merge(...arrays) {

  return [].concat(...arrays);

}



merge([1, 2], [3, 4], [5, 6]); // [1, 2, 3, 4, 5, 6]



// Find common elements

function intersection(...arrays) {

  if (arrays.length === 0) return [];

  return arrays.reduce((acc, arr) => 

    acc.filter(item => arr.includes(item))

  );

}



intersection([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [3]



// Unique values from multiple arrays

function uniqueValues(...arrays) {

  return [...new Set([].concat(...arrays))];

}



uniqueValues([1, 2], [2, 3], [3, 4]); // [1, 2, 3, 4]

```



**7. Partial Application / Currying:**

```javascript

function partial(fn, ...args) {

  return function(...remainingArgs) {

    return fn(...args, ...remainingArgs);

  };

}



function greet(greeting, name, punctuation) {

  return `${greeting}, ${name}${punctuation}`;

}



const sayHello = partial(greet, 'Hello');

sayHello('John', '!'); // "Hello, John!"



const sayHelloJohn = partial(greet, 'Hello', 'John');

sayHelloJohn('!'); // "Hello, John!"

```



**With Destructuring:**

```javascript

// Destructure + rest for objects

const user = {

  id: 1,

  name: 'John',

  email: 'john@example.com',

  age: 30,

  role: 'admin'

};



const { id, name, ...rest } = user;

console.log(rest); // { email: '...', age: 30, role: 'admin' }



// In function parameters

function updateUser({ id, ...updates }) {

  return database.update(id, updates);

}



updateUser({ id: 1, name: 'Jane', age: 31 });

// Updates only name and age, not id



// Array destructuring with rest

const [first, second, ...remaining] = [1, 2, 3, 4, 5];

console.log(first);     // 1

console.log(second);    // 2

console.log(remaining); // [3, 4, 5]

```



**Performance Considerations:**

```javascript

// Rest parameters are efficient (no conversion needed)

function processItems(...items) {

  return items.filter(x => x > 0); // Direct array operations

}



// With arguments object (old way, less efficient)

function processItems() {

  const items = Array.from(arguments); // Conversion overhead

  return items.filter(x => x > 0);

}

```



**Best Practices:**

- Use rest parameters instead of the `arguments` object

- Name rest parameters descriptively (`...numbers`, `...items`, `...args`)

- Always place rest parameter last

- Works seamlessly with arrow functions

- Perfect for variable-length argument lists

- Use with spread operator for powerful array/object manipulations

- Ideal for wrapper/decorator functions that forward arguments



## Scope & Closures





</details>
<details><summary>21. What is scope in JavaScript?</summary>






**Answer:**

Scope determines the accessibility (visibility) of variables, functions, and objects in different parts of your code during runtime. It defines where variables can be accessed and helps prevent naming conflicts.



**Types of Scope in JavaScript:**




1. **Global Scope** - Accessible everywhere in the code



2. **Function Scope** - Accessible only within the function



3. **Block Scope** - Accessible only within the block `{ }` (ES6+)



4. **Module Scope** - Accessible only within the module (ES6 modules)




**Global Scope:**

```javascript

// Variables declared outside any function or block

var globalVar = 'Global';

let globalLet = 'Also Global';

const globalConst = 'Global too';



function test() {

  console.log(globalVar); // Accessible

}



console.log(globalVar); // Accessible

```



**Function Scope:**

```javascript

function outer() {

  var functionScoped = 'Inside function';

  let alsoFunctionScoped = 'Also inside';

  

  console.log(functionScoped); // ✅ Accessible

  

  function inner() {

    console.log(functionScoped); // ✅ Accessible (parent scope)

  }

  

  inner();

}



outer();

// console.log(functionScoped); // ❌ ReferenceError: not accessible outside

```



**Block Scope (ES6+):**

```javascript

{

  let blockScoped = 'Inside block';

  const alsoBlockScoped = 'Block scoped';

  var notBlockScoped = 'Function scoped!';

  

  console.log(blockScoped); // ✅ Accessible

}



// console.log(blockScoped); // ❌ ReferenceError

console.log(notBlockScoped); // ✅ var ignores block scope!



// if statements create block scope

if (true) {

  let x = 10;

  const y = 20;

  var z = 30;

}

// console.log(x); // ❌ ReferenceError

// console.log(y); // ❌ ReferenceError

console.log(z); // ✅ 30 (var leaks out)



// for loops

for (let i = 0; i < 3; i++) {

  setTimeout(() => console.log(i), 100); // 0, 1, 2 (each iteration has own 'i')

}



for (var i = 0; i < 3; i++) {

  setTimeout(() => console.log(i), 100); // 3, 3, 3 (shared 'i')

}

```



**Scope Hierarchy:**

```javascript

let global = 'Global';



function outer() {

  let outerVar = 'Outer';

  

  function middle() {

    let middleVar = 'Middle';

    

    function inner() {

      let innerVar = 'Inner';

      

      // All are accessible from inner scope

      console.log(innerVar);   // ✅ Own scope

      console.log(middleVar);  // ✅ Parent scope

      console.log(outerVar);   // ✅ Grandparent scope

      console.log(global);     // ✅ Global scope

    }

    

    inner();

    // console.log(innerVar); // ❌ Not accessible

  }

  

  middle();

}



outer();

```



**Production Implications:**



**1. Variable Collision Prevention:**

```javascript

// Without proper scoping

var name = 'Global Name';



function setName() {

  name = 'Changed'; // Modifies global!

}



setName();

console.log(name); // 'Changed' - unintended side effect



// With proper scoping

let name = 'Global Name';



function setName() {

  let name = 'Local'; // New variable, doesn't affect global

  console.log(name); // 'Local'

}



setName();

console.log(name); // 'Global Name' - safe

```



**2. Memory Management:**

```javascript

// Variables stay in memory while in scope

function processLargeData() {

  let largeArray = new Array(1000000).fill('data');

  

  // largeArray is in memory here

  doSomething(largeArray);

  

  // After function ends, largeArray can be garbage collected

}



// vs keeping in global scope

let largeArray = new Array(1000000).fill('data'); // Stays in memory forever!

```



**3. Module Pattern (Pre-ES6):**

```javascript

const counterModule = (function() {

  // Private variables (function scope)

  let count = 0;

  

  // Private function

  function log() {

    console.log(`Count: ${count}`);

  }

  

  // Public API

  return {

    increment() {

      count++;

      log();

    },

    decrement() {

      count--;

      log();

    },

    getCount() {

      return count;

    }

  };

})();



counterModule.increment(); // Count: 1

counterModule.getCount();  // 1

// counterModule.count;    // undefined - private!

```



**4. Avoiding Global Pollution:**

```javascript

// ❌ Bad - pollutes global scope

var helper1 = function() { /* ... */ };

var helper2 = function() { /* ... */ };

var helper3 = function() { /* ... */ };



// ✅ Good - namespace pattern

const MyApp = {

  helpers: {

    helper1: function() { /* ... */ },

    helper2: function() { /* ... */ },

    helper3: function() { /* ... */ }

  }

};



// ✅ Better - ES6 modules

// helpers.js

export function helper1() { /* ... */ }

export function helper2() { /* ... */ }

```



**Scope and `this`:**

```javascript

const obj = {

  name: 'Object',

  regularMethod: function() {

    console.log(this.name); // 'Object' - this refers to obj

    

    function inner() {

      console.log(this.name); // undefined - this is global/undefined

    }

    inner();

  },

  arrowMethod: function() {

    console.log(this.name); // 'Object'

    

    const inner = () => {

      console.log(this.name); // 'Object' - arrow function inherits this

    };

    inner();

  }

};

```



**Best Practices:**

- Use `let` and `const` (block-scoped) instead of `var`

- Keep variables in the smallest scope possible

- Avoid global variables whenever possible

- Use modules to encapsulate code

- Declare variables at the top of their scope for clarity

- Use IIFE or modules for private variables/functions





</details>
<details><summary>22. What is the difference between global scope and local scope?</summary>






**Answer:**

Global scope and local scope define the accessibility boundaries of variables in JavaScript. Understanding the difference is crucial for writing maintainable and bug-free code.



**Global Scope:**

Variables declared outside any function or block are in the global scope. They are accessible from anywhere in the code.



```javascript

// Global scope

var globalVar = 'I am global';

let globalLet = 'Also global';

const globalConst = 'Global constant';



function test() {

  console.log(globalVar); // ✅ Accessible

}



if (true) {

  console.log(globalLet); // ✅ Accessible

}



console.log(globalConst); // ✅ Accessible

```



**Local Scope:**

Variables declared inside a function or block are in local scope. They are only accessible within that function or block.



```javascript

function myFunction() {

  // Local scope (function)

  var localVar = 'I am local';

  let localLet = 'Also local';

  const localConst = 'Local constant';

  

  console.log(localVar); // ✅ Accessible inside function

}



myFunction();

// console.log(localVar); // ❌ ReferenceError: not defined



// Block scope

{

  let blockVar = 'Block scoped';

  console.log(blockVar); // ✅ Accessible inside block

}

// console.log(blockVar); // ❌ ReferenceError

```



**Detailed Comparison:**



| Aspect | Global Scope | Local Scope |

|--------|-------------|-------------|

| **Accessibility** | Everywhere in code | Only within function/block |

| **Lifetime** | Entire application runtime | Until function/block exits |

| **Memory** | Persists forever | Released after scope ends |

| **Naming Conflicts** | High risk | Low risk (isolated) |

| **Browser Global** | Attached to `window` (var) | Not attached to window |

| **Testing** | Harder (side effects) | Easier (isolated) |



**Global Variables in Browser:**

```javascript

// In browser

var globalVar = 'test';

let globalLet = 'test2';



console.log(window.globalVar);  // 'test' (var creates window property)

console.log(window.globalLet);  // undefined (let doesn't)



// Global object properties

window.myGlobal = 'value';

console.log(myGlobal); // 'value' - accessible globally

```



**Shadowing (Local Overrides Global):**

```javascript

let name = 'Global';



function test() {

  let name = 'Local'; // Shadows global variable

  console.log(name);  // 'Local'

}



test();

console.log(name); // 'Global' - unchanged

```



**Accidental Globals:**

```javascript

function createGlobal() {

  // ❌ Forgot 'let', 'const', or 'var' - creates global!

  accidentalGlobal = 'Oops';

}



createGlobal();

console.log(accidentalGlobal); // 'Oops' - now global!



// In strict mode, this throws an error

'use strict';

function strictFunction() {

  undeclared = 'Error'; // ReferenceError: undeclared is not defined

}

```



**Production Problems with Global Scope:**



**1. Naming Conflicts:**

```javascript

// library1.js

var userId = 123;



// library2.js

var userId = 456; // Overwrites library1's userId!



// yourCode.js

console.log(userId); // 456 - unexpected!

```



**2. Memory Leaks:**

```javascript

// ❌ Global variables never garbage collected

var cache = [];



function addToCache(data) {

  cache.push(data); // Grows indefinitely

}



// ✅ Use local scope or proper cleanup

function processData() {

  let localCache = [];

  // ... use cache ...

  // localCache is garbage collected after function ends

}

```



**3. Tight Coupling:**

```javascript

// ❌ Functions depend on global state

var config = { theme: 'dark' };



function renderUI() {

  if (config.theme === 'dark') { /* ... */ }

}



// ✅ Pass dependencies explicitly

function renderUI(config) {

  if (config.theme === 'dark') { /* ... */ }

}

```



**Best Practices:**



**1. Minimize Global Variables:**

```javascript

// ❌ Multiple globals

var app = {};

var config = {};

var utils = {};



// ✅ Single global namespace

var MyApp = {

  app: {},

  config: {},

  utils: {}

};



// ✅✅ ES6 Modules (no globals needed)

// app.js

export const app = {};

export const config = {};

export const utils = {};

```



**2. Use Modules:**

```javascript

// config.js

const API_URL = 'https://api.example.com';

const TIMEOUT = 5000;



export { API_URL, TIMEOUT };



// main.js

import { API_URL, TIMEOUT } from './config.js';

// Only imported when needed, not global

```



**3. IIFE for Isolation:**

```javascript

(function() {

  // All variables here are local

  var privateVar = 'Not global';

  

  function privateFunction() {

    return privateVar;

  }

  

  // Only expose what's needed

  window.MyLibrary = {

    publicMethod: function() {

      return privateFunction();

    }

  };

})();

```



**4. Use 'use strict':**

```javascript

'use strict';



function test() {

  undeclaredVar = 'value'; // ReferenceError - prevents accidental globals

}

```



**Local Scope Benefits:**



```javascript

// ✅ Encapsulation

function calculatePrice(quantity, price) {

  let tax = 0.1;           // Local, can't interfere with other code

  let total = quantity * price * (1 + tax);

  return total;

}



// ✅ Reusability (no side effects)

function processUser(user) {

  let tempData = transform(user); // Local, function is pure

  return tempData;

}



// ✅ Testing (isolated)

function add(a, b) {

  return a + b; // No global dependencies

}

```



**When Global Scope is Acceptable:**

- Application configuration constants

- Third-party library exports

- Polyfills

- Single-page app root instance (like React root)

- Feature flags (sparingly)



```javascript

// Acceptable globals

const APP_VERSION = '1.0.0';

const IS_PRODUCTION = true;



// Or better, as module exports

export const APP_VERSION = '1.0.0';

export const IS_PRODUCTION = true;

```





</details>
<details><summary>23. What is lexical scoping?</summary>






**Answer:**

Lexical scoping (also called static scoping) means that the scope of a variable is determined by its position in the source code at the time it's written, not where it's called from. JavaScript uses lexical scoping to resolve variable access.



**Core Concept:**

```javascript

const name = 'Global';



function outer() {

  const name = 'Outer';

  

  function inner() {

    // 'name' is resolved by looking at WHERE inner() was DEFINED,

    // not where it's CALLED from

    console.log(name); // 'Outer' - uses parent scope

  }

  

  return inner;

}



const name = 'Another Global';

const innerFunc = outer();

innerFunc(); // 'Outer' - not 'Another Global' (lexical scope!)

```



**How Lexical Scope Works:**



JavaScript looks for variables by walking up the scope chain based on the code structure:



```javascript

const global = 'Global level';



function level1() {

  const level1Var = 'Level 1';

  

  function level2() {

    const level2Var = 'Level 2';

    

    function level3() {

      const level3Var = 'Level 3';

      

      // Lookup chain: level3 -> level2 -> level1 -> global

      console.log(level3Var); // ✅ Found in current scope

      console.log(level2Var); // ✅ Found in parent scope

      console.log(level1Var); // ✅ Found in grandparent scope

      console.log(global);    // ✅ Found in global scope

    }

    

    level3();

  }

  

  level2();

}



level1();

```



**Lexical vs Dynamic Scoping:**



```javascript

const value = 'Global';



function showValue() {

  console.log(value);

}



function outer() {

  const value = 'Outer';

  showValue();

}



outer(); // 'Global' - lexical scoping (where defined)

// If JavaScript used dynamic scoping, it would print 'Outer' (where called)

```



**Closure and Lexical Scope:**



Closures work because of lexical scoping - inner functions remember their lexical environment:



```javascript

function createCounter() {

  let count = 0; // Lexically scoped to createCounter

  

  return function() {

    count++; // Has access to 'count' due to lexical scope

    return count;

  };

}



const counter = createCounter();

console.log(counter()); // 1

console.log(counter()); // 2

console.log(counter()); // 3



// 'count' is accessed based on WHERE the inner function was DEFINED,

// not where it's CALLED

```



**Nested Function Example:**



```javascript

function outer(x) {

  function middle(y) {

    function inner(z) {

      // All three parameters accessible due to lexical scope

      console.log(x + y + z);

    }

    return inner;

  }

  return middle;

}



const fn = outer(1)(2);

fn(3); // 6 - all three variables still accessible

```



**Production Use Cases:**



**1. Data Privacy / Encapsulation:**

```javascript

function createBankAccount(initialBalance) {

  // 'balance' is private - only accessible via lexical scope

  let balance = initialBalance;

  

  return {

    deposit(amount) {

      balance += amount; // Accesses parent scope

      return balance;

    },

    withdraw(amount) {

      if (amount <= balance) {

        balance -= amount;

        return balance;

      }

      throw new Error('Insufficient funds');

    },

    getBalance() {

      return balance;

    }

  };

}



const account = createBankAccount(1000);

account.deposit(500);  // 1500

account.withdraw(200); // 1300

// account.balance;    // undefined - truly private!

```



**2. Event Handlers with State:**

```javascript

function setupButton(buttonId, initialCount) {

  let clickCount = initialCount; // Lexically scoped

  const button = document.getElementById(buttonId);

  

  button.addEventListener('click', function() {

    // Event handler accesses clickCount via lexical scope

    clickCount++;

    button.textContent = `Clicked ${clickCount} times`;

  });

}



setupButton('btn1', 0); // Each button has its own clickCount

setupButton('btn2', 0);

```



**3. Factory Functions:**

```javascript

function createLogger(prefix) {

  // prefix is captured lexically

  return {

    info: function(message) {

      console.log(`[${prefix}] INFO: ${message}`);

    },

    error: function(message) {

      console.log(`[${prefix}] ERROR: ${message}`);

    }

  };

}



const userLogger = createLogger('USER');

const adminLogger = createLogger('ADMIN');



userLogger.info('Logged in');   // [USER] INFO: Logged in

adminLogger.error('Access denied'); // [ADMIN] ERROR: Access denied

```



**4. Configuration Builders:**

```javascript

function createAPIClient(baseURL) {

  // baseURL captured in lexical scope

  return {

    get(endpoint) {

      return fetch(`${baseURL}${endpoint}`); // Uses lexical baseURL

    },

    post(endpoint, data) {

      return fetch(`${baseURL}${endpoint}`, {

        method: 'POST',

        body: JSON.stringify(data)

      });

    }

  };

}



const api1 = createAPIClient('https://api1.example.com');

const api2 = createAPIClient('https://api2.example.com');



api1.get('/users'); // https://api1.example.com/users

api2.get('/users'); // https://api2.example.com/users

```



**5. Memoization:**

```javascript

function memoize(fn) {

  const cache = {}; // Lexically scoped cache

  

  return function(...args) {

    const key = JSON.stringify(args);

    // Inner function accesses cache via lexical scope

    if (key in cache) {

      return cache[key];

    }

    const result = fn(...args);

    cache[key] = result;

    return result;

  };

}



const expensiveCalc = memoize(function(n) {

  console.log('Calculating...');

  return n * n;

});



expensiveCalc(5); // 'Calculating...' -> 25

expensiveCalc(5); // 25 (cached, no log)

```



**Loop Variable Capture (Classic Problem):**



```javascript

// ❌ Problem with var (not block-scoped)

for (var i = 0; i < 3; i++) {

  setTimeout(function() {

    console.log(i); // 3, 3, 3 (all callbacks share same 'i')

  }, 100);

}



// ✅ Solution 1: IIFE creates new lexical scope

for (var i = 0; i < 3; i++) {

  (function(j) { // j is lexically scoped to this IIFE

    setTimeout(function() {

      console.log(j); // 0, 1, 2

    }, 100);

  })(i);

}



// ✅ Solution 2: let is block-scoped (each iteration = new scope)

for (let i = 0; i < 3; i++) {

  setTimeout(function() {

    console.log(i); // 0, 1, 2

  }, 100);

}

```



**Scope Chain Walking:**



```javascript

let a = 'global a';

let b = 'global b';



function outer() {

  let a = 'outer a';

  let c = 'outer c';

  

  function inner() {

    let a = 'inner a';

    let d = 'inner d';

    

    console.log(a); // 'inner a' - found in current scope

    console.log(b); // 'global b' - walks up to global

    console.log(c); // 'outer c' - walks up to outer

    console.log(d); // 'inner d' - found in current scope

    // Variable lookup stops at first match while walking up

  }

  

  inner();

}



outer();

```



**Lexical Scope is Determined at Parse Time:**



```javascript

function outer() {

  let x = 10;

  

  function inner() {

    console.log(x); // Scope is determined HERE (parse time)

  }

  

  return inner;

}



let x = 20;

const fn = outer();

fn(); // 10 - not 20! Uses lexical scope from definition

```



**Benefits of Lexical Scoping:**

- **Predictable:** Scope is clear from reading code structure

- **Tooling:** IDEs can statically analyze variable usage

- **Closures:** Enables powerful closure patterns

- **Optimization:** Engines can optimize scope lookups

- **Debugging:** Easier to trace variable origins



**Gotchas:**



```javascript

// Modifying parent scope variables

function outer() {

  let count = 0;

  

  function increment() {

    count++; // Modifies outer's count!

  }

  

  increment();

  console.log(count); // 1 - modified

}



// Reference vs Value

function outer() {

  let obj = { value: 0 };

  

  function modify() {

    obj.value = 10; // Modifies the object

    obj = { value: 20 }; // Only changes local reference

  }

  

  modify();

  console.log(obj.value); // 10 - object was modified

}

```





</details>
<details><summary>24. What is a closure?</summary>






**Answer:**

A closure is a function that has access to variables from its outer (enclosing) lexical scope, even after the outer function has finished executing. Closures are created every time a function is created in JavaScript.



**Simple Definition:**

> A closure is the combination of a function and the lexical environment within which that function was declared.



**Basic Example:**

```javascript

function outer() {

  let count = 0; // Outer scope variable

  

  function inner() {

    count++; // Inner function accesses outer variable

    return count;

  }

  

  return inner;

}



const counter = outer(); // outer() has finished executing

console.log(counter());  // 1 - but 'count' is still accessible!

console.log(counter());  // 2 - 'count' persists between calls

console.log(counter());  // 3 - this is a closure

```



**How Closures Work:**



When a function is created, it maintains a reference to its lexical environment (the scope in which it was created). This reference persists even after the outer function returns.



```javascript

function createGreeter(greeting) {

  // 'greeting' is in the closure

  return function(name) {

    return `${greeting}, ${name}!`;

  };

}



const sayHello = createGreeter('Hello');

const sayHi = createGreeter('Hi');



console.log(sayHello('John')); // "Hello, John!"

console.log(sayHi('Jane'));    // "Hi, Jane!"



// Each closure maintains its own copy of 'greeting'

```



**Multiple Closures Sharing Same Scope:**



```javascript

function createCounter() {

  let count = 0;

  

  return {

    increment: function() {

      count++;

      return count;

    },

    decrement: function() {

      count--;

      return count;

    },

    getCount: function() {

      return count;

    }

  };

}



const counter = createCounter();

counter.increment(); // 1

counter.increment(); // 2

counter.decrement(); // 1

console.log(counter.getCount()); // 1

// All three methods share the same 'count' via closure

```



**Closure Scope Chain:**



```javascript

const global = 'Global';



function outer() {

  const outerVar = 'Outer';

  

  function middle() {

    const middleVar = 'Middle';

    

    function inner() {

      const innerVar = 'Inner';

      

      // inner() has closure over all outer scopes

      console.log(innerVar);   // 'Inner'

      console.log(middleVar);  // 'Middle'

      console.log(outerVar);   // 'Outer'

      console.log(global);     // 'Global'

    }

    

    return inner;

  }

  

  return middle();

}



const fn = outer();

fn(); // Accesses all variables via closure chain

```



**Production Use Cases:**



**1. Data Privacy / Encapsulation:**

```javascript

function createUser(name, email) {

  // Private variables

  let password = '';

  let loginAttempts = 0;

  const MAX_ATTEMPTS = 3;

  

  // Private function

  function hashPassword(pass) {

    return btoa(pass); // Simple hash (use crypto in production)

  }

  

  // Public API (methods use closure to access private data)

  return {

    getName() {

      return name;

    },

    getEmail() {

      return email;

    },

    setPassword(newPassword) {

      password = hashPassword(newPassword);

    },

    login(inputPassword) {

      if (loginAttempts >= MAX_ATTEMPTS) {

        throw new Error('Account locked');

      }

      

      if (hashPassword(inputPassword) === password) {

        loginAttempts = 0;

        return true;

      }

      

      loginAttempts++;

      return false;

    }

  };

}



const user = createUser('John', 'john@example.com');

user.setPassword('secret123');

user.login('secret123'); // true

// user.password; // undefined - truly private!

```



**2. Event Handlers with State:**

```javascript

function setupButtons() {

  const buttons = document.querySelectorAll('.counter-btn');

  

  buttons.forEach((button, index) => {

    let count = 0; // Each button has its own count via closure

    

    button.addEventListener('click', function() {

      count++; // Closure captures 'count' and 'button'

      button.textContent = `Clicked ${count} times`;

    });

  });

}

```



**3. Module Pattern:**

```javascript

const ShoppingCart = (function() {

  // Private state

  let items = [];

  let total = 0;

  

  // Private functions

  function calculateTotal() {

    total = items.reduce((sum, item) => sum + item.price, 0);

  }

  

  // Public API

  return {

    addItem(item) {

      items.push(item);

      calculateTotal();

    },

    removeItem(itemId) {

      items = items.filter(item => item.id !== itemId);

      calculateTotal();

    },

    getItems() {

      return [...items]; // Return copy to prevent external modification

    },

    getTotal() {

      return total;

    },

    clear() {

      items = [];

      total = 0;

    }

  };

})();



ShoppingCart.addItem({ id: 1, name: 'Book', price: 20 });

ShoppingCart.addItem({ id: 2, name: 'Pen', price: 5 });

console.log(ShoppingCart.getTotal()); // 25

// ShoppingCart.items; // undefined - private!

```



**4. Function Factories:**

```javascript

function createMultiplier(multiplier) {

  return function(number) {

    return number * multiplier; // Closure over 'multiplier'

  };

}



const double = createMultiplier(2);

const triple = createMultiplier(3);

const quadruple = createMultiplier(4);



console.log(double(5));     // 10

console.log(triple(5));     // 15

console.log(quadruple(5));  // 20



// API client factory

function createAPIClient(baseURL, apiKey) {

  return {

    async get(endpoint) {

      const response = await fetch(`${baseURL}${endpoint}`, {

        headers: { 'Authorization': `Bearer ${apiKey}` }

      });

      return response.json();

    },

    async post(endpoint, data) {

      const response = await fetch(`${baseURL}${endpoint}`, {

        method: 'POST',

        headers: { 

          'Authorization': `Bearer ${apiKey}`,

          'Content-Type': 'application/json'

        },

        body: JSON.stringify(data)

      });

      return response.json();

    }

  };

}



const apiClient = createAPIClient('https://api.example.com', 'secret-key-123');

apiClient.get('/users');

```



**5. Callback Functions:**

```javascript

function fetchUser(userId) {

  const requestTime = Date.now();

  

  fetch(`/api/users/${userId}`)

    .then(response => response.json())

    .then(user => {

      // Closure captures requestTime and userId

      const duration = Date.now() - requestTime;

      console.log(`Fetched user ${userId} in ${duration}ms`);

      return user;

    });

}

```



**6. Iterators and Generators:**

```javascript

function createIterator(array) {

  let index = 0; // Closure maintains state between calls

  

  return {

    next() {

      if (index < array.length) {

        return { value: array[index++], done: false };

      }

      return { done: true };

    },

    reset() {

      index = 0;

    }

  };

}



const iterator = createIterator([1, 2, 3]);

console.log(iterator.next()); // { value: 1, done: false }

console.log(iterator.next()); // { value: 2, done: false }

iterator.reset();

console.log(iterator.next()); // { value: 1, done: false }

```



**Common Pitfalls:**



**1. Loop Closure Problem:**

```javascript

// ❌ Problem: All callbacks share same 'i'

function createButtons() {

  for (var i = 0; i < 5; i++) {

    document.getElementById(`btn${i}`).onclick = function() {

      alert(i); // Always alerts 5!

    };

  }

}



// ✅ Solution 1: IIFE creates new scope

for (var i = 0; i < 5; i++) {

  (function(j) {

    document.getElementById(`btn${j}`).onclick = function() {

      alert(j); // Alerts correct value

    };

  })(i);

}



// ✅ Solution 2: Use let (block-scoped)

for (let i = 0; i < 5; i++) {

  document.getElementById(`btn${i}`).onclick = function() {

    alert(i); // Alerts correct value

  };

}

```



**2. Memory Leaks:**

```javascript

// ⚠️ Potential memory leak

function createHeavyClosures() {

  const largeData = new Array(1000000).fill('data');

  

  return function() {

    // Even if not using largeData, it's kept in memory

    console.log('Hello');

  };

}



// ✅ Better: Only close over what you need

function createHeavyClosures() {

  const largeData = new Array(1000000).fill('data');

  const summary = largeData.length; // Extract only what's needed

  

  return function() {

    console.log(`Array size: ${summary}`);

    // largeData can be garbage collected

  };

}

```



**3. Accidental Sharing:**

```javascript

function createFunctions() {

  const functions = [];

  

  for (var i = 0; i < 3; i++) {

    functions.push(function() {

      return i; // Shares same 'i'

    });

  }

  

  return functions;

}



const fns = createFunctions();

console.log(fns[0]()); // 3

console.log(fns[1]()); // 3

console.log(fns[2]()); // 3 (all return 3!)

```



**Performance Considerations:**

```javascript

// ⚠️ Creating closures in constructors (memory overhead)

function SlowObject() {

  this.value = 0;

  

  // Each instance creates new function in memory

  this.increment = function() {

    this.value++;

  };

}



// ✅ Better: Use prototype (shared across instances)

function FastObject() {

  this.value = 0;

}



FastObject.prototype.increment = function() {

  this.value++;

};



// When you need closure, balance is key

function OptimizedObject(initialValue) {

  this.value = initialValue;

  

  // Only create closure if needed

  if (initialValue > 100) {

    this.increment = function() {

      this.value++;

    };

  }

}

OptimizedObject.prototype.increment = function() {

  this.value++;

};

```



**Key Takeaways:**

- Closures give functions access to outer scope variables

- They persist even after outer function returns

- Essential for data privacy and encapsulation

- Enable powerful patterns (modules, factories, callbacks)

- Be mindful of memory implications

- Every function creates a closure in JavaScript





</details>
<details><summary>25. What are the practical uses of closures?</summary>






**Answer:**

Closures are one of the most powerful features in JavaScript. They enable numerous design patterns and solve common programming problems elegantly. Here are the most practical uses in production applications:



**1. Data Privacy and Encapsulation:**



Creating truly private variables that cannot be accessed from outside:



```javascript

function createWallet(initialBalance) {

  // Private variables - only accessible via closure

  let balance = initialBalance;

  const transactions = [];

  

  // Private function

  function recordTransaction(type, amount) {

    transactions.push({

      type,

      amount,

      timestamp: new Date(),

      balance: balance

    });

  }

  

  // Public API

  return {

    deposit(amount) {

      if (amount <= 0) throw new Error('Invalid amount');

      balance += amount;

      recordTransaction('deposit', amount);

      return balance;

    },

    

    withdraw(amount) {

      if (amount <= 0) throw new Error('Invalid amount');

      if (amount > balance) throw new Error('Insufficient funds');

      balance -= amount;

      recordTransaction('withdraw', amount);

      return balance;

    },

    

    getBalance() {

      return balance;

    },

    

    getTransactions() {

      return [...transactions]; // Return copy

    }

  };

}



const myWallet = createWallet(1000);

myWallet.deposit(500);     // 1500

myWallet.withdraw(200);    // 1300

console.log(myWallet.getBalance()); // 1300

// myWallet.balance = 99999; // ❌ Can't access private balance!

```



**2. Function Factories:**



Creating customized functions on demand:



```javascript

// HTTP request builder

function createHTTPClient(baseURL, defaultHeaders = {}) {

  return {

    async request(endpoint, options = {}) {

      const url = `${baseURL}${endpoint}`;

      const config = {

        ...options,

        headers: {

          ...defaultHeaders,

          ...options.headers

        }

      };

      

      const response = await fetch(url, config);

      return response.json();

    },

    

    get(endpoint) {

      return this.request(endpoint, { method: 'GET' });

    },

    

    post(endpoint, data) {

      return this.request(endpoint, {

        method: 'POST',

        body: JSON.stringify(data)

      });

    }

  };

}



// Create clients for different APIs

const githubAPI = createHTTPClient('https://api.github.com', {

  'Authorization': 'token GITHUB_TOKEN'

});



const internalAPI = createHTTPClient('https://internal.company.com/api', {

  'X-API-Key': 'internal-key'

});



githubAPI.get('/users/octocat');

internalAPI.post('/users', { name: 'John' });

```



**3. Memoization / Caching:**



Remembering computed results to avoid redundant calculations:



```javascript

function memoize(fn) {

  const cache = new Map(); // Closure maintains cache

  

  return function(...args) {

    const key = JSON.stringify(args);

    

    if (cache.has(key)) {

      console.log('Cache hit!');

      return cache.get(key);

    }

    

    console.log('Computing...');

    const result = fn.apply(this, args);

    cache.set(key, result);

    return result;

  };

}



// Expensive Fibonacci calculation

function fibonacci(n) {

  if (n <= 1) return n;

  return fibonacci(n - 1) + fibonacci(n - 2);

}



const fastFib = memoize(fibonacci);



console.log(fastFib(40)); // Computing... (slow first time)

console.log(fastFib(40)); // Cache hit! (instant)



// Memoized API calls

const memoizedFetch = memoize(async (url) => {

  const response = await fetch(url);

  return response.json();

});



await memoizedFetch('/api/users'); // First call - hits server

await memoizedFetch('/api/users'); // Cache hit - instant

```



**4. Event Handlers with Private State:**



Managing state in event handlers without global variables:



```javascript

function setupCounter(buttonId, displayId) {

  let count = 0; // Private to this closure

  const button = document.getElementById(buttonId);

  const display = document.getElementById(displayId);

  

  button.addEventListener('click', function() {

    count++; // Accesses private count

    display.textContent = count;

  });

  

  return {

    reset() {

      count = 0;

      display.textContent = count;

    },

    getCount() {

      return count;

    }

  };

}



const counter1 = setupCounter('btn1', 'display1');

const counter2 = setupCounter('btn2', 'display2');

// Each counter has independent state via closures

```



**5. Partial Application and Currying:**



Creating specialized functions from general ones:



```javascript

// Partial application

function partial(fn, ...fixedArgs) {

  return function(...remainingArgs) {

    return fn(...fixedArgs, ...remainingArgs);

  };

}



function log(level, module, message) {

  console.log(`[${level}] [${module}] ${message}`);

}



const logError = partial(log, 'ERROR');

const logUserError = partial(log, 'ERROR', 'USER');



logError('AUTH', 'Login failed'); // [ERROR] [AUTH] Login failed

logUserError('Invalid email');    // [ERROR] [USER] Invalid email



// Discount calculator

function calculatePrice(basePrice, taxRate, discount) {

  return basePrice * (1 + taxRate) * (1 - discount);

}



const calculateWithTax = partial(calculatePrice, undefined, 0.1);

const calculateWithDiscount = partial(calculatePrice, undefined, 0.1, 0.2);



// More elegant currying

const multiply = a => b => c => a * b * c;

const multiplyBy2 = multiply(2);

const multiplyBy2And3 = multiplyBy2(3);

console.log(multiplyBy2And3(4)); // 24

```



**6. Module Pattern:**



Creating modules with public and private members:



```javascript

const DatabaseModule = (function() {

  // Private variables

  let connection = null;

  const queryCache = new Map();

  const MAX_RETRIES = 3;

  

  // Private functions

  function validateQuery(query) {

    if (!query || typeof query !== 'string') {

      throw new Error('Invalid query');

    }

  }

  

  async function retryOperation(operation, retries = MAX_RETRIES) {

    for (let i = 0; i < retries; i++) {

      try {

        return await operation();

      } catch (error) {

        if (i === retries - 1) throw error;

        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));

      }

    }

  }

  

  // Public API

  return {

    async connect(connectionString) {

      connection = await retryOperation(() => 

        establishConnection(connectionString)

      );

      console.log('Connected to database');

    },

    

    async query(sql) {

      validateQuery(sql);

      

      if (queryCache.has(sql)) {

        return queryCache.get(sql);

      }

      

      const result = await retryOperation(() => 

        connection.execute(sql)

      );

      

      queryCache.set(sql, result);

      return result;

    },

    

    clearCache() {

      queryCache.clear();

    },

    

    async disconnect() {

      if (connection) {

        await connection.close();

        connection = null;

        queryCache.clear();

      }

    }

  };

})();



// Usage

await DatabaseModule.connect('mongodb://localhost');

const users = await DatabaseModule.query('SELECT * FROM users');

```



**7. Debouncing and Throttling:**



Rate limiting function execution:



```javascript

function debounce(fn, delay) {

  let timeoutId; // Closure maintains timeout ID

  

  return function(...args) {

    clearTimeout(timeoutId);

    

    timeoutId = setTimeout(() => {

      fn.apply(this, args);

    }, delay);

  };

}



function throttle(fn, limit) {

  let inThrottle;

  let lastResult;

  

  return function(...args) {

    if (!inThrottle) {

      lastResult = fn.apply(this, args);

      inThrottle = true;

      

      setTimeout(() => {

        inThrottle = false;

      }, limit);

    }

    

    return lastResult;

  };

}



// Search as user types (debounced)

const searchAPI = debounce(function(query) {

  fetch(`/api/search?q=${query}`)

    .then(response => response.json())

    .then(results => displayResults(results));

}, 300);



document.getElementById('search').addEventListener('input', (e) => {

  searchAPI(e.target.value);

});



// Scroll handler (throttled)

const handleScroll = throttle(function() {

  const scrollPercent = (window.scrollY / document.body.scrollHeight) * 100;

  updateScrollIndicator(scrollPercent);

}, 100);



window.addEventListener('scroll', handleScroll);

```



**8. Iterator Pattern:**



Creating custom iterators with internal state:



```javascript

function createRangeIterator(start, end, step = 1) {

  let current = start; // Closure maintains state

  

  return {

    next() {

      if (current <= end) {

        const value = current;

        current += step;

        return { value, done: false };

      }

      return { done: true };

    },

    

    [Symbol.iterator]() {

      return this;

    }

  };

}



const range = createRangeIterator(1, 10, 2);

for (const num of range) {

  console.log(num); // 1, 3, 5, 7, 9

}



// Infinite sequence

function createInfiniteSequence(start = 0) {

  let current = start;

  

  return {

    next() {

      return { value: current++, done: false };

    }

  };

}



const sequence = createInfiniteSequence();

console.log(sequence.next().value); // 0

console.log(sequence.next().value); // 1

console.log(sequence.next().value); // 2

```



**9. Once Function:**



Ensuring a function runs only once:



```javascript

function once(fn) {

  let called = false;

  let result;

  

  return function(...args) {

    if (!called) {

      called = true;

      result = fn.apply(this, args);

    }

    return result;

  };

}



const initializeApp = once(function() {

  console.log('Initializing application...');

  // Expensive setup

  return { initialized: true, timestamp: Date.now() };

});



initializeApp(); // Runs initialization

initializeApp(); // Returns cached result

initializeApp(); // Returns cached result



// Singleton pattern

const DatabaseConnection = (function() {

  let instance;

  

  function createInstance() {

    return {

      connect() { console.log('Connected'); },

      query() { /* ... */ }

    };

  }

  

  return {

    getInstance() {

      if (!instance) {

        instance = createInstance();

      }

      return instance;

    }

  };

})();



const db1 = DatabaseConnection.getInstance();

const db2 = DatabaseConnection.getInstance();

console.log(db1 === db2); // true - same instance

```



**10. React Hooks Pattern:**



State management in functional components (similar to how React Hooks work internally):



```javascript

function createStatefulComponent() {

  let state = {}; // Closure maintains state

  const hooks = [];

  let hookIndex = 0;

  

  function useState(initialValue) {

    const currentIndex = hookIndex;

    hookIndex++;

    

    if (hooks[currentIndex] === undefined) {

      hooks[currentIndex] = initialValue;

    }

    

    const setState = (newValue) => {

      hooks[currentIndex] = newValue;

      render(); // Re-render component

    };

    

    return [hooks[currentIndex], setState];

  }

  

  function useEffect(callback, deps) {

    const currentIndex = hookIndex;

    hookIndex++;

    

    const oldDeps = hooks[currentIndex];

    const hasChanged = !oldDeps || deps.some((dep, i) => dep !== oldDeps[i]);

    

    if (hasChanged) {

      callback();

      hooks[currentIndex] = deps;

    }

  }

  

  function render() {

    hookIndex = 0; // Reset for next render

    component();

  }

  

  function component() {

    const [count, setCount] = useState(0);

    const [name, setName] = useState('Guest');

    

    useEffect(() => {

      console.log(`Count changed to ${count}`);

    }, [count]);

    

    return { count, setCount, name, setName };

  }

  

  return { render, component };

}

```



**Best Practices:**

- Use closures for data privacy (better than private symbols)

- Perfect for factory functions and configuration builders

- Essential for event handlers with state

- Enable functional programming patterns (memoization, currying)

- Be mindful of memory leaks (don't capture unnecessary data)

- Modern alternative to class-based encapsulation

- Combine with module systems for clean architecture





</details>
<details><summary>26. What is the scope chain?</summary>






**Answer:**

The scope chain is the mechanism JavaScript uses to resolve variable names when they're referenced in code. When a variable is accessed, JavaScript searches for it starting from the current scope and moving up through parent scopes until it finds the variable or reaches the global scope.



**How It Works:**



Each execution context (function or block) has a reference to its outer lexical environment, creating a chain of scopes.



```javascript

const globalVar = 'Global';



function outer() {

  const outerVar = 'Outer';

  

  function middle() {

    const middleVar = 'Middle';

    

    function inner() {

      const innerVar = 'Inner';

      

      // Scope chain lookup order:

      // 1. inner scope (innerVar)

      // 2. middle scope (middleVar)

      // 3. outer scope (outerVar)

      // 4. global scope (globalVar)

      

      console.log(innerVar);   // Found in step 1

      console.log(middleVar);  // Found in step 2

      console.log(outerVar);   // Found in step 3

      console.log(globalVar);  // Found in step 4

      

      // console.log(nonExistent); // ReferenceError: Searched entire chain

    }

    

    inner();

  }

  

  middle();

}



outer();

```



**Visual Representation:**



```

Global Scope

  ↓ (contains)

outer() Scope

  ↓ (contains)

middle() Scope

  ↓ (contains)

inner() Scope



When inner() looks for a variable:

inner → middle → outer → global → ReferenceError (if not found)

```



**Scope Chain Creation:**



```javascript

// Each function "remembers" where it was defined

const x = 'global x';



function first() {

  const x = 'first x';

  

  return function second() {

    const x = 'second x';

    

    return function third() {

      console.log(x); // 'second x' - stops at first match

    };

  };

}



const fn = first()();

fn(); // Scope chain: third → second → first → global

```



**Variable Shadowing:**



When a variable in an inner scope has the same name as one in outer scope:



```javascript

let name = 'Global';



function outer() {

  let name = 'Outer'; // Shadows global 'name'

  

  function inner() {

    let name = 'Inner'; // Shadows outer 'name'

    console.log(name);  // 'Inner' - stops at first match

  }

  

  inner();

  console.log(name); // 'Outer'

}



outer();

console.log(name); // 'Global'

```



**Scope Chain and Closures:**



Closures work because functions maintain references to their scope chain:



```javascript

function createCounter() {

  let count = 0; // In createCounter's scope

  

  return function increment() {

    count++; // Looks up scope chain: increment → createCounter

    return count;

  };

}



const counter = createCounter();

counter(); // 1 - still has access to 'count' via scope chain

counter(); // 2

```



**Production Example - Nested Configuration:**



```javascript

const appConfig = {

  apiUrl: 'https://api.example.com',

  timeout: 5000

};



function createService(serviceName) {

  const serviceUrl = `${appConfig.apiUrl}/${serviceName}`;

  

  return {

    get(endpoint) {

      const fullUrl = `${serviceUrl}${endpoint}`;

      

      return fetch(fullUrl, {

        timeout: appConfig.timeout // Scope chain: method → service → global

      });

    },

    

    post(endpoint, data) {

      const fullUrl = `${serviceUrl}${endpoint}`;

      

      return fetch(fullUrl, {

        method: 'POST',

        body: JSON.stringify(data),

        timeout: appConfig.timeout

      });

    }

  };

}



const userService = createService('users');

userService.get('/profile'); // Access variables from multiple scopes

```



**Scope Chain with `let`, `const`, and `var`:**



```javascript

function testScope() {

  console.log(varVariable);   // undefined (hoisted)

  // console.log(letVariable); // ReferenceError (TDZ)

  

  var varVariable = 'var';

  let letVariable = 'let';

  

  {

    var blockVar = 'not block scoped';

    let blockLet = 'block scoped';

    

    // Scope chain for this block:

    // Current block → testScope → global

  }

  

  console.log(blockVar);     // 'not block scoped' (var ignores blocks)

  // console.log(blockLet);  // ReferenceError (block scoped)

}

```



**Performance Implications:**



```javascript

// Longer scope chains = slower lookups

const global1 = 'value';



function level1() {

  const level1Var = 'value';

  

  function level2() {

    const level2Var = 'value';

    

    function level3() {

      const level3Var = 'value';

      

      function level4() {

        // ⚠️ Deep nesting - slower to access global1

        console.log(global1); // Must traverse entire chain

        

        // ✅ Faster - local variable

        console.log(level3Var);

      }

      

      level4();

    }

    

    level3();

  }

  

  level2();

}



// Optimization: Store frequently accessed variables locally

function optimized() {

  const localGlobal = global1; // Cache in local scope

  

  function inner() {

    console.log(localGlobal); // Faster - shorter lookup

  }

  

  inner();

}

```



**Scope Chain vs Prototype Chain:**



Don't confuse these two concepts:



```javascript

// Scope chain - for variable lookup

function outer() {

  const x = 10;

  

  function inner() {

    console.log(x); // Scope chain lookup

  }

  

  inner();

}



// Prototype chain - for property lookup on objects

const obj = { a: 1 };

console.log(obj.toString()); // Prototype chain: obj → Object.prototype

```



**Common Pitfalls:**



**1. Accidental Global Creation:**

```javascript

function oops() {

  // Forgot 'let' - creates global after scope chain search fails

  someVar = 'value'; // Searches entire scope chain, then creates global

}



'use strict'; // Prevents this

function safe() {

  // someVar = 'value'; // ReferenceError in strict mode

}

```



**2. Loop Variable Capture:**

```javascript

// ❌ All closures share same 'i' in scope chain

for (var i = 0; i < 3; i++) {

  setTimeout(() => console.log(i), 100); // 3, 3, 3

}



// ✅ Each iteration has own scope

for (let i = 0; i < 3; i++) {

  setTimeout(() => console.log(i), 100); // 0, 1, 2

}

```



**3. Memory Leaks from Long Scope Chains:**

```javascript

function createLeak() {

  const largeData = new Array(1000000).fill('data');

  

  return function() {

    // Even if not using largeData, it stays in scope chain

    console.log('hello');

  };

}



// ✅ Better - only keep what you need

function noLeak() {

  const largeData = new Array(1000000).fill('data');

  const summary = largeData.length;

  

  return function() {

    console.log(summary); // Only summary in scope chain, not largeData

  };

}

```



**Debugging Scope Chain:**



```javascript

function debugScopes() {

  const localVar = 'local';

  

  debugger; // Pause here

  

  function inner() {

    const innerVar = 'inner';

    debugger; // Check scope chain in dev tools

    console.log(localVar); // Inspect how it's resolved

  }

  

  inner();

}



// In Chrome DevTools:

// 1. Open Sources tab

// 2. Hit debugger breakpoint

// 3. View "Scope" panel showing scope chain

```



**Best Practices:**



- Minimize scope chain depth for performance

- Use local variables for frequently accessed outer scope values

- Understand that closures extend scope chain lifetime

- Be aware of memory implications with large scope chains

- Use `const` and `let` to create proper block scopes

- Use strict mode to catch accidental global creation

- Keep functions shallow when possible



**Key Takeaways:**

- Scope chain is how JavaScript resolves variable references

- Search goes from inner to outer scopes

- Stops at first match (variable shadowing)

- Created when function is defined (lexical scoping)

- Essential to understanding closures and variable access

- Longer chains can impact performance slightly





</details>
<details><summary>27. What is block scope?</summary>






**Answer:**

Block scope is a scope created by a pair of curly braces `{}`. Variables declared with `let` and `const` inside a block are only accessible within that block and not outside it. This was introduced in ES6 (2015).



**Block Scope Basics:**



```javascript

{

  // This is a block

  let blockScoped = 'I am block scoped';

  const alsoBlockScoped = 'Me too';

  var notBlockScoped = 'I am NOT block scoped';

  

  console.log(blockScoped);      // ✅ Accessible

  console.log(alsoBlockScoped);  // ✅ Accessible

  console.log(notBlockScoped);   // ✅ Accessible

}



// console.log(blockScoped);      // ❌ ReferenceError

// console.log(alsoBlockScoped);  // ❌ ReferenceError

console.log(notBlockScoped);   // ✅ 'I am NOT block scoped' (var ignores blocks!)

```



**Block Scope in Different Contexts:**



**1. If Statements:**

```javascript

const age = 20;



if (age >= 18) {

  let status = 'adult';

  const canVote = true;

  var message = 'Welcome';

  

  console.log(status);   // ✅ 'adult'

  console.log(canVote);  // ✅ true

}



// console.log(status);   // ❌ ReferenceError

// console.log(canVote);  // ❌ ReferenceError

console.log(message);     // ✅ 'Welcome' (var leaks out)

```



**2. For Loops:**

```javascript

// Classic problem with var

for (var i = 0; i < 3; i++) {

  setTimeout(() => console.log(i), 100);

}

// Output: 3, 3, 3 (all share same 'i')



// Fixed with let (each iteration has own block scope)

for (let i = 0; i < 3; i++) {

  setTimeout(() => console.log(i), 100);

}

// Output: 0, 1, 2 (each closure captures its own 'i')



// let creates a new binding for each iteration

for (let i = 0; i < 3; i++) {

  let i = 'inner'; // Different variable!

  console.log(i);  // 'inner', 'inner', 'inner'

}

```



**3. Switch Statements:**

```javascript

const action = 'start';



switch (action) {

  case 'start': {

    // Block scope prevents variable collision

    let message = 'Starting...';

    console.log(message);

    break;

  }

  case 'stop': {

    let message = 'Stopping...'; // Different variable

    console.log(message);

    break;

  }

  default: {

    let message = 'Unknown action';

    console.log(message);

  }

}



// Without blocks - error!

switch (action) {

  case 'start':

    let message = 'Starting...';

    break;

  case 'stop':

    // let message = 'Stopping...'; // ❌ SyntaxError: Identifier 'message' already declared

    break;

}

```



**4. Try-Catch Blocks:**

```javascript

try {

  let result = riskyOperation();

  const data = processData(result);

  console.log(data);

} catch (error) {

  // 'error' is block-scoped to catch block

  console.error(error);

  let retryCount = 0;

  // Handle error

}



// console.log(result); // ❌ ReferenceError

// console.log(error);  // ❌ ReferenceError

```



**5. Standalone Blocks:**

```javascript

// You can create blocks anywhere

{

  let temp = expensiveCalculation();

  let result = process(temp);

  saveResult(result);

}

// temp and result are garbage collected here



// Useful for limiting variable lifetime

{

  const tempData = fetchLargeData();

  processData(tempData);

  // tempData can be garbage collected now

}

```



**Block Scope vs Function Scope:**



```javascript

function testScopes() {

  // Function scope - entire function

  var functionScoped = 'Available throughout function';

  

  if (true) {

    // Block scope - only in this block

    let blockScoped = 'Only in this block';

    var alsoFunctionScoped = 'Also available throughout function';

    

    console.log(blockScoped);      // ✅ Works

    console.log(functionScoped);   // ✅ Works

  }

  

  console.log(functionScoped);       // ✅ Works

  console.log(alsoFunctionScoped);   // ✅ Works (var)

  // console.log(blockScoped);       // ❌ ReferenceError

}

```



**Temporal Dead Zone (TDZ) in Block Scope:**



```javascript

{

  // TDZ for x starts here

  console.log(x); // ❌ ReferenceError: Cannot access before initialization

  let x = 10;     // TDZ ends here

  console.log(x); // ✅ 10

}



{

  console.log(y); // undefined (var is hoisted)

  var y = 20;

  console.log(y); // 20

}

```



**Production Use Cases:**



**1. Limiting Variable Lifetime:**

```javascript

function processUsers(users) {

  const results = [];

  

  for (const user of users) {

    // Each iteration has its own block scope

    let isValid = validateUser(user);

    let processedData = null;

    

    if (isValid) {

      processedData = transformUser(user);

      results.push(processedData);

    }

    

    // isValid and processedData are cleaned up here

  }

  

  return results;

}



// vs using var (all variables stay in memory longer)

function processUsersOld(users) {

  var results = [];

  

  for (var i = 0; i < users.length; i++) {

    var isValid = validateUser(users[i]);

    var processedData = null;

    

    if (isValid) {

      processedData = transformUser(users[i]);

      results.push(processedData);

    }

    

    // isValid and processedData still in memory

  }

  

  return results;

}

```



**2. Event Handlers in Loops:**

```javascript

// ✅ Correct - each handler has its own 'index'

const buttons = document.querySelectorAll('.button');



buttons.forEach((button, index) => {

  // let creates block scope for each iteration

  button.addEventListener('click', () => {

    console.log(`Button ${index} clicked`);

  });

});



// ❌ Wrong - all handlers share same 'i'

for (var i = 0; i < buttons.length; i++) {

  buttons[i].addEventListener('click', () => {

    console.log(`Button ${i} clicked`); // Always logs final value of i

  });

}



// ✅ Fixed with let

for (let i = 0; i < buttons.length; i++) {

  buttons[i].addEventListener('click', () => {

    console.log(`Button ${i} clicked`); // Correct index

  });

}

```



**3. Avoiding Variable Pollution:**

```javascript

function calculateTotal(items) {

  let total = 0;

  

  // Temporary calculation block

  {

    let tax = 0;

    let discount = 0;

    

    for (const item of items) {

      if (item.taxable) {

        tax += item.price * 0.1;

      }

      if (item.onSale) {

        discount += item.price * 0.2;

      }

    }

    

    total = items.reduce((sum, item) => sum + item.price, 0);

    total = total + tax - discount;

  }

  

  // tax and discount are no longer accessible

  return total;

}

```



**4. Switch Statement Safety:**

```javascript

function handleAction(action, data) {

  switch (action) {

    case 'CREATE': {

      let newItem = createItem(data);

      return saveToDatabase(newItem);

    }

    case 'UPDATE': {

      let newItem = updateItem(data); // Different variable, no conflict

      return saveToDatabase(newItem);

    }

    case 'DELETE': {

      return deleteFromDatabase(data);

    }

  }

}

```



**5. Resource Cleanup:**

```javascript

async function processFile(filename) {

  let fileHandle;

  

  try {

    fileHandle = await openFile(filename);

    

    {

      // Processing in its own block

      let data = await fileHandle.read();

      let processed = transformData(data);

      await saveProcessed(processed);

      

      // data and processed can be garbage collected here

    }

    

  } finally {

    if (fileHandle) {

      await fileHandle.close();

    }

  }

}

```



**Block Scope and Hoisting:**



```javascript

console.log(x); // undefined (var is hoisted)

var x = 10;



// console.log(y); // ReferenceError (let is hoisted but in TDZ)

let y = 20;



// The difference:

// var: hoisted and initialized to undefined

// let/const: hoisted but not initialized (TDZ)



{

  // var is hoisted to function/global scope

  var a = 1;

  

  // let is hoisted to block scope only

  let b = 2;

}



console.log(a); // ✅ 1

// console.log(b); // ❌ ReferenceError

```



**Nested Block Scopes:**



```javascript

let outer = 'outer';



{

  let outer = 'first block';

  console.log(outer); // 'first block'

  

  {

    let outer = 'second block';

    console.log(outer); // 'second block'

    

    {

      let outer = 'third block';

      console.log(outer); // 'third block'

    }

    

    console.log(outer); // 'second block'

  }

  

  console.log(outer); // 'first block'

}



console.log(outer); // 'outer'

```



**Best Practices:**



```javascript

// ✅ Use const by default

const API_URL = 'https://api.example.com';



// ✅ Use let when you need to reassign

let counter = 0;

counter++;



// ❌ Avoid var in modern code

// var oldStyle = 'avoid this';



// ✅ Create blocks to limit scope

{

  const tempData = getLargeData();

  processData(tempData);

  // tempData released here

}



// ✅ Use block scope in loops

for (let i = 0; i < 10; i++) {

  // Each iteration has its own 'i'

}



// ✅ Block scope in switch statements

switch (type) {

  case 'A': {

    const result = handleA();

    return result;

  }

  case 'B': {

    const result = handleB();

    return result;

  }

}

```



**Key Takeaways:**

- Block scope applies to `let` and `const` (not `var`)

- Created by `{}` in if, for, while, switch, try-catch, or standalone blocks

- Variables are only accessible within their block

- Each loop iteration with `let` creates a new block scope

- Helps prevent variable collisions and memory leaks

- Part of ES6, essential for modern JavaScript

- Use `const` by default, `let` when reassignment needed, avoid `var`





</details>
<details><summary>28. What is function scope?</summary>






**Answer:**

Function scope means that variables declared inside a function are only accessible within that function and its nested functions. This is the traditional scoping mechanism in JavaScript and applies to variables declared with `var`, as well as function parameters.



**Basic Function Scope:**



```javascript

function myFunction() {

  var functionScoped = 'I am function scoped';

  let alsoFunctionScoped = 'Me too';

  const andMe = 'And me';

  

  console.log(functionScoped);      // ✅ Accessible

  console.log(alsoFunctionScoped);  // ✅ Accessible

  console.log(andMe);               // ✅ Accessible

}



myFunction();

// console.log(functionScoped);      // ❌ ReferenceError

// console.log(alsoFunctionScoped);  // ❌ ReferenceError

// console.log(andMe);               // ❌ ReferenceError

```



**Function Scope vs Block Scope:**



```javascript

function demonstrateScopes() {

  // Function-scoped with var

  var functionVar = 'Available throughout function';

  

  if (true) {

    var stillFunctionScoped = 'Also throughout function';

    let blockScoped = 'Only in this block';

    

    console.log(functionVar);         // ✅ Works

    console.log(stillFunctionScoped); // ✅ Works

    console.log(blockScoped);         // ✅ Works

  }

  

  console.log(functionVar);           // ✅ Works

  console.log(stillFunctionScoped);   // ✅ Works (var ignores block)

  // console.log(blockScoped);        // ❌ ReferenceError (block-scoped)

}

```



**Function Parameters are Function-Scoped:**



```javascript

function greet(name, age) {

  // name and age are function-scoped

  console.log(name); // Accessible

  console.log(age);  // Accessible

  

  function inner() {

    // Parameters accessible in nested functions

    console.log(name); // ✅ Accessible via scope chain

  }

  

  inner();

}



greet('John', 30);

// console.log(name); // ❌ ReferenceError

```



**Nested Functions and Function Scope:**



```javascript

function outer() {

  var outerVar = 'Outer';

  

  function inner() {

    var innerVar = 'Inner';

    

    console.log(outerVar); // ✅ Accessible (parent function scope)

    console.log(innerVar); // ✅ Accessible (own scope)

  }

  

  inner();

  console.log(outerVar);   // ✅ Accessible

  // console.log(innerVar); // ❌ ReferenceError (child scope not accessible)

}



outer();

```



**var is Function-Scoped (Key Difference from let/const):**



```javascript

function testVar() {

  console.log(x); // undefined (hoisted but not initialized)

  

  if (true) {

    var x = 10; // Function-scoped, not block-scoped

  }

  

  console.log(x); // ✅ 10 (accessible outside if block)

  

  for (var i = 0; i < 3; i++) {

    // i is function-scoped

  }

  

  console.log(i); // ✅ 3 (accessible outside loop)

}



function testLet() {

  // console.log(y); // ReferenceError (TDZ)

  

  if (true) {

    let y = 10; // Block-scoped

  }

  

  // console.log(y); // ❌ ReferenceError

  

  for (let j = 0; j < 3; j++) {

    // j is block-scoped to loop

  }

  

  // console.log(j); // ❌ ReferenceError

}

```



**Function Scope and Hoisting:**



```javascript

function hoistingDemo() {

  console.log(a); // undefined (hoisted)

  console.log(b); // undefined (hoisted)

  

  var a = 10;

  

  if (true) {

    var b = 20; // Still hoisted to function scope

  }

  

  console.log(a); // 10

  console.log(b); // 20

}



// Behind the scenes (conceptually):

function hoistingDemo() {

  var a; // Hoisted to top of function

  var b; // Hoisted to top of function

  

  console.log(a); // undefined

  console.log(b); // undefined

  

  a = 10;

  

  if (true) {

    b = 20;

  }

  

  console.log(a); // 10

  console.log(b); // 20

}

```



**Function Declarations are Function-Scoped:**



```javascript

function outer() {

  // Function declaration is hoisted in function scope

  console.log(inner()); // ✅ Works (hoisted)

  

  function inner() {

    return 'Inner function';

  }

  

  if (true) {

    // Function declaration in block (behavior varies by mode)

    function blockFunction() {

      return 'Block function';

    }

  }

  

  // In non-strict mode, blockFunction might be accessible

  // In strict mode, it's block-scoped

}

```



**Production Use Cases:**



**1. Module Pattern (Pre-ES6 Modules):**

```javascript

const counterModule = (function() {

  // Function scope creates private variables

  var count = 0;

  var maxCount = 100;

  

  function validateCount(newCount) {

    return newCount >= 0 && newCount <= maxCount;

  }

  

  // Return public API

  return {

    increment: function() {

      if (validateCount(count + 1)) {

        count++;

      }

      return count;

    },

    

    decrement: function() {

      if (validateCount(count - 1)) {

        count--;

      }

      return count;

    },

    

    getCount: function() {

      return count;

    },

    

    reset: function() {

      count = 0;

    }

  };

})();



counterModule.increment(); // 1

counterModule.increment(); // 2

// counterModule.count;    // undefined (private!)

// counterModule.maxCount; // undefined (private!)

```



**2. Immediately Invoked Function Expression (IIFE):**

```javascript

// Create isolated function scope

(function() {

  var privateVar = 'Private';

  var helper = function() { /* ... */ };

  

  // Only expose what's needed

  window.MyLibrary = {

    publicMethod: function() {

      return privateVar;

    }

  };

})();



// privateVar and helper are not accessible globally

```



**3. Closure with Function Scope:**

```javascript

function createCounter(initialCount) {

  var count = initialCount; // Function-scoped, private

  

  return {

    increment: function() {

      count++;

      return count;

    },

    decrement: function() {

      count--;

      return count;

    },

    getCount: function() {

      return count;

    }

  };

}



const counter1 = createCounter(0);

const counter2 = createCounter(10);



counter1.increment(); // 1

counter2.increment(); // 11

// Each has its own function scope

```



**4. Loop Variable Problem with Function Scope:**

```javascript

// ❌ Classic problem with var (function-scoped)

var callbacks = [];



for (var i = 0; i < 3; i++) {

  callbacks.push(function() {

    console.log(i); // All closures share same 'i'

  });

}



callbacks[0](); // 3

callbacks[1](); // 3

callbacks[2](); // 3



// ✅ Solution 1: IIFE creates new function scope

var callbacks = [];



for (var i = 0; i < 3; i++) {

  callbacks.push((function(index) {

    return function() {

      console.log(index); // Each has its own 'index'

    };

  })(i));

}



callbacks[0](); // 0

callbacks[1](); // 1

callbacks[2](); // 2



// ✅ Solution 2: Use let (block-scoped)

const callbacks = [];



for (let i = 0; i < 3; i++) {

  callbacks.push(function() {

    console.log(i); // Each iteration has its own 'i'

  });

}



callbacks[0](); // 0

callbacks[1](); // 1

callbacks[2](); // 2

```



**5. Avoiding Global Pollution:**

```javascript

// ❌ Bad - pollutes global scope

var config = { /* ... */ };

var helper1 = function() { /* ... */ };

var helper2 = function() { /* ... */ };



// ✅ Good - use function scope

(function() {

  var config = { /* ... */ };

  var helper1 = function() { /* ... */ };

  var helper2 = function() { /* ... */ };

  

  // Initialize app

  init();

})();



// ✅ Modern - use modules

// config.js

export const config = { /* ... */ };



// helpers.js

export function helper1() { /* ... */ }

export function helper2() { /* ... */ }

```



**Function Scope and `this`:**



```javascript

function Person(name) {

  var self = this; // Store reference in function scope

  

  this.name = name;

  this.age = 0;

  

  // setTimeout uses different 'this'

  setTimeout(function() {

    // this.age++; // ❌ 'this' is not Person instance

    self.age++;    // ✅ Uses stored reference

    console.log(self.name, self.age);

  }, 1000);

  

  // Modern solution: arrow function (lexical this)

  setTimeout(() => {

    this.age++; // ✅ Arrow function inherits 'this'

    console.log(this.name, this.age);

  }, 1000);

}

```



**Function Scope in Classes:**



```javascript

class Counter {

  constructor() {

    this.count = 0;

    

    // Function expression - can access class scope

    this.increment = function() {

      this.count++; // 'this' refers to instance

    };

  }

  

  // Method - on prototype

  decrement() {

    this.count--;

  }

}



const counter = new Counter();

counter.increment(); // Works

counter.decrement(); // Works

```



**Best Practices:**



```javascript

// ✅ Use let/const instead of var in modern code

function modern() {

  const data = fetchData();

  let count = 0;

  

  for (let i = 0; i < data.length; i++) {

    count += data[i];

  }

  

  return count;

}



// ❌ Avoid var (function-scoped, confusing)

function legacy() {

  var data = fetchData();

  var count = 0;

  

  for (var i = 0; i < data.length; i++) {

    count += data[i];

  }

  

  return count;

}



// ✅ Use IIFE for isolation when needed

(function() {

  // Isolated function scope

  const privateData = { /* ... */ };

  

  // Expose only what's needed

  window.MyAPI = {

    getData() { return { ...privateData }; }

  };

})();



// ✅ Use modules (ES6+) instead of IIFE

// myModule.js

const privateData = { /* ... */ };



export function getData() {

  return { ...privateData };

}

```



**Key Takeaways:**

- Function scope means variables are accessible throughout the entire function

- Applies to `var`, function parameters, and function declarations

- Variables are hoisted to the top of the function

- `var` is function-scoped (ignores blocks like if, for, while)

- `let` and `const` are block-scoped (more restrictive)

- Function scope enables closures and private data

- Modern code prefers block-scoped `let`/`const` over function-scoped `var`

- IIFE pattern uses function scope for encapsulation

- Understanding function scope is essential for understanding closures



## Objects & Prototypes





</details>
<details><summary>29. What are objects in JavaScript?</summary>






**Answer:**

Objects are JavaScript's fundamental data structure for storing collections of key-value pairs. They are the building blocks of JavaScript and nearly everything in JavaScript is an object or behaves like one (except primitives).



**What is an Object?**



An object is a collection of **properties**, where each property is an association between a **key** (string or Symbol) and a **value** (any type).



```javascript

// Simple object

const person = {

  name: 'John',

  age: 30,

  email: 'john@example.com'

};



// Accessing properties

console.log(person.name);       // 'John' (dot notation)

console.log(person['age']);     // 30 (bracket notation)

```



**Object Characteristics:**



**1. Key-Value Pairs:**

```javascript

const user = {

  // String keys

  firstName: 'John',

  'last-name': 'Doe',  // Keys with special chars need quotes

  

  // Number keys (converted to strings)

  1: 'one',

  2: 'two',

  

  // Values can be any type

  age: 30,              // Number

  isActive: true,       // Boolean

  hobbies: ['coding'],  // Array

  address: {            // Nested object

    city: 'New York'

  },

  greet: function() {   // Function (method)

    return `Hello, ${this.firstName}`;

  }

};



console.log(user[1]);           // 'one'

console.log(user['last-name']); // 'Doe'

console.log(user.greet());      // 'Hello, John'

```



**2. Dynamic Nature:**

```javascript

const obj = {};



// Add properties dynamically

obj.name = 'John';

obj['age'] = 30;

obj.greet = function() { return 'Hello'; };



// Modify properties

obj.name = 'Jane';



// Delete properties

delete obj.age;



console.log(obj); // { name: 'Jane', greet: [Function] }

```



**3. Reference Type:**

```javascript

// Objects are passed by reference

const original = { count: 0 };

const reference = original;



reference.count = 10;

console.log(original.count); // 10 (both point to same object)



// Comparison by reference

const a = { value: 1 };

const b = { value: 1 };

console.log(a === b);        // false (different objects)



const c = a;

console.log(a === c);        // true (same reference)

```



**Property Access Methods:**



```javascript

const person = {

  name: 'John',

  age: 30

};



// Dot notation (preferred for valid identifiers)

console.log(person.name);



// Bracket notation (required for special cases)

console.log(person['name']);



// Dynamic property access

const prop = 'age';

console.log(person[prop]); // 30



// Computed property names (ES6)

const dynamicKey = 'email';

const user = {

  [dynamicKey]: 'john@example.com',

  [`${dynamicKey}Verified`]: true

};

console.log(user.email);         // 'john@example.com'

console.log(user.emailVerified); // true

```



**Methods in Objects:**



```javascript

const calculator = {

  value: 0,

  

  // Method: function property

  add: function(n) {

    this.value += n;

    return this;

  },

  

  // ES6 method shorthand

  subtract(n) {

    this.value -= n;

    return this;

  },

  

  // Arrow function (doesn't have own 'this')

  multiply: (n) => {

    // this.value *= n; // ❌ 'this' doesn't refer to calculator

  },

  

  getValue() {

    return this.value;

  }

};



calculator.add(5).subtract(2); // Method chaining

console.log(calculator.getValue()); // 3

```



**Everything is an Object (Almost):**



```javascript

// Primitives have object wrappers

const str = 'hello';

console.log(str.toUpperCase()); // 'HELLO' (temporary String object)

console.log(str.length);        // 5



// Arrays are objects

const arr = [1, 2, 3];

console.log(typeof arr);        // 'object'

console.log(Array.isArray(arr)); // true



// Functions are objects

function greet() {}

greet.customProperty = 'value';

console.log(typeof greet);      // 'function' (special object)

console.log(greet.customProperty); // 'value'



// null is special

console.log(typeof null);       // 'object' (historical bug)

```



**Built-in Object Types:**



```javascript

// Object literal

const obj = {};



// Array

const arr = [1, 2, 3];



// Function

const func = function() {};



// Date

const date = new Date();



// RegExp

const regex = /ab+c/;



// Map (ES6)

const map = new Map();



// Set (ES6)

const set = new Set();



// Error

const error = new Error('Something went wrong');

```



**Production Use Cases:**



**1. Data Modeling:**

```javascript

const product = {

  id: 1001,

  name: 'Laptop',

  price: 999.99,

  category: 'Electronics',

  inStock: true,

  specifications: {

    cpu: 'Intel i7',

    ram: '16GB',

    storage: '512GB SSD'

  },

  tags: ['computer', 'portable', 'work'],

  

  getDisplayPrice() {

    return `$${this.price.toFixed(2)}`;

  },

  

  applyDiscount(percent) {

    this.price *= (1 - percent / 100);

    return this;

  }

};

```



**2. Configuration Objects:**

```javascript

const apiConfig = {

  baseURL: 'https://api.example.com',

  timeout: 5000,

  headers: {

    'Content-Type': 'application/json',

    'Authorization': 'Bearer token'

  },

  retries: 3,

  

  request(endpoint, options = {}) {

    const url = `${this.baseURL}${endpoint}`;

    return fetch(url, {

      ...options,

      timeout: this.timeout,

      headers: { ...this.headers, ...options.headers }

    });

  }

};

```



**3. State Management:**

```javascript

const appState = {

  user: null,

  isAuthenticated: false,

  theme: 'light',

  notifications: [],

  

  login(user) {

    this.user = user;

    this.isAuthenticated = true;

    this.notify('Login successful');

  },

  

  logout() {

    this.user = null;

    this.isAuthenticated = false;

    this.notify('Logged out');

  },

  

  notify(message) {

    this.notifications.push({

      message,

      timestamp: Date.now()

    });

  }

};

```



**4. Namespacing:**

```javascript

// Avoid global pollution

const MyApp = {

  config: {

    version: '1.0.0',

    apiUrl: 'https://api.example.com'

  },

  

  utils: {

    formatDate(date) { /* ... */ },

    validateEmail(email) { /* ... */ }

  },

  

  services: {

    userService: {

      getUser() { /* ... */ },

      updateUser() { /* ... */ }

    },

    authService: {

      login() { /* ... */ },

      logout() { /* ... */ }

    }

  },

  

  init() {

    console.log(`App ${this.config.version} initialized`);

  }

};



MyApp.init();

```



**5. Options/Settings Pattern:**

```javascript

function createSlider(element, options = {}) {

  // Merge with defaults

  const settings = {

    autoplay: false,

    speed: 300,

    infinite: true,

    arrows: true,

    dots: true,

    ...options  // Override defaults

  };

  

  return {

    element,

    settings,

    

    play() {

      if (this.settings.autoplay) {

        // Start autoplay

      }

    },

    

    next() {

      // Go to next slide

    }

  };

}



const slider = createSlider('.slider', {

  autoplay: true,

  speed: 500

});

```



**Object Literal Enhancements (ES6+):**



```javascript

const name = 'John';

const age = 30;



// Property shorthand

const person = {

  name,    // Same as name: name

  age      // Same as age: age

};



// Method shorthand

const obj = {

  // Old way

  greet: function() {

    return 'Hello';

  },

  

  // New way

  greet() {

    return 'Hello';

  }

};



// Computed property names

const propName = 'score';

const game = {

  [propName]: 100,

  [`${propName}Multiplier`]: 2

};



console.log(game.score);           // 100

console.log(game.scoreMultiplier); // 2

```



**Checking Properties:**



```javascript

const user = {

  name: 'John',

  age: 30

};



// Check if property exists

console.log('name' in user);          // true

console.log('email' in user);         // false



// hasOwnProperty (checks own properties, not inherited)

console.log(user.hasOwnProperty('name'));     // true

console.log(user.hasOwnProperty('toString')); // false (inherited)



// Check if property value is undefined

console.log(user.name !== undefined);  // true

console.log(user.email !== undefined); // false



// Optional chaining (ES2020)

console.log(user?.email?.toLowerCase()); // undefined (no error)

```



**Key Takeaways:**

- Objects are collections of key-value pairs (properties)

- Keys are strings or Symbols, values can be any type

- Objects are reference types (passed by reference)

- Nearly everything in JavaScript is an object

- Objects are mutable and dynamic

- Essential for data modeling, configuration, and state management

- Foundation of object-oriented programming in JavaScript

- Understanding objects is crucial for mastering JavaScript





</details>
<details><summary>30. What are the different ways to create objects?</summary>






**Answer:**

JavaScript provides multiple ways to create objects, each with its own use cases and advantages. Understanding these methods is essential for effective object-oriented programming in JavaScript.



**1. Object Literal (Most Common):**



The simplest and most direct way to create objects.



```javascript

// Empty object

const emptyObj = {};



// Object with properties

const person = {

  name: 'John',

  age: 30,

  greet() {

    return `Hello, I'm ${this.name}`;

  }

};



console.log(person.name);  // 'John'

console.log(person.greet()); // "Hello, I'm John"



// Nested objects

const user = {

  id: 1,

  name: 'John',

  address: {

    street: '123 Main St',

    city: 'New York',

    country: 'USA'

  },

  settings: {

    theme: 'dark',

    notifications: true

  }

};

```



**When to use:** Quick object creation, configuration objects, single instances, JSON-like data structures.



**2. Object Constructor (new Object()):**



Less common, but useful to understand.



```javascript

// Using Object constructor

const person = new Object();

person.name = 'John';

person.age = 30;

person.greet = function() {

  return `Hello, I'm ${this.name}`;

};



// Equivalent to object literal

const person2 = {

  name: 'John',

  age: 30,

  greet() {

    return `Hello, I'm ${this.name}`;

  }

};



console.log(person.name); // 'John'

```



**When to use:** Rarely used; object literals are preferred. Sometimes useful when the type is determined dynamically.



**3. Constructor Function (Pre-ES6 Classes):**



Pattern for creating multiple objects with the same structure.



```javascript

// Constructor function (capitalize first letter by convention)

function Person(name, age) {

  this.name = name;

  this.age = age;

  this.greet = function() {

    return `Hello, I'm ${this.name}`;

  };

}



// Create instances with 'new' keyword

const john = new Person('John', 30);

const jane = new Person('Jane', 25);



console.log(john.name);   // 'John'

console.log(jane.greet()); // "Hello, I'm Jane"



// Adding methods to prototype (more efficient)

Person.prototype.sayAge = function() {

  return `I am ${this.age} years old`;

};



console.log(john.sayAge()); // "I am 30 years old"



// Check instance

console.log(john instanceof Person); // true

```



**When to use:** Creating multiple instances with shared behavior, before ES6 classes, understanding JavaScript's prototypal inheritance.



**4. ES6 Classes (Modern Approach):**



Syntactic sugar over constructor functions, providing cleaner syntax.



```javascript

class Person {

  constructor(name, age) {

    this.name = name;

    this.age = age;

  }

  

  // Methods are added to prototype automatically

  greet() {

    return `Hello, I'm ${this.name}`;

  }

  

  sayAge() {

    return `I am ${this.age} years old`;

  }

  

  // Static method

  static species() {

    return 'Homo sapiens';

  }

  

  // Getter

  get info() {

    return `${this.name}, ${this.age}`;

  }

  

  // Setter

  set age(value) {

    if (value < 0) throw new Error('Age must be positive');

    this._age = value;

  }

}



const john = new Person('John', 30);

console.log(john.greet());        // "Hello, I'm John"

console.log(Person.species());    // 'Homo sapiens'



// Inheritance

class Employee extends Person {

  constructor(name, age, jobTitle) {

    super(name, age); // Call parent constructor

    this.jobTitle = jobTitle;

  }

  

  // Override method

  greet() {

    return `${super.greet()}, I'm a ${this.jobTitle}`;

  }

}



const emp = new Employee('Alice', 28, 'Developer');

console.log(emp.greet()); // "Hello, I'm Alice, I'm a Developer"

```



**When to use:** Modern object-oriented programming, inheritance, cleaner syntax, production applications.



**5. Object.create() (Prototypal Inheritance):**



Creates a new object with specified prototype.



```javascript

// Create object with specific prototype

const personPrototype = {

  greet() {

    return `Hello, I'm ${this.name}`;

  },

  sayAge() {

    return `I am ${this.age} years old`;

  }

};



// Create object inheriting from personPrototype

const john = Object.create(personPrototype);

john.name = 'John';

john.age = 30;



console.log(john.greet()); // "Hello, I'm John"



// With properties

const jane = Object.create(personPrototype, {

  name: {

    value: 'Jane',

    writable: true,

    enumerable: true,

    configurable: true

  },

  age: {

    value: 25,

    writable: true,

    enumerable: true,

    configurable: true

  }

});



console.log(jane.sayAge()); // "I am 25 years old"



// Create object with null prototype (no inherited properties)

const pureObj = Object.create(null);

pureObj.name = 'Pure';

console.log(pureObj.toString); // undefined (no inherited methods)

```



**When to use:** Prototypal inheritance, avoiding constructor overhead, creating objects without `Object.prototype` methods.



**6. Factory Functions:**



Functions that return new objects without using `new`.



```javascript

// Simple factory

function createPerson(name, age) {

  return {

    name,

    age,

    greet() {

      return `Hello, I'm ${this.name}`;

    }

  };

}



const john = createPerson('John', 30);

const jane = createPerson('Jane', 25);



console.log(john.greet()); // "Hello, I'm John"



// Factory with private variables (closure)

function createCounter(initialValue = 0) {

  let count = initialValue; // Private variable

  

  return {

    increment() {

      count++;

      return count;

    },

    decrement() {

      count--;

      return count;

    },

    getCount() {

      return count;

    }

  };

}



const counter = createCounter(10);

console.log(counter.increment()); // 11

console.log(counter.getCount());  // 11

// counter.count; // undefined (truly private)



// Factory with validation

function createUser(name, email) {

  if (!email.includes('@')) {

    throw new Error('Invalid email');

  }

  

  return {

    name,

    email,

    toString() {

      return `${this.name} <${this.email}>`;

    }

  };

}



const user = createUser('John', 'john@example.com');

```



**When to use:** Encapsulation with closures, avoiding `new` keyword, flexible object creation, private variables.



**7. Object.assign() (Cloning/Merging):**



Creates a new object by copying properties.



```javascript

// Clone object

const original = { name: 'John', age: 30 };

const clone = Object.assign({}, original);



clone.age = 31;

console.log(original.age); // 30 (not affected)



// Merge objects

const defaults = { theme: 'light', language: 'en' };

const userPrefs = { theme: 'dark' };

const settings = Object.assign({}, defaults, userPrefs);



console.log(settings); // { theme: 'dark', language: 'en' }



// Modern alternative: Spread operator

const settings2 = { ...defaults, ...userPrefs };

console.log(settings2); // { theme: 'dark', language: 'en' }

```



**When to use:** Cloning objects, merging configurations, creating objects from existing ones.



**8. Spread Operator (ES6+):**



Modern way to clone and merge objects.



```javascript

// Clone object

const original = { name: 'John', age: 30 };

const clone = { ...original };



// Merge objects

const user = { name: 'John' };

const details = { age: 30, email: 'john@example.com' };

const complete = { ...user, ...details };



console.log(complete); // { name: 'John', age: 30, email: 'john@example.com' }



// Override properties

const defaults = { theme: 'light', size: 'medium' };

const custom = { ...defaults, theme: 'dark' };



console.log(custom); // { theme: 'dark', size: 'medium' }



// Add properties

const enhanced = {

  ...original,

  city: 'New York',

  getInfo() {

    return `${this.name} from ${this.city}`;

  }

};

```



**When to use:** Modern codebases, cloning, merging, adding properties to existing objects.



**Comparison Table:**



| Method | Use Case | Prototype | Private Data | Performance |

|--------|----------|-----------|--------------|-------------|

| **Object Literal** | Simple objects, configs | Object.prototype | No | Fast |

| **new Object()** | Rarely used | Object.prototype | No | Fast |

| **Constructor Function** | Multiple instances | Custom | No | Fast |

| **ES6 Class** | OOP, inheritance | Custom | No | Fast |

| **Object.create()** | Custom prototype | Custom | No | Fast |

| **Factory Function** | Encapsulation | Object.prototype | Yes (closure) | Slower |

| **Object.assign()** | Cloning, merging | Source's prototype | No | Medium |

| **Spread Operator** | Modern cloning | Source's prototype | No | Medium |



**Production Examples:**



**Use Case 1: API Response Objects**

```javascript

// Object literal for simple data

const apiResponse = {

  status: 200,

  data: {

    users: [],

    total: 0

  },

  error: null

};

```



**Use Case 2: Creating Multiple Similar Objects**

```javascript

// Class for multiple instances

class Product {

  constructor(name, price, category) {

    this.name = name;

    this.price = price;

    this.category = category;

  }

  

  getDisplayPrice() {

    return `$${this.price.toFixed(2)}`;

  }

}



const products = [

  new Product('Laptop', 999.99, 'Electronics'),

  new Product('Mouse', 29.99, 'Accessories'),

  new Product('Keyboard', 79.99, 'Accessories')

];

```



**Use Case 3: Private State Management**

```javascript

// Factory function with closures

function createWallet(initialBalance) {

  let balance = initialBalance;

  const transactions = [];

  

  return {

    deposit(amount) {

      balance += amount;

      transactions.push({ type: 'deposit', amount, date: new Date() });

    },

    withdraw(amount) {

      if (amount <= balance) {

        balance -= amount;

        transactions.push({ type: 'withdraw', amount, date: new Date() });

      }

    },

    getBalance() {

      return balance;

    }

  };

}

```



**Use Case 4: Configuration with Defaults**

```javascript

// Spread operator for merging

function initializeApp(userConfig = {}) {

  const defaultConfig = {

    apiUrl: 'https://api.example.com',

    timeout: 5000,

    retries: 3,

    debug: false

  };

  

  const config = { ...defaultConfig, ...userConfig };

  return config;

}

```



**Best Practices:**

- Use **object literals** for simple, one-off objects

- Use **classes** for OOP and multiple instances in modern code

- Use **factory functions** when you need private data via closures

- Use **Object.create()** for prototypal inheritance without constructors

- Use **spread operator** for cloning and merging in modern code

- Avoid `new Object()` - use object literals instead

- Choose based on needs: simplicity, inheritance, encapsulation, or performance





</details>
<details><summary>31. What is the prototype chain?</summary>






**Answer:**

The prototype chain is a mechanism that allows objects to inherit properties and methods from other objects. When you try to access a property on an object, JavaScript first looks on the object itself, then on its prototype, then on the prototype's prototype, and so on until it reaches `null`.



**How It Works:**



```javascript

const animal = {

  eats: true,

  walk() {

    console.log('Animal walks');

  }

};



const rabbit = {

  jumps: true

};



// Set animal as prototype of rabbit

rabbit.__proto__ = animal; // Don't use this in production! Use Object.create()



console.log(rabbit.jumps);  // true (own property)

console.log(rabbit.eats);   // true (inherited from animal)

rabbit.walk();              // 'Animal walks' (inherited method)



console.log(rabbit.toString()); // [object Object] (inherited from Object.prototype)

```



**The Chain Lookup:**



```javascript

// When accessing rabbit.walk():

// 1. Check rabbit object itself - not found

// 2. Check rabbit.__proto__ (animal) - found! Execute it

// 3. If not found, check animal.__proto__ (Object.prototype) - would check here

// 4. If not found, check Object.prototype.__proto__ (null) - undefined



const obj = {

  a: 1

};



// Prototype chain: obj → Object.prototype → null

console.log(obj.toString()); // From Object.prototype

console.log(obj.hasOwnProperty('a')); // From Object.prototype

```



**Visual Representation:**



```

rabbit object

  |

  | [[Prototype]] / __proto__

  ↓

animal object

  |

  | [[Prototype]] / __proto__

  ↓

Object.prototype

  |

  | [[Prototype]]

  ↓

null (end of chain)

```



**Constructor Functions and Prototype Chain:**



```javascript

function Person(name) {

  this.name = name;

}



Person.prototype.greet = function() {

  return `Hello, I'm ${this.name}`;

};



const john = new Person('John');



// Prototype chain: john → Person.prototype → Object.prototype → null

console.log(john.name);          // 'John' (own property)

console.log(john.greet());       // 'Hello, I'm John' (from Person.prototype)

console.log(john.toString());    // [object Object] (from Object.prototype)

console.log(john.hasOwnProperty('name')); // true (from Object.prototype)



// Checking the chain

console.log(john.__proto__ === Person.prototype);              // true

console.log(Person.prototype.__proto__ === Object.prototype);  // true

console.log(Object.prototype.__proto__);                       // null

```



**ES6 Classes and Prototype Chain:**



```javascript

class Animal {

  constructor(name) {

    this.name = name;

  }

  

  speak() {

    return `${this.name} makes a sound`;

  }

}



class Dog extends Animal {

  constructor(name, breed) {

    super(name);

    this.breed = breed;

  }

  

  speak() {

    return `${this.name} barks`;

  }

  

  fetch() {

    return `${this.name} fetches the ball`;

  }

}



const myDog = new Dog('Rex', 'Labrador');



// Prototype chain: myDog → Dog.prototype → Animal.prototype → Object.prototype → null

console.log(myDog.name);         // 'Rex' (own property)

console.log(myDog.breed);        // 'Labrador' (own property)

console.log(myDog.fetch());      // 'Rex fetches the ball' (from Dog.prototype)

console.log(myDog.speak());      // 'Rex barks' (from Dog.prototype, overridden)

console.log(myDog.toString());   // [object Object] (from Object.prototype)



// Verify the chain

console.log(myDog.__proto__ === Dog.prototype);                    // true

console.log(Dog.prototype.__proto__ === Animal.prototype);         // true

console.log(Animal.prototype.__proto__ === Object.prototype);      // true

console.log(Object.prototype.__proto__);                           // null

```



**Checking Prototype Chain:**



```javascript

function Person(name) {

  this.name = name;

}



const john = new Person('John');



// instanceof checks prototype chain

console.log(john instanceof Person);     // true

console.log(john instanceof Object);     // true

console.log(john instanceof Array);      // false



// isPrototypeOf() checks if object is in prototype chain

console.log(Person.prototype.isPrototypeOf(john));    // true

console.log(Object.prototype.isPrototypeOf(john));    // true



// getPrototypeOf() returns the prototype

console.log(Object.getPrototypeOf(john) === Person.prototype); // true

```



**Property Lookup Performance:**



```javascript

const obj = {

  prop: 'own property'

};



// Fast - found immediately

console.log(obj.prop);



// Slower - must traverse prototype chain

console.log(obj.toString());



// Even slower - must check multiple levels

class A {}

class B extends A {}

class C extends B {}

class D extends C {}



const instance = new D();

// Deep prototype chain = slower lookups

```



**Shadowing Properties:**



```javascript

const animal = {

  eats: true

};



const rabbit = Object.create(animal);

rabbit.eats = false; // Shadows animal.eats



console.log(rabbit.eats);      // false (own property)

console.log(animal.eats);      // true (unchanged)



delete rabbit.eats;

console.log(rabbit.eats);      // true (now uses inherited property)

```



**Production Use Cases:**



**1. Method Sharing (Memory Efficiency):**

```javascript

// ❌ Bad - each instance has its own method copy

function Person(name) {

  this.name = name;

  this.greet = function() { // New function for each instance!

    return `Hello, ${this.name}`;

  };

}



const person1 = new Person('John');

const person2 = new Person('Jane');

console.log(person1.greet === person2.greet); // false (different functions)



// ✅ Good - methods shared via prototype

function PersonOptimized(name) {

  this.name = name;

}



PersonOptimized.prototype.greet = function() {

  return `Hello, ${this.name}`;

};



const person3 = new PersonOptimized('John');

const person4 = new PersonOptimized('Jane');

console.log(person3.greet === person4.greet); // true (same function)

```



**2. Extending Built-in Objects (Use Caution):**

```javascript

// Adding method to all arrays (generally not recommended)

Array.prototype.last = function() {

  return this[this.length - 1];

};



const arr = [1, 2, 3];

console.log(arr.last()); // 3



// Better: Use utility functions or extend in controlled way

class MyArray extends Array {

  last() {

    return this[this.length - 1];

  }

}



const myArr = new MyArray(1, 2, 3);

console.log(myArr.last()); // 3

```



**3. Polyfills:**

```javascript

// Add missing methods to older browsers via prototype chain

if (!Array.prototype.includes) {

  Array.prototype.includes = function(element) {

    return this.indexOf(element) !== -1;

  };

}



// Now all arrays have .includes()

[1, 2, 3].includes(2); // true

```



**4. Creating Object Hierarchies:**

```javascript

// Base class

class Vehicle {

  constructor(brand) {

    this.brand = brand;

  }

  

  start() {

    return `${this.brand} vehicle started`;

  }

}



// Intermediate class

class Car extends Vehicle {

  constructor(brand, model) {

    super(brand);

    this.model = model;

  }

  

  drive() {

    return `Driving ${this.brand} ${this.model}`;

  }

}



// Specific class

class ElectricCar extends Car {

  constructor(brand, model, batteryLife) {

    super(brand, model);

    this.batteryLife = batteryLife;

  }

  

  charge() {

    return `Charging ${this.brand} ${this.model}`;

  }

}



const tesla = new ElectricCar('Tesla', 'Model 3', 100);



// Prototype chain: tesla → ElectricCar.prototype → Car.prototype → Vehicle.prototype → Object.prototype → null

console.log(tesla.charge());  // From ElectricCar.prototype

console.log(tesla.drive());   // From Car.prototype

console.log(tesla.start());   // From Vehicle.prototype

console.log(tesla.toString()); // From Object.prototype

```



**Modifying Prototype Chain:**



```javascript

// Get prototype

const proto = Object.getPrototypeOf(obj);



// Set prototype (prefer Object.create over this)

Object.setPrototypeOf(obj, prototype);



// Create with specific prototype

const obj = Object.create(prototype);



// Check if object has own property (not inherited)

obj.hasOwnProperty('propertyName');



// Get all own properties (not inherited)

Object.keys(obj);

Object.getOwnPropertyNames(obj);

```



**Common Pitfalls:**



**1. Modifying Object.prototype (Never Do This):**

```javascript

// ❌ VERY BAD - affects ALL objects

Object.prototype.myMethod = function() {

  return 'bad idea';

};



const obj = {};

console.log(obj.myMethod()); // 'bad idea' - unintended side effect



// Breaks for...in loops

for (let key in obj) {

  console.log(key); // Logs 'myMethod' unexpectedly

}

```



**2. Circular Prototype Chain:**

```javascript

const obj1 = {};

const obj2 = {};



// ❌ This would create circular reference (throws error)

// Object.setPrototypeOf(obj1, obj2);

// Object.setPrototypeOf(obj2, obj1); // TypeError

```



**3. Performance Issues with Long Chains:**

```javascript

// ⚠️ Deep inheritance can be slow

class Level1 {}

class Level2 extends Level1 {}

class Level3 extends Level2 {}

class Level4 extends Level3 {}

class Level5 extends Level4 {}



const instance = new Level5();

// Property lookups traverse entire chain

```



**Debugging Prototype Chain:**



```javascript

function printPrototypeChain(obj) {

  let current = obj;

  let level = 0;

  

  while (current !== null) {

    console.log(`Level ${level}:`, current.constructor?.name || 'Object');

    current = Object.getPrototypeOf(current);

    level++;

  }

  console.log('End of chain (null)');

}



class Animal {}

class Dog extends Animal {}

const myDog = new Dog();



printPrototypeChain(myDog);

// Level 0: Dog

// Level 1: Animal

// Level 2: Object

// End of chain (null)

```



**Best Practices:**

- Use prototype for shared methods (memory efficiency)

- Keep prototype chains shallow for performance

- Never modify `Object.prototype`

- Use `hasOwnProperty()` to check own properties vs inherited

- Prefer `Object.create()` over direct `__proto__` manipulation

- Use classes for cleaner syntax (they use prototypes under the hood)

- Understand that nearly all JavaScript inheritance is prototypal

- Use `instanceof` carefully (breaks across different execution contexts)



**Key Takeaways:**

- The prototype chain is how JavaScript implements inheritance

- Property lookup traverses up the chain until found or reaching `null`

- Every object has a prototype (except the root)

- Prototypes enable method sharing and memory efficiency

- Understanding the chain is essential for OOP in JavaScript

- Modern classes are syntactic sugar over the prototype chain





</details>
<details><summary>32. What is prototypal inheritance?</summary>






**Answer:**

Prototypal inheritance is JavaScript's mechanism where objects inherit properties and methods directly from other objects. Unlike classical inheritance (found in Java, C++), JavaScript objects inherit from other objects, not from classes (although ES6 classes are syntactic sugar over prototypal inheritance).



**Core Concept:**



In prototypal inheritance, objects can be created from other objects directly, and they "inherit" properties by linking to the parent object through the prototype chain.



```javascript

// Parent object (prototype)

const animal = {

  eats: true,

  sleep() {

    console.log('Sleeping...');

  }

};



// Child object inheriting from animal

const rabbit = Object.create(animal);

rabbit.jumps = true;



console.log(rabbit.eats);   // true (inherited)

console.log(rabbit.jumps);  // true (own property)

rabbit.sleep();             // 'Sleeping...' (inherited method)



// Rabbit inherits from animal

console.log(Object.getPrototypeOf(rabbit) === animal); // true

```



**Methods of Implementing Prototypal Inheritance:**



**1. Object.create() (Most Direct):**

```javascript

const parent = {

  greet() {

    return `Hello from ${this.name}`;

  }

};



const child = Object.create(parent);

child.name = 'Child';



console.log(child.greet()); // 'Hello from Child'



// With initial properties

const child2 = Object.create(parent, {

  name: {

    value: 'Child2',

    writable: true,

    enumerable: true

  }

});

```



**2. Constructor Functions (Pre-ES6):**

```javascript

// Parent constructor

function Animal(name) {

  this.name = name;

}



Animal.prototype.eat = function() {

  return `${this.name} is eating`;

};



// Child constructor

function Dog(name, breed) {

  Animal.call(this, name); // Call parent constructor

  this.breed = breed;

}



// Set up inheritance

Dog.prototype = Object.create(Animal.prototype);

Dog.prototype.constructor = Dog;



// Add child-specific method

Dog.prototype.bark = function() {

  return `${this.name} barks!`;

};



const myDog = new Dog('Rex', 'Labrador');

console.log(myDog.eat());  // 'Rex is eating' (inherited)

console.log(myDog.bark()); // 'Rex barks!' (own method)



console.log(myDog instanceof Dog);    // true

console.log(myDog instanceof Animal); // true

```



**3. ES6 Classes (Modern Syntax):**

```javascript

// Parent class

class Animal {

  constructor(name) {

    this.name = name;

  }

  

  eat() {

    return `${this.name} is eating`;

  }

  

  sleep() {

    return `${this.name} is sleeping`;

  }

}



// Child class

class Dog extends Animal {

  constructor(name, breed) {

    super(name); // Call parent constructor

    this.breed = breed;

  }

  

  bark() {

    return `${this.name} barks!`;

  }

  

  // Override parent method

  eat() {

    return `${super.eat()} dog food`;

  }

}



const myDog = new Dog('Rex', 'Labrador');

console.log(myDog.eat());   // 'Rex is eating dog food'

console.log(myDog.bark());  // 'Rex barks!'

console.log(myDog.sleep()); // 'Rex is sleeping' (inherited)

```



**Prototypal vs Classical Inheritance:**



| Aspect | Prototypal (JavaScript) | Classical (Java, C++) |

|--------|------------------------|---------------------|

| **Inherit From** | Objects | Classes |

| **Flexibility** | Very flexible, dynamic | More rigid, compile-time |

| **Syntax** | Object.create(), prototype | class, extends |

| **Multiple Inheritance** | Via mixins | Not supported (usually) |

| **Property Lookup** | Prototype chain | Class hierarchy |

| **Memory** | Methods shared via prototype | Methods in class definition |



**Advanced Prototypal Patterns:**



**1. Multiple Inheritance (Mixins):**

```javascript

// Mixin pattern (JavaScript's way of multiple inheritance)

const canEat = {

  eat() {

    return `${this.name} is eating`;

  }

};



const canWalk = {

  walk() {

    return `${this.name} is walking`;

  }

};



const canSwim = {

  swim() {

    return `${this.name} is swimming`;

  }

};



// Combine multiple behaviors

class Animal {

  constructor(name) {

    this.name = name;

  }

}



// Mix in multiple behaviors

Object.assign(Animal.prototype, canEat, canWalk);



class Fish extends Animal {

  constructor(name) {

    super(name);

    Object.assign(Fish.prototype, canSwim);

  }

}



const salmon = new Fish('Salmon');

console.log(salmon.eat());  // 'Salmon is eating'

console.log(salmon.swim()); // 'Salmon is swimming'



// Modern mixin pattern

function mixin(...mixins) {

  return function(BaseClass) {

    mixins.forEach(mixin => {

      Object.assign(BaseClass.prototype, mixin);

    });

    return BaseClass;

  };

}



@mixin(canEat, canWalk, canSwim)

class Duck extends Animal {

  constructor(name) {

    super(name);

  }

}

```



**2. Delegation Pattern:**

```javascript

// Instead of copying, delegate to another object

const behavior = {

  speak() {

    return `${this.name} speaks`;

  },

  move() {

    return `${this.name} moves`;

  }

};



function createEntity(name) {

  return {

    name,

    // Delegate method calls to behavior

    speak: behavior.speak,

    move: behavior.move

  };

}



const entity = createEntity('Entity');

console.log(entity.speak()); // 'Entity speaks'

```



**3. OLOO (Objects Linking to Other Objects):**

```javascript

// Kyle Simpson's OLOO pattern - pure prototypal inheritance

const Vehicle = {

  init(brand) {

    this.brand = brand;

    return this;

  },

  drive() {

    return `Driving ${this.brand}`;

  }

};



const Car = Object.create(Vehicle);

Car.setup = function(brand, model) {

  this.init(brand);

  this.model = model;

  return this;

};

Car.honk = function() {

  return `${this.brand} ${this.model} honks`;

};



const myCar = Object.create(Car).setup('Toyota', 'Camry');

console.log(myCar.drive()); // 'Driving Toyota'

console.log(myCar.honk());  // 'Toyota Camry honks'

```



**Production Use Cases:**



**1. Component Inheritance:**

```javascript

// Base UI Component

class Component {

  constructor(selector) {

    this.element = document.querySelector(selector);

    this.state = {};

  }

  

  setState(newState) {

    this.state = { ...this.state, ...newState };

    this.render();

  }

  

  render() {

    // Override in child classes

  }

}



// Button component inheriting from Component

class Button extends Component {

  constructor(selector, onClick) {

    super(selector);

    this.onClick = onClick;

    this.setup();

  }

  

  setup() {

    this.element.addEventListener('click', () => {

      this.onClick();

    });

  }

  

  render() {

    this.element.textContent = this.state.text || 'Click me';

  }

}



// Modal component

class Modal extends Component {

  constructor(selector) {

    super(selector);

    this.state = { isOpen: false };

  }

  

  open() {

    this.setState({ isOpen: true });

  }

  

  close() {

    this.setState({ isOpen: false });

  }

  

  render() {

    this.element.style.display = this.state.isOpen ? 'block' : 'none';

  }

}

```



**2. API Client Inheritance:**

```javascript

// Base HTTP client

class HTTPClient {

  constructor(baseURL) {

    this.baseURL = baseURL;

  }

  

  async request(endpoint, options = {}) {

    const url = `${this.baseURL}${endpoint}`;

    const response = await fetch(url, options);

    

    if (!response.ok) {

      throw new Error(`HTTP error! status: ${response.status}`);

    }

    

    return response.json();

  }

  

  async get(endpoint) {

    return this.request(endpoint, { method: 'GET' });

  }

  

  async post(endpoint, data) {

    return this.request(endpoint, {

      method: 'POST',

      headers: { 'Content-Type': 'application/json' },

      body: JSON.stringify(data)

    });

  }

}



// Authenticated client

class AuthenticatedClient extends HTTPClient {

  constructor(baseURL, token) {

    super(baseURL);

    this.token = token;

  }

  

  async request(endpoint, options = {}) {

    const authOptions = {

      ...options,

      headers: {

        ...options.headers,

        'Authorization': `Bearer ${this.token}`

      }

    };

    

    return super.request(endpoint, authOptions);

  }

}



// User-specific client

class UserClient extends AuthenticatedClient {

  async getProfile() {

    return this.get('/user/profile');

  }

  

  async updateProfile(data) {

    return this.post('/user/profile', data);

  }

}



const userClient = new UserClient('https://api.example.com', 'token123');

await userClient.getProfile(); // Uses inherited request method with auth

```



**3. Error Handling Hierarchy:**

```javascript

// Base error

class AppError extends Error {

  constructor(message, statusCode) {

    super(message);

    this.statusCode = statusCode;

    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);

  }

}



// Specific errors

class ValidationError extends AppError {

  constructor(message) {

    super(message, 400);

    this.name = 'ValidationError';

  }

}



class AuthenticationError extends AppError {

  constructor(message) {

    super(message, 401);

    this.name = 'AuthenticationError';

  }

}



class NotFoundError extends AppError {

  constructor(resource) {

    super(`${resource} not found`, 404);

    this.name = 'NotFoundError';

  }

}



// Usage

try {

  throw new ValidationError('Invalid email format');

} catch (error) {

  if (error instanceof ValidationError) {

    console.log('Validation failed:', error.message);

  }

  if (error instanceof AppError) {

    console.log('Status code:', error.statusCode);

  }

}

```



**4. Model Inheritance (ORM-style):**

```javascript

// Base model

class Model {

  static tableName = '';

  

  static async find(id) {

    const result = await db.query(

      `SELECT * FROM ${this.tableName} WHERE id = ?`,

      [id]

    );

    return new this(result[0]);

  }

  

  async save() {

    const fields = Object.keys(this);

    const values = Object.values(this);

    

    return await db.query(

      `INSERT INTO ${this.constructor.tableName} SET ?`,

      [this]

    );

  }

  

  async delete() {

    return await db.query(

      `DELETE FROM ${this.constructor.tableName} WHERE id = ?`,

      [this.id]

    );

  }

}



// User model

class User extends Model {

  static tableName = 'users';

  

  constructor(data) {

    super();

    this.id = data.id;

    this.name = data.name;

    this.email = data.email;

  }

  

  async getPosts() {

    return await Post.findByUserId(this.id);

  }

}



// Post model

class Post extends Model {

  static tableName = 'posts';

  

  constructor(data) {

    super();

    this.id = data.id;

    this.userId = data.userId;

    this.title = data.title;

    this.content = data.content;

  }

  

  static async findByUserId(userId) {

    const results = await db.query(

      `SELECT * FROM ${this.tableName} WHERE userId = ?`,

      [userId]

    );

    return results.map(row => new this(row));

  }

}



// Usage

const user = await User.find(1);

await user.save();

const posts = await user.getPosts();

```



**Benefits of Prototypal Inheritance:**

- **Memory Efficiency:** Methods shared via prototype

- **Dynamic:** Can modify inheritance at runtime

- **Simple:** Objects inherit from objects directly

- **Flexible:** Easy to compose behaviors

- **Natural to JavaScript:** Language's native inheritance model



**Drawbacks:**

- **Can be confusing:** Different from classical OOP

- **Performance:** Deep prototype chains can be slower

- **No true privacy:** All properties are accessible

- **Complexity:** Mixing patterns can be confusing



**Best Practices:**

- Use ES6 classes for cleaner syntax (they use prototypes underneath)

- Prefer composition over deep inheritance hierarchies

- Keep prototype chains shallow for performance

- Use `Object.create()` for prototypal inheritance without constructors

- Don't modify built-in prototypes (Array.prototype, Object.prototype, etc.)

- Use `super` to call parent methods in classes

- Understand that classes are syntactic sugar over prototypes

- Consider mixins for multiple inheritance scenarios



**Key Takeaways:**

- Prototypal inheritance is JavaScript's native inheritance mechanism

- Objects inherit directly from other objects

- ES6 classes are syntactic sugar over prototypal inheritance

- Methods are shared via prototype for memory efficiency

- More flexible and dynamic than classical inheritance

- Understanding it is essential for mastering JavaScript OOP





</details>
<details><summary>33. What is the difference between `__proto__` and `prototype`?</summary>






**Answer:**

`__proto__` and `prototype` are two different properties that are often confused, but they serve different purposes in JavaScript's prototypal inheritance system.



**Key Differences:**



| Aspect | `__proto__` | `prototype` |

|--------|------------|------------|

| **What it is** | Actual object used in lookup chain | Property on constructor functions |

| **Exists on** | Every object (instances) | Only on constructor functions |

| **Points to** | The prototype of the object | Object that will become `__proto__` of instances |

| **Used for** | Prototype chain lookup | Creating new instances with `new` |

| **Standard** | Non-standard (deprecated) | Standard part of JavaScript |

| **Modern alternative** | `Object.getPrototypeOf()` / `Object.setPrototypeOf()` | Still used with constructors |



**`prototype` Property:**



The `prototype` property exists **only on constructor functions** (and classes). It's an object that will become the `__proto__` of instances created with that constructor.



```javascript

// Constructor function

function Person(name) {

  this.name = name;

}



// prototype is a property on the constructor

Person.prototype.greet = function() {

  return `Hello, I'm ${this.name}`;

};



console.log(typeof Person.prototype);        // 'object'

console.log(Person.prototype.constructor === Person); // true



// Create instance

const john = new Person('John');



// john doesn't have a prototype property

console.log(john.prototype); // undefined



// But john's __proto__ points to Person.prototype

console.log(john.__proto__ === Person.prototype); // true

```



**`__proto__` Property:**



The `__proto__` property exists on **every object** (except `null`). It's the actual object used in the prototype chain for property lookups.



```javascript

const john = new Person('John');



// __proto__ is the actual prototype used for lookups

console.log(john.__proto__);                    // Person.prototype

console.log(john.__proto__ === Person.prototype); // true



// The chain continues

console.log(john.__proto__.__proto__ === Object.prototype); // true

console.log(Object.prototype.__proto__); // null (end of chain)

```



**Visual Representation:**



```

Constructor Function: Person

    |

    | .prototype property

    ↓

Person.prototype object

    ↑

    | [[Prototype]] / __proto__

    |

Instance: john object

```



**Complete Example:**



```javascript

function Animal(name) {

  this.name = name;

}



Animal.prototype.eat = function() {

  return `${this.name} is eating`;

};



const dog = new Animal('Dog');



// Animal.prototype - the prototype object for instances

console.log(Animal.prototype);                    // { eat: [Function], constructor: Animal }



// dog.__proto__ - dog's actual prototype

console.log(dog.__proto__);                       // Same as Animal.prototype

console.log(dog.__proto__ === Animal.prototype);  // true



// dog doesn't have .prototype property

console.log(dog.prototype);                       // undefined



// Animal.prototype has __proto__ too

console.log(Animal.prototype.__proto__ === Object.prototype); // true



// The constructor property links back

console.log(Animal.prototype.constructor === Animal);         // true

console.log(dog.constructor === Animal);                      // true (via prototype chain)

```



**Why Two Different Properties?**



```javascript

function Person(name) {

  this.name = name;

}



// 1. Person.prototype: Template for instances

Person.prototype.greet = function() {

  return `Hello, ${this.name}`;

};



// 2. Create instance with 'new'

const john = new Person('John');



// 3. Behind the scenes, new does this:

// const john = {};

// john.__proto__ = Person.prototype; // Link instance to constructor's prototype

// Person.call(john, 'John');         // Call constructor with instance as 'this'

// return john;



// Now john can access greet via __proto__

console.log(john.greet()); // Works because john.__proto__.greet exists

```



**Using `__proto__` (Deprecated - Don't Use):**



```javascript

const animal = {

  eats: true

};



const rabbit = {

  jumps: true

};



// ❌ Don't use __proto__ directly (deprecated)

rabbit.__proto__ = animal;



console.log(rabbit.eats); // true (inherited)



// ✅ Use Object.getPrototypeOf() / Object.setPrototypeOf() instead

Object.setPrototypeOf(rabbit, animal);

console.log(Object.getPrototypeOf(rabbit) === animal); // true



// ✅ Or better, use Object.create()

const rabbit2 = Object.create(animal);

rabbit2.jumps = true;

```



**Modern Alternatives to `__proto__`:**



```javascript

const animal = { eats: true };

const rabbit = { jumps: true };



// ❌ Old way (deprecated)

rabbit.__proto__ = animal;



// ✅ Get prototype

const proto = Object.getPrototypeOf(rabbit);



// ✅ Set prototype

Object.setPrototypeOf(rabbit, animal);



// ✅ Best: Create with prototype from the start

const rabbit2 = Object.create(animal);

rabbit2.jumps = true;



// Check prototype

console.log(Object.getPrototypeOf(rabbit2) === animal); // true

```



**ES6 Classes and prototype:**



```javascript

class Animal {

  constructor(name) {

    this.name = name;

  }

  

  speak() {

    return `${this.name} makes a sound`;

  }

}



// Even with classes, prototype still exists

console.log(typeof Animal.prototype); // 'object'



Animal.prototype.sleep = function() {

  return `${this.name} is sleeping`;

};



const cat = new Animal('Cat');



// Instance has __proto__ pointing to class prototype

console.log(cat.__proto__ === Animal.prototype); // true



// Can still access prototype methods

console.log(cat.speak());  // 'Cat makes a sound'

console.log(cat.sleep());  // 'Cat is sleeping'



// Class methods are added to prototype

console.log(Animal.prototype.speak); // [Function: speak]

```



**Practical Examples:**



**1. Adding Methods to Instances vs Prototype:**

```javascript

function Person(name) {

  this.name = name;

  

  // ❌ Bad - method created for each instance

  this.greet = function() {

    return `Hello, ${this.name}`;

  };

}



// ✅ Good - method shared via prototype

Person.prototype.greet = function() {

  return `Hello, ${this.name}`;

};



const person1 = new Person('John');

const person2 = new Person('Jane');



// With instance methods - different functions

console.log(person1.greet === person2.greet); // false (if defined in constructor)



// With prototype methods - same function

console.log(person1.greet === person2.greet); // true (if on prototype)

```



**2. Checking the Prototype Chain:**

```javascript

function Animal() {}

function Dog() {}



Dog.prototype = Object.create(Animal.prototype);

Dog.prototype.constructor = Dog;



const myDog = new Dog();



// Check with __proto__ (don't use in production)

console.log(myDog.__proto__ === Dog.prototype);                    // true

console.log(myDog.__proto__.__proto__ === Animal.prototype);       // true



// ✅ Better: Use Object.getPrototypeOf()

console.log(Object.getPrototypeOf(myDog) === Dog.prototype);       // true

console.log(Object.getPrototypeOf(Dog.prototype) === Animal.prototype); // true



// ✅ Or use instanceof

console.log(myDog instanceof Dog);    // true

console.log(myDog instanceof Animal); // true

```



**3. Dynamic Prototype Modification:**

```javascript

function Counter() {

  this.count = 0;

}



const counter1 = new Counter();



// Add method to prototype dynamically

Counter.prototype.increment = function() {

  this.count++;

};



// Existing instances immediately have access

counter1.increment();

console.log(counter1.count); // 1



// New instances also have it

const counter2 = new Counter();

counter2.increment();

console.log(counter2.count); // 1



// Both instances share the same method

console.log(counter1.increment === counter2.increment); // true

```



**4. Object Literals Don't Have prototype Property:**

```javascript

const obj = {

  name: 'Object'

};



// Object literals don't have .prototype

console.log(obj.prototype); // undefined



// But they have __proto__

console.log(obj.__proto__ === Object.prototype); // true



// Functions have both

function func() {}

console.log(func.prototype);                     // {} (exists)

console.log(func.__proto__ === Function.prototype); // true

```



**Common Pitfalls:**



**1. Confusing Which to Use:**

```javascript

function Person() {}



// ❌ Wrong - trying to add to instance's __proto__

const john = new Person();

john.__proto__.greet = function() { /* ... */ }; // Don't do this



// ✅ Right - add to constructor's prototype

Person.prototype.greet = function() { /* ... */ };

```



**2. Losing Constructor Reference:**

```javascript

function Parent() {}

function Child() {}



// ❌ Wrong - loses constructor reference

Child.prototype = Parent.prototype; // Don't do this



// ✅ Right - creates new object with Parent.prototype as prototype

Child.prototype = Object.create(Parent.prototype);

Child.prototype.constructor = Child; // Restore constructor

```



**3. Modifying Built-in Prototypes:**

```javascript

// ❌ Bad practice - affects all arrays globally

Array.prototype.last = function() {

  return this[this.length - 1];

};



// ✅ Better - extend in a controlled way

class MyArray extends Array {

  last() {

    return this[this.length - 1];

  }

}

```



**Memory Implications:**



```javascript

function Person(name) {

  this.name = name;

  

  // ❌ Each instance gets its own copy (wastes memory)

  this.greet = function() {

    return `Hello, ${this.name}`;

  };

}



// Creating 1000 instances = 1000 copies of greet function

const people = Array.from({ length: 1000 }, (_, i) => new Person(`Person${i}`));



// ✅ All instances share one copy via prototype (efficient)

Person.prototype.greet = function() {

  return `Hello, ${this.name}`;

};



// Creating 1000 instances = 1 copy of greet function

```



**Best Practices:**

- Never use `__proto__` directly in production code (deprecated)

- Use `Object.getPrototypeOf()` to read prototypes

- Use `Object.setPrototypeOf()` to set prototypes (or better, `Object.create()`)

- Use `Object.create()` when creating objects with specific prototypes

- Add shared methods to `.prototype` for memory efficiency

- Understand `prototype` is only on constructor functions

- Remember `__proto__` exists on all objects

- Use ES6 classes for cleaner syntax (they handle prototypes for you)



**Key Takeaways:**

- `prototype`: Property on constructor functions, template for instances

- `__proto__`: Property on instances, actual prototype used in lookups

- `__proto__` is deprecated, use `Object.getPrototypeOf()` / `Object.setPrototypeOf()`

- Methods on `prototype` are shared across instances (memory efficient)

- Understanding both is crucial for JavaScript inheritance

- ES6 classes hide this complexity but use prototypes underneath





</details>
<details><summary>34. What is Object.create()?</summary>






**Answer:**

`Object.create()` is a method that creates a new object with a specified prototype object and optional property descriptors. It's the most direct way to implement prototypal inheritance in JavaScript without using constructor functions or classes.



**Syntax:**



```javascript

Object.create(proto, [propertiesObject])

```



- `proto`: The object which should be the prototype of the newly-created object

- `propertiesObject` (optional): An object whose properties define property descriptors to be added to the newly-created object



**Basic Usage:**



```javascript

// Create object with specific prototype

const animal = {

  eats: true,

  walk() {

    console.log('Animal walks');

  }

};



// Create rabbit with animal as prototype

const rabbit = Object.create(animal);

rabbit.jumps = true;



console.log(rabbit.eats);   // true (inherited from animal)

console.log(rabbit.jumps);  // true (own property)

rabbit.walk();              // 'Animal walks' (inherited method)



// Verify prototype

console.log(Object.getPrototypeOf(rabbit) === animal); // true

```



**Creating Object with No Prototype:**



```javascript

// Create truly empty object (no prototype)

const pureObject = Object.create(null);



console.log(pureObject.toString); // undefined (no inherited methods)

console.log(Object.getPrototypeOf(pureObject)); // null



// Useful for creating dictionaries/hash maps

pureObject.key = 'value';

console.log('toString' in pureObject); // false (no inherited properties)



// Regular object has Object.prototype

const regularObject = {};

console.log('toString' in regularObject); // true (inherited from Object.prototype)

```



**With Property Descriptors:**



```javascript

const person = {

  isHuman: true

};



const john = Object.create(person, {

  name: {

    value: 'John',

    writable: true,

    enumerable: true,

    configurable: true

  },

  age: {

    value: 30,

    writable: true,

    enumerable: true,

    configurable: true

  },

  id: {

    value: 123,

    writable: false,     // Read-only

    enumerable: false,   // Won't show in for...in

    configurable: false  // Can't be deleted or reconfigured

  }

});



console.log(john.name);    // 'John'

console.log(john.age);     // 30

console.log(john.isHuman); // true (inherited)



john.name = 'Jane';        // Works (writable: true)

john.id = 999;             // Fails silently (writable: false)

console.log(john.id);      // 123 (unchanged)



delete john.id;            // Fails silently (configurable: false)

console.log(john.id);      // 123 (still there)



for (let key in john) {

  console.log(key);        // 'name', 'age' (id is not enumerable)

}

```



**Comparison with Other Object Creation Methods:**



```javascript

// 1. Object literal

const obj1 = { a: 1 };

// Prototype: Object.prototype



// 2. Constructor function

function MyClass(a) {

  this.a = a;

}

const obj2 = new MyClass(1);

// Prototype: MyClass.prototype



// 3. Object.create()

const proto = { b: 2 };

const obj3 = Object.create(proto);

obj3.a = 1;

// Prototype: proto (custom)



// 4. Object.create(null) - truly empty

const obj4 = Object.create(null);

obj4.a = 1;

// Prototype: null (no prototype)

```



**Implementing Inheritance:**



```javascript

// Parent object

const Animal = {

  init(name) {

    this.name = name;

    return this;

  },

  eat() {

    return `${this.name} is eating`;

  }

};



// Child object

const Dog = Object.create(Animal);

Dog.bark = function() {

  return `${this.name} barks`;

};

Dog.init = function(name, breed) {

  Animal.init.call(this, name);

  this.breed = breed;

  return this;

};



// Create instance

const myDog = Object.create(Dog).init('Rex', 'Labrador');



console.log(myDog.eat());   // 'Rex is eating' (from Animal)

console.log(myDog.bark());  // 'Rex barks' (from Dog)

console.log(myDog.name);    // 'Rex'

console.log(myDog.breed);   // 'Labrador'



// Prototype chain: myDog → Dog → Animal → Object.prototype → null

```



**Polyfill (Understanding How It Works):**



```javascript

if (!Object.create) {

  Object.create = function(proto, propertiesObject) {

    if (typeof proto !== 'object' && typeof proto !== 'function') {

      throw new TypeError('Object prototype may only be an Object or null');

    }

    if (propertiesObject !== undefined) {

      throw new Error('Second argument not supported');

    }

    

    function F() {}

    F.prototype = proto;

    return new F();

  };

}



// This shows that Object.create() essentially:

// 1. Creates a temporary constructor

// 2. Sets its prototype to the provided object

// 3. Returns a new instance

```



**Production Use Cases:**



**1. Creating Dictionary/Hash Map:**

```javascript

// Problem: Regular objects inherit from Object.prototype

const cache = {};

cache.toString = 'some value';

console.log(typeof cache.toString); // 'string' (overwrote inherited method)



// Solution: Use Object.create(null)

const pureCache = Object.create(null);

pureCache.toString = 'some value';

console.log(pureCache.toString); // 'some value' (no conflict)

console.log(pureCache.hasOwnProperty); // undefined (no inherited methods)



// Safe to use any key without conflicts

pureCache.constructor = 'value';

pureCache.__proto__ = 'value';

pureCache.hasOwnProperty = 'value';

// All work without issues

```



**2. Creating Clones with Specific Prototype:**

```javascript

function cloneWithPrototype(obj) {

  // Clone object preserving its prototype

  const clone = Object.create(Object.getPrototypeOf(obj));

  

  // Copy own properties

  Object.keys(obj).forEach(key => {

    clone[key] = obj[key];

  });

  

  return clone;

}



function Person(name) {

  this.name = name;

}

Person.prototype.greet = function() {

  return `Hello, ${this.name}`;

};



const john = new Person('John');

const johnClone = cloneWithPrototype(john);



console.log(johnClone.name);         // 'John'

console.log(johnClone.greet());      // 'Hello, John'

console.log(johnClone instanceof Person); // true

```



**3. Implementing Object Inheritance Pattern:**

```javascript

// Base configuration

const baseConfig = {

  apiUrl: 'https://api.example.com',

  timeout: 5000,

  retries: 3,

  headers: {

    'Content-Type': 'application/json'

  }

};



// Environment-specific configs

const devConfig = Object.create(baseConfig);

devConfig.apiUrl = 'http://localhost:3000';

devConfig.debug = true;



const prodConfig = Object.create(baseConfig);

prodConfig.apiUrl = 'https://api.production.com';

prodConfig.timeout = 10000;



console.log(devConfig.timeout);   // 5000 (inherited)

console.log(devConfig.apiUrl);    // 'http://localhost:3000' (overridden)

console.log(prodConfig.retries);  // 3 (inherited)



// Changes to base affect all children

baseConfig.retries = 5;

console.log(devConfig.retries);   // 5 (inherited)

console.log(prodConfig.retries);  // 5 (inherited)

```



**4. Factory Pattern with Inheritance:**

```javascript

// Base prototype

const Vehicle = {

  init(brand, model) {

    this.brand = brand;

    this.model = model;

    return this;

  },

  getInfo() {

    return `${this.brand} ${this.model}`;

  }

};



// Specialized prototypes

const Car = Object.create(Vehicle);

Car.init = function(brand, model, doors) {

  Vehicle.init.call(this, brand, model);

  this.doors = doors;

  return this;

};

Car.drive = function() {

  return `Driving ${this.getInfo()}`;

};



const Motorcycle = Object.create(Vehicle);

Motorcycle.init = function(brand, model, engineCC) {

  Vehicle.init.call(this, brand, model);

  this.engineCC = engineCC;

  return this;

};

Motorcycle.ride = function() {

  return `Riding ${this.getInfo()}`;

};



// Create instances

const myCar = Object.create(Car).init('Toyota', 'Camry', 4);

const myBike = Object.create(Motorcycle).init('Harley', 'Street 750', 750);



console.log(myCar.drive());      // 'Driving Toyota Camry'

console.log(myBike.ride());      // 'Riding Harley Street 750'

console.log(myCar.getInfo());    // 'Toyota Camry' (inherited from Vehicle)

```



**5. Implementing Method Chaining:**

```javascript

const Calculator = {

  init(value = 0) {

    this.value = value;

    return this;

  },

  add(n) {

    this.value += n;

    return this;

  },

  subtract(n) {

    this.value -= n;

    return this;

  },

  multiply(n) {

    this.value *= n;

    return this;

  },

  divide(n) {

    this.value /= n;

    return this;

  },

  getResult() {

    return this.value;

  }

};



// Create calculator instance

const calc = Object.create(Calculator).init(10);



const result = calc

  .add(5)

  .multiply(2)

  .subtract(10)

  .divide(2)

  .getResult();



console.log(result); // 10

```



**6. Creating Private Data Store:**

```javascript

function createPerson(name, age) {

  // Private data

  const privateData = { name, age };

  

  // Public interface

  return Object.create(null, {

    getName: {

      value: function() {

        return privateData.name;

      },

      enumerable: true

    },

    getAge: {

      value: function() {

        return privateData.age;

      },

      enumerable: true

    },

    setAge: {

      value: function(newAge) {

        if (newAge > 0) {

          privateData.age = newAge;

        }

      },

      enumerable: true

    }

  });

}



const person = createPerson('John', 30);

console.log(person.getName()); // 'John'

console.log(person.getAge());  // 30

person.setAge(31);

console.log(person.getAge());  // 31



// Can't access private data directly

console.log(person.name); // undefined

console.log(person.age);  // undefined

```



**Common Patterns:**



**1. OLOO (Objects Linking to Other Objects):**

```javascript

// Kyle Simpson's OLOO pattern

const Parent = {

  init(name) {

    this.name = name;

    return this;

  },

  greet() {

    return `Hello, I'm ${this.name}`;

  }

};



const Child = Object.create(Parent);

Child.setup = function(name, age) {

  this.init(name);

  this.age = age;

  return this;

};

Child.introduce = function() {

  return `${this.greet()} and I'm ${this.age} years old`;

};



const child = Object.create(Child).setup('John', 10);

console.log(child.introduce()); // "Hello, I'm John and I'm 10 years old"

```



**2. Extending Built-in Types:**

```javascript

// Create enhanced array with custom prototype

const arrayMethods = Object.create(Array.prototype);



arrayMethods.first = function() {

  return this[0];

};



arrayMethods.last = function() {

  return this[this.length - 1];

};



function createArray(...items) {

  const arr = Object.create(arrayMethods);

  arr.push(...items);

  return arr;

}



const myArray = createArray(1, 2, 3, 4, 5);

console.log(myArray.first());  // 1

console.log(myArray.last());   // 5

console.log(myArray.length);   // 5

```



**Advantages of Object.create():**

- **Pure prototypal inheritance:** No constructors needed

- **Flexible:** Can create objects with any prototype (including `null`)

- **Property descriptors:** Fine control over property characteristics

- **Memory efficient:** Methods shared via prototype

- **Clean syntax:** Direct and explicit

- **No `new` keyword:** Simpler mental model



**Disadvantages:**

- **Verbose:** Requires more code than classes

- **No initialization:** Need separate init method

- **Less familiar:** Classes are more common pattern

- **Property descriptors:** Second parameter is complex

- **Performance:** Slightly slower than literal notation in some engines



**Object.create() vs Constructor vs Class:**



```javascript

// 1. Object.create()

const proto1 = { greet() { return 'Hello'; } };

const obj1 = Object.create(proto1);

obj1.name = 'John';



// 2. Constructor function

function Person(name) {

  this.name = name;

}

Person.prototype.greet = function() { return 'Hello'; };

const obj2 = new Person('John');



// 3. ES6 Class

class PersonClass {

  constructor(name) {

    this.name = name;

  }

  greet() { return 'Hello'; }

}

const obj3 = new PersonClass('John');



// All achieve similar results, different syntax

console.log(obj1.greet()); // 'Hello'

console.log(obj2.greet()); // 'Hello'

console.log(obj3.greet()); // 'Hello'

```



**Best Practices:**

- Use `Object.create(null)` for dictionaries/hash maps to avoid inherited properties

- Prefer classes for constructor-based patterns (cleaner syntax)

- Use `Object.create()` for pure prototypal inheritance without constructors

- Always check for `null` prototype when using `Object.create(null)`

- Use property descriptors when you need fine control over properties

- Consider OLOO pattern for functional programming style

- Don't mix too many patterns in same codebase (consistency is key)



**Key Takeaways:**

- `Object.create()` creates new object with specified prototype

- Most direct way to implement prototypal inheritance

- Can create objects with `null` prototype (no inherited properties)

- Supports property descriptors for fine-grained control

- Useful for pure prototypal patterns and dictionaries

- Classes are syntactic sugar, `Object.create()` is the underlying mechanism

- Essential for understanding JavaScript's inheritance model





</details>
<details><summary>35. What are getters and setters?</summary>






**Answer:**

Getters and setters are special methods that provide access control to object properties. They allow you to define custom behavior when reading (getting) or writing (setting) a property value, enabling validation, computed properties, and encapsulation.



**Syntax:**



```javascript

// Object literal syntax

const obj = {

  get propertyName() {

    // Return value

  },

  set propertyName(value) {

    // Set value

  }

};



// Class syntax

class MyClass {

  get propertyName() {

    // Return value

  }

  set propertyName(value) {

    // Set value

  }

}



// Object.defineProperty syntax

Object.defineProperty(obj, 'propertyName', {

  get() {

    // Return value

  },

  set(value) {

    // Set value

  }

});

```



**Basic Example:**



```javascript

const person = {

  firstName: 'John',

  lastName: 'Doe',

  

  // Getter - called when reading property

  get fullName() {

    return `${this.firstName} ${this.lastName}`;

  },

  

  // Setter - called when writing property

  set fullName(value) {

    const parts = value.split(' ');

    this.firstName = parts[0];

    this.lastName = parts[1];

  }

};



// Using getter (looks like property access)

console.log(person.fullName); // 'John Doe' (no parentheses!)



// Using setter (looks like assignment)

person.fullName = 'Jane Smith';

console.log(person.firstName); // 'Jane'

console.log(person.lastName);  // 'Smith'

console.log(person.fullName);  // 'Jane Smith'

```



**Getters (Reading Values):**



```javascript

const circle = {

  radius: 5,

  

  // Computed property

  get diameter() {

    return this.radius * 2;

  },

  

  get circumference() {

    return 2 * Math.PI * this.radius;

  },

  

  get area() {

    return Math.PI * this.radius ** 2;

  }

};



console.log(circle.diameter);      // 10

console.log(circle.circumference); // 31.41592653589793

console.log(circle.area);          // 78.53981633974483



// Update radius

circle.radius = 10;

console.log(circle.diameter);      // 20 (automatically updates)

console.log(circle.area);          // 314.1592653589793

```



**Setters (Writing Values with Validation):**



```javascript

const user = {

  _age: 0, // Convention: underscore indicates "private"

  

  get age() {

    return this._age;

  },

  

  set age(value) {

    if (typeof value !== 'number') {

      throw new TypeError('Age must be a number');

    }

    if (value < 0 || value > 150) {

      throw new RangeError('Age must be between 0 and 150');

    }

    this._age = value;

  }

};



user.age = 25;

console.log(user.age); // 25



// Validation in action

try {

  user.age = -5; // Throws RangeError

} catch (e) {

  console.error(e.message); // 'Age must be between 0 and 150'

}



try {

  user.age = 'twenty'; // Throws TypeError

} catch (e) {

  console.error(e.message); // 'Age must be a number'

}

```



**Class Example:**



```javascript

class Temperature {

  constructor(celsius) {

    this._celsius = celsius;

  }

  

  get celsius() {

    return this._celsius;

  }

  

  set celsius(value) {

    if (value < -273.15) {

      throw new Error('Temperature below absolute zero!');

    }

    this._celsius = value;

  }

  

  get fahrenheit() {

    return (this._celsius * 9/5) + 32;

  }

  

  set fahrenheit(value) {

    this.celsius = (value - 32) * 5/9;

  }

  

  get kelvin() {

    return this._celsius + 273.15;

  }

  

  set kelvin(value) {

    this.celsius = value - 273.15;

  }

}



const temp = new Temperature(25);

console.log(temp.celsius);    // 25

console.log(temp.fahrenheit); // 77

console.log(temp.kelvin);     // 298.15



// Set using different scale

temp.fahrenheit = 68;

console.log(temp.celsius);    // 20



temp.kelvin = 300;

console.log(temp.celsius);    // 26.850000000000023

```



**Using Object.defineProperty:**



```javascript

const bankAccount = {

  _balance: 1000

};



Object.defineProperty(bankAccount, 'balance', {

  get() {

    console.log('Getting balance...');

    return this._balance;

  },

  set(value) {

    console.log('Setting balance...');

    if (value < 0) {

      throw new Error('Balance cannot be negative');

    }

    this._balance = value;

  },

  enumerable: true,

  configurable: true

});



console.log(bankAccount.balance); // Getting balance... 1000

bankAccount.balance = 2000;       // Setting balance...

console.log(bankAccount.balance); // Getting balance... 2000

```



**Read-Only Properties (Getter without Setter):**



```javascript

const config = {

  _apiKey: 'secret-key-12345',

  

  // Only getter, no setter - effectively read-only

  get apiKey() {

    return this._apiKey;

  }

};



console.log(config.apiKey); // 'secret-key-12345'

config.apiKey = 'new-key';  // Silently fails (or throws in strict mode)

console.log(config.apiKey); // Still 'secret-key-12345'



// In strict mode

'use strict';

const strictConfig = {

  _value: 42,

  get value() {

    return this._value;

  }

};



strictConfig.value = 100; // TypeError: Cannot set property value of #<Object> which has only a getter

```



**Write-Only Properties (Setter without Getter):**



```javascript

const logger = {

  _logs: [],

  

  // Only setter, no getter

  set log(message) {

    this._logs.push({

      message,

      timestamp: new Date()

    });

    console.log(`[${new Date().toISOString()}] ${message}`);

  }

};



logger.log = 'User logged in';  // Works

logger.log = 'User logged out'; // Works



// Can't read the property

console.log(logger.log); // undefined

console.log(logger._logs); // Can still access underlying data

```



**Production Use Cases:**



**1. Data Validation:**

```javascript

class User {

  constructor(email, password) {

    this.email = email;

    this.password = password;

  }

  

  get email() {

    return this._email;

  }

  

  set email(value) {

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    if (!emailRegex.test(value)) {

      throw new Error('Invalid email format');

    }

    this._email = value.toLowerCase();

  }

  

  get password() {

    return '********'; // Never expose password

  }

  

  set password(value) {

    if (value.length < 8) {

      throw new Error('Password must be at least 8 characters');

    }

    if (!/[A-Z]/.test(value)) {

      throw new Error('Password must contain uppercase letter');

    }

    if (!/[0-9]/.test(value)) {

      throw new Error('Password must contain number');

    }

    this._password = value; // In real app, hash this!

  }

}



const user = new User('JOHN@EXAMPLE.COM', 'Password123');

console.log(user.email);    // 'john@example.com' (normalized)

console.log(user.password); // '********' (hidden)

```



**2. Lazy Evaluation/Computed Properties:**

```javascript

class DataSet {

  constructor(data) {

    this.data = data;

    this._sum = null;

    this._average = null;

  }

  

  // Lazy calculation - computed only when first accessed

  get sum() {

    if (this._sum === null) {

      console.log('Computing sum...');

      this._sum = this.data.reduce((a, b) => a + b, 0);

    }

    return this._sum;

  }

  

  get average() {

    if (this._average === null) {

      console.log('Computing average...');

      this._average = this.sum / this.data.length;

    }

    return this._average;

  }

  

  addValue(value) {

    this.data.push(value);

    // Invalidate cached values

    this._sum = null;

    this._average = null;

  }

}



const dataset = new DataSet([1, 2, 3, 4, 5]);

console.log(dataset.average); // Computing sum... Computing average... 3

console.log(dataset.average); // 3 (cached, no recomputation)



dataset.addValue(6);

console.log(dataset.average); // Computing sum... Computing average... 3.5 (recalculated)

```



**3. Property Change Tracking:**

```javascript

class Observable {

  constructor() {

    this._listeners = {};

    this._data = {};

  }

  

  defineProperty(propName, initialValue) {

    this._data[propName] = initialValue;

    

    Object.defineProperty(this, propName, {

      get() {

        return this._data[propName];

      },

      set(value) {

        const oldValue = this._data[propName];

        this._data[propName] = value;

        this._notify(propName, oldValue, value);

      }

    });

  }

  

  onChange(propName, callback) {

    if (!this._listeners[propName]) {

      this._listeners[propName] = [];

    }

    this._listeners[propName].push(callback);

  }

  

  _notify(propName, oldValue, newValue) {

    if (this._listeners[propName]) {

      this._listeners[propName].forEach(callback => {

        callback(newValue, oldValue);

      });

    }

  }

}



const model = new Observable();

model.defineProperty('name', 'John');

model.defineProperty('age', 25);



model.onChange('name', (newVal, oldVal) => {

  console.log(`Name changed from ${oldVal} to ${newVal}`);

});



model.name = 'Jane'; // Name changed from John to Jane

model.age = 26;      // No listener, no notification

```



**4. API Response Formatting:**

```javascript

class APIResponse {

  constructor(data) {

    this._data = data;

  }

  

  get data() {

    return this._data;

  }

  

  // Format data differently for different contexts

  get jsonAPI() {

    return {

      data: {

        type: this._data.type,

        id: this._data.id,

        attributes: { ...this._data }

      }

    };

  }

  

  get restAPI() {

    return {

      status: 'success',

      result: this._data,

      timestamp: Date.now()

    };

  }

  

  get graphQL() {

    return {

      data: this._data,

      errors: null

    };

  }

}



const response = new APIResponse({ id: 1, name: 'John', type: 'user' });



console.log(response.jsonAPI);

// { data: { type: 'user', id: 1, attributes: {...} } }



console.log(response.restAPI);

// { status: 'success', result: {...}, timestamp: ... }

```



**5. Dependency Injection:**

```javascript

class ServiceContainer {

  constructor() {

    this._services = new Map();

  }

  

  register(name, factory) {

    this._services.set(name, { factory, instance: null });

  }

  

  // Lazy singleton instantiation

  getService(name) {

    if (!this._services.has(name)) {

      throw new Error(`Service ${name} not registered`);

    }

    

    const service = this._services.get(name);

    

    if (!service.instance) {

      console.log(`Instantiating ${name}...`);

      service.instance = service.factory();

    }

    

    return service.instance;

  }

}



// Create dynamic getters

class App {

  constructor() {

    this.container = new ServiceContainer();

    

    // Register services

    this.container.register('logger', () => new Logger());

    this.container.register('database', () => new Database());

    

    // Create getters for each service

    ['logger', 'database'].forEach(serviceName => {

      Object.defineProperty(this, serviceName, {

        get() {

          return this.container.getService(serviceName);

        }

      });

    });

  }

}



const app = new App();

console.log(app.logger);   // Instantiating logger... [Logger instance]

console.log(app.logger);   // [Logger instance] (same instance, no reinstantiation)

console.log(app.database); // Instantiating database... [Database instance]

```



**Common Patterns:**



**1. Private Properties Pattern:**

```javascript

class Counter {

  #count = 0; // Private field (ES2022)

  

  get value() {

    return this.#count;

  }

  

  increment() {

    this.#count++;

  }

  

  decrement() {

    this.#count--;

  }

}



const counter = new Counter();

console.log(counter.value);  // 0

counter.increment();

console.log(counter.value);  // 1

// counter.#count; // SyntaxError: Private field '#count' must be declared in an enclosing class

```



**2. Proxy-like Behavior:**

```javascript

const target = {

  _name: 'Original'

};



Object.defineProperty(target, 'name', {

  get() {

    console.log('GET name');

    return this._name;

  },

  set(value) {

    console.log('SET name to', value);

    this._name = value;

  }

});



target.name;           // GET name

target.name = 'New';   // SET name to New

```



**Advantages:**

- **Validation:** Check values before setting

- **Computed properties:** Calculate values dynamically

- **Encapsulation:** Hide internal implementation

- **Side effects:** Trigger actions on get/set

- **Backwards compatibility:** Add validation without breaking API

- **Lazy evaluation:** Compute expensive values only when needed



**Disadvantages:**

- **Performance:** Slightly slower than direct property access

- **Debugging:** Harder to debug (hidden behavior)

- **Confusion:** Can be unclear that logic is executing

- **Inheritance:** Can be tricky with prototypes

- **Serialization:** JSON.stringify doesn't call getters



**Best Practices:**

- Use underscore prefix convention for "private" backing properties (`_property`)

- Keep getter/setter logic simple and fast

- Don't perform heavy computations in getters

- Avoid side effects in getters when possible

- Use meaningful names that indicate behavior

- Document getter/setter behavior in comments

- Consider using private fields (#field) instead of underscore convention

- Be consistent with getter/setter usage across codebase



**Key Takeaways:**

- Getters/setters provide controlled access to properties

- Enable validation, computed properties, and encapsulation

- Look like regular property access (no parentheses)

- Can be defined in object literals, classes, or Object.defineProperty

- Useful for data validation, lazy evaluation, and change tracking

- Slightly slower than direct property access

- Essential for clean APIs and data integrity





</details>
<details><summary>36. What is the difference between Object.freeze() and Object.seal()?</summary>






**Answer:**

`Object.freeze()` and `Object.seal()` are methods that prevent modifications to objects, but they have different levels of restriction. Both make objects immutable to some degree, but `freeze()` is more restrictive than `seal()`.



**Quick Comparison:**



| Operation | Normal Object | Object.seal() | Object.freeze() |

|-----------|--------------|---------------|-----------------|

| Add new properties | ✅ Yes | ❌ No | ❌ No |

| Delete properties | ✅ Yes | ❌ No | ❌ No |

| Modify existing properties | ✅ Yes | ✅ Yes | ❌ No |

| Reconfigure properties | ✅ Yes | ❌ No | ❌ No |

| Change prototype | ✅ Yes | ❌ No | ❌ No |



**Object.seal():**



`Object.seal()` prevents adding or removing properties, but allows modifying existing property values.



```javascript

const person = {

  name: 'John',

  age: 30

};



Object.seal(person);



// ✅ Can modify existing properties

person.name = 'Jane';

person.age = 31;

console.log(person); // { name: 'Jane', age: 31 }



// ❌ Cannot add new properties

person.email = 'jane@example.com';

console.log(person.email); // undefined (silently fails)



// ❌ Cannot delete properties

delete person.age;

console.log(person.age); // 31 (still there)



// Check if sealed

console.log(Object.isSealed(person)); // true

```



**Object.freeze():**



`Object.freeze()` prevents adding, removing, AND modifying properties. The object becomes completely immutable.



```javascript

const config = {

  apiUrl: 'https://api.example.com',

  timeout: 5000

};



Object.freeze(config);



// ❌ Cannot modify existing properties

config.apiUrl = 'https://api.malicious.com';

console.log(config.apiUrl); // 'https://api.example.com' (unchanged)



config.timeout = 10000;

console.log(config.timeout); // 5000 (unchanged)



// ❌ Cannot add new properties

config.retries = 3;

console.log(config.retries); // undefined



// ❌ Cannot delete properties

delete config.timeout;

console.log(config.timeout); // 5000 (still there)



// Check if frozen

console.log(Object.isFrozen(config)); // true

```



**Detailed Comparison:**



```javascript

// Normal object

const normal = { a: 1, b: 2 };

normal.a = 10;        // ✅ Works

normal.c = 3;         // ✅ Works

delete normal.b;      // ✅ Works

console.log(normal);  // { a: 10, c: 3 }



// Sealed object

const sealed = { a: 1, b: 2 };

Object.seal(sealed);

sealed.a = 10;        // ✅ Works (can modify)

sealed.c = 3;         // ❌ Fails (cannot add)

delete sealed.b;      // ❌ Fails (cannot delete)

console.log(sealed);  // { a: 10, b: 2 }



// Frozen object

const frozen = { a: 1, b: 2 };

Object.freeze(frozen);

frozen.a = 10;        // ❌ Fails (cannot modify)

frozen.c = 3;         // ❌ Fails (cannot add)

delete frozen.b;      // ❌ Fails (cannot delete)

console.log(frozen);  // { a: 1, b: 2 } (completely unchanged)

```



**Strict Mode Behavior:**



In strict mode, attempts to violate freeze/seal restrictions throw errors instead of failing silently.



```javascript

'use strict';



const sealed = Object.seal({ a: 1 });

sealed.b = 2; // TypeError: Cannot add property b, object is not extensible



const frozen = Object.freeze({ a: 1 });

frozen.a = 2; // TypeError: Cannot assign to read only property 'a'

```



**Nested Objects (Shallow Operation):**



Both `freeze()` and `seal()` are **shallow** - they don't affect nested objects.



```javascript

const user = {

  name: 'John',

  address: {

    city: 'New York',

    zip: '10001'

  }

};



Object.freeze(user);



// ❌ Cannot modify top-level properties

user.name = 'Jane';

console.log(user.name); // 'John' (unchanged)



// ✅ CAN modify nested object properties!

user.address.city = 'Los Angeles';

console.log(user.address.city); // 'Los Angeles' (changed!)



// Check frozen status

console.log(Object.isFrozen(user));         // true (top level)

console.log(Object.isFrozen(user.address)); // false (nested object)

```



**Deep Freeze Implementation:**



```javascript

function deepFreeze(obj) {

  // Freeze the object itself

  Object.freeze(obj);

  

  // Recursively freeze all properties

  Object.keys(obj).forEach(key => {

    const value = obj[key];

    if (value && typeof value === 'object') {

      deepFreeze(value);

    }

  });

  

  return obj;

}



const data = {

  user: {

    name: 'John',

    address: {

      city: 'New York'

    }

  }

};



deepFreeze(data);



// Now nested objects are also frozen

data.user.address.city = 'LA';

console.log(data.user.address.city); // 'New York' (unchanged)

```



**Deep Seal Implementation:**



```javascript

function deepSeal(obj) {

  Object.seal(obj);

  

  Object.keys(obj).forEach(key => {

    const value = obj[key];

    if (value && typeof value === 'object') {

      deepSeal(value);

    }

  });

  

  return obj;

}

```



**Checking Status:**



```javascript

const obj = { a: 1 };



// Check if extensible (can add properties)

console.log(Object.isExtensible(obj)); // true



Object.seal(obj);

console.log(Object.isExtensible(obj)); // false

console.log(Object.isSealed(obj));     // true

console.log(Object.isFrozen(obj));     // false (can still modify)



Object.freeze(obj);

console.log(Object.isSealed(obj));     // true (frozen implies sealed)

console.log(Object.isFrozen(obj));     // true

```



**Relationship Between Methods:**



```javascript

// Hierarchy: freeze > seal > preventExtensions



Object.preventExtensions(obj); // Cannot add properties

// Can still: modify, delete, reconfigure



Object.seal(obj); // Cannot add OR delete properties

// Can still: modify existing values



Object.freeze(obj); // Cannot add, delete, OR modify

// Completely immutable (shallow)



// freeze implies seal implies preventExtensions

if (Object.isFrozen(obj)) {

  console.log(Object.isSealed(obj));        // Always true

  console.log(Object.isExtensible(obj));    // Always false

}

```



**Production Use Cases:**



**1. Configuration Objects:**

```javascript

// Prevent accidental modification of config

const CONFIG = Object.freeze({

  API_URL: 'https://api.example.com',

  API_KEY: 'secret-key',

  TIMEOUT: 5000,

  MAX_RETRIES: 3

});



// Typo won't create new property

CONFIG.TIMEOOT = 10000; // Silently fails

console.log(CONFIG.TIMEOUT); // 5000 (correct value)



// Cannot be overridden

CONFIG.API_KEY = 'hacked'; // Fails

console.log(CONFIG.API_KEY); // 'secret-key' (safe)

```



**2. Enum-like Constants:**

```javascript

const Status = Object.freeze({

  PENDING: 'pending',

  IN_PROGRESS: 'in_progress',

  COMPLETED: 'completed',

  FAILED: 'failed'

});



// Safe to use throughout application

function updateStatus(newStatus) {

  if (!Object.values(Status).includes(newStatus)) {

    throw new Error('Invalid status');

  }

  // Update logic...

}



// Cannot be tampered with

Status.PENDING = 'hacked'; // Fails

delete Status.COMPLETED;   // Fails

```



**3. Data Integrity in Classes:**

```javascript

class Transaction {

  constructor(id, amount, timestamp) {

    // Make transaction immutable after creation

    Object.defineProperties(this, {

      id: { value: id, writable: false, enumerable: true },

      amount: { value: amount, writable: false, enumerable: true },

      timestamp: { value: timestamp, writable: false, enumerable: true }

    });

    

    Object.freeze(this);

  }

}



const transaction = new Transaction(1, 100, Date.now());

transaction.amount = 999999; // Fails silently (or throws in strict mode)

console.log(transaction.amount); // 100 (safe)

```



**4. Preventing Prototype Pollution:**

```javascript

// Seal prototypes to prevent pollution attacks

Object.seal(Object.prototype);

Object.seal(Array.prototype);

Object.seal(Function.prototype);



// Now these attacks fail

try {

  Object.prototype.isAdmin = true; // Fails

} catch (e) {

  console.error('Prototype pollution prevented');

}

```



**5. State Management:**

```javascript

class Store {

  constructor(initialState) {

    this._state = initialState;

    Object.freeze(this._state); // Immutable state

  }

  

  getState() {

    return this._state;

  }

  

  setState(newState) {

    // Create new frozen object instead of mutating

    this._state = Object.freeze({

      ...this._state,

      ...newState

    });

  }

}



const store = new Store({ count: 0 });



// Cannot mutate state directly

const state = store.getState();

state.count++; // Fails

console.log(store.getState().count); // 0 (unchanged)



// Must use setState

store.setState({ count: 1 });

console.log(store.getState().count); // 1

```



**Performance Considerations:**



```javascript

// Freezing has performance implications

const obj = { a: 1, b: 2, c: 3 };



// Normal object - fast property access

console.time('normal');

for (let i = 0; i < 1000000; i++) {

  obj.a;

}

console.timeEnd('normal');



// Frozen object - slightly slower

Object.freeze(obj);

console.time('frozen');

for (let i = 0; i < 1000000; i++) {

  obj.a;

}

console.timeEnd('frozen');



// Difference is usually negligible for normal use

```



**Common Pitfalls:**



**1. Forgetting Shallow Nature:**

```javascript

const config = Object.freeze({

  database: {

    host: 'localhost',

    port: 5432

  }

});



// ⚠️ Nested objects are NOT frozen

config.database.host = 'hacker.com'; // Works!

console.log(config.database.host); // 'hacker.com' (modified)



// Need deep freeze for nested objects

```



**2. Arrays Are Objects:**

```javascript

const arr = Object.freeze([1, 2, 3]);



// ❌ Cannot modify

arr[0] = 999;

console.log(arr[0]); // 1 (unchanged)



// ❌ Cannot use mutating methods

arr.push(4);    // TypeError

arr.pop();      // TypeError

arr.sort();     // TypeError



// ✅ Can use non-mutating methods

const newArr = arr.map(x => x * 2);

console.log(newArr); // [2, 4, 6]

```



**3. Not Checking Before Operations:**

```javascript

function addProperty(obj, key, value) {

  // ❌ Bad - doesn't check if frozen

  obj[key] = value;

  

  // ✅ Good - check first

  if (Object.isFrozen(obj)) {

    throw new Error('Cannot modify frozen object');

  }

  obj[key] = value;

}

```



**Advantages:**

- **Immutability:** Prevent accidental mutations

- **Security:** Protect critical data

- **Debugging:** Easier to track bugs (state doesn't change unexpectedly)

- **Thread safety:** Safe to share between workers

- **Predictability:** Object behavior is guaranteed



**Disadvantages:**

- **Performance:** Slight overhead

- **Shallow only:** Must deep freeze manually

- **Inflexibility:** Cannot undo freeze/seal

- **Complexity:** Adds conceptual overhead

- **Silent failures:** May hide bugs in non-strict mode



**Best Practices:**

- Use `freeze()` for constants and configuration objects

- Use `seal()` when you need to modify values but not structure

- Always use strict mode to catch violations

- Implement deep freeze for nested objects when needed

- Document frozen/sealed objects in code

- Consider immutability libraries (Immutable.js, Immer) for complex cases

- Don't overuse - only for data that truly needs protection

- Check frozen status before attempting modifications



**Key Takeaways:**

- `Object.seal()`: Prevents adding/removing properties, allows modifications

- `Object.freeze()`: Prevents adding/removing/modifying properties (fully immutable)

- Both are shallow operations - don't affect nested objects

- Use for configuration, constants, and data integrity

- Frozen objects are sealed, but sealed objects aren't necessarily frozen

- Silent failures in non-strict mode, throws errors in strict mode

- Essential for functional programming and immutable data patterns





</details>
<details><summary>37. What is the difference between deep copy and shallow copy?</summary>






**Answer:**

A **shallow copy** duplicates only the top-level properties of an object, while a **deep copy** recursively duplicates all nested objects and arrays, creating completely independent copies.



**Shallow Copy:**



A shallow copy creates a new object, but nested objects/arrays are still references to the original.



```javascript

const original = {

  name: 'John',

  age: 30,

  address: {

    city: 'New York',

    zip: '10001'

  },

  hobbies: ['reading', 'gaming']

};



// Shallow copy using spread operator

const shallowCopy = { ...original };



// Top-level properties are independent

shallowCopy.name = 'Jane';

console.log(original.name);    // 'John' (unchanged)

console.log(shallowCopy.name); // 'Jane'



// ⚠️ Nested objects are still SHARED (references)

shallowCopy.address.city = 'Los Angeles';

console.log(original.address.city);    // 'Los Angeles' (changed!)

console.log(shallowCopy.address.city); // 'Los Angeles'



// ⚠️ Arrays are also SHARED

shallowCopy.hobbies.push('cooking');

console.log(original.hobbies);    // ['reading', 'gaming', 'cooking']

console.log(shallowCopy.hobbies); // ['reading', 'gaming', 'cooking']



// They share the same reference

console.log(original.address === shallowCopy.address); // true

console.log(original.hobbies === shallowCopy.hobbies); // true

```



**Deep Copy:**



A deep copy creates completely independent copies of all nested structures.



```javascript

const original = {

  name: 'John',

  age: 30,

  address: {

    city: 'New York',

    zip: '10001'

  },

  hobbies: ['reading', 'gaming']

};



// Deep copy using JSON (has limitations)

const deepCopy = JSON.parse(JSON.stringify(original));



// All levels are independent

deepCopy.name = 'Jane';

deepCopy.address.city = 'Los Angeles';

deepCopy.hobbies.push('cooking');



console.log(original.name);           // 'John' (unchanged)

console.log(original.address.city);   // 'New York' (unchanged)

console.log(original.hobbies);        // ['reading', 'gaming'] (unchanged)



console.log(deepCopy.name);           // 'Jane'

console.log(deepCopy.address.city);   // 'Los Angeles'

console.log(deepCopy.hobbies);        // ['reading', 'gaming', 'cooking']



// Different references

console.log(original.address === deepCopy.address); // false

console.log(original.hobbies === deepCopy.hobbies); // false

```



**Visual Representation:**



```

Shallow Copy:

original     →  { name: 'John', address: ──→ { city: 'NY' } }

                                              ↑

shallowCopy  →  { name: 'Jane', address: ────┘ }

                (Different object, but address points to same object)



Deep Copy:

original     →  { name: 'John', address: ──→ { city: 'NY' } }



deepCopy     →  { name: 'Jane', address: ──→ { city: 'LA' } }

                (Completely independent objects)

```



**Shallow Copy Methods:**



**1. Spread Operator (...):**

```javascript

const original = { a: 1, b: { c: 2 } };

const copy = { ...original };



copy.a = 10;

console.log(original.a); // 1 (independent)



copy.b.c = 20;

console.log(original.b.c); // 20 (shared!)

```



**2. Object.assign():**

```javascript

const original = { a: 1, b: { c: 2 } };

const copy = Object.assign({}, original);



copy.b.c = 20;

console.log(original.b.c); // 20 (shared!)

```



**3. Array.slice() / Array.concat():**

```javascript

const original = [1, 2, { a: 3 }];

const copy1 = original.slice();

const copy2 = [].concat(original);



copy1[0] = 10;

console.log(original[0]); // 1 (independent)



copy1[2].a = 30;

console.log(original[2].a); // 30 (shared!)

```



**4. Array.from():**

```javascript

const original = [1, 2, [3, 4]];

const copy = Array.from(original);



copy[0] = 10;

console.log(original[0]); // 1 (independent)



copy[2][0] = 30;

console.log(original[2][0]); // 30 (shared!)

```



**Deep Copy Methods:**



**1. JSON.parse(JSON.stringify()) - Simple but Limited:**

```javascript

const original = {

  name: 'John',

  age: 30,

  address: {

    city: 'New York'

  }

};



const deepCopy = JSON.parse(JSON.stringify(original));



// Completely independent

deepCopy.address.city = 'LA';

console.log(original.address.city); // 'New York'



// ⚠️ Limitations:

// - Loses functions

const obj1 = { 

  func: () => console.log('hello')

};

const copy1 = JSON.parse(JSON.stringify(obj1));

console.log(copy1.func); // undefined (lost!)



// - Loses undefined values

const obj2 = { a: undefined, b: 1 };

const copy2 = JSON.parse(JSON.stringify(obj2));

console.log(copy2); // { b: 1 } (a is missing)



// - Loses Dates (converts to string)

const obj3 = { date: new Date() };

const copy3 = JSON.parse(JSON.stringify(obj3));

console.log(typeof copy3.date); // 'string' (not Date object)



// - Loses RegExp, Map, Set

const obj4 = { 

  regex: /test/,

  map: new Map([['key', 'value']]),

  set: new Set([1, 2, 3])

};

const copy4 = JSON.parse(JSON.stringify(obj4));

console.log(copy4.regex); // {} (lost pattern)

console.log(copy4.map);   // {} (lost entries)

console.log(copy4.set);   // {} (lost items)



// - Cannot handle circular references

const obj5 = { a: 1 };

obj5.self = obj5;

// JSON.parse(JSON.stringify(obj5)); // TypeError: Converting circular structure

```



**2. structuredClone() - Modern Standard (Node 17+, Modern Browsers):**

```javascript

const original = {

  name: 'John',

  date: new Date(),

  regex: /test/i,

  map: new Map([['key', 'value']]),

  set: new Set([1, 2, 3]),

  nested: {

    deep: {

      value: 'deeply nested'

    }

  }

};



const deepCopy = structuredClone(original);



// Handles most types correctly

console.log(deepCopy.date instanceof Date);     // true

console.log(deepCopy.regex instanceof RegExp);  // true

console.log(deepCopy.map instanceof Map);       // true

console.log(deepCopy.set instanceof Set);       // true



// Completely independent

deepCopy.nested.deep.value = 'changed';

console.log(original.nested.deep.value); // 'deeply nested' (unchanged)



// ⚠️ Still cannot clone functions

const obj = { func: () => {} };

// structuredClone(obj); // DataCloneError: could not be cloned

```



**3. Custom Deep Clone Function:**

```javascript

function deepClone(obj, hash = new WeakMap()) {

  // Handle null or undefined

  if (obj === null || obj === undefined) return obj;

  

  // Handle primitive types

  if (typeof obj !== 'object') return obj;

  

  // Handle circular references

  if (hash.has(obj)) return hash.get(obj);

  

  // Handle Date

  if (obj instanceof Date) return new Date(obj);

  

  // Handle RegExp

  if (obj instanceof RegExp) return new RegExp(obj);

  

  // Handle Map

  if (obj instanceof Map) {

    const clonedMap = new Map();

    hash.set(obj, clonedMap);

    obj.forEach((value, key) => {

      clonedMap.set(key, deepClone(value, hash));

    });

    return clonedMap;

  }

  

  // Handle Set

  if (obj instanceof Set) {

    const clonedSet = new Set();

    hash.set(obj, clonedSet);

    obj.forEach(value => {

      clonedSet.add(deepClone(value, hash));

    });

    return clonedSet;

  }

  

  // Handle Array

  if (Array.isArray(obj)) {

    const clonedArr = [];

    hash.set(obj, clonedArr);

    obj.forEach((item, index) => {

      clonedArr[index] = deepClone(item, hash);

    });

    return clonedArr;

  }

  

  // Handle Object

  const clonedObj = Object.create(Object.getPrototypeOf(obj));

  hash.set(obj, clonedObj);

  

  Object.keys(obj).forEach(key => {

    clonedObj[key] = deepClone(obj[key], hash);

  });

  

  return clonedObj;

}



// Test with complex object

const complex = {

  name: 'John',

  date: new Date(),

  regex: /test/i,

  map: new Map([['key', 'value']]),

  set: new Set([1, 2, 3]),

  nested: {

    deep: {

      value: 'very deep'

    }

  }

};



// Handle circular reference

complex.self = complex;



const cloned = deepClone(complex);

console.log(cloned.date instanceof Date);      // true

console.log(cloned.regex instanceof RegExp);   // true

console.log(cloned.self === cloned);           // true (circular maintained)

console.log(cloned.self === complex);          // false (different object)



// Independent

cloned.nested.deep.value = 'changed';

console.log(complex.nested.deep.value);        // 'very deep' (unchanged)

```



**4. Using Lodash (Library Solution):**

```javascript

const _ = require('lodash');



const original = {

  name: 'John',

  nested: {

    deep: {

      value: 'test'

    }

  }

};



const deepCopy = _.cloneDeep(original);



deepCopy.nested.deep.value = 'changed';

console.log(original.nested.deep.value); // 'test' (unchanged)

```



**Comparison Table:**



| Method | Deep/Shallow | Functions | Dates | RegExp | Map/Set | Circular Refs | Speed |

|--------|-------------|-----------|-------|--------|---------|---------------|-------|

| Spread `{...obj}` | Shallow | ✅ | ✅ | ✅ | ✅ | ✅ | Fast |

| `Object.assign()` | Shallow | ✅ | ✅ | ✅ | ✅ | ✅ | Fast |

| `JSON` methods | Deep | ❌ | ⚠️ String | ❌ | ❌ | ❌ | Medium |

| `structuredClone()` | Deep | ❌ | ✅ | ✅ | ✅ | ✅ | Fast |

| Custom `deepClone()` | Deep | ⚠️ | ✅ | ✅ | ✅ | ✅ | Slow |

| Lodash `cloneDeep()` | Deep | ✅ | ✅ | ✅ | ✅ | ✅ | Medium |



**Production Use Cases:**



**1. State Management (Immutability):**

```javascript

// Redux-style state updates require copies

const state = {

  user: {

    name: 'John',

    preferences: {

      theme: 'dark'

    }

  }

};



// ❌ Wrong - mutates original state

state.user.preferences.theme = 'light';



// ✅ Shallow copy - works for one level

const newState1 = {

  ...state,

  user: {

    ...state.user,

    name: 'Jane'

  }

};



// ✅ Deep copy - for nested updates

const newState2 = JSON.parse(JSON.stringify(state));

newState2.user.preferences.theme = 'light';

```



**2. Caching Responses:**

```javascript

class APICache {

  constructor() {

    this.cache = new Map();

  }

  

  set(key, value) {

    // Deep clone to prevent external mutations

    this.cache.set(key, structuredClone(value));

  }

  

  get(key) {

    const cached = this.cache.get(key);

    // Return deep clone to prevent mutations

    return cached ? structuredClone(cached) : undefined;

  }

}



const cache = new APICache();

const data = { users: [{ name: 'John' }] };



cache.set('users', data);



const retrieved = cache.get('users');

retrieved.users[0].name = 'Jane';



// Original cache is unchanged

console.log(cache.get('users').users[0].name); // 'John'

```



**3. Undo/Redo Functionality:**

```javascript

class History {

  constructor(initialState) {

    this.states = [structuredClone(initialState)];

    this.currentIndex = 0;

  }

  

  saveState(state) {

    // Remove any future states if we're not at the end

    this.states.splice(this.currentIndex + 1);

    // Deep clone to preserve state

    this.states.push(structuredClone(state));

    this.currentIndex++;

  }

  

  undo() {

    if (this.currentIndex > 0) {

      this.currentIndex--;

      return structuredClone(this.states[this.currentIndex]);

    }

    return null;

  }

  

  redo() {

    if (this.currentIndex < this.states.length - 1) {

      this.currentIndex++;

      return structuredClone(this.states[this.currentIndex]);

    }

    return null;

  }

}



const editor = new History({ text: 'Hello' });

editor.saveState({ text: 'Hello World' });

editor.saveState({ text: 'Hello World!' });



console.log(editor.undo()); // { text: 'Hello World' }

console.log(editor.undo()); // { text: 'Hello' }

console.log(editor.redo()); // { text: 'Hello World' }

```



**Common Pitfalls:**



**1. Assuming Spread is Deep Copy:**

```javascript

const original = { a: { b: 1 } };

const copy = { ...original };



copy.a.b = 2;

console.log(original.a.b); // 2 (shared!) - Common mistake

```



**2. JSON Method Limitations:**

```javascript

const obj = {

  date: new Date(),

  func: () => console.log('hi'),

  undefined: undefined

};



const copy = JSON.parse(JSON.stringify(obj));

console.log(copy.date instanceof Date);  // false (it's a string)

console.log(copy.func);                  // undefined (lost)

console.log('undefined' in copy);        // false (property lost)

```



**3. Performance with Large Objects:**

```javascript

const huge = { /* very large object */ };



// Slow for large objects

console.time('JSON');

const copy1 = JSON.parse(JSON.stringify(huge));

console.timeEnd('JSON');



// Faster

console.time('structuredClone');

const copy2 = structuredClone(huge);

console.timeEnd('structuredClone');

```



**Best Practices:**

- Use **shallow copy** when you only need to modify top-level properties

- Use **deep copy** when you need complete independence from original

- Prefer `structuredClone()` for modern environments (best performance and features)

- Use JSON method only for simple objects (no functions, dates, etc.)

- Consider libraries (Lodash) for complex cloning needs

- Be aware of performance implications with large objects

- Test edge cases (circular refs, special types, functions)

- Document whether functions expect shallow or deep copies



**Key Takeaways:**

- **Shallow copy**: Duplicates top level only, nested objects are references

- **Deep copy**: Recursively duplicates everything, completely independent

- Spread operator and `Object.assign()` create shallow copies

- `structuredClone()` is the modern standard for deep cloning

- JSON method is simple but has many limitations

- Choose based on data structure complexity and performance needs

- Understanding the difference prevents subtle bugs with nested data





</details>
<details><summary>38. How do you clone an object in JavaScript?</summary>






**Answer:**

There are multiple ways to clone objects in JavaScript, each with different characteristics regarding shallow vs deep copying, performance, and support for various data types.



**Shallow Cloning Methods:**



**1. Spread Operator (ES6+) - Most Common:**

```javascript

const original = { a: 1, b: 2, c: 3 };

const clone = { ...original };



clone.a = 10;

console.log(original.a); // 1 (independent)

console.log(clone.a);    // 10



// ⚠️ Shallow only

const nested = { a: 1, b: { c: 2 } };

const shallowClone = { ...nested };



shallowClone.b.c = 20;

console.log(nested.b.c); // 20 (shared!)

```



**2. Object.assign():**

```javascript

const original = { a: 1, b: 2, c: 3 };

const clone = Object.assign({}, original);



// Can also merge multiple objects

const obj1 = { a: 1 };

const obj2 = { b: 2 };

const obj3 = { c: 3 };

const merged = Object.assign({}, obj1, obj2, obj3);

console.log(merged); // { a: 1, b: 2, c: 3 }



// Later properties overwrite earlier ones

const result = Object.assign({}, { a: 1 }, { a: 2 });

console.log(result.a); // 2

```



**3. Object.create() with Property Descriptors:**

```javascript

const original = { a: 1, b: 2 };



// Clone with same prototype

const clone = Object.create(

  Object.getPrototypeOf(original),

  Object.getOwnPropertyDescriptors(original)

);



console.log(clone.a); // 1

console.log(Object.getPrototypeOf(clone) === Object.getPrototypeOf(original)); // true



// Preserves property descriptors

const obj = {};

Object.defineProperty(obj, 'readOnly', {

  value: 42,

  writable: false,

  enumerable: true,

  configurable: false

});



const cloned = Object.create(

  Object.getPrototypeOf(obj),

  Object.getOwnPropertyDescriptors(obj)

);



cloned.readOnly = 100; // Fails silently (non-writable)

console.log(cloned.readOnly); // 42

```



**4. Array Cloning:**

```javascript

const original = [1, 2, 3, 4, 5];



// Method 1: slice()

const clone1 = original.slice();



// Method 2: spread

const clone2 = [...original];



// Method 3: Array.from()

const clone3 = Array.from(original);



// Method 4: concat()

const clone4 = [].concat(original);



// Method 5: map()

const clone5 = original.map(x => x);



// All create shallow copies

clone1[0] = 10;

console.log(original[0]); // 1 (independent)



// ⚠️ Nested arrays are still shared

const nested = [1, 2, [3, 4]];

const shallowClone = [...nested];



shallowClone[2][0] = 30;

console.log(nested[2][0]); // 30 (shared!)

```



**Deep Cloning Methods:**



**1. structuredClone() - Modern Standard (Recommended):**

```javascript

const original = {

  name: 'John',

  age: 30,

  date: new Date(),

  regex: /test/i,

  map: new Map([['key', 'value']]),

  set: new Set([1, 2, 3]),

  buffer: new ArrayBuffer(8),

  nested: {

    deep: {

      value: [1, 2, 3]

    }

  }

};



// ✅ Handles most types correctly

const deepClone = structuredClone(original);



deepClone.nested.deep.value.push(4);

console.log(original.nested.deep.value); // [1, 2, 3] (unchanged)



// Preserves types

console.log(deepClone.date instanceof Date);      // true

console.log(deepClone.regex instanceof RegExp);   // true

console.log(deepClone.map instanceof Map);        // true

console.log(deepClone.set instanceof Set);        // true



// Handles circular references

const circular = { a: 1 };

circular.self = circular;

const clonedCircular = structuredClone(circular);

console.log(clonedCircular.self === clonedCircular); // true



// ⚠️ Cannot clone functions

const withFunc = { func: () => {} };

// structuredClone(withFunc); // DataCloneError

```



**2. JSON.parse(JSON.stringify()) - Simple but Limited:**

```javascript

const original = {

  name: 'John',

  age: 30,

  address: {

    city: 'New York',

    coordinates: {

      lat: 40.7128,

      lng: -74.0060

    }

  }

};



const deepClone = JSON.parse(JSON.stringify(original));



deepClone.address.coordinates.lat = 50;

console.log(original.address.coordinates.lat); // 40.7128 (unchanged)



// ⚠️ Limitations:

const problematic = {

  func: () => console.log('hi'),    // Lost

  date: new Date(),                 // Becomes string

  undefined: undefined,             // Lost

  infinity: Infinity,               // Becomes null

  nan: NaN,                        // Becomes null

  regex: /test/,                   // Becomes {}

  symbol: Symbol('test'),          // Lost

  map: new Map([['a', 1]]),        // Becomes {}

  set: new Set([1, 2, 3])         // Becomes {}

};



const cloned = JSON.parse(JSON.stringify(problematic));

console.log(cloned.func);      // undefined

console.log(typeof cloned.date); // 'string'

console.log('undefined' in cloned); // false

```



**3. Custom Deep Clone Function:**

```javascript

function deepClone(obj, hash = new WeakMap()) {

  // Primitives and null

  if (obj === null || typeof obj !== 'object') {

    return obj;

  }

  

  // Handle circular references

  if (hash.has(obj)) {

    return hash.get(obj);

  }

  

  // Handle specific object types

  if (obj instanceof Date) {

    return new Date(obj.getTime());

  }

  

  if (obj instanceof RegExp) {

    return new RegExp(obj.source, obj.flags);

  }

  

  if (obj instanceof Map) {

    const clonedMap = new Map();

    hash.set(obj, clonedMap);

    for (const [key, value] of obj) {

      clonedMap.set(key, deepClone(value, hash));

    }

    return clonedMap;

  }

  

  if (obj instanceof Set) {

    const clonedSet = new Set();

    hash.set(obj, clonedSet);

    for (const value of obj) {

      clonedSet.add(deepClone(value, hash));

    }

    return clonedSet;

  }

  

  // Handle Arrays

  if (Array.isArray(obj)) {

    const clonedArr = [];

    hash.set(obj, clonedArr);

    for (let i = 0; i < obj.length; i++) {

      clonedArr[i] = deepClone(obj[i], hash);

    }

    return clonedArr;

  }

  

  // Handle plain objects

  const clonedObj = Object.create(Object.getPrototypeOf(obj));

  hash.set(obj, clonedObj);

  

  for (const key of Object.keys(obj)) {

    clonedObj[key] = deepClone(obj[key], hash);

  }

  

  return clonedObj;

}



// Usage

const complex = {

  name: 'John',

  date: new Date(),

  map: new Map([['key', 'value']]),

  nested: {

    arr: [1, 2, { deep: 3 }]

  }

};



complex.circular = complex; // Circular reference



const cloned = deepClone(complex);

cloned.nested.arr[2].deep = 99;



console.log(complex.nested.arr[2].deep); // 3 (unchanged)

console.log(cloned.circular === cloned); // true (maintains circular ref)

console.log(cloned.date instanceof Date); // true

console.log(cloned.map instanceof Map);   // true

```



**4. Library Solutions:**



**Lodash cloneDeep:**

```javascript

const _ = require('lodash');



const original = {

  name: 'John',

  nested: {

    deep: {

      value: [1, 2, 3]

    }

  },

  func: () => console.log('hi')

};



const deepClone = _.cloneDeep(original);



deepClone.nested.deep.value.push(4);

console.log(original.nested.deep.value); // [1, 2, 3] (unchanged)



// ✅ Preserves functions

console.log(typeof deepClone.func); // 'function'

```



**Ramda clone:**

```javascript

const R = require('ramda');



const original = { a: { b: { c: 1 } } };

const cloned = R.clone(original);



cloned.a.b.c = 2;

console.log(original.a.b.c); // 1 (unchanged)

```



**Special Cases:**



**1. Cloning with Getters/Setters:**

```javascript

const original = {

  _value: 42,

  get value() {

    return this._value;

  },

  set value(val) {

    this._value = val;

  }

};



// Spread operator loses getters/setters

const spreadClone = { ...original };

console.log(Object.getOwnPropertyDescriptor(spreadClone, 'value'));

// { value: 42, writable: true, enumerable: true, configurable: true }

// (Converted to regular property!)



// ✅ Preserve getters/setters

const properClone = Object.defineProperties(

  {},

  Object.getOwnPropertyDescriptors(original)

);



console.log(Object.getOwnPropertyDescriptor(properClone, 'value'));

// { get: [Function: get], set: [Function: set], enumerable: true, configurable: true }

// (Getters/setters preserved!)

```



**2. Cloning Class Instances:**

```javascript

class Person {

  constructor(name, age) {

    this.name = name;

    this.age = age;

  }

  

  greet() {

    return `Hello, I'm ${this.name}`;

  }

  

  clone() {

    return new Person(this.name, this.age);

  }

}



const john = new Person('John', 30);



// ❌ Loses class methods

const spreadClone = { ...john };

console.log(spreadClone.greet); // undefined



// ❌ Still loses methods

const jsonClone = JSON.parse(JSON.stringify(john));

console.log(jsonClone.greet); // undefined



// ✅ Use custom clone method

const properClone = john.clone();

console.log(properClone.greet()); // 'Hello, I'm John'

console.log(properClone instanceof Person); // true



// ✅ Or preserve prototype

const protoClone = Object.assign(

  Object.create(Object.getPrototypeOf(john)),

  john

);

console.log(protoClone.greet()); // 'Hello, I'm John'

console.log(protoClone instanceof Person); // true

```



**3. Cloning with Symbols:**

```javascript

const sym = Symbol('key');

const original = {

  [sym]: 'symbol value',

  regular: 'regular value'

};



// Spread doesn't copy symbol properties

const spreadClone = { ...original };

console.log(spreadClone[sym]); // undefined



// Object.assign doesn't copy symbol properties

const assignClone = Object.assign({}, original);

console.log(assignClone[sym]); // undefined



// ✅ Copy symbols manually

const properClone = {};

Object.assign(properClone, original);

Object.getOwnPropertySymbols(original).forEach(s => {

  properClone[s] = original[s];

});

console.log(properClone[sym]); // 'symbol value'



// ✅ Or use this helper

function cloneWithSymbols(obj) {

  const clone = { ...obj };

  Object.getOwnPropertySymbols(obj).forEach(sym => {

    clone[sym] = obj[sym];

  });

  return clone;

}

```



**Performance Comparison:**



```javascript

const large = { /* large nested object */ };



// Fastest - shallow copy

console.time('spread');

const clone1 = { ...large };

console.timeEnd('spread'); // ~0.1ms



// Fast - shallow copy

console.time('Object.assign');

const clone2 = Object.assign({}, large);

console.timeEnd('Object.assign'); // ~0.15ms



// Medium - deep copy

console.time('JSON');

const clone3 = JSON.parse(JSON.stringify(large));

console.timeEnd('JSON'); // ~2ms



// Fast - deep copy (modern)

console.time('structuredClone');

const clone4 = structuredClone(large);

console.timeEnd('structuredClone'); // ~1ms



// Slow - deep copy (comprehensive)

console.time('deepClone');

const clone5 = deepClone(large);

console.timeEnd('deepClone'); // ~5ms

```



**Method Selection Guide:**



```javascript

// Simple object, top-level only → Spread operator

const simple = { a: 1, b: 2 };

const clone1 = { ...simple };



// Nested object, no special types → JSON

const nested = { a: { b: { c: 1 } } };

const clone2 = JSON.parse(JSON.stringify(nested));



// Nested with Dates, Maps, Sets → structuredClone

const complex = { date: new Date(), map: new Map() };

const clone3 = structuredClone(complex);



// With functions, class instances → Custom or library

const withMethods = new MyClass();

const clone4 = _.cloneDeep(withMethods);



// Array of primitives → Spread or slice

const arr = [1, 2, 3];

const clone5 = [...arr]; // or arr.slice()



// Array of objects → structuredClone

const arrOfObj = [{ a: 1 }, { b: 2 }];

const clone6 = structuredClone(arrOfObj);

```



**Production Use Cases:**



**1. Redux State Updates:**

```javascript

// Immutable state updates

const state = {

  user: {

    name: 'John',

    preferences: {

      theme: 'dark'

    }

  }

};



// ✅ Correct way - create new objects at each level

const newState = {

  ...state,

  user: {

    ...state.user,

    preferences: {

      ...state.user.preferences,

      theme: 'light'

    }

  }

};

```



**2. Form Data Backup:**

```javascript

class FormManager {

  constructor(initialData) {

    this.currentData = initialData;

    this.backup = structuredClone(initialData);

  }

  

  updateField(field, value) {

    this.currentData[field] = value;

  }

  

  reset() {

    this.currentData = structuredClone(this.backup);

  }

  

  hasChanges() {

    return JSON.stringify(this.currentData) !== JSON.stringify(this.backup);

  }

}



const form = new FormManager({ name: 'John', email: 'john@example.com' });

form.updateField('name', 'Jane');

console.log(form.hasChanges()); // true

form.reset();

console.log(form.currentData.name); // 'John' (restored)

```



**3. Default Configuration:**

```javascript

const defaultConfig = {

  timeout: 5000,

  retries: 3,

  headers: {

    'Content-Type': 'application/json'

  }

};



function createClient(userConfig = {}) {

  // Merge with defaults, ensuring original defaults unchanged

  return {

    ...structuredClone(defaultConfig),

    ...userConfig

  };

}



const client1 = createClient({ timeout: 10000 });

const client2 = createClient({ retries: 5 });



console.log(client1.timeout); // 10000

console.log(client2.timeout); // 5000 (default)

```



**Best Practices:**

- Use **spread operator** for simple shallow copies (most common case)

- Use **structuredClone()** for deep copies in modern environments

- Use **JSON method** only for plain objects without special types

- Implement **custom clone method** in classes for proper cloning

- Consider **libraries** (Lodash) for complex cloning requirements

- Always test cloning with your actual data structures

- Document whether functions expect original or cloned data

- Be aware of performance implications with large objects



**Key Takeaways:**

- Multiple cloning methods exist for different use cases

- Spread operator and `Object.assign()` create shallow copies

- `structuredClone()` is the modern standard for deep cloning

- JSON method is simple but has many limitations (functions, dates, etc.)

- Choose method based on data complexity and required features

- Custom deep clone functions offer maximum control but complexity

- Libraries provide battle-tested solutions for edge cases

- Understanding cloning is essential for immutability patterns



## Arrays



</details>
<details><summary>39. What are arrays in JavaScript?</summary>






**Answer:**

Arrays are ordered, indexed collections that can hold multiple values of any type. In JavaScript, arrays are actually special objects with numeric keys and a length property, providing powerful methods for data manipulation.



**Array Basics:**



```javascript

// Creating arrays

const empty = [];

const numbers = [1, 2, 3, 4, 5];

const mixed = [1, 'two', true, null, { key: 'value' }, [1, 2]];



// Accessing elements (zero-indexed)

console.log(numbers[0]);  // 1 (first element)

console.log(numbers[4]);  // 5 (last element)

console.log(numbers[-1]); // undefined (no negative indexing like Python)



// Length property

console.log(numbers.length); // 5



// Modifying elements

numbers[0] = 10;

console.log(numbers); // [10, 2, 3, 4, 5]



// Arrays are objects

console.log(typeof numbers); // 'object'

console.log(Array.isArray(numbers)); // true (proper check)

```



**Array Creation Methods:**



```javascript

// 1. Array literal (most common)

const arr1 = [1, 2, 3];



// 2. Array constructor

const arr2 = new Array(1, 2, 3);

console.log(arr2); // [1, 2, 3]



// ⚠️ Single number creates empty array with that length

const arr3 = new Array(5);

console.log(arr3); // [ <5 empty items> ]

console.log(arr3.length); // 5



// 3. Array.of() - creates array from arguments

const arr4 = Array.of(1, 2, 3);

console.log(arr4); // [1, 2, 3]



const arr5 = Array.of(5); // Creates [5], not empty array

console.log(arr5); // [5]



// 4. Array.from() - creates from iterable or array-like

const arr6 = Array.from('hello');

console.log(arr6); // ['h', 'e', 'l', 'l', 'o']



const arr7 = Array.from({ length: 3 }, (_, i) => i * 2);

console.log(arr7); // [0, 2, 4]



// 5. Spread operator with iterable

const arr8 = [...'hello'];

console.log(arr8); // ['h', 'e', 'l', 'l', 'o']



const arr9 = [...new Set([1, 2, 2, 3])];

console.log(arr9); // [1, 2, 3] (duplicates removed)

```



**Array Characteristics:**



```javascript

// 1. Dynamic size

const arr = [1, 2, 3];

arr.push(4);  // Can grow

console.log(arr); // [1, 2, 3, 4]



arr.length = 2; // Can shrink

console.log(arr); // [1, 2]



// 2. Heterogeneous (mixed types)

const mixed = [

  42,                    // number

  'hello',              // string

  true,                 // boolean

  null,                 // null

  undefined,            // undefined

  { key: 'value' },    // object

  [1, 2, 3],           // array

  () => console.log('hi') // function

];



// 3. Sparse arrays (gaps in indices)

const sparse = [];

sparse[0] = 'first';

sparse[10] = 'eleventh';

console.log(sparse.length); // 11 (not 2!)

console.log(sparse); // ['first', <9 empty items>, 'eleventh']



// Empty slots are different from undefined

console.log(sparse[5]); // undefined

console.log(5 in sparse); // false (no property at index 5)



const explicit = [1, undefined, 3];

console.log(1 in explicit); // true (undefined is explicitly set)



// 4. Arrays are objects with numeric keys

const arr2 = ['a', 'b', 'c'];

console.log(arr2['0']); // 'a' (string key works)

console.log(arr2[0]);   // 'a' (numeric key)



// Can have non-numeric properties (but shouldn't)

arr2.customProp = 'value';

console.log(arr2.customProp); // 'value'

console.log(arr2.length); // 3 (non-numeric props don't affect length)

```



**Common Array Operations:**



**1. Adding Elements:**

```javascript

const arr = [1, 2, 3];



// Add to end

arr.push(4, 5);

console.log(arr); // [1, 2, 3, 4, 5]



// Add to beginning

arr.unshift(0);

console.log(arr); // [0, 1, 2, 3, 4, 5]



// Add at specific position

arr.splice(3, 0, 2.5); // At index 3, delete 0, insert 2.5

console.log(arr); // [0, 1, 2, 2.5, 3, 4, 5]



// Using length property

arr[arr.length] = 6;

console.log(arr); // [0, 1, 2, 2.5, 3, 4, 5, 6]

```



**2. Removing Elements:**

```javascript

const arr = [1, 2, 3, 4, 5];



// Remove from end

const last = arr.pop();

console.log(last); // 5

console.log(arr); // [1, 2, 3, 4]



// Remove from beginning

const first = arr.shift();

console.log(first); // 1

console.log(arr); // [2, 3, 4]



// Remove at specific position

arr.splice(1, 1); // At index 1, delete 1 element

console.log(arr); // [2, 4]



// Remove using delete (creates hole - avoid)

const arr2 = [1, 2, 3];

delete arr2[1];

console.log(arr2); // [1, <1 empty item>, 3]

console.log(arr2.length); // 3 (length unchanged!)

```



**3. Searching:**

```javascript

const fruits = ['apple', 'banana', 'orange', 'banana'];



// indexOf - first occurrence

console.log(fruits.indexOf('banana')); // 1



// lastIndexOf - last occurrence

console.log(fruits.lastIndexOf('banana')); // 3



// includes - boolean check

console.log(fruits.includes('apple')); // true

console.log(fruits.includes('grape')); // false



// find - first element matching condition

const numbers = [1, 5, 10, 15, 20];

const found = numbers.find(n => n > 10);

console.log(found); // 15



// findIndex - index of first match

const foundIndex = numbers.findIndex(n => n > 10);

console.log(foundIndex); // 3



// some - at least one matches

console.log(numbers.some(n => n > 15)); // true



// every - all match

console.log(numbers.every(n => n > 0)); // true

console.log(numbers.every(n => n > 10)); // false

```



**4. Transforming:**

```javascript

const numbers = [1, 2, 3, 4, 5];



// map - transform each element

const doubled = numbers.map(n => n * 2);

console.log(doubled); // [2, 4, 6, 8, 10]



// filter - keep elements matching condition

const evens = numbers.filter(n => n % 2 === 0);

console.log(evens); // [2, 4]



// reduce - accumulate to single value

const sum = numbers.reduce((acc, n) => acc + n, 0);

console.log(sum); // 15



const product = numbers.reduce((acc, n) => acc * n, 1);

console.log(product); // 120



// flatMap - map then flatten

const nested = [1, 2, 3];

const result = nested.flatMap(n => [n, n * 2]);

console.log(result); // [1, 2, 2, 4, 3, 6]

```



**5. Sorting and Reversing:**

```javascript

const numbers = [3, 1, 4, 1, 5, 9, 2, 6];



// sort - sorts in place (⚠️ lexicographic by default)

numbers.sort();

console.log(numbers); // [1, 1, 2, 3, 4, 5, 6, 9]



const nums = [1, 5, 10, 25, 100];

nums.sort(); // ⚠️ Problem!

console.log(nums); // [1, 10, 100, 25, 5] (lexicographic!)



// Proper numeric sort

nums.sort((a, b) => a - b);

console.log(nums); // [1, 5, 10, 25, 100]



// reverse - reverses in place

nums.reverse();

console.log(nums); // [100, 25, 10, 5, 1]



// Sort objects

const people = [

  { name: 'John', age: 30 },

  { name: 'Jane', age: 25 },

  { name: 'Bob', age: 35 }

];



people.sort((a, b) => a.age - b.age);

console.log(people);

// [{ name: 'Jane', age: 25 }, { name: 'John', age: 30 }, { name: 'Bob', age: 35 }]

```



**6. Extracting Portions:**

```javascript

const arr = [1, 2, 3, 4, 5];



// slice - extract portion (doesn't modify original)

const portion = arr.slice(1, 4);

console.log(portion); // [2, 3, 4]

console.log(arr); // [1, 2, 3, 4, 5] (unchanged)



// Negative indices

console.log(arr.slice(-2)); // [4, 5] (last 2)

console.log(arr.slice(0, -1)); // [1, 2, 3, 4] (all except last)



// Copy array

const copy = arr.slice();

console.log(copy); // [1, 2, 3, 4, 5]

```



**7. Joining and Splitting:**

```javascript

// join - array to string

const arr = ['Hello', 'World'];

console.log(arr.join(' ')); // 'Hello World'

console.log(arr.join('-')); // 'Hello-World'

console.log(arr.join('')); // 'HelloWorld'



// String split - string to array

const str = 'Hello World';

console.log(str.split(' ')); // ['Hello', 'World']

console.log(str.split('')); // ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']



// CSV parsing

const csv = 'name,age,city';

console.log(csv.split(',')); // ['name', 'age', 'city']

```



**8. Flattening:**

```javascript

// flat - flatten nested arrays

const nested = [1, [2, 3], [4, [5, 6]]];



console.log(nested.flat());    // [1, 2, 3, 4, [5, 6]] (1 level)

console.log(nested.flat(2));   // [1, 2, 3, 4, 5, 6] (2 levels)

console.log(nested.flat(Infinity)); // [1, 2, 3, 4, 5, 6] (all levels)



// Remove empty slots

const sparse = [1, , 3, , 5];

console.log(sparse.flat()); // [1, 3, 5] (removes empty slots)

```



**Multi-dimensional Arrays:**



```javascript

// 2D array (matrix)

const matrix = [

  [1, 2, 3],

  [4, 5, 6],

  [7, 8, 9]

];



console.log(matrix[0][0]); // 1

console.log(matrix[1][2]); // 6

console.log(matrix[2][1]); // 8



// Iterate 2D array

for (let i = 0; i < matrix.length; i++) {

  for (let j = 0; j < matrix[i].length; j++) {

    console.log(matrix[i][j]);

  }

}



// Using forEach

matrix.forEach(row => {

  row.forEach(cell => {

    console.log(cell);

  });

});



// Create 3x3 matrix of zeros

const zeros = Array.from({ length: 3 }, () => Array(3).fill(0));

console.log(zeros);

// [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

```



**Array Iteration:**



```javascript

const arr = ['a', 'b', 'c'];



// 1. for loop

for (let i = 0; i < arr.length; i++) {

  console.log(i, arr[i]);

}



// 2. for...of (values)

for (const value of arr) {

  console.log(value);

}



// 3. for...in (indices - avoid for arrays)

for (const index in arr) {

  console.log(index, arr[index]);

}



// 4. forEach

arr.forEach((value, index, array) => {

  console.log(index, value);

});



// 5. map (when transforming)

const upper = arr.map(s => s.toUpperCase());



// 6. entries() - [index, value] pairs

for (const [index, value] of arr.entries()) {

  console.log(index, value);

}



// 7. keys() - indices

for (const index of arr.keys()) {

  console.log(index);

}



// 8. values() - values

for (const value of arr.values()) {

  console.log(value);

}

```



**Performance Considerations:**



```javascript

// Fast operations (O(1))

arr.push(item);      // Add to end

arr.pop();           // Remove from end

arr[index];          // Access by index

arr.length;          // Get length



// Slow operations (O(n))

arr.unshift(item);   // Add to beginning (shifts all elements)

arr.shift();         // Remove from beginning (shifts all elements)

arr.splice(i, 0, x); // Insert in middle (shifts elements)



// Very slow operations (O(n) or worse)

arr.indexOf(item);   // Linear search

arr.includes(item);  // Linear search

arr.sort();          // O(n log n)

```



**Production Use Cases:**



**1. Data Processing Pipeline:**

```javascript

const users = [

  { name: 'John', age: 25, active: true },

  { name: 'Jane', age: 30, active: false },

  { name: 'Bob', age: 35, active: true }

];



// Chain operations

const result = users

  .filter(user => user.active)

  .map(user => user.name)

  .sort();



console.log(result); // ['Bob', 'John']

```



**2. Grouping Data:**

```javascript

const transactions = [

  { category: 'food', amount: 50 },

  { category: 'transport', amount: 30 },

  { category: 'food', amount: 20 },

  { category: 'transport', amount: 40 }

];



const grouped = transactions.reduce((acc, t) => {

  if (!acc[t.category]) {

    acc[t.category] = [];

  }

  acc[t.category].push(t);

  return acc;

}, {});



console.log(grouped);

// { food: [...], transport: [...] }

```



**3. Pagination:**

```javascript

function paginate(array, pageSize, pageNumber) {

  const start = (pageNumber - 1) * pageSize;

  const end = start + pageSize;

  return array.slice(start, end);

}



const items = Array.from({ length: 100 }, (_, i) => i + 1);

console.log(paginate(items, 10, 1)); // [1, 2, ..., 10]

console.log(paginate(items, 10, 2)); // [11, 12, ..., 20]

```



**Best Practices:**

- Use array literals `[]` instead of `new Array()`

- Use `Array.isArray()` to check for arrays

- Prefer immutable methods (`map`, `filter`, `slice`) over mutating ones

- Use `for...of` for iteration, not `for...in`

- Avoid sparse arrays when possible

- Use appropriate methods for performance

- Consider `Set` for unique values

- Use typed arrays for binary data



**Key Takeaways:**

- Arrays are ordered, indexed collections of any type

- Actually objects with numeric keys and special length property

- Dynamic size, can grow or shrink

- Rich set of built-in methods for manipulation

- Zero-indexed (first element at index 0)

- Essential data structure for most JavaScript programs

- Understanding array methods is crucial for effective programming





</details>
<details><summary>40. What is the difference between array methods: map, filter, and reduce?</summary>






**Answer:**

`map()`, `filter()`, and `reduce()` are fundamental array methods for functional programming in JavaScript. Each serves a different purpose: `map()` transforms elements, `filter()` selects elements, and `reduce()` accumulates elements into a single value.



**Quick Comparison:**



| Method | Purpose | Returns | Use When |

|--------|---------|---------|----------|

| **map()** | Transform each element | New array (same length) | Converting/modifying all elements |

| **filter()** | Select elements | New array (≤ length) | Keeping elements that match criteria |

| **reduce()** | Accumulate to single value | Any type | Calculating sum, building object, etc. |



**map() - Transform Elements:**



`map()` creates a new array by applying a function to each element. The resulting array has the **same length** as the original.



```javascript

const numbers = [1, 2, 3, 4, 5];



// Transform each element

const doubled = numbers.map(n => n * 2);

console.log(doubled); // [2, 4, 6, 8, 10]



// Original unchanged

console.log(numbers); // [1, 2, 3, 4, 5]



// Map with objects

const users = [

  { firstName: 'John', lastName: 'Doe' },

  { firstName: 'Jane', lastName: 'Smith' }

];



const fullNames = users.map(user => `${user.firstName} ${user.lastName}`);

console.log(fullNames); // ['John Doe', 'Jane Smith']



// Map with index

const indexed = numbers.map((num, index) => ({

  index,

  value: num,

  doubled: num * 2

}));

console.log(indexed);

// [

//   { index: 0, value: 1, doubled: 2 },

//   { index: 1, value: 2, doubled: 4 },

//   ...

// ]

```



**filter() - Select Elements:**



`filter()` creates a new array with only elements that pass a test. The resulting array has **equal or smaller length**.



```javascript

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];



// Keep only even numbers

const evens = numbers.filter(n => n % 2 === 0);

console.log(evens); // [2, 4, 6, 8, 10]



// Keep only numbers greater than 5

const greaterThanFive = numbers.filter(n => n > 5);

console.log(greaterThanFive); // [6, 7, 8, 9, 10]



// Filter with objects

const users = [

  { name: 'John', age: 25, active: true },

  { name: 'Jane', age: 30, active: false },

  { name: 'Bob', age: 35, active: true }

];



const activeUsers = users.filter(user => user.active);

console.log(activeUsers);

// [{ name: 'John', age: 25, active: true }, { name: 'Bob', age: 35, active: true }]



// Filter with multiple conditions

const youngActiveUsers = users.filter(user => user.active && user.age < 30);

console.log(youngActiveUsers);

// [{ name: 'John', age: 25, active: true }]



// Filter falsy values

const mixed = [0, 1, false, 2, '', 3, null, undefined, 4];

const truthy = mixed.filter(Boolean);

console.log(truthy); // [1, 2, 3, 4]

```



**reduce() - Accumulate to Single Value:**



`reduce()` executes a reducer function on each element, resulting in a **single output value**.



```javascript

const numbers = [1, 2, 3, 4, 5];



// Sum all numbers

const sum = numbers.reduce((accumulator, current) => {

  return accumulator + current;

}, 0); // 0 is initial value

console.log(sum); // 15



// Product of all numbers

const product = numbers.reduce((acc, curr) => acc * curr, 1);

console.log(product); // 120



// Find maximum

const max = numbers.reduce((max, curr) => curr > max ? curr : max);

console.log(max); // 5



// Count occurrences

const fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];

const count = fruits.reduce((acc, fruit) => {

  acc[fruit] = (acc[fruit] || 0) + 1;

  return acc;

}, {});

console.log(count); // { apple: 3, banana: 2, orange: 1 }



// Group by property

const people = [

  { name: 'John', age: 25 },

  { name: 'Jane', age: 30 },

  { name: 'Bob', age: 25 }

];



const groupedByAge = people.reduce((acc, person) => {

  const age = person.age;

  if (!acc[age]) {

    acc[age] = [];

  }

  acc[age].push(person);

  return acc;

}, {});

console.log(groupedByAge);

// {

//   25: [{ name: 'John', age: 25 }, { name: 'Bob', age: 25 }],

//   30: [{ name: 'Jane', age: 30 }]

// }



// Flatten array

const nested = [[1, 2], [3, 4], [5, 6]];

const flattened = nested.reduce((acc, curr) => acc.concat(curr), []);

console.log(flattened); // [1, 2, 3, 4, 5, 6]

```



**Detailed Comparison:**



**1. Return Value:**

```javascript

const numbers = [1, 2, 3, 4, 5];



// map: always returns array with same length

const mapped = numbers.map(n => n * 2);

console.log(mapped.length); // 5 (same as original)



// filter: returns array with ≤ length

const filtered = numbers.filter(n => n > 3);

console.log(filtered.length); // 2 (smaller)



// reduce: returns single value (any type)

const reduced = numbers.reduce((sum, n) => sum + n, 0);

console.log(typeof reduced); // 'number'



// reduce can return array, object, etc.

const reducedArray = numbers.reduce((acc, n) => [...acc, n * 2], []);

console.log(reducedArray); // [2, 4, 6, 8, 10] (like map)

```



**2. Callback Parameters:**

```javascript

const arr = [10, 20, 30];



// map(element, index, array)

arr.map((element, index, array) => {

  console.log('Element:', element);

  console.log('Index:', index);

  console.log('Array:', array);

  return element * 2;

});



// filter(element, index, array)

arr.filter((element, index, array) => {

  console.log('Element:', element);

  console.log('Index:', index);

  console.log('Array:', array);

  return element > 15;

});



// reduce(accumulator, element, index, array)

arr.reduce((accumulator, element, index, array) => {

  console.log('Accumulator:', accumulator);

  console.log('Element:', element);

  console.log('Index:', index);

  console.log('Array:', array);

  return accumulator + element;

}, 0); // Initial value

```



**3. Initial Value (reduce only):**

```javascript

const numbers = [1, 2, 3, 4, 5];



// With initial value

const sum1 = numbers.reduce((acc, n) => acc + n, 0);

console.log(sum1); // 15



// Without initial value (uses first element)

const sum2 = numbers.reduce((acc, n) => acc + n);

console.log(sum2); // 15



// ⚠️ Empty array without initial value throws error

const empty = [];

// empty.reduce((acc, n) => acc + n); // TypeError!

const safeSum = empty.reduce((acc, n) => acc + n, 0); // 0 (safe)



// Initial value type can differ from array elements

const strings = ['1', '2', '3'];

const numberSum = strings.reduce((acc, str) => acc + Number(str), 0);

console.log(numberSum); // 6 (number, not string)

```



**Combining Methods (Chaining):**



```javascript

const users = [

  { name: 'John', age: 25, salary: 50000, active: true },

  { name: 'Jane', age: 30, salary: 60000, active: false },

  { name: 'Bob', age: 35, salary: 70000, active: true },

  { name: 'Alice', age: 28, salary: 55000, active: true }

];



// Complex transformation pipeline

const result = users

  .filter(user => user.active)              // Keep active users

  .map(user => user.salary)                 // Extract salaries

  .reduce((sum, salary) => sum + salary, 0); // Sum salaries



console.log(result); // 175000



// Get names of active users over 25, sorted

const activeNames = users

  .filter(user => user.active && user.age > 25)

  .map(user => user.name)

  .sort();



console.log(activeNames); // ['Alice', 'Bob']



// Average salary of active users

const avgSalary = users

  .filter(user => user.active)

  .reduce((acc, user, idx, arr) => {

    acc += user.salary;

    if (idx === arr.length - 1) {

      return acc / arr.length;

    }

    return acc;

  }, 0);



console.log(avgSalary); // 58333.33

```



**When to Use Each:**



**Use map() when:**

```javascript

// Converting data types

const strings = [1, 2, 3];

const numbers = strings.map(String); // ['1', '2', '3']



// Extracting properties

const users = [{ name: 'John' }, { name: 'Jane' }];

const names = users.map(u => u.name); // ['John', 'Jane']



// Transforming objects

const products = [{ price: 10 }, { price: 20 }];

const withTax = products.map(p => ({ ...p, total: p.price * 1.1 }));



// Adding computed properties

const items = [1, 2, 3];

const enriched = items.map((n, i) => ({ id: i, value: n, squared: n ** 2 }));

```



**Use filter() when:**

```javascript

// Removing unwanted elements

const numbers = [1, 2, 3, 4, 5];

const evens = numbers.filter(n => n % 2 === 0);



// Finding matches

const users = [{ age: 25 }, { age: 30 }, { age: 35 }];

const adults = users.filter(u => u.age >= 18);



// Removing duplicates (with indexOf)

const arr = [1, 2, 2, 3, 3, 4];

const unique = arr.filter((n, i, self) => self.indexOf(n) === i);



// Removing falsy values

const mixed = [0, 1, false, 2, '', 3];

const truthy = mixed.filter(Boolean);

```



**Use reduce() when:**

```javascript

// Calculating single value

const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((a, b) => a + b, 0);



// Building object/map

const pairs = [['a', 1], ['b', 2]];

const obj = pairs.reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {});



// Grouping/categorizing

const items = [{ type: 'A' }, { type: 'B' }, { type: 'A' }];

const grouped = items.reduce((acc, item) => {

  (acc[item.type] = acc[item.type] || []).push(item);

  return acc;

}, {});



// Complex aggregations

const sales = [{ amount: 100 }, { amount: 200 }];

const stats = sales.reduce((acc, sale) => ({

  total: acc.total + sale.amount,

  count: acc.count + 1,

  average: (acc.total + sale.amount) / (acc.count + 1)

}), { total: 0, count: 0, average: 0 });

```



**Performance Considerations:**



```javascript

const large = Array.from({ length: 1000000 }, (_, i) => i);



// Single operation is faster

console.time('map then filter');

const result1 = large

  .map(n => n * 2)

  .filter(n => n > 100);

console.timeEnd('map then filter'); // ~50ms (processes array twice)



// Combined operation is more efficient

console.time('single reduce');

const result2 = large.reduce((acc, n) => {

  const doubled = n * 2;

  if (doubled > 100) {

    acc.push(doubled);

  }

  return acc;

}, []);

console.timeEnd('single reduce'); // ~25ms (processes array once)



// But readability often matters more than micro-optimizations

// Use chaining for clarity unless performance is critical

```



**Common Patterns:**



**1. map + filter (could be reduce):**

```javascript

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];



// Using map + filter

const result1 = numbers

  .map(n => n * 2)

  .filter(n => n > 10);



// Using reduce (more efficient but less readable)

const result2 = numbers.reduce((acc, n) => {

  const doubled = n * 2;

  if (doubled > 10) {

    acc.push(doubled);

  }

  return acc;

}, []);



console.log(result1); // [12, 14, 16, 18, 20]

console.log(result2); // [12, 14, 16, 18, 20]

```



**2. Counting with reduce:**

```javascript

const votes = ['yes', 'no', 'yes', 'yes', 'no'];



const tally = votes.reduce((acc, vote) => {

  acc[vote] = (acc[vote] || 0) + 1;

  return acc;

}, {});



console.log(tally); // { yes: 3, no: 2 }

```



**3. Creating lookup map:**

```javascript

const users = [

  { id: 1, name: 'John' },

  { id: 2, name: 'Jane' },

  { id: 3, name: 'Bob' }

];



const userMap = users.reduce((acc, user) => {

  acc[user.id] = user;

  return acc;

}, {});



console.log(userMap[2]); // { id: 2, name: 'Jane' }

```



**Production Use Cases:**



**1. Data Transformation Pipeline:**

```javascript

const rawData = [

  { date: '2024-01-01', amount: 100, status: 'completed' },

  { date: '2024-01-02', amount: 200, status: 'pending' },

  { date: '2024-01-03', amount: 150, status: 'completed' }

];



const totalCompleted = rawData

  .filter(tx => tx.status === 'completed')

  .map(tx => tx.amount)

  .reduce((sum, amount) => sum + amount, 0);



console.log(totalCompleted); // 250

```



**2. React Component Rendering:**

```javascript

const TodoList = ({ todos }) => {

  // Map items to React elements

  const todoItems = todos

    .filter(todo => !todo.deleted)

    .map(todo => (

      <TodoItem key={todo.id} todo={todo} />

    ));

  

  return <ul>{todoItems}</ul>;

};

```



**3. API Response Processing:**

```javascript

async function getUserStats(userIds) {

  const users = await fetchUsers(userIds);

  

  return users

    .filter(user => user.active)

    .reduce((stats, user) => ({

      totalAge: stats.totalAge + user.age,

      totalSalary: stats.totalSalary + user.salary,

      count: stats.count + 1

    }), { totalAge: 0, totalSalary: 0, count: 0 });

}

```



**Best Practices:**

- Use **map()** for transformations (1-to-1 mapping)

- Use **filter()** for selections (keeping subset)

- Use **reduce()** for aggregations (many-to-one)

- Chain methods for readability, use reduce for performance

- Always provide initial value to reduce for safety

- Consider readability over micro-optimizations

- Use arrow functions for concise callbacks

- Don't mutate original array (all three return new arrays/values)



**Key Takeaways:**

- **map()**: Transform each element → new array (same length)

- **filter()**: Select elements → new array (≤ length)

- **reduce()**: Accumulate to single value → any type

- All are pure functions (don't modify original)

- Can be chained for complex data transformations

- Fundamental to functional programming in JavaScript

- Choose based on desired output: array transformation, subset, or single value





</details>
<details><summary>41. What is the difference between forEach and map?</summary>






**Answer:**

`forEach()` and `map()` are both array iteration methods, but they have fundamentally different purposes: `forEach()` executes a function for each element (side effects), while `map()` transforms elements and returns a new array.



**Quick Comparison:**



| Feature | forEach() | map() |

|---------|-----------|-------|

| **Returns** | `undefined` | New array |

| **Purpose** | Execute side effects | Transform elements |

| **Creates new array** | No | Yes |

| **Chainable** | No | Yes |

| **Use for** | Logging, updating external state | Data transformation |

| **Return value matters** | No | Yes |



**forEach() - Execute Side Effects:**



`forEach()` executes a function for each element but **returns `undefined`**. Used for side effects like logging, updating external state, or DOM manipulation.



```javascript

const numbers = [1, 2, 3, 4, 5];



// forEach returns undefined

const result = numbers.forEach(n => {

  console.log(n * 2);

});



console.log(result); // undefined (no return value!)



// forEach is for side effects

let sum = 0;

numbers.forEach(n => {

  sum += n; // Modifying external variable

});

console.log(sum); // 15



// Common use: logging

numbers.forEach((num, index) => {

  console.log(`Index ${index}: ${num}`);

});



// DOM manipulation

const elements = document.querySelectorAll('.item');

elements.forEach(el => {

  el.classList.add('active'); // Side effect: modifying DOM

});



// Updating external object

const users = [{ name: 'John' }, { name: 'Jane' }];

const userMap = {};

users.forEach(user => {

  userMap[user.name] = user; // Side effect: modifying external object

});

```



**map() - Transform Elements:**



`map()` creates a **new array** with transformed elements. Used for data transformation.



```javascript

const numbers = [1, 2, 3, 4, 5];



// map returns new array

const doubled = numbers.map(n => n * 2);

console.log(doubled); // [2, 4, 6, 8, 10]



// Original array unchanged

console.log(numbers); // [1, 2, 3, 4, 5]



// Transform objects

const users = [

  { firstName: 'John', lastName: 'Doe' },

  { firstName: 'Jane', lastName: 'Smith' }

];



const fullNames = users.map(user => 

  `${user.firstName} ${user.lastName}`

);

console.log(fullNames); // ['John Doe', 'Jane Smith']



// Extract properties

const ids = users.map(user => user.id);



// Add computed properties

const enriched = numbers.map((n, i) => ({

  index: i,

  value: n,

  squared: n ** 2

}));

```



**Side-by-Side Comparison:**



```javascript

const numbers = [1, 2, 3, 4, 5];



// ❌ Wrong: forEach doesn't return new array

const doubled1 = numbers.forEach(n => n * 2);

console.log(doubled1); // undefined



// ✅ Correct: map returns new array

const doubled2 = numbers.map(n => n * 2);

console.log(doubled2); // [2, 4, 6, 8, 10]



// ❌ Wrong: map for side effects (wasteful)

numbers.map(n => {

  console.log(n); // Works but creates unnecessary array

});



// ✅ Correct: forEach for side effects

numbers.forEach(n => {

  console.log(n); // Appropriate use

});

```



**Return Value Behavior:**



```javascript

const numbers = [1, 2, 3];



// forEach: return value in callback is ignored

const forEachResult = numbers.forEach(n => {

  return n * 2; // This return value is ignored!

});

console.log(forEachResult); // undefined



// map: return value in callback is used

const mapResult = numbers.map(n => {

  return n * 2; // This return value creates new array

});

console.log(mapResult); // [2, 4, 6]



// Explicit return required in map (with block body)

const doubled = numbers.map(n => {

  const result = n * 2;

  return result; // Must return!

});



// Implicit return with arrow function

const doubled2 = numbers.map(n => n * 2); // Implicit return

```



**Chaining:**



```javascript

const numbers = [1, 2, 3, 4, 5];



// ✅ map is chainable

const result = numbers

  .map(n => n * 2)

  .filter(n => n > 5)

  .map(n => n + 1);

console.log(result); // [7, 9, 11]



// ❌ forEach is not chainable

// numbers

//   .forEach(n => n * 2)

//   .filter(n => n > 5); // TypeError: Cannot read property 'filter' of undefined



// forEach breaks the chain

numbers

  .map(n => n * 2)

  .forEach(n => console.log(n)); // Chain ends here (returns undefined)

  // .map(n => n + 1); // Can't continue

```



**Performance:**



```javascript

const large = Array.from({ length: 1000000 }, (_, i) => i);



// forEach: slightly faster (no array creation)

console.time('forEach');

let sum1 = 0;

large.forEach(n => {

  sum1 += n;

});

console.timeEnd('forEach'); // ~10ms



// map: creates new array (slower + memory overhead)

console.time('map');

const result = large.map(n => n * 2);

console.timeEnd('map'); // ~30ms



// For side effects only, forEach is more efficient

// For transformations, map is the right choice

```



**Use Cases:**



**Use forEach() when:**



```javascript

// 1. Logging/debugging

const users = [{ name: 'John' }, { name: 'Jane' }];

users.forEach((user, index) => {

  console.log(`${index}: ${user.name}`);

});



// 2. DOM manipulation

const buttons = document.querySelectorAll('button');

buttons.forEach(button => {

  button.addEventListener('click', handleClick);

});



// 3. Updating external state

let total = 0;

const prices = [10, 20, 30];

prices.forEach(price => {

  total += price;

});



// 4. Calling functions with side effects

const callbacks = [fn1, fn2, fn3];

callbacks.forEach(fn => fn());



// 5. Database operations

const ids = [1, 2, 3];

ids.forEach(async id => {

  await database.update(id, { status: 'processed' });

});



// 6. Mutating array elements (careful!)

const objects = [{ count: 0 }, { count: 0 }];

objects.forEach(obj => {

  obj.count++; // Mutating objects

});

```



**Use map() when:**



```javascript

// 1. Transforming data

const numbers = [1, 2, 3];

const doubled = numbers.map(n => n * 2);



// 2. Extracting properties

const users = [{ name: 'John', age: 25 }, { name: 'Jane', age: 30 }];

const names = users.map(u => u.name);



// 3. Converting types

const strings = ['1', '2', '3'];

const numbers = strings.map(Number);



// 4. React component rendering

const TodoList = ({ todos }) => (

  <ul>

    {todos.map(todo => (

      <TodoItem key={todo.id} todo={todo} />

    ))}

  </ul>

);



// 5. API response formatting

const rawData = [{ id: 1, value: 'a' }, { id: 2, value: 'b' }];

const formatted = rawData.map(item => ({

  identifier: item.id,

  content: item.value.toUpperCase()

}));



// 6. Creating derived data

const products = [{ price: 10 }, { price: 20 }];

const withTax = products.map(p => ({

  ...p,

  totalPrice: p.price * 1.1

}));

```



**Common Mistakes:**



**1. Using forEach when map is needed:**

```javascript

const numbers = [1, 2, 3];



// ❌ Wrong: trying to collect results with forEach

const doubled = [];

numbers.forEach(n => {

  doubled.push(n * 2);

});



// ✅ Right: use map

const doubled = numbers.map(n => n * 2);

```



**2. Using map when forEach is needed:**

```javascript

const users = [{ name: 'John' }, { name: 'Jane' }];



// ❌ Wrong: map creates unnecessary array

users.map(user => {

  console.log(user.name); // Just logging, don't need new array

});



// ✅ Right: use forEach for side effects

users.forEach(user => {

  console.log(user.name);

});

```



**3. Forgetting to return in map:**

```javascript

const numbers = [1, 2, 3];



// ❌ Wrong: no return statement

const doubled = numbers.map(n => {

  n * 2; // Missing return!

});

console.log(doubled); // [undefined, undefined, undefined]



// ✅ Right: explicit return

const doubled = numbers.map(n => {

  return n * 2;

});



// ✅ Or use implicit return

const doubled = numbers.map(n => n * 2);

```



**4. Using map result incorrectly:**

```javascript

const numbers = [1, 2, 3];



// ❌ Wrong: ignoring map's return value

numbers.map(n => n * 2); // Creates array but doesn't use it



// ✅ Right: use or store the result

const doubled = numbers.map(n => n * 2);

console.log(doubled);

```



**Breaking Out of Loop:**



```javascript

const numbers = [1, 2, 3, 4, 5];



// ❌ Can't break out of forEach

numbers.forEach(n => {

  if (n === 3) {

    // break; // SyntaxError: Illegal break statement

    return; // Only skips current iteration, doesn't stop loop

  }

  console.log(n); // Logs: 1, 2, 4, 5

});



// ❌ Can't break out of map either

numbers.map(n => {

  if (n === 3) {

    // break; // SyntaxError

  }

  return n * 2;

});



// ✅ Use for loop if you need to break

for (let i = 0; i < numbers.length; i++) {

  if (numbers[i] === 3) {

    break; // Stops loop

  }

  console.log(numbers[i]); // Logs: 1, 2

}



// ✅ Or use some/every to short-circuit

numbers.some(n => {

  console.log(n);

  return n === 3; // Stops when true

}); // Logs: 1, 2, 3

```



**Async Operations:**



```javascript

const ids = [1, 2, 3, 4, 5];



// ❌ forEach doesn't wait for promises

ids.forEach(async id => {

  const data = await fetchData(id);

  console.log(data);

});

// Continues immediately, doesn't wait for fetches



// ✅ Use Promise.all with map for parallel async

const promises = ids.map(id => fetchData(id));

const results = await Promise.all(promises);

console.log(results); // All data



// ✅ Or for...of for sequential async

for (const id of ids) {

  const data = await fetchData(id);

  console.log(data);

}

```



**Production Examples:**



**1. React Component:**

```javascript

// ✅ Use map for rendering

const UserList = ({ users }) => (

  <div>

    {users.map(user => (

      <UserCard key={user.id} user={user} />

    ))}

  </div>

);



// ❌ Don't use forEach for rendering

const BadUserList = ({ users }) => {

  const cards = [];

  users.forEach(user => {

    cards.push(<UserCard key={user.id} user={user} />);

  });

  return <div>{cards}</div>; // Awkward

};

```



**2. Data Processing:**

```javascript

// ✅ Use map for transformation

const processData = (rawData) => {

  return rawData.map(item => ({

    id: item.id,

    name: item.name.toUpperCase(),

    timestamp: Date.now()

  }));

};



// ✅ Use forEach for side effects

const logData = (data) => {

  data.forEach(item => {

    logger.info(`Processing item ${item.id}`);

  });

};

```



**3. Event Handling:**

```javascript

// ✅ Use forEach for adding listeners

const buttons = document.querySelectorAll('.btn');

buttons.forEach(button => {

  button.addEventListener('click', handleClick);

});



// ❌ Don't use map (creates unnecessary array)

const result = buttons.map(button => {

  button.addEventListener('click', handleClick);

}); // result is array of undefined values

```



**Best Practices:**

- Use **map()** when you need transformed data (new array)

- Use **forEach()** when you need side effects (logging, DOM, state updates)

- Don't ignore map's return value

- Don't use map when forEach is sufficient (performance + clarity)

- Always return a value in map callback

- Consider for...of loop if you need to break out

- Use map with Promise.all for async operations

- Chain map for multiple transformations



**Key Takeaways:**

- **forEach()**: Executes function for each element, returns `undefined`

- **map()**: Transforms elements, returns new array

- forEach for side effects, map for transformations

- map is chainable, forEach is not

- Both don't modify original array

- Can't break out of either (use for loop if needed)

- Choose based on whether you need the return value





</details>
<details><summary>42. What are some common array methods?</summary>






**Answer:**

JavaScript arrays have a rich set of built-in methods for manipulation, transformation, and querying. Understanding these methods is essential for effective array handling and functional programming.



**Adding/Removing Elements:**



```javascript

const arr = [1, 2, 3];



// push() - add to end (mutates, returns new length)

const newLength = arr.push(4, 5);

console.log(arr); // [1, 2, 3, 4, 5]

console.log(newLength); // 5



// pop() - remove from end (mutates, returns removed element)

const removed = arr.pop();

console.log(removed); // 5

console.log(arr); // [1, 2, 3, 4]



// unshift() - add to beginning (mutates, returns new length)

arr.unshift(0);

console.log(arr); // [0, 1, 2, 3, 4]



// shift() - remove from beginning (mutates, returns removed element)

const first = arr.shift();

console.log(first); // 0

console.log(arr); // [1, 2, 3, 4]



// splice() - add/remove at any position (mutates, returns removed elements)

arr.splice(2, 1, 'a', 'b'); // At index 2, remove 1, insert 'a', 'b'

console.log(arr); // [1, 2, 'a', 'b', 4]



const removed = arr.splice(1, 2); // Remove 2 elements starting at index 1

console.log(removed); // [2, 'a']

console.log(arr); // [1, 'b', 4]

```



**Searching and Finding:**



```javascript

const numbers = [1, 2, 3, 4, 5, 3];



// indexOf() - first index of element (-1 if not found)

console.log(numbers.indexOf(3)); // 2

console.log(numbers.indexOf(10)); // -1



// lastIndexOf() - last index of element

console.log(numbers.lastIndexOf(3)); // 5



// includes() - boolean check

console.log(numbers.includes(3)); // true

console.log(numbers.includes(10)); // false



// find() - first element matching condition

const found = numbers.find(n => n > 3);

console.log(found); // 4



// findIndex() - index of first match

const index = numbers.findIndex(n => n > 3);

console.log(index); // 3



// findLast() - last element matching condition (ES2023)

const lastFound = numbers.findLast(n => n === 3);

console.log(lastFound); // 3



// findLastIndex() - index of last match (ES2023)

const lastIndex = numbers.findLastIndex(n => n === 3);

console.log(lastIndex); // 5

```



**Testing Arrays:**



```javascript

const numbers = [1, 2, 3, 4, 5];



// some() - at least one element matches

console.log(numbers.some(n => n > 4)); // true

console.log(numbers.some(n => n > 10)); // false



// every() - all elements match

console.log(numbers.every(n => n > 0)); // true

console.log(numbers.every(n => n > 3)); // false



// Array.isArray() - check if value is array

console.log(Array.isArray(numbers)); // true

console.log(Array.isArray('string')); // false

console.log(Array.isArray({ length: 0 })); // false

```



**Transforming Arrays:**



```javascript

const numbers = [1, 2, 3, 4, 5];



// map() - transform each element

const doubled = numbers.map(n => n * 2);

console.log(doubled); // [2, 4, 6, 8, 10]



// filter() - keep elements matching condition

const evens = numbers.filter(n => n % 2 === 0);

console.log(evens); // [2, 4]



// reduce() - accumulate to single value

const sum = numbers.reduce((acc, n) => acc + n, 0);

console.log(sum); // 15



// reduceRight() - reduce from right to left

const arr = [1, 2, 3, 4];

const result = arr.reduceRight((acc, n) => acc + n, 0);

console.log(result); // 10 (same sum, but processed right to left)



// flat() - flatten nested arrays

const nested = [1, [2, 3], [4, [5, 6]]];

console.log(nested.flat()); // [1, 2, 3, 4, [5, 6]] (1 level)

console.log(nested.flat(2)); // [1, 2, 3, 4, 5, 6] (2 levels)

console.log(nested.flat(Infinity)); // [1, 2, 3, 4, 5, 6] (all levels)



// flatMap() - map then flatten one level

const words = ['hello world', 'foo bar'];

const letters = words.flatMap(word => word.split(' '));

console.log(letters); // ['hello', 'world', 'foo', 'bar']

```



**Extracting Portions:**



```javascript

const arr = [1, 2, 3, 4, 5];



// slice() - extract portion (doesn't mutate)

console.log(arr.slice(1, 4)); // [2, 3, 4]

console.log(arr.slice(2)); // [3, 4, 5] (from index to end)

console.log(arr.slice(-2)); // [4, 5] (last 2 elements)

console.log(arr.slice()); // [1, 2, 3, 4, 5] (shallow copy)



// at() - get element at index (supports negative)

console.log(arr.at(0)); // 1

console.log(arr.at(-1)); // 5 (last element)

console.log(arr.at(-2)); // 4 (second to last)

```



**Joining and Concatenating:**



```javascript

const arr1 = [1, 2, 3];

const arr2 = [4, 5, 6];



// concat() - merge arrays (doesn't mutate)

const merged = arr1.concat(arr2);

console.log(merged); // [1, 2, 3, 4, 5, 6]



// Can concatenate multiple arrays

const arr3 = [7, 8];

const merged2 = arr1.concat(arr2, arr3);

console.log(merged2); // [1, 2, 3, 4, 5, 6, 7, 8]



// join() - array to string

const words = ['Hello', 'World'];

console.log(words.join(' ')); // 'Hello World'

console.log(words.join('-')); // 'Hello-World'

console.log(words.join('')); // 'HelloWorld'

console.log(words.join()); // 'Hello,World' (default separator is comma)

```



**Sorting and Reversing:**



```javascript

const numbers = [3, 1, 4, 1, 5, 9, 2, 6];



// sort() - sorts in place (⚠️ converts to strings by default)

numbers.sort();

console.log(numbers); // [1, 1, 2, 3, 4, 5, 6, 9]



// Numeric sort

const nums = [1, 10, 2, 20, 3, 30];

nums.sort(); // ⚠️ [1, 10, 2, 20, 3, 30] (lexicographic!)

nums.sort((a, b) => a - b); // ✅ [1, 2, 3, 10, 20, 30]



// Descending sort

nums.sort((a, b) => b - a);



// Sort objects

const people = [

  { name: 'John', age: 30 },

  { name: 'Jane', age: 25 },

  { name: 'Bob', age: 35 }

];

people.sort((a, b) => a.age - b.age);



// reverse() - reverses in place

const arr = [1, 2, 3, 4, 5];

arr.reverse();

console.log(arr); // [5, 4, 3, 2, 1]



// toSorted() - returns sorted copy (ES2023, doesn't mutate)

const original = [3, 1, 2];

const sorted = original.toSorted();

console.log(original); // [3, 1, 2] (unchanged)

console.log(sorted); // [1, 2, 3]



// toReversed() - returns reversed copy (ES2023)

const reversed = original.toReversed();

console.log(reversed); // [2, 1, 3]

```



**Iterating:**



```javascript

const arr = ['a', 'b', 'c'];



// forEach() - execute function for each element

arr.forEach((value, index) => {

  console.log(`${index}: ${value}`);

});



// entries() - iterator of [index, value] pairs

for (const [index, value] of arr.entries()) {

  console.log(index, value);

}



// keys() - iterator of indices

for (const index of arr.keys()) {

  console.log(index); // 0, 1, 2

}



// values() - iterator of values

for (const value of arr.values()) {

  console.log(value); // 'a', 'b', 'c'

}

```



**Filling and Copying:**



```javascript

// fill() - fill with static value (mutates)

const arr1 = [1, 2, 3, 4, 5];

arr1.fill(0);

console.log(arr1); // [0, 0, 0, 0, 0]



const arr2 = [1, 2, 3, 4, 5];

arr2.fill(0, 2, 4); // Fill from index 2 to 4 (exclusive)

console.log(arr2); // [1, 2, 0, 0, 5]



// copyWithin() - copy part of array to another location (mutates)

const arr3 = [1, 2, 3, 4, 5];

arr3.copyWithin(0, 3); // Copy from index 3 to index 0

console.log(arr3); // [4, 5, 3, 4, 5]



const arr4 = [1, 2, 3, 4, 5];

arr4.copyWithin(0, 3, 4); // Copy index 3-4 to index 0

console.log(arr4); // [4, 2, 3, 4, 5]



// with() - returns copy with element replaced (ES2023)

const arr5 = [1, 2, 3, 4, 5];

const modified = arr5.with(2, 99);

console.log(arr5); // [1, 2, 3, 4, 5] (unchanged)

console.log(modified); // [1, 2, 99, 4, 5]

```



**Static Methods:**



```javascript

// Array.isArray() - check if value is array

console.log(Array.isArray([1, 2, 3])); // true

console.log(Array.isArray('string')); // false



// Array.from() - create array from iterable/array-like

console.log(Array.from('hello')); // ['h', 'e', 'l', 'l', 'o']

console.log(Array.from({ length: 3 }, (_, i) => i)); // [0, 1, 2]

console.log(Array.from(new Set([1, 2, 2, 3]))); // [1, 2, 3]



// Array.of() - create array from arguments

console.log(Array.of(1, 2, 3)); // [1, 2, 3]

console.log(Array.of(5)); // [5] (not empty array with length 5)

console.log(new Array(5)); // [ <5 empty items> ]

```



**Converting to String:**



```javascript

const arr = [1, 2, 3];



// toString() - convert to comma-separated string

console.log(arr.toString()); // '1,2,3'



// toLocaleString() - localized string representation

const numbers = [1000, 2000, 3000];

console.log(numbers.toLocaleString('en-US')); // '1,000, 2,000, 3,000'



const dates = [new Date('2024-01-01'), new Date('2024-12-31')];

console.log(dates.toLocaleString('en-US'));

```



**Method Categories:**



**Mutating Methods (modify original):**

```javascript

const arr = [1, 2, 3];



arr.push(4);        // [1, 2, 3, 4]

arr.pop();          // [1, 2, 3]

arr.shift();        // [2, 3]

arr.unshift(1);     // [1, 2, 3]

arr.splice(1, 1);   // [1, 3]

arr.sort();         // [1, 3]

arr.reverse();      // [3, 1]

arr.fill(0);        // [0, 0]

arr.copyWithin(0, 1); // [0, 0]

```



**Non-Mutating Methods (return new array/value):**

```javascript

const arr = [1, 2, 3];



arr.slice(1);       // [2, 3]

arr.concat([4]);    // [1, 2, 3, 4]

arr.map(n => n * 2); // [2, 4, 6]

arr.filter(n => n > 1); // [2, 3]

arr.flat();         // [1, 2, 3]

arr.flatMap(n => [n, n]); // [1, 1, 2, 2, 3, 3]

arr.toSorted();     // [1, 2, 3]

arr.toReversed();   // [3, 2, 1]

arr.with(0, 99);    // [99, 2, 3]



console.log(arr);   // [1, 2, 3] (unchanged)

```



**Common Patterns:**



**1. Remove duplicates:**

```javascript

const arr = [1, 2, 2, 3, 3, 4];



// Using Set

const unique1 = [...new Set(arr)];



// Using filter

const unique2 = arr.filter((item, index) => arr.indexOf(item) === index);

```



**2. Flatten deeply nested array:**

```javascript

const nested = [1, [2, [3, [4]]]];

const flat = nested.flat(Infinity);

```



**3. Create range of numbers:**

```javascript

const range = Array.from({ length: 10 }, (_, i) => i + 1);

// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```



**4. Group by property:**

```javascript

const people = [

  { name: 'John', age: 25 },

  { name: 'Jane', age: 30 },

  { name: 'Bob', age: 25 }

];



const grouped = people.reduce((acc, person) => {

  const age = person.age;

  if (!acc[age]) acc[age] = [];

  acc[age].push(person);

  return acc;

}, {});

```



**5. Chunk array:**

```javascript

function chunk(arr, size) {

  return Array.from(

    { length: Math.ceil(arr.length / size) },

    (_, i) => arr.slice(i * size, i * size + size)

  );

}



console.log(chunk([1, 2, 3, 4, 5, 6, 7], 3));

// [[1, 2, 3], [4, 5, 6], [7]]

```



**Best Practices:**

- Prefer non-mutating methods for immutability

- Use appropriate method for the task (don't use map for side effects)

- Always provide comparator function to sort() for numbers

- Use Array.isArray() to check for arrays, not typeof

- Chain methods for readable data transformations

- Consider performance with large arrays

- Use ES2023 methods (toSorted, with) for immutability



**Key Takeaways:**

- JavaScript arrays have 30+ built-in methods

- Methods fall into categories: mutating vs non-mutating

- Common operations: add/remove, search, transform, test, sort

- Understanding methods enables functional programming patterns

- Choose based on whether you want to mutate or create new array

- Method chaining creates readable data pipelines

- Essential for effective JavaScript development





</details>
<details><summary>43. How do you check if a variable is an array?</summary>






**Answer:**

The recommended way to check if a variable is an array is using `Array.isArray()`. While other methods exist, they have limitations and edge cases that make them unreliable.



**Best Method: Array.isArray():**



```javascript

const arr = [1, 2, 3];

const obj = { 0: 1, 1: 2, 2: 3, length: 3 };

const str = 'hello';



// ✅ Most reliable method

console.log(Array.isArray(arr));  // true

console.log(Array.isArray(obj));  // false

console.log(Array.isArray(str));  // false



// Works across different execution contexts (iframes)

// Works with all array types

console.log(Array.isArray([]));                // true

console.log(Array.isArray(new Array(5)));      // true

console.log(Array.isArray(Array.from('hi')));  // true



// Typed arrays are NOT regular arrays

console.log(Array.isArray(new Int8Array()));   // false

```



**Why Array.isArray() is Best:**



```javascript

// 1. Works across different execution contexts

const iframe = document.createElement('iframe');

document.body.appendChild(iframe);

const arrFromIframe = new iframe.contentWindow.Array(1, 2, 3);



console.log(Array.isArray(arrFromIframe));      // true ✅

console.log(arrFromIframe instanceof Array);    // false ❌



// 2. Handles edge cases correctly

console.log(Array.isArray(Array.prototype));    // true

console.log(Array.isArray({ __proto__: Array.prototype })); // false

```



**Alternative Methods (Not Recommended):**



**1. typeof (Doesn't Work):**

```javascript

const arr = [1, 2, 3];

console.log(typeof arr); // 'object' (not helpful!)

console.log(typeof {});  // 'object' (same!)

```



**2. instanceof Array (Has Issues):**

```javascript

const arr = [1, 2, 3];

console.log(arr instanceof Array); // true



// ❌ Fails across different contexts

// ❌ Can be fooled by prototype manipulation

const fakeArray = { __proto__: Array.prototype };

console.log(fakeArray instanceof Array); // true (but not an array!)

console.log(Array.isArray(fakeArray));   // false ✅

```



**Array-Like Objects (Not Arrays):**



```javascript

// Arguments object

function test() {

  console.log(Array.isArray(arguments)); // false

  const argsArray = Array.from(arguments);

  console.log(Array.isArray(argsArray)); // true

}



// NodeList

const divs = document.querySelectorAll('div');

console.log(Array.isArray(divs)); // false



// Convert to array

const divsArray = Array.from(divs);

console.log(Array.isArray(divsArray)); // true

```



**Practical Use Cases:**



```javascript

// 1. Function parameter validation

function processItems(items) {

  if (!Array.isArray(items)) {

    throw new TypeError('Expected an array');

  }

  return items.map(item => item * 2);

}



// 2. Normalize input

function toArray(input) {

  return Array.isArray(input) ? input : [input];

}



console.log(toArray([1, 2, 3])); // [1, 2, 3]

console.log(toArray(5));         // [5]



// 3. Safe array operations

function safeMap(array, fn) {

  if (!Array.isArray(array)) {

    console.warn('Expected array');

    return [];

  }

  return array.map(fn);

}

```



**Best Practices:**

- **Always use `Array.isArray()`** for checking arrays

- Don't rely on `typeof`, `instanceof`, or `constructor`

- Be aware of array-like objects (arguments, NodeList, etc.)

- Convert array-like objects with `Array.from()` or spread operator

- Validate array inputs in functions



**Key Takeaways:**

- `Array.isArray()` is the only reliable method

- `typeof` returns 'object' (not helpful)

- `instanceof` fails across execution contexts

- Array-like objects are not arrays

- Essential for safe array operations and validation





</details>
<details><summary>44. What is the difference between slice() and splice()?</summary>






**Answer:**

`slice()` and `splice()` both extract portions of arrays, but have fundamentally different behaviors: `slice()` creates a shallow copy without modifying the original, while `splice()` modifies the original array in place.



**Quick Comparison:**



| Feature | slice() | splice() |

|---------|---------|----------|

| **Modifies original** | No (immutable) | Yes (mutates) |

| **Returns** | New array | Array of removed elements |

| **Purpose** | Extract/copy | Add/remove/replace |

| **Parameters** | (start, end) | (start, deleteCount, ...items) |

| **Can add items** | No | Yes |



**slice() - Extract Without Modifying:**



**Syntax:** `array.slice(start, end)`



```javascript

const arr = [1, 2, 3, 4, 5];



// Extract from index 1 to 4 (end is exclusive)

const portion = arr.slice(1, 4);

console.log(portion); // [2, 3, 4]

console.log(arr);     // [1, 2, 3, 4, 5] (unchanged!)



// From index to end

console.log(arr.slice(2)); // [3, 4, 5]



// Negative indices (from end)

console.log(arr.slice(-2));     // [4, 5]

console.log(arr.slice(-3, -1)); // [3, 4]



// Copy entire array

const copy = arr.slice();

console.log(copy === arr); // false (different reference)

```



**splice() - Modify Original Array:**



**Syntax:** `array.splice(start, deleteCount, item1, item2, ...)`



```javascript

const arr = [1, 2, 3, 4, 5];



// Remove 2 elements starting at index 1

const removed = arr.splice(1, 2);

console.log(removed); // [2, 3]

console.log(arr);     // [1, 4, 5] (modified!)



// Remove and insert

const arr2 = [1, 2, 3, 4, 5];

arr2.splice(2, 1, 'a', 'b');

console.log(arr2); // [1, 2, 'a', 'b', 4, 5]



// Insert without removing

const arr3 = [1, 2, 3];

arr3.splice(1, 0, 'x');

console.log(arr3); // [1, 'x', 2, 3]

```



**Detailed Comparison:**



```javascript

const original = [1, 2, 3, 4, 5];



// slice - doesn't modify

const sliced = original.slice(1, 3);

console.log(original); // [1, 2, 3, 4, 5] (unchanged)

console.log(sliced);   // [2, 3]



// splice - modifies

const arr2 = [1, 2, 3, 4, 5];

const spliced = arr2.splice(1, 2);

console.log(arr2);     // [1, 4, 5] (modified!)

console.log(spliced);  // [2, 3]

```



**Common Use Cases:**



**slice() Use Cases:**

```javascript

// 1. Copy array

const copy = arr.slice();



// 2. Get last N elements

const lastThree = arr.slice(-3);



// 3. Pagination

function paginate(array, pageSize, pageNumber) {

  const start = (pageNumber - 1) * pageSize;

  return array.slice(start, start + pageSize);

}

```



**splice() Use Cases:**

```javascript

// 1. Remove elements

arr.splice(2, 1); // Remove 1 at index 2



// 2. Insert elements

arr.splice(2, 0, 'x', 'y'); // Insert at index 2



// 3. Replace elements

arr.splice(1, 2, 'a', 'b'); // Replace 2 elements

```



**Immutability:**



```javascript

// slice is safe for immutability

const state = [1, 2, 3, 4, 5];

const newState = state.slice(1, 4);

// state unchanged



// splice breaks immutability

state.splice(1, 2); // Mutates state!



// Immutable alternative

const immutableSplice = (arr, start, del, ...items) => [

  ...arr.slice(0, start),

  ...items,

  ...arr.slice(start + del)

];

```



**Best Practices:**

- Use **slice()** for immutability (React, Redux)

- Use **splice()** for in-place modifications

- Remember: **slice** = **s**afe, **splice** = **sp**ecial

- Always assign slice() result

- Consider toSpliced() (ES2023) for immutable splice



**Key Takeaways:**

- **slice()**: Extracts, returns new array, immutable

- **splice()**: Modifies in place, can add/remove/replace

- slice is safe, splice mutates

- Critical for frameworks relying on immutability





</details>
<details><summary>45. What is array destructuring?</summary>






**Answer:**

Array destructuring is a JavaScript expression that unpacks values from arrays into distinct variables using convenient shorthand syntax, introduced in ES6.



**Basic Syntax:**



```javascript

// Traditional way

const arr = [1, 2, 3];

const first = arr[0];

const second = arr[1];



// ✅ Destructuring (cleaner)

const [first, second, third] = [1, 2, 3];

console.log(first);  // 1

console.log(second); // 2

console.log(third);  // 3

```



**Basic Destructuring:**



```javascript

const colors = ['red', 'green', 'blue'];



// Extract values

const [primary, secondary] = colors;

console.log(primary);   // 'red'

console.log(secondary); // 'green'



// More variables than array → undefined

const [a, b, c, d] = ['x', 'y', 'z'];

console.log(d); // undefined



// Fewer variables → extras ignored

const [first] = [1, 2, 3, 4, 5];

console.log(first); // 1

```



**Skipping Elements:**



```javascript

const arr = [1, 2, 3, 4, 5];



// Skip with empty slots

const [first, , third] = arr;

console.log(first); // 1

console.log(third); // 3



// Get first and last

const [head, , , , tail] = arr;

console.log(head); // 1

console.log(tail); // 5

```



**Rest Pattern (...):**



```javascript

const numbers = [1, 2, 3, 4, 5];



// Collect remaining elements

const [first, ...rest] = numbers;

console.log(first); // 1

console.log(rest);  // [2, 3, 4, 5]



// Get first two and rest

const [a, b, ...remaining] = numbers;

console.log(remaining); // [3, 4, 5]



// Rest must be last

// const [...rest, last] = arr; // ❌ SyntaxError

```



**Default Values:**



```javascript

// Without defaults

const [a, b, c] = [1, 2];

console.log(c); // undefined



// With defaults

const [x, y, z = 3] = [1, 2];

console.log(z); // 3 (default used)



// Default only for undefined

const [m, n = 10] = [5, null];

console.log(n); // null (not undefined, default not used)

```



**Nested Destructuring:**



```javascript

const nested = [1, [2, 3], 4];

const [a, [b, c], d] = nested;

console.log(a); // 1

console.log(b); // 2

console.log(c); // 3

console.log(d); // 4



// Deeply nested

const deep = [1, [2, [3, 4]]];

const [x, [y, [z, w]]] = deep;

console.log(z); // 3

```



**Swapping Variables:**



```javascript

// Traditional swap

let a = 1, b = 2;

let temp = a;

a = b;

b = temp;



// ✅ Destructuring swap (elegant)

let x = 1, y = 2;

[x, y] = [y, x];

console.log(x, y); // 2, 1

```



**Function Return Values:**



```javascript

function getCoordinates() {

  return [10, 20];

}



const [x, y] = getCoordinates();

console.log(x); // 10

console.log(y); // 20



// Ignore some values

function getStats() {

  return [10, 20, 30, 40];

}



const [count, , total] = getStats();

console.log(count); // 10

console.log(total); // 30

```



**Function Parameters:**



```javascript

// Destructure parameters

function sum([a, b]) {

  return a + b;

}



console.log(sum([3, 5])); // 8



// With defaults

function process([x, y = 0]) {

  return x + y;

}



console.log(process([1]));    // 1

console.log(process([1, 2])); // 3

```



**Iterating with Destructuring:**



```javascript

const pairs = [[1, 'one'], [2, 'two']];



// Destructure in for...of

for (const [num, word] of pairs) {

  console.log(`${num}: ${word}`);

}



// Object.entries()

const obj = { a: 1, b: 2 };

for (const [key, value] of Object.entries(obj)) {

  console.log(`${key}: ${value}`);

}

```



**Practical Use Cases:**



**1. React Hooks:**

```javascript

const [count, setCount] = useState(0);

const [state, dispatch] = useReducer(reducer, initialState);

```



**2. Promise.all:**

```javascript

const [users, posts] = await Promise.all([

  fetchUsers(),

  fetchPosts()

]);

```



**3. CSV Parsing:**

```javascript

const csv = 'John,Doe,30';

const [firstName, lastName, age] = csv.split(',');

```



**4. Regular Expressions:**

```javascript

const dateStr = '2024-01-15';

const [, year, month, day] = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);

console.log(year); // '2024'

```



**Common Pitfalls:**



```javascript

// 1. Undefined values

const [a, b, c] = [1, 2]; // c is undefined

// Use defaults: const [a, b, c = 0] = [1, 2];



// 2. Rest must be last

// const [...rest, last] = [1, 2, 3]; // ❌ SyntaxError



// 3. Can't destructure null/undefined

// const [a] = null; // ❌ TypeError

const [a] = arr || []; // ✅ Safe

```



**Best Practices:**

- Use for cleaner code when extracting array values

- Provide defaults for potentially undefined values

- Use rest pattern for remaining elements

- Skip unwanted elements with empty slots

- Great for React hooks, Promise.all, multi-returns

- Don't over-nest for readability



**Key Takeaways:**

- Unpacks array values into variables

- Syntax: `const [a, b] = array`

- Can skip elements, use defaults, rest pattern

- Works with any iterable

- Enables elegant variable swapping

- Essential in modern JavaScript and React

- Part of ES6, widely supported





</details>
<details><summary>46. What is the spread operator?</summary>






**Answer:**

The spread operator (`...`) is an ES6 feature that expands (spreads) an iterable (like an array, string, or object) into individual elements. It's used for copying, merging, and passing elements as function arguments.



**Syntax:** `...iterable`



**Array Spreading:**



```javascript

const arr = [1, 2, 3];



// Spread array elements

console.log(...arr); // 1 2 3 (individual arguments)

console.log([...arr]); // [1, 2, 3] (new array)



// Copy array (shallow)

const original = [1, 2, 3];

const copy = [...original];

console.log(copy); // [1, 2, 3]

console.log(copy === original); // false (different reference)



// Concatenate arrays

const arr1 = [1, 2];

const arr2 = [3, 4];

const merged = [...arr1, ...arr2];

console.log(merged); // [1, 2, 3, 4]



// Add elements while spreading

const numbers = [2, 3, 4];

const extended = [1, ...numbers, 5];

console.log(extended); // [1, 2, 3, 4, 5]



// Spread in any position

const middle = [0, ...numbers, 5, 6];

console.log(middle); // [0, 2, 3, 4, 5, 6]

```



**Object Spreading (ES2018):**



```javascript

const obj = { a: 1, b: 2 };



// Copy object (shallow)

const copy = { ...obj };

console.log(copy); // { a: 1, b: 2 }

console.log(copy === obj); // false



// Merge objects

const obj1 = { a: 1, b: 2 };

const obj2 = { c: 3, d: 4 };

const merged = { ...obj1, ...obj2 };

console.log(merged); // { a: 1, b: 2, c: 3, d: 4 }



// Override properties (last wins)

const defaults = { theme: 'light', lang: 'en' };

const userSettings = { theme: 'dark' };

const settings = { ...defaults, ...userSettings };

console.log(settings); // { theme: 'dark', lang: 'en' }



// Add new properties

const user = { name: 'John' };

const extendedUser = { ...user, age: 30, email: 'john@example.com' };

console.log(extendedUser); // { name: 'John', age: 30, email: 'john@example.com' }

```



**String Spreading:**



```javascript

const str = 'hello';



// Spread into array

const chars = [...str];

console.log(chars); // ['h', 'e', 'l', 'l', 'o']



// Combine with other elements

const letters = ['a', ...str, 'z'];

console.log(letters); // ['a', 'h', 'e', 'l', 'l', 'o', 'z']



// Create array from string

const word = [...'JavaScript'];

console.log(word); // ['J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't']

```



**Function Arguments:**



```javascript

function sum(a, b, c) {

  return a + b + c;

}



const numbers = [1, 2, 3];



// Without spread (old way)

sum.apply(null, numbers); // 6



// ✅ With spread (clean)

sum(...numbers); // 6



// Math functions

const nums = [5, 2, 8, 1, 9];

console.log(Math.max(...nums)); // 9

console.log(Math.min(...nums)); // 1



// Variable number of arguments

function greet(greeting, ...names) {

  return `${greeting} ${names.join(', ')}!`;

}



console.log(greet('Hello', 'John', 'Jane', 'Bob')); // 'Hello John, Jane, Bob!'

```



**Set and Map Spreading:**



```javascript

// Set to array

const set = new Set([1, 2, 3, 2, 1]);

const arr = [...set];

console.log(arr); // [1, 2, 3] (duplicates removed)



// Map to array

const map = new Map([['a', 1], ['b', 2]]);

const entries = [...map];

console.log(entries); // [['a', 1], ['b', 2]]



const keys = [...map.keys()];

console.log(keys); // ['a', 'b']



const values = [...map.values()];

console.log(values); // [1, 2]

```



**Copying vs Reference:**



```javascript

// Primitives - copied

const arr1 = [1, 2, 3];

const arr2 = [...arr1];

arr2[0] = 99;

console.log(arr1[0]); // 1 (unchanged)



// ⚠️ Shallow copy - nested objects are references

const nested = [1, [2, 3]];

const copy = [...nested];

copy[1][0] = 99;

console.log(nested[1][0]); // 99 (changed! shared reference)



// Deep copy needed for nested structures

const deepCopy = JSON.parse(JSON.stringify(nested));

// or use structuredClone()

const deepCopy2 = structuredClone(nested);

```



**Practical Use Cases:**



**1. Cloning Arrays/Objects:**

```javascript

// Array clone

const original = [1, 2, 3, 4, 5];

const clone = [...original];



// Object clone

const user = { name: 'John', age: 30 };

const userCopy = { ...user };



// Prevent mutation

function processArray(arr) {

  const safeCopy = [...arr];

  safeCopy.sort();

  return safeCopy;

}



const numbers = [3, 1, 2];

processArray(numbers);

console.log(numbers); // [3, 1, 2] (original unchanged)

```



**2. Merging Arrays:**

```javascript

const fruits = ['apple', 'banana'];

const vegetables = ['carrot', 'spinach'];

const food = [...fruits, ...vegetables];

console.log(food); // ['apple', 'banana', 'carrot', 'spinach']



// Multiple arrays

const arr1 = [1, 2];

const arr2 = [3, 4];

const arr3 = [5, 6];

const merged = [...arr1, ...arr2, ...arr3];

console.log(merged); // [1, 2, 3, 4, 5, 6]



// Alternative to concat

// Old: arr1.concat(arr2)

// New: [...arr1, ...arr2]

```



**3. Merging Objects:**

```javascript

const defaults = {

  theme: 'light',

  lang: 'en',

  notifications: true

};



const userPrefs = {

  theme: 'dark',

  fontSize: 14

};



const config = { ...defaults, ...userPrefs };

console.log(config);

// {

//   theme: 'dark',      // overridden

//   lang: 'en',         // from defaults

//   notifications: true, // from defaults

//   fontSize: 14        // from userPrefs

// }

```



**4. Adding/Updating Object Properties:**

```javascript

const user = { name: 'John', age: 30 };



// Add property

const withEmail = { ...user, email: 'john@example.com' };



// Update property

const olderUser = { ...user, age: 31 };



// Conditional property

const isAdmin = true;

const userWithRole = {

  ...user,

  ...(isAdmin && { role: 'admin' })

};

console.log(userWithRole); // { name: 'John', age: 30, role: 'admin' }

```



**5. React State Updates:**

```javascript

// Array state

const [items, setItems] = useState([1, 2, 3]);



// Add item immutably

setItems([...items, 4]);



// Remove item immutably

setItems(items.filter(item => item !== 2));



// Object state

const [user, setUser] = useState({ name: 'John', age: 30 });



// Update property immutably

setUser({ ...user, age: 31 });



// Nested state update

const [data, setData] = useState({

  user: { name: 'John', address: { city: 'NY' } }

});



setData({

  ...data,

  user: {

    ...data.user,

    address: {

      ...data.user.address,

      city: 'LA'

    }

  }

});

```



**6. Function Arguments:**

```javascript

// Pass array elements as arguments

const point = [10, 20];

const canvas = { moveTo: (x, y) => console.log(`Moving to ${x}, ${y}`) };

canvas.moveTo(...point); // Moving to 10, 20



// Creating Date with array

const dateComponents = [2024, 0, 15]; // Year, Month (0-indexed), Day

const date = new Date(...dateComponents);

console.log(date); // Mon Jan 15 2024

```



**7. Removing Duplicates:**

```javascript

const numbers = [1, 2, 2, 3, 3, 4, 5, 5];

const unique = [...new Set(numbers)];

console.log(unique); // [1, 2, 3, 4, 5]



// With objects (by property)

const users = [

  { id: 1, name: 'John' },

  { id: 2, name: 'Jane' },

  { id: 1, name: 'John' }

];



const uniqueUsers = [...new Map(users.map(u => [u.id, u])).values()];

console.log(uniqueUsers); // [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]

```



**8. Converting Iterables to Arrays:**

```javascript

// NodeList to Array

const divs = document.querySelectorAll('div');

const divsArray = [...divs];

divsArray.forEach(div => div.classList.add('active'));



// Arguments to Array

function myFunction() {

  const args = [...arguments];

  return args.map(arg => arg * 2);

}



// String to Array

const chars = [...'hello'];

console.log(chars); // ['h', 'e', 'l', 'l', 'o']

```



**Spread vs Rest:**



```javascript

// Spread - expands array/object

const arr = [1, 2, 3];

console.log(...arr); // 1 2 3 (spread)

const copy = [...arr]; // [1, 2, 3]



// Rest - collects into array

function sum(...numbers) { // rest parameter

  return numbers.reduce((a, b) => a + b, 0);

}

console.log(sum(1, 2, 3, 4)); // 10



// Array destructuring with rest

const [first, ...rest] = [1, 2, 3, 4];

console.log(first); // 1

console.log(rest); // [2, 3, 4]



// Object destructuring with rest

const { name, ...others } = { name: 'John', age: 30, city: 'NY' };

console.log(name); // 'John'

console.log(others); // { age: 30, city: 'NY' }

```



**Comparison with Other Methods:**



```javascript

// Concatenating arrays

const arr1 = [1, 2];

const arr2 = [3, 4];



// concat()

const merged1 = arr1.concat(arr2);



// Spread (cleaner)

const merged2 = [...arr1, ...arr2];



// Copying arrays

const original = [1, 2, 3];



// slice()

const copy1 = original.slice();



// Spread (more intuitive)

const copy2 = [...original];



// Copying objects

const obj = { a: 1, b: 2 };



// Object.assign()

const copy1 = Object.assign({}, obj);



// Spread (cleaner)

const copy2 = { ...obj };

```



**Performance Considerations:**



```javascript

const large = Array.from({ length: 100000 }, (_, i) => i);



// Spread is fast but creates new array

console.time('spread');

const copy = [...large];

console.timeEnd('spread'); // ~2ms



// For very large arrays, consider alternatives

console.time('slice');

const copy2 = large.slice();

console.timeEnd('slice'); // ~1ms (slightly faster)



// For simple cases, spread is fine and more readable

```



**Common Mistakes:**



**1. Assuming deep copy:**

```javascript

const nested = { a: 1, b: { c: 2 } };

const copy = { ...nested };



copy.b.c = 99;

console.log(nested.b.c); // 99 (shared reference!)



// Need deep copy

const deepCopy = structuredClone(nested);

```



**2. Order matters in object spread:**

```javascript

const obj1 = { a: 1, b: 2 };

const obj2 = { b: 3, c: 4 };



const merged1 = { ...obj1, ...obj2 };

console.log(merged1); // { a: 1, b: 3, c: 4 } (obj2.b wins)



const merged2 = { ...obj2, ...obj1 };

console.log(merged2); // { b: 2, c: 4, a: 1 } (obj1.b wins)

```



**3. Spreading non-iterables:**

```javascript

const num = 42;

// [...num]; // ❌ TypeError: num is not iterable



const obj = { a: 1 };

// [...obj]; // ❌ TypeError: obj is not iterable



// Objects need object spread

const objCopy = { ...obj }; // ✅ Works

```



**Browser Support:**



```javascript

// Array/String spread - ES6 (2015), widely supported

const arr = [...[1, 2, 3]];



// Object spread - ES2018, modern browsers

const obj = { ...{ a: 1, b: 2 } };



// Polyfills available for older environments

```



**Best Practices:**

- Use spread for **immutable operations** (don't mutate originals)

- Prefer spread over `.concat()` and `Object.assign()` for readability

- Remember spread creates **shallow copies**

- Use `structuredClone()` or libraries for deep copying

- Leverage spread for **cleaner React state updates**

- Combine with destructuring for powerful patterns

- Be aware of performance with very large arrays

- Order matters when spreading objects



**Key Takeaways:**

- Spread operator (`...`) expands iterables into individual elements

- Works with arrays, objects, strings, Sets, Maps, etc.

- Creates shallow copies (nested objects are references)

- Cleaner than `concat()`, `Object.assign()`, `apply()`

- Essential for immutable operations in React/Redux

- Different from rest operator (same syntax, opposite purpose)

- Introduced in ES6 (arrays) and ES2018 (objects)

- Fundamental tool for modern JavaScript development





</details>
<details><summary>47. How do you remove duplicates from an array?</summary>






**Answer:**

There are multiple ways to remove duplicates from an array in JavaScript, with the Set approach being the most common and efficient for simple cases.



**1. Using Set (Most Common):**



```javascript

const numbers = [1, 2, 2, 3, 3, 4, 5, 5];



// ✅ Simplest and most efficient

const unique = [...new Set(numbers)];

console.log(unique); // [1, 2, 3, 4, 5]



// Alternative: Array.from()

const unique2 = Array.from(new Set(numbers));

console.log(unique2); // [1, 2, 3, 4, 5]



// Works with any type

const strings = ['a', 'b', 'a', 'c', 'b'];

const uniqueStrings = [...new Set(strings)];

console.log(uniqueStrings); // ['a', 'b', 'c']

```



**How Set Works:**



```javascript

// Set only keeps unique values

const set = new Set([1, 2, 2, 3, 3, 4]);

console.log(set); // Set(4) { 1, 2, 3, 4 }



// Convert back to array

const array = [...set];

console.log(array); // [1, 2, 3, 4]



// Size property

console.log(set.size); // 4



// Check for value

console.log(set.has(2)); // true

```



**2. Using filter() with indexOf():**



```javascript

const numbers = [1, 2, 2, 3, 3, 4, 5, 5];



const unique = numbers.filter((item, index) => {

  return numbers.indexOf(item) === index;

});



console.log(unique); // [1, 2, 3, 4, 5]



// One-liner

const unique2 = numbers.filter((item, i) => numbers.indexOf(item) === i);

```



**How indexOf() Method Works:**



```javascript

// indexOf returns first occurrence

const arr = [1, 2, 2, 3];



console.log(arr.indexOf(1)); // 0 (first occurrence at index 0)

console.log(arr.indexOf(2)); // 1 (first occurrence at index 1)



// For duplicates, indexOf always returns first position

// At index 1: arr.indexOf(2) === 1 → true (keep)

// At index 2: arr.indexOf(2) === 1 → false (remove)

```



**3. Using reduce():**



```javascript

const numbers = [1, 2, 2, 3, 3, 4, 5, 5];



const unique = numbers.reduce((acc, current) => {

  if (!acc.includes(current)) {

    acc.push(current);

  }

  return acc;

}, []);



console.log(unique); // [1, 2, 3, 4, 5]



// More concise

const unique2 = numbers.reduce((acc, curr) => 

  acc.includes(curr) ? acc : [...acc, curr], []

);

```



**4. Using forEach() with Object/Set:**



```javascript

const numbers = [1, 2, 2, 3, 3, 4, 5, 5];



// Using Set

const unique = [];

const seen = new Set();



numbers.forEach(num => {

  if (!seen.has(num)) {

    seen.add(num);

    unique.push(num);

  }

});



console.log(unique); // [1, 2, 3, 4, 5]



// Using Object

const unique2 = [];

const obj = {};



numbers.forEach(num => {

  if (!obj[num]) {

    obj[num] = true;

    unique2.push(num);

  }

});

```



**Removing Duplicates from Arrays of Objects:**



**By Property Value:**



```javascript

const users = [

  { id: 1, name: 'John' },

  { id: 2, name: 'Jane' },

  { id: 1, name: 'John' }, // duplicate

  { id: 3, name: 'Bob' }

];



// Using Map

const uniqueById = [...new Map(users.map(user => [user.id, user])).values()];

console.log(uniqueById);

// [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }, { id: 3, name: 'Bob' }]



// Using filter

const unique = users.filter((user, index, self) =>

  index === self.findIndex(u => u.id === user.id)

);



// Using reduce

const uniqueUsers = users.reduce((acc, user) => {

  const exists = acc.find(u => u.id === user.id);

  if (!exists) {

    acc.push(user);

  }

  return acc;

}, []);

```



**By Multiple Properties:**



```javascript

const data = [

  { id: 1, type: 'A' },

  { id: 2, type: 'B' },

  { id: 1, type: 'A' }, // duplicate

  { id: 1, type: 'B' }, // different type

  { id: 2, type: 'B' }  // duplicate

];



// Create unique key from multiple properties

const unique = [...new Map(

  data.map(item => [`${item.id}-${item.type}`, item])

).values()];



console.log(unique);

// [

//   { id: 1, type: 'A' },

//   { id: 2, type: 'B' },

//   { id: 1, type: 'B' }

// ]



// Alternative with JSON.stringify (works but slower)

const seen = new Set();

const unique2 = data.filter(item => {

  const key = JSON.stringify(item);

  if (seen.has(key)) {

    return false;

  }

  seen.add(key);

  return true;

});

```



**Case-Insensitive Deduplication:**



```javascript

const words = ['Apple', 'banana', 'APPLE', 'Banana', 'cherry'];



// Convert to lowercase for comparison

const uniqueLower = [...new Set(words.map(w => w.toLowerCase()))];

console.log(uniqueLower); // ['apple', 'banana', 'cherry']



// Keep original case (first occurrence)

const unique = words.filter((word, index, self) =>

  self.findIndex(w => w.toLowerCase() === word.toLowerCase()) === index

);

console.log(unique); // ['Apple', 'banana', 'cherry']



// Using Map to preserve first occurrence

const map = new Map();

words.forEach(word => {

  const key = word.toLowerCase();

  if (!map.has(key)) {

    map.set(key, word);

  }

});

const unique2 = [...map.values()];

console.log(unique2); // ['Apple', 'banana', 'cherry']

```



**Performance Comparison:**



```javascript

const large = Array.from({ length: 10000 }, () => 

  Math.floor(Math.random() * 1000)

);



// 1. Set - Fastest (O(n))

console.time('Set');

const unique1 = [...new Set(large)];

console.timeEnd('Set'); // ~1ms



// 2. filter + indexOf - Slow (O(n²))

console.time('filter + indexOf');

const unique2 = large.filter((item, i) => large.indexOf(item) === i);

console.timeEnd('filter + indexOf'); // ~50ms



// 3. reduce + includes - Slow (O(n²))

console.time('reduce');

const unique3 = large.reduce((acc, curr) => 

  acc.includes(curr) ? acc : [...acc, curr], []

);

console.timeEnd('reduce'); // ~40ms



// 4. forEach + Set - Fast (O(n))

console.time('forEach + Set');

const unique4 = [];

const seen = new Set();

large.forEach(num => {

  if (!seen.has(num)) {

    seen.add(num);

    unique4.push(num);

  }

});

console.timeEnd('forEach + Set'); // ~2ms



// Winner: Set-based methods are fastest

```



**Practical Use Cases:**



**1. Unique Tags/Categories:**

```javascript

const posts = [

  { title: 'Post 1', tags: ['js', 'react'] },

  { title: 'Post 2', tags: ['js', 'vue'] },

  { title: 'Post 3', tags: ['react', 'node'] }

];



// Get all unique tags

const allTags = posts.flatMap(post => post.tags);

const uniqueTags = [...new Set(allTags)];

console.log(uniqueTags); // ['js', 'react', 'vue', 'node']

```



**2. Merging Arrays Without Duplicates:**

```javascript

const arr1 = [1, 2, 3, 4];

const arr2 = [3, 4, 5, 6];



const merged = [...new Set([...arr1, ...arr2])];

console.log(merged); // [1, 2, 3, 4, 5, 6]

```



**3. User Input Validation:**

```javascript

function getUniqueEmails(emails) {

  // Normalize and deduplicate

  return [...new Set(emails.map(e => e.trim().toLowerCase()))];

}



const emails = ['john@example.com', 'JOHN@EXAMPLE.COM', 'jane@example.com'];

console.log(getUniqueEmails(emails)); // ['john@example.com', 'jane@example.com']

```



**4. Form Data Processing:**

```javascript

const formData = {

  interests: ['coding', 'music', 'coding', 'sports', 'music']

};



// Remove duplicates from interests

formData.interests = [...new Set(formData.interests)];

console.log(formData.interests); // ['coding', 'music', 'sports']

```



**Maintaining Order:**



```javascript

// Set maintains insertion order

const numbers = [3, 1, 2, 3, 2, 4, 1];

const unique = [...new Set(numbers)];

console.log(unique); // [3, 1, 2, 4] (order preserved)



// If you need sorted unique values

const sortedUnique = [...new Set(numbers)].sort((a, b) => a - b);

console.log(sortedUnique); // [1, 2, 3, 4]

```



**Edge Cases:**



```javascript

// Empty array

console.log([...new Set([])]); // []



// Array with NaN

const withNaN = [1, NaN, 2, NaN, 3];

console.log([...new Set(withNaN)]); // [1, NaN, 2, 3]

// Note: Set treats NaN === NaN (different from ===)



// Array with null/undefined

const mixed = [1, null, 2, undefined, null, 3];

console.log([...new Set(mixed)]); // [1, null, 2, undefined, 3]



// Objects (by reference)

const obj1 = { a: 1 };

const obj2 = { a: 1 };

const objs = [obj1, obj2, obj1];

console.log([...new Set(objs)]); // [obj1, obj2] (by reference)

console.log(objs[0] === objs[2]); // true

```



**Best Practices:**

- Use **Set** for simple primitive deduplication (fastest and cleanest)

- Use **Map** for object deduplication by property

- Avoid `filter + indexOf` for large arrays (O(n²) complexity)

- Consider case sensitivity for strings

- For objects, decide deduplication criteria (by reference or by value)

- Use `structuredClone()` or deep copy if objects should be truly unique

- Document whether first or last occurrence is kept

- Test with edge cases (NaN, null, undefined)



**Key Takeaways:**

- **Set** is the best method for primitive arrays (fast, clean)

- `[...new Set(array)]` is the standard pattern

- `filter + indexOf` works but is slow for large arrays

- Objects need special handling (deduplicate by property)

- Set maintains insertion order

- Performance varies significantly (Set is O(n), filter+indexOf is O(n²))

- Essential for data cleaning and normalization

- Consider case sensitivity and comparison criteria





</details>
<details><summary>48. What is Array.from()?</summary>






**Answer:**

`Array.from()` is a static method that creates a new array from an array-like or iterable object. It's particularly useful for converting non-array objects (like NodeList, arguments, strings) into proper arrays.



**Syntax:** `Array.from(arrayLike, mapFn, thisArg)`



**Basic Usage:**



```javascript

// From string

const str = 'hello';

const chars = Array.from(str);

console.log(chars); // ['h', 'e', 'l', 'l', 'o']



// From Set

const set = new Set([1, 2, 3]);

const arr = Array.from(set);

console.log(arr); // [1, 2, 3]



// From Map

const map = new Map([['a', 1], ['b', 2]]);

const entries = Array.from(map);

console.log(entries); // [['a', 1], ['b', 2]]



// From array-like object

const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };

const array = Array.from(arrayLike);

console.log(array); // ['a', 'b', 'c']

```



**With Mapping Function (Second Parameter):**



```javascript

// Transform while converting

const numbers = [1, 2, 3];

const doubled = Array.from(numbers, x => x * 2);

console.log(doubled); // [2, 4, 6]



// From string with transformation

const str = 'hello';

const upperChars = Array.from(str, char => char.toUpperCase());

console.log(upperChars); // ['H', 'E', 'L', 'L', 'O']



// With index

const indexed = Array.from([10, 20, 30], (value, index) => ({

  index,

  value,

  squared: value ** 2

}));

console.log(indexed);

// [

//   { index: 0, value: 10, squared: 100 },

//   { index: 1, value: 20, squared: 400 },

//   { index: 2, value: 30, squared: 900 }

// ]

```



**Creating Ranges:**



```javascript

// Create array of numbers 0-9

const range = Array.from({ length: 10 }, (_, i) => i);

console.log(range); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]



// Create array 1-10

const oneToTen = Array.from({ length: 10 }, (_, i) => i + 1);

console.log(oneToTen); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]



// Create range with step

const evens = Array.from({ length: 5 }, (_, i) => i * 2);

console.log(evens); // [0, 2, 4, 6, 8]



// Descending range

const countdown = Array.from({ length: 5 }, (_, i) => 5 - i);

console.log(countdown); // [5, 4, 3, 2, 1]



// Character range

const alphabet = Array.from({ length: 26 }, (_, i) => 

  String.fromCharCode(97 + i)

);

console.log(alphabet); // ['a', 'b', 'c', ..., 'z']

```



**Converting Array-Like Objects:**



```javascript

// NodeList to Array

const divs = document.querySelectorAll('div');

const divsArray = Array.from(divs);

divsArray.forEach(div => div.classList.add('active'));



// HTMLCollection to Array

const links = document.getElementsByTagName('a');

const linksArray = Array.from(links);

const hrefs = linksArray.map(link => link.href);



// Arguments object to Array

function sum() {

  const args = Array.from(arguments);

  return args.reduce((a, b) => a + b, 0);

}

console.log(sum(1, 2, 3, 4)); // 10



// Modern alternative for arguments

function sum2(...args) {

  return args.reduce((a, b) => a + b, 0);

}

```



**Working with Strings:**



```javascript

// String to character array

const word = 'JavaScript';

const letters = Array.from(word);

console.log(letters); // ['J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't']



// Handle Unicode properly (unlike split)

const emoji = '😀😃😄';

console.log(emoji.split('')); // Wrong: splits surrogate pairs

console.log(Array.from(emoji)); // Correct: ['😀', '😃', '😄']



// Count emoji correctly

const text = 'Hello 😀 World 😃';

console.log(text.length); // 17 (wrong, counts surrogate pairs)

console.log(Array.from(text).length); // 15 (correct)

```



**Creating Initialized Arrays:**



```javascript

// Array of same values

const zeros = Array.from({ length: 5 }, () => 0);

console.log(zeros); // [0, 0, 0, 0, 0]



// Array of objects (each unique)

const users = Array.from({ length: 3 }, (_, i) => ({

  id: i + 1,

  name: `User ${i + 1}`

}));

console.log(users);

// [

//   { id: 1, name: 'User 1' },

//   { id: 2, name: 'User 2' },

//   { id: 3, name: 'User 3' }

// ]



// Array of arrays (matrix)

const matrix = Array.from({ length: 3 }, () => 

  Array.from({ length: 3 }, () => 0)

);

console.log(matrix);

// [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

```



**Practical Use Cases:**



**1. Paginate Array:**

```javascript

function paginate(array, pageSize) {

  return Array.from(

    { length: Math.ceil(array.length / pageSize) },

    (_, i) => array.slice(i * pageSize, (i + 1) * pageSize)

  );

}



const data = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const pages = paginate(data, 3);

console.log(pages); // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

```



**2. Generate Test Data:**

```javascript

const mockUsers = Array.from({ length: 10 }, (_, i) => ({

  id: i + 1,

  name: `User ${i + 1}`,

  email: `user${i + 1}@example.com`,

  active: Math.random() > 0.5

}));

```



**3. Convert Map Keys/Values:**

```javascript

const map = new Map([

  ['name', 'John'],

  ['age', 30],

  ['city', 'New York']

]);



const keys = Array.from(map.keys());

console.log(keys); // ['name', 'age', 'city']



const values = Array.from(map.values());

console.log(values); // ['John', 30, 'New York']



const entries = Array.from(map.entries());

console.log(entries); // [['name', 'John'], ['age', 30], ['city', 'New York']]

```



**4. Deduplicate While Transforming:**

```javascript

const numbers = [1, 2, 2, 3, 3, 4];

const uniqueDoubled = Array.from(

  new Set(numbers),

  num => num * 2

);

console.log(uniqueDoubled); // [2, 4, 6, 8]

```



**5. Chunk Array:**

```javascript

function chunk(array, size) {

  return Array.from(

    { length: Math.ceil(array.length / size) },

    (_, i) => array.slice(i * size, i * size + size)

  );

}



const items = [1, 2, 3, 4, 5, 6, 7];

console.log(chunk(items, 3)); // [[1, 2, 3], [4, 5, 6], [7]]

```



**Array.from() vs Spread Operator:**



```javascript

const set = new Set([1, 2, 3]);



// Both work for iterables

const arr1 = Array.from(set);

const arr2 = [...set];

console.log(arr1); // [1, 2, 3]

console.log(arr2); // [1, 2, 3]



// Array.from() works with array-like (spread doesn't)

const arrayLike = { 0: 'a', 1: 'b', length: 2 };

const arr3 = Array.from(arrayLike);

console.log(arr3); // ['a', 'b']

// const arr4 = [...arrayLike]; // ❌ TypeError: not iterable



// Array.from() allows mapping

const doubled = Array.from([1, 2, 3], x => x * 2);

const doubled2 = [...[1, 2, 3]].map(x => x * 2); // Spread needs separate map

```



**With thisArg (Third Parameter):**



```javascript

// Rarely used - sets 'this' context in mapping function

const multiplier = {

  factor: 2,

  multiply(x) {

    return x * this.factor;

  }

};



const numbers = [1, 2, 3];

const result = Array.from(numbers, multiplier.multiply, multiplier);

console.log(result); // [2, 4, 6]



// Modern alternative: arrow function (captures this automatically)

const result2 = Array.from(numbers, x => multiplier.multiply(x));

```



**Edge Cases:**



```javascript

// Empty array-like

console.log(Array.from({ length: 0 })); // []



// Missing length property

console.log(Array.from({ 0: 'a', 1: 'b' })); // [] (no length)



// Non-numeric length

console.log(Array.from({ length: '5' })); // [undefined × 5] (converts to number)



// Negative length

console.log(Array.from({ length: -5 })); // [] (treated as 0)



// null/undefined

console.log(Array.from(null)); // TypeError

console.log(Array.from(undefined)); // TypeError

console.log(Array.from(null) || []); // [] (safe default)

```



**Performance Considerations:**



```javascript

// Creating large arrays

const size = 1000000;



// Array.from with mapping

console.time('Array.from');

const arr1 = Array.from({ length: size }, (_, i) => i);

console.timeEnd('Array.from'); // ~50ms



// Traditional loop

console.time('for loop');

const arr2 = [];

for (let i = 0; i < size; i++) {

  arr2.push(i);

}

console.timeEnd('for loop'); // ~30ms



// For small arrays, Array.from is fine and more readable

// For very large arrays, traditional loops may be faster

```



**Best Practices:**

- Use **Array.from()** to convert array-like and iterable objects

- Leverage second parameter for transformation (cleaner than separate map)

- Prefer spread operator for simple iterable conversion

- Use for creating ranges and initialized arrays

- Handle Unicode strings properly with Array.from()

- Validate input (check for null/undefined)

- Consider performance for very large arrays

- Great for functional programming patterns



**Key Takeaways:**

- `Array.from()` creates arrays from array-like or iterable objects

- Accepts optional mapping function as second parameter

- Works with NodeList, arguments, strings, Sets, Maps, etc.

- Useful for creating ranges: `Array.from({ length: n }, (_, i) => i)`

- Handles Unicode correctly (unlike split)

- More versatile than spread operator (works with array-like objects)

- Essential for DOM manipulation and functional programming

- Part of ES6, widely supported



## Asynchronous JavaScript



</details>
<details><summary>49. What is asynchronous programming?</summary>






**Answer:**

Asynchronous programming is a programming paradigm that allows code to execute without blocking the main thread, enabling operations (like network requests, file I/O, or timers) to run in the background while the program continues executing other code. This is crucial for maintaining responsive user interfaces and efficient resource utilization.



**Synchronous vs Asynchronous:**



```javascript

// ❌ Synchronous - blocks execution

console.log('Start');

// Imagine a 3-second blocking operation

for (let i = 0; i < 3000000000; i++) {} // Blocks for ~3 seconds

console.log('End');

// Output: Start -> (3 second freeze) -> End



// ✅ Asynchronous - doesn't block

console.log('Start');

setTimeout(() => {

  console.log('After 3 seconds');

}, 3000);

console.log('End');

// Output: Start -> End -> (3 seconds later) -> After 3 seconds

```



**Real-World Example:**



```javascript

// Synchronous (blocking) - BAD for web

function fetchDataSync() {

  // Blocks for 2 seconds

  const data = makeNetworkRequestSync(); // Freezes browser!

  console.log(data);

  console.log('Next operation');

}



// Asynchronous (non-blocking) - GOOD

function fetchDataAsync() {

  makeNetworkRequestAsync((data) => {

    console.log(data);

  });

  console.log('Next operation'); // Runs immediately

}



fetchDataAsync();

// Output: 'Next operation' -> (later) -> data

```



**Why Asynchronous Programming?**



```javascript

// Without async - UI freezes

function processLargeData() {

  showLoadingSpinner();

  const result = processMillionsOfRecords(); // 5 seconds - UI FROZEN!

  hideLoadingSpinner();

  displayResults(result);

}



// With async - UI stays responsive

async function processLargeDataAsync() {

  showLoadingSpinner();

  // Processing happens in chunks, UI can update

  const result = await processInChunks();

  hideLoadingSpinner();

  displayResults(result);

}

```



**Asynchronous Patterns in JavaScript:**



**1. Callbacks (Original Pattern):**



```javascript

function fetchUser(id, callback) {

  setTimeout(() => {

    const user = { id, name: 'John' };

    callback(user);

  }, 1000);

}



fetchUser(1, (user) => {

  console.log('User:', user);

});

console.log('Fetching user...'); // Runs first



// Output:

// Fetching user...

// User: { id: 1, name: 'John' }

```



**2. Promises (ES6):**



```javascript

function fetchUser(id) {

  return new Promise((resolve, reject) => {

    setTimeout(() => {

      const user = { id, name: 'John' };

      resolve(user);

    }, 1000);

  });

}



fetchUser(1)

  .then(user => console.log('User:', user))

  .catch(error => console.error('Error:', error));



console.log('Fetching user...'); // Runs first

```



**3. Async/Await (ES2017):**



```javascript

async function getUser(id) {

  try {

    const user = await fetchUser(id);

    console.log('User:', user);

  } catch (error) {

    console.error('Error:', error);

  }

}



getUser(1);

console.log('Fetching user...'); // Runs first

```



**Common Asynchronous Operations:**



**Network Requests:**



```javascript

// Fetch API (returns Promise)

async function loadData() {

  try {

    const response = await fetch('https://api.example.com/data');

    const data = await response.json();

    console.log('Data:', data);

  } catch (error) {

    console.error('Failed to load:', error);

  }

}



// XMLHttpRequest (callback-based)

function loadDataXHR(callback) {

  const xhr = new XMLHttpRequest();

  xhr.open('GET', 'https://api.example.com/data');

  xhr.onload = () => callback(xhr.responseText);

  xhr.send();

}

```



**Timers:**



```javascript

// setTimeout - runs once after delay

setTimeout(() => {

  console.log('Executed after 2 seconds');

}, 2000);



// setInterval - runs repeatedly

const intervalId = setInterval(() => {

  console.log('Runs every second');

}, 1000);



// Clear interval after 5 seconds

setTimeout(() => {

  clearInterval(intervalId);

  console.log('Interval stopped');

}, 5000);

```



**File Operations (Node.js):**



```javascript

const fs = require('fs').promises;



// Asynchronous file read

async function readConfig() {

  try {

    const data = await fs.readFile('config.json', 'utf8');

    const config = JSON.parse(data);

    return config;

  } catch (error) {

    console.error('Failed to read config:', error);

  }

}



// Multiple file operations

async function processFiles() {

  const [file1, file2, file3] = await Promise.all([

    fs.readFile('file1.txt', 'utf8'),

    fs.readFile('file2.txt', 'utf8'),

    fs.readFile('file3.txt', 'utf8')

  ]);

  

  return file1 + file2 + file3;

}

```



**DOM Events:**



```javascript

// Event listeners are asynchronous

document.getElementById('button').addEventListener('click', () => {

  console.log('Button clicked');

  // Event handler runs when event occurs

});



console.log('Event listener registered'); // Runs immediately



// async event handler

document.getElementById('submit').addEventListener('click', async (e) => {

  e.preventDefault();

  const data = await submitForm();

  displaySuccess(data);

});

```



**Practical Examples:**



**1. Sequential Async Operations:**



```javascript

// Load user, then their posts, then comments

async function loadUserData(userId) {

  try {

    console.log('Loading user...');

    const user = await fetchUser(userId);

    

    console.log('Loading posts...');

    const posts = await fetchPosts(user.id);

    

    console.log('Loading comments...');

    const comments = await fetchComments(posts[0].id);

    

    return { user, posts, comments };

  } catch (error) {

    console.error('Error loading data:', error);

  }

}



// Each operation waits for previous to complete

```



**2. Parallel Async Operations:**



```javascript

// Load multiple resources simultaneously

async function loadDashboardData() {

  try {

    console.log('Loading dashboard...');

    

    // All requests start simultaneously

    const [user, posts, notifications, stats] = await Promise.all([

      fetchUser(1),

      fetchPosts(),

      fetchNotifications(),

      fetchStats()

    ]);

    

    return { user, posts, notifications, stats };

  } catch (error) {

    console.error('Error loading dashboard:', error);

  }

}



// Much faster than sequential loading

```



**3. Race Condition Handling:**



```javascript

// Use first response, timeout the rest

async function fetchWithTimeout(url, timeout = 5000) {

  const controller = new AbortController();

  

  const timeoutPromise = new Promise((_, reject) => {

    setTimeout(() => {

      controller.abort();

      reject(new Error('Request timeout'));

    }, timeout);

  });

  

  const fetchPromise = fetch(url, { signal: controller.signal });

  

  return Promise.race([fetchPromise, timeoutPromise]);

}



// Usage

try {

  const response = await fetchWithTimeout('https://api.example.com/data', 3000);

  const data = await response.json();

} catch (error) {

  console.error('Request failed or timed out:', error);

}

```



**4. Retry Logic:**



```javascript

async function fetchWithRetry(url, maxRetries = 3) {

  for (let i = 0; i < maxRetries; i++) {

    try {

      console.log(`Attempt ${i + 1}/${maxRetries}`);

      const response = await fetch(url);

      

      if (!response.ok) {

        throw new Error(`HTTP ${response.status}`);

      }

      

      return await response.json();

    } catch (error) {

      console.error(`Attempt ${i + 1} failed:`, error.message);

      

      if (i === maxRetries - 1) {

        throw new Error('Max retries reached');

      }

      

      // Exponential backoff

      await new Promise(resolve => 

        setTimeout(resolve, Math.pow(2, i) * 1000)

      );

    }

  }

}



// Usage

try {

  const data = await fetchWithRetry('https://api.example.com/data');

  console.log('Data:', data);

} catch (error) {

  console.error('Failed after retries:', error);

}

```



**5. Debouncing Async Operations:**



```javascript

function debounce(fn, delay) {

  let timeoutId;

  

  return function(...args) {

    clearTimeout(timeoutId);

    

    return new Promise((resolve, reject) => {

      timeoutId = setTimeout(async () => {

        try {

          const result = await fn(...args);

          resolve(result);

        } catch (error) {

          reject(error);

        }

      }, delay);

    });

  };

}



// Debounced search

const debouncedSearch = debounce(async (query) => {

  const response = await fetch(`/api/search?q=${query}`);

  return await response.json();

}, 300);



// Usage in input handler

searchInput.addEventListener('input', async (e) => {

  try {

    const results = await debouncedSearch(e.target.value);

    displayResults(results);

  } catch (error) {

    console.error('Search failed:', error);

  }

});

```



**Benefits of Asynchronous Programming:**



| Benefit | Description | Example |

|---------|-------------|---------|

| **Non-blocking** | Code continues executing | UI remains responsive during network calls |

| **Better Performance** | Multiple operations in parallel | Load user data and posts simultaneously |

| **Resource Efficiency** | CPU used while waiting | Handle multiple requests without extra threads |

| **Improved UX** | No frozen interfaces | Show loading spinners, update progressively |

| **Scalability** | Handle more concurrent operations | Server can handle thousands of requests |



**Common Pitfalls:**



**1. Not Handling Errors:**



```javascript

// ❌ No error handling

async function loadData() {

  const data = await fetch('/api/data'); // If this fails, unhandled rejection

  return data;

}



// ✅ Proper error handling

async function loadData() {

  try {

    const response = await fetch('/api/data');

    if (!response.ok) {

      throw new Error(`HTTP ${response.status}`);

    }

    return await response.json();

  } catch (error) {

    console.error('Failed to load data:', error);

    return null; // or throw, or return default value

  }

}

```



**2. Forgetting await:**



```javascript

// ❌ Forgot await - returns Promise, not data

async function getUser() {

  const user = fetchUser(1); // Missing await!

  console.log(user); // Promise { <pending> }

  return user.name; // undefined or error

}



// ✅ Correct

async function getUser() {

  const user = await fetchUser(1);

  console.log(user); // { id: 1, name: 'John' }

  return user.name; // 'John'

}

```



**3. Sequential When Could Be Parallel:**



```javascript

// ❌ Slow - runs sequentially (5 seconds total)

async function loadData() {

  const user = await fetchUser(1);      // 2 seconds

  const posts = await fetchPosts();     // 2 seconds

  const comments = await fetchComments(); // 1 second

  return { user, posts, comments };

}



// ✅ Fast - runs in parallel (2 seconds total)

async function loadData() {

  const [user, posts, comments] = await Promise.all([

    fetchUser(1),      // 2 seconds

    fetchPosts(),      // 2 seconds

    fetchComments()    // 1 second

  ]);

  return { user, posts, comments };

}

```



**4. Creating Promises in Loops:**



```javascript

// ❌ Creates all promises at once (may overwhelm server)

async function processUsers(userIds) {

  const promises = userIds.map(id => fetchUser(id));

  const users = await Promise.all(promises); // 100 concurrent requests!

  return users;

}



// ✅ Process in batches

async function processUsers(userIds, batchSize = 5) {

  const results = [];

  

  for (let i = 0; i < userIds.length; i += batchSize) {

    const batch = userIds.slice(i, i + batchSize);

    const batchResults = await Promise.all(

      batch.map(id => fetchUser(id))

    );

    results.push(...batchResults);

  }

  

  return results;

}

```



**Best Practices:**

- Always handle errors (try/catch or .catch())

- Use async/await for cleaner code

- Run independent operations in parallel (Promise.all)

- Implement timeouts for network requests

- Add retry logic for critical operations

- Debounce/throttle frequent async calls

- Avoid blocking the main thread

- Test error scenarios thoroughly

- Use AbortController for cancellable requests

- Consider loading states and user feedback



**Key Takeaways:**

- Asynchronous programming allows non-blocking code execution

- Essential for network requests, timers, file I/O, events

- JavaScript uses callbacks, Promises, and async/await

- Enables responsive UIs and better performance

- Run independent operations in parallel for speed

- Always handle errors properly

- Main thread remains free for user interactions

- Critical for modern web development and Node.js





</details>
<details><summary>50. What is the event loop?</summary>






**Answer:**

The event loop is JavaScript's mechanism for handling asynchronous operations in a single-threaded environment. It continuously checks the call stack and task queues, executing code in a specific order, which allows JavaScript to perform non-blocking operations despite being single-threaded.



**JavaScript is Single-Threaded:**



```javascript

// JavaScript runs one piece of code at a time

console.log('First');

console.log('Second');

console.log('Third');



// Output (predictable, sequential):

// First

// Second

// Third

```



**How the Event Loop Works:**



**Core Components:**




1. **Call Stack** - Tracks function execution



2. **Web APIs** - Browser/Node.js APIs (setTimeout, fetch, etc.)



3. **Callback Queue (Task Queue)** - Holds callbacks from async operations



4. **Microtask Queue** - Holds Promise callbacks (higher priority)



5. **Event Loop** - Monitors and coordinates everything




```

┌───────────────────────────┐

│      Call Stack           │ ← JavaScript execution

└───────────────────────────┘

            ↑

            │

┌───────────────────────────┐

│      Event Loop           │ ← Checks if stack is empty

└───────────────────────────┘

            ↑

     ┌──────┴──────┐

     │             │

┌─────────┐  ┌─────────────┐

│Microtask│  │ Callback    │

│ Queue   │  │ Queue       │

│(Promise)│  │(setTimeout) │

└─────────┘  └─────────────┘

     ↑             ↑

     │             │

┌────────────────────────────┐

│     Web APIs / Node APIs    │

│  (setTimeout, fetch, etc.)  │

└────────────────────────────┘

```



**Event Loop Process:**



```javascript

// Step-by-step execution

console.log('1: Start'); // → Call stack



setTimeout(() => {

  console.log('2: Timeout'); // → Web API → Callback Queue

}, 0);



Promise.resolve().then(() => {

  console.log('3: Promise'); // → Microtask Queue

});



console.log('4: End'); // → Call stack



// Output order:

// 1: Start

// 4: End

// 3: Promise  (microtask - higher priority)

// 2: Timeout  (macrotask)

```



**Detailed Example with Explanation:**



```javascript

function main() {

  console.log('A'); // 1. Goes to call stack, executes

  

  setTimeout(() => {

    console.log('B'); // 4. Moved to callback queue after 0ms

  }, 0);

  

  Promise.resolve().then(() => {

    console.log('C'); // 3. Moved to microtask queue

  });

  

  console.log('D'); // 2. Goes to call stack, executes

}



main();



// Execution flow:

// 1. main() called → added to call stack

// 2. console.log('A') → executes → 'A' printed

// 3. setTimeout() → registered with Web API → removed from stack

// 4. Promise.resolve().then() → callback added to microtask queue

// 5. console.log('D') → executes → 'D' printed

// 6. main() finishes → removed from call stack

// 7. Call stack empty → event loop checks microtask queue

// 8. Promise callback executes → 'C' printed

// 9. Microtask queue empty → event loop checks callback queue

// 10. setTimeout callback executes → 'B' printed



// Output: A → D → C → B

```



**Call Stack Visualization:**



```javascript

function first() {

  console.log('First function');

  second();

  console.log('First function end');

}



function second() {

  console.log('Second function');

  third();

  console.log('Second function end');

}



function third() {

  console.log('Third function');

}



first();



// Call stack changes:

// Step 1: [first]

// Step 2: [first, second]

// Step 3: [first, second, third]

// Step 4: [first, second]        (third done)

// Step 5: [first]                (second done)

// Step 6: []                     (first done)



// Output:

// First function

// Second function

// Third function

// Second function end

// First function end

```



**Blocking the Event Loop:**



```javascript

// ❌ BAD - Blocks event loop

console.log('Start');



// Synchronous loop blocks for ~3 seconds

for (let i = 0; i < 3000000000; i++) {

  // Heavy computation - nothing else can run!

}



console.log('End');

// UI frozen for 3 seconds!



// ✅ GOOD - Non-blocking

console.log('Start');



setTimeout(() => {

  console.log('Async work done');

}, 0);



console.log('End');

// UI remains responsive

// Output: Start → End → Async work done

```



**Microtasks vs Macrotasks:**



```javascript

// Demonstration of queue priorities

console.log('Script start');



// Macrotask (lower priority)

setTimeout(() => {

  console.log('setTimeout 1');

}, 0);



// Microtask (higher priority)

Promise.resolve()

  .then(() => {

    console.log('Promise 1');

    return Promise.resolve();

  })

  .then(() => {

    console.log('Promise 2');

  });



// Another macrotask

setTimeout(() => {

  console.log('setTimeout 2');

}, 0);



// Microtask

Promise.resolve().then(() => {

  console.log('Promise 3');

});



console.log('Script end');



// Output:

// Script start

// Script end

// Promise 1

// Promise 3

// Promise 2

// setTimeout 1

// setTimeout 2



// Explanation:

// 1. Synchronous code runs first (Script start, Script end)

// 2. Call stack empties

// 3. ALL microtasks run (Promise 1, 3, 2)

// 4. One macrotask runs (setTimeout 1)

// 5. Check microtasks again (none)

// 6. Next macrotask runs (setTimeout 2)

```



**Microtasks (Higher Priority):**



- `Promise.then/catch/finally`

- `queueMicrotask()`

- `MutationObserver`

- `process.nextTick()` (Node.js - even higher priority)



**Macrotasks (Lower Priority):**



- `setTimeout`

- `setInterval`

- `setImmediate` (Node.js)

- I/O operations

- UI rendering



**Complex Example:**



```javascript

console.log('1');



setTimeout(() => {

  console.log('2');

  Promise.resolve().then(() => {

    console.log('3');

  });

}, 0);



Promise.resolve().then(() => {

  console.log('4');

  setTimeout(() => {

    console.log('5');

  }, 0);

});



Promise.resolve().then(() => {

  console.log('6');

});



setTimeout(() => {

  console.log('7');

  Promise.resolve().then(() => {

    console.log('8');

  });

}, 0);



console.log('9');



// Output: 1 → 9 → 4 → 6 → 2 → 3 → 7 → 8 → 5



// Step-by-step:

// 1. console.log('1') - executes

// 2. setTimeout(2) - queued as macrotask

// 3. Promise(4) - queued as microtask

// 4. Promise(6) - queued as microtask

// 5. setTimeout(7) - queued as macrotask

// 6. console.log('9') - executes

// 7. Call stack empty → run microtasks

// 8. Promise(4) executes → queues setTimeout(5) as macrotask

// 9. Promise(6) executes

// 10. Microtasks done → run macrotask setTimeout(2)

// 11. console.log('2') → queues Promise(3) as microtask

// 12. Run microtask Promise(3)

// 13. Run macrotask setTimeout(7)

// 14. console.log('7') → queues Promise(8) as microtask

// 15. Run microtask Promise(8)

// 16. Run macrotask setTimeout(5)

```



**Practical Implications:**



**1. Responsive UI:**



```javascript

// ❌ Blocks UI

function processLargeArray(arr) {

  for (let item of arr) {

    processItem(item); // 10,000 items - UI freezes!

  }

}



// ✅ Chunks work, keeps UI responsive

async function processLargeArrayAsync(arr, chunkSize = 100) {

  for (let i = 0; i < arr.length; i += chunkSize) {

    const chunk = arr.slice(i, i + chunkSize);

    

    // Process chunk

    chunk.forEach(item => processItem(item));

    

    // Yield to event loop (let UI update)

    await new Promise(resolve => setTimeout(resolve, 0));

  }

}

```



**2. Promise Resolution Order:**



```javascript

// Understanding when Promises resolve

const promise1 = Promise.resolve('A');

const promise2 = new Promise(resolve => {

  setTimeout(() => resolve('B'), 0);

});



promise1.then(console.log);

promise2.then(console.log);

console.log('C');



// Output: C → A → B

// Explanation:

// - console.log('C') is synchronous (runs first)

// - promise1.then goes to microtask queue

// - promise2.then waits for setTimeout (macrotask)

// - Microtasks run before macrotasks

```



**3. Event Handler Execution:**



```javascript

button.addEventListener('click', () => {

  console.log('Click 1');

  

  Promise.resolve().then(() => {

    console.log('Promise 1');

  });

  

  console.log('Click 2');

});



button.addEventListener('click', () => {

  console.log('Click 3');

  

  Promise.resolve().then(() => {

    console.log('Promise 2');

  });

  

  console.log('Click 4');

});



// When button clicked:

// Click 1

// Click 2

// Click 3

// Click 4

// Promise 1

// Promise 2



// Both handlers run synchronously, then microtasks

```



**4. Preventing Stack Overflow:**



```javascript

// ❌ Synchronous recursion - stack overflow

function recursiveSync(n) {

  if (n === 0) return;

  console.log(n);

  recursiveSync(n - 1); // Direct recursion - builds stack

}

// recursiveSync(100000); // RangeError: Maximum call stack size exceeded



// ✅ Asynchronous recursion - no stack overflow

function recursiveAsync(n) {

  if (n === 0) return;

  console.log(n);

  setTimeout(() => recursiveAsync(n - 1), 0); // Stack clears between calls

}

recursiveAsync(100000); // Works fine!

```



**Node.js Event Loop (More Complex):**



```javascript

// Node.js has additional queues

const fs = require('fs');



console.log('1: Start');



// Timer queue (macrotask)

setTimeout(() => console.log('2: setTimeout'), 0);



// I/O queue (macrotask)

fs.readFile(__filename, () => {

  console.log('3: readFile');

});



// Immediate queue (macrotask, after I/O)

setImmediate(() => console.log('4: setImmediate'));



// Microtask queue (highest priority)

Promise.resolve().then(() => console.log('5: Promise'));



// Next tick queue (even higher than microtasks in Node)

process.nextTick(() => console.log('6: nextTick'));



console.log('7: End');



// Output (Node.js):

// 1: Start

// 7: End

// 6: nextTick      (nextTick queue)

// 5: Promise       (microtask queue)

// 2: setTimeout    (timer queue)

// 4: setImmediate  (check queue)

// 3: readFile      (I/O queue, varies by file size)

```



**Common Misconceptions:**



**1. setTimeout(fn, 0) runs immediately:**



```javascript

console.log('A');

setTimeout(() => console.log('B'), 0);

console.log('C');



// Output: A → C → B (NOT A → B → C)

// setTimeout always defers to next macrotask

```



**2. Promises are synchronous:**



```javascript

console.log('A');



new Promise((resolve) => {

  console.log('B'); // Constructor callback is SYNCHRONOUS

  resolve();

}).then(() => {

  console.log('C'); // .then is ASYNCHRONOUS

});



console.log('D');



// Output: A → B → D → C

```



**3. All async code runs later:**



```javascript

async function test() {

  console.log('A'); // Runs synchronously until first await

  await Promise.resolve();

  console.log('B'); // Runs asynchronously after await

}



console.log('C');

test();

console.log('D');



// Output: C → A → D → B

```



**Visualizing Event Loop Cycle:**



```



</details>
<details><summary>1. Execute all synchronous code (call stack)</summary>






</details>
<details><summary>2. Call stack empty?</summary>




   YES → Go to step 3

   NO → Continue executing



</details>
<details><summary>3. Process ALL microtasks</summary>




   - Run one microtask

   - If it creates more microtasks, add to queue

   - Repeat until microtask queue is empty



</details>
<details><summary>4. Render UI (if browser)</summary>






</details>
<details><summary>5. Process ONE macrotask</summary>




   - Run oldest task from callback queue



</details>
<details><summary>6. Go back to step 2</summary>






Key: Microtasks can starve macrotasks if infinite!

```



**Best Practices:**

- Don't block the event loop with heavy synchronous operations

- Break large computations into chunks with setTimeout/setImmediate

- Understand microtask priority for Promise timing

- Use Web Workers for CPU-intensive tasks

- Monitor event loop lag in production (Node.js)

- Avoid infinite microtask loops

- Use async/await for readable async code

- Profile and optimize slow synchronous code



**Performance Monitoring:**



```javascript

// Measure event loop delay (Node.js)

const { performance } = require('perf_hooks');



let lastTime = performance.now();



setInterval(() => {

  const currentTime = performance.now();

  const delay = currentTime - lastTime - 1000; // Expected 1000ms

  

  if (delay > 100) {

    console.warn(`Event loop delay: ${delay}ms`);

  }

  

  lastTime = currentTime;

}, 1000);

```



**Key Takeaways:**

- Event loop enables async behavior in single-threaded JavaScript

- Components: call stack, queues (micro/macro), Web APIs, event loop

- Microtasks (Promises) run before macrotasks (setTimeout)

- ALL microtasks run before ANY macrotask

- Synchronous code always runs first

- Don't block the event loop with heavy operations

- Understanding the event loop is crucial for debugging async code

- Foundation of JavaScript's concurrency model





</details>
<details><summary>51. What is a Promise?</summary>






**Answer:**

A Promise is a JavaScript object representing the eventual completion (or failure) of an asynchronous operation and its resulting value. It's a cleaner alternative to callbacks, providing better error handling and avoiding callback hell.



**Basic Concept:**



```javascript

// A Promise is a placeholder for a future value

const promise = new Promise((resolve, reject) => {

  // Async operation

  setTimeout(() => {

    const success = true;

    

    if (success) {

      resolve('Operation succeeded!'); // Fulfill the promise

    } else {

      reject('Operation failed!'); // Reject the promise

    }

  }, 1000);

});



// Consuming the promise

promise

  .then(result => console.log(result)) // 'Operation succeeded!'

  .catch(error => console.error(error))

  .finally(() => console.log('Done'));

```



**Creating Promises:**



**1. Promise Constructor:**



```javascript

const myPromise = new Promise((resolve, reject) => {

  // resolve(value) - when operation succeeds

  // reject(error) - when operation fails

  

  const randomNum = Math.random();

  

  if (randomNum > 0.5) {

    resolve({ data: 'Success!', value: randomNum });

  } else {

    reject(new Error('Number too low'));

  }

});



myPromise

  .then(result => console.log('✓', result))

  .catch(error => console.error('✗', error.message));

```



**2. Promise.resolve() and Promise.reject():**



```javascript

// Create immediately resolved promise

const resolvedPromise = Promise.resolve('Immediate success');

resolvedPromise.then(console.log); // 'Immediate success'



// Create immediately rejected promise

const rejectedPromise = Promise.reject(new Error('Immediate failure'));

rejectedPromise.catch(console.error); // Error: Immediate failure



// Wrap value in promise

const value = 42;

const wrappedValue = Promise.resolve(value);

wrappedValue.then(val => console.log(val)); // 42



// If value is already a promise, returns it

const existingPromise = Promise.resolve('test');

const samePromise = Promise.resolve(existingPromise);

console.log(existingPromise === samePromise); // true

```



**Promise States:**



A Promise is in one of three states:




1. **Pending** - Initial state, operation not complete



2. **Fulfilled** - Operation completed successfully



3. **Rejected** - Operation failed




```javascript

// Pending → Fulfilled

const fulfilled = new Promise((resolve) => {

  setTimeout(() => resolve('Done'), 1000);

});



// Pending → Rejected

const rejected = new Promise((_, reject) => {

  setTimeout(() => reject(new Error('Failed')), 1000);

});



// Check state (not directly accessible, but observable)

const promise = Promise.resolve('value');

console.log(promise); // Promise { 'value' } - fulfilled



const pendingPromise = new Promise(() => {});

console.log(pendingPromise); // Promise { <pending> }

```



**Consuming Promises:**



**1. .then() - Handle Success:**



```javascript

fetch('https://api.example.com/user/1')

  .then(response => response.json())

  .then(user => {

    console.log('User:', user);

    return user.id; // Return value for next .then()

  })

  .then(userId => {

    console.log('User ID:', userId);

  });



// .then() returns a new promise

const promise1 = Promise.resolve(1);

const promise2 = promise1.then(x => x + 1);

const promise3 = promise2.then(x => x * 2);



promise3.then(console.log); // 4

// Chain: 1 → (1+1) → (2*2) → 4

```



**2. .catch() - Handle Errors:**



```javascript

fetch('https://api.example.com/user/1')

  .then(response => {

    if (!response.ok) {

      throw new Error(`HTTP ${response.status}`);

    }

    return response.json();

  })

  .then(user => console.log(user))

  .catch(error => {

    console.error('Error:', error.message);

    // Handle error (show message, retry, etc.)

  });



// .catch() catches errors from any previous .then()

Promise.resolve()

  .then(() => {

    throw new Error('Step 1 failed');

  })

  .then(() => {

    console.log('Step 2'); // Skipped

  })

  .catch(error => {

    console.error('Caught:', error.message); // Caught: Step 1 failed

  });

```



**3. .finally() - Cleanup:**



```javascript

showLoadingSpinner();



fetchUserData()

  .then(data => {

    displayData(data);

  })

  .catch(error => {

    showError(error);

  })

  .finally(() => {

    hideLoadingSpinner(); // Runs regardless of success/failure

  });



// .finally() doesn't receive arguments

Promise.resolve('success')

  .finally(() => {

    console.log('Cleanup'); // No access to 'success'

  })

  .then(value => {

    console.log(value); // 'success' - passed through

  });

```



**Promise Chaining:**



```javascript

// Sequential async operations

getUserById(1)

  .then(user => {

    console.log('User:', user.name);

    return getPostsByUser(user.id); // Return promise

  })

  .then(posts => {

    console.log('Posts:', posts.length);

    return getComments(posts[0].id); // Return promise

  })

  .then(comments => {

    console.log('Comments:', comments.length);

  })

  .catch(error => {

    console.error('Error in chain:', error);

  });



// Each .then() returns a new promise

// Errors propagate down to nearest .catch()

```



**Practical Examples:**



**1. Fetch Data:**



```javascript

function fetchUser(id) {

  return fetch(`https://api.example.com/users/${id}`)

    .then(response => {

      if (!response.ok) {

        throw new Error(`HTTP ${response.status}`);

      }

      return response.json();

    })

    .then(user => {

      console.log('Fetched user:', user);

      return user;

    })

    .catch(error => {

      console.error('Failed to fetch user:', error);

      throw error; // Re-throw to let caller handle

    });

}



// Usage

fetchUser(1)

  .then(user => displayUser(user))

  .catch(error => showError(error));

```



**2. Retry Logic:**



```javascript

function fetchWithRetry(url, retries = 3) {

  return fetch(url)

    .then(response => {

      if (!response.ok) {

        throw new Error(`HTTP ${response.status}`);

      }

      return response.json();

    })

    .catch(error => {

      if (retries > 0) {

        console.log(`Retrying... (${retries} attempts left)`);

        return fetchWithRetry(url, retries - 1);

      }

      throw error;

    });

}



fetchWithRetry('https://api.example.com/data')

  .then(data => console.log('Data:', data))

  .catch(error => console.error('Failed after retries:', error));

```



**3. Timeout Wrapper:**



```javascript

function withTimeout(promise, ms) {

  const timeout = new Promise((_, reject) => {

    setTimeout(() => reject(new Error('Timeout')), ms);

  });

  

  return Promise.race([promise, timeout]);

}



// Usage

const slowFetch = fetch('https://slow-api.example.com/data');



withTimeout(slowFetch, 5000)

  .then(response => response.json())

  .then(data => console.log('Data:', data))

  .catch(error => {

    if (error.message === 'Timeout') {

      console.error('Request timed out');

    } else {

      console.error('Request failed:', error);

    }

  });

```



**4. Promise Composition:**



```javascript

// Parallel operations

function loadDashboard(userId) {

  return Promise.all([

    fetchUser(userId),

    fetchPosts(userId),

    fetchNotifications(userId)

  ]).then(([user, posts, notifications]) => {

    return {

      user,

      posts,

      notifications,

      timestamp: Date.now()

    };

  });

}



loadDashboard(1)

  .then(dashboard => console.log('Dashboard:', dashboard))

  .catch(error => console.error('Failed to load dashboard:', error));

```



**Promise vs Callback:**



```javascript

// ❌ Callback hell

getUserById(1, (error, user) => {

  if (error) {

    console.error(error);

    return;

  }

  

  getPosts(user.id, (error, posts) => {

    if (error) {

      console.error(error);

      return;

    }

    

    getComments(posts[0].id, (error, comments) => {

      if (error) {

        console.error(error);

        return;

      }

      

      console.log(comments);

    });

  });

});



// ✅ Promise chain (cleaner)

getUserById(1)

  .then(user => getPosts(user.id))

  .then(posts => getComments(posts[0].id))

  .then(comments => console.log(comments))

  .catch(error => console.error(error)); // Single error handler

```



**Common Promise Methods:**



**1. Promise.all() - All must succeed:**



```javascript

const promises = [

  fetch('/api/user'),

  fetch('/api/posts'),

  fetch('/api/comments')

];



Promise.all(promises)

  .then(responses => Promise.all(responses.map(r => r.json())))

  .then(([user, posts, comments]) => {

    console.log('All data loaded:', { user, posts, comments });

  })

  .catch(error => {

    console.error('At least one failed:', error);

  });



// If ANY promise rejects, Promise.all() rejects immediately

```



**2. Promise.race() - First to finish:**



```javascript

const fast = new Promise(resolve => setTimeout(() => resolve('fast'), 100));

const slow = new Promise(resolve => setTimeout(() => resolve('slow'), 500));



Promise.race([fast, slow])

  .then(result => console.log('Winner:', result)); // 'fast'



// Use for timeouts

Promise.race([

  fetch('/api/data'),

  new Promise((_, reject) => 

    setTimeout(() => reject(new Error('Timeout')), 5000)

  )

]);

```



**3. Promise.allSettled() - Wait for all, regardless:**



```javascript

const promises = [

  Promise.resolve('success'),

  Promise.reject('error'),

  Promise.resolve('another success')

];



Promise.allSettled(promises).then(results => {

  results.forEach(result => {

    if (result.status === 'fulfilled') {

      console.log('✓', result.value);

    } else {

      console.error('✗', result.reason);

    }

  });

});



// Output:

// ✓ success

// ✗ error

// ✓ another success

```



**4. Promise.any() - First fulfilled:**



```javascript

const promises = [

  fetch('https://api1.example.com/data'),

  fetch('https://api2.example.com/data'),

  fetch('https://api3.example.com/data')

];



Promise.any(promises)

  .then(response => {

    console.log('First successful response:', response);

  })

  .catch(error => {

    console.error('All failed:', error); // AggregateError

  });

```



**Error Handling:**



```javascript

// Errors propagate to nearest .catch()

Promise.resolve()

  .then(() => {

    throw new Error('Error in step 1');

  })

  .then(() => {

    console.log('Skipped'); // Skipped

  })

  .catch(error => {

    console.error('Caught:', error.message);

    return 'recovered'; // Recover from error

  })

  .then(value => {

    console.log('Continued:', value); // 'recovered'

  });



// Multiple catch handlers

fetchData()

  .then(processData)

  .catch(error => {

    // Handle specific error

    if (error.name === 'NetworkError') {

      return retryFetch();

    }

    throw error; // Re-throw if can't handle

  })

  .then(displayData)

  .catch(error => {

    // Final error handler

    console.error('Unhandled error:', error);

  });

```



**Common Mistakes:**



**1. Forgetting to return:**



```javascript

// ❌ Doesn't wait for inner promise

getUserById(1)

  .then(user => {

    getPosts(user.id).then(posts => {

      console.log(posts); // Wrong nesting!

    });

  })

  .then(() => {

    // Runs immediately, doesn't wait for posts

  });



// ✅ Return promise to chain properly

getUserById(1)

  .then(user => {

    return getPosts(user.id); // Return!

  })

  .then(posts => {

    console.log(posts); // Runs after posts loaded

  });

```



**2. Not handling rejections:**



```javascript

// ❌ Unhandled promise rejection

fetchData(); // If this fails, unhandled rejection warning



// ✅ Always add .catch()

fetchData().catch(error => console.error(error));



// Or use try/catch with async/await

async function loadData() {

  try {

    await fetchData();

  } catch (error) {

    console.error(error);

  }

}

```



**3. Creating unnecessary promises:**



```javascript

// ❌ Unnecessary wrapping (anti-pattern)

function getUser(id) {

  return new Promise((resolve, reject) => {

    fetchUser(id) // Already returns a promise!

      .then(user => resolve(user))

      .catch(error => reject(error));

  });

}



// ✅ Just return the promise

function getUser(id) {

  return fetchUser(id);

}

```



**Best Practices:**

- Always handle errors with .catch() or try/catch

- Return promises from .then() for proper chaining

- Use Promise.all() for parallel operations

- Avoid creating unnecessary promises (promise constructor anti-pattern)

- Prefer async/await for more readable code

- Don't nest promises (use chaining)

- Use .finally() for cleanup logic

- Add timeout wrappers for network requests



**Key Takeaways:**

- Promise represents eventual completion of async operation

- Three states: pending, fulfilled, rejected

- Created with `new Promise(executor)` or Promise.resolve/reject

- Consumed with .then(), .catch(), .finally()

- Chaining creates sequential async flows

- Cleaner than callbacks, avoids callback hell

- Foundation for async/await syntax

- Essential for modern JavaScript async programming





</details>
<details><summary>52. What are Promise states?</summary>






**Answer:**

A Promise can be in one of three states: **pending** (initial state), **fulfilled** (operation succeeded), or **rejected** (operation failed). Once a Promise is fulfilled or rejected, it becomes **settled** and its state cannot change (immutable).



**Three Promise States:**



| State | Description | Can Transition To |

|-------|-------------|-------------------|

| **Pending** | Initial state, neither fulfilled nor rejected | Fulfilled or Rejected |

| **Fulfilled** | Operation completed successfully, has a value | None (final state) |

| **Rejected** | Operation failed, has a reason (error) | None (final state) |



**State Transitions:**



```javascript

// Pending → Fulfilled

const fulfilled = new Promise((resolve, reject) => {

  setTimeout(() => {

    resolve('Success!'); // Transitions to fulfilled

  }, 1000);

});



// Pending → Rejected

const rejected = new Promise((resolve, reject) => {

  setTimeout(() => {

    reject(new Error('Failed!')); // Transitions to rejected

  }, 1000);

});



// Pending (never settles)

const pending = new Promise(() => {

  // Never calls resolve() or reject()

});

```



**1. Pending State:**



```javascript

// Promise starts in pending state

const promise = new Promise((resolve, reject) => {

  console.log('Promise created'); // Executes immediately

  

  // Async operation

  setTimeout(() => {

    resolve('Done');

  }, 2000);

});



console.log(promise); // Promise { <pending> }



// After 2 seconds

setTimeout(() => {

  console.log(promise); // Promise { 'Done' } - fulfilled

}, 2500);

```



**Characteristics of Pending:**

- Initial state when Promise is created

- Operation is still in progress

- No value or error yet

- Can transition to fulfilled or rejected

- Handlers (.then/.catch) are queued but not executed



```javascript

const pendingPromise = new Promise((resolve) => {

  // Long-running operation

  setTimeout(() => resolve('result'), 5000);

});



// These handlers are queued, waiting for settlement

pendingPromise.then(value => console.log('Value:', value));

pendingPromise.catch(error => console.error('Error:', error));



console.log('Promise is pending...');

// After 5 seconds: 'Value: result'

```



**2. Fulfilled State:**



```javascript

// Promise becomes fulfilled when resolve() is called

const fulfilledPromise = new Promise((resolve, reject) => {

  const data = { id: 1, name: 'John' };

  resolve(data); // Transition to fulfilled with value

});



fulfilledPromise.then(value => {

  console.log('Fulfilled with:', value);

  // { id: 1, name: 'John' }

});



// Immediately fulfilled promise

const immediate = Promise.resolve('Instant success');

console.log(immediate); // Promise { 'Instant success' }

```



**Characteristics of Fulfilled:**

- Operation completed successfully

- Has a resulting value (can be any type, including undefined)

- State is permanent (cannot change)

- `.then()` handlers execute

- `.catch()` handlers are skipped

- `.finally()` handlers execute



```javascript

Promise.resolve('Success')

  .then(value => {

    console.log('✓ Then handler:', value); // Executes

  })

  .catch(error => {

    console.log('✗ Catch handler:', error); // Skipped

  })

  .finally(() => {

    console.log('Finally handler'); // Executes

  });



// Output:

// ✓ Then handler: Success

// Finally handler

```



**3. Rejected State:**



```javascript

// Promise becomes rejected when reject() is called

const rejectedPromise = new Promise((resolve, reject) => {

  const error = new Error('Something went wrong');

  reject(error); // Transition to rejected with reason

});



rejectedPromise.catch(error => {

  console.error('Rejected with:', error.message);

  // 'Something went wrong'

});



// Immediately rejected promise

const immediateReject = Promise.reject(new Error('Instant failure'));

console.log(immediateReject); // Promise { <rejected> Error: Instant failure }

```



**Characteristics of Rejected:**

- Operation failed

- Has a reason (typically an Error object)

- State is permanent (cannot change)

- `.then()` handlers are skipped

- `.catch()` handlers execute

- `.finally()` handlers execute

- Causes "unhandled rejection" warning if not caught



```javascript

Promise.reject('Failure')

  .then(value => {

    console.log('✓ Then handler:', value); // Skipped

  })

  .catch(error => {

    console.log('✗ Catch handler:', error); // Executes

  })

  .finally(() => {

    console.log('Finally handler'); // Executes

  });



// Output:

// ✗ Catch handler: Failure

// Finally handler

```



**State Immutability:**



```javascript

// Once settled, state cannot change

const promise = new Promise((resolve, reject) => {

  resolve('First'); // Promise fulfilled

  resolve('Second'); // ❌ Ignored

  reject('Error'); // ❌ Ignored

  

  // Only the first settlement counts

});



promise.then(value => {

  console.log(value); // 'First' (only first resolve)

});



// Multiple calls have no effect

const promise2 = new Promise((resolve, reject) => {

  resolve('Success');

});



promise2.then(value => console.log(value)); // 'Success'



// Trying to change state externally - impossible

// promise2 is immutable once settled

```



**Checking Promise State (Indirectly):**



```javascript

// You cannot directly access the state property

// But you can check behavior



function getPromiseState(promise) {

  const pending = { state: 'pending' };

  

  return Promise.race([promise, pending])

    .then(

      value => value === pending ? 'pending' : 'fulfilled',

      () => 'rejected'

    );

}



// Usage

const p1 = Promise.resolve('done');

const p2 = Promise.reject('error');

const p3 = new Promise(() => {}); // never settles



getPromiseState(p1).then(console.log); // 'fulfilled'

getPromiseState(p2).then(console.log); // 'rejected'

getPromiseState(p3).then(console.log); // 'pending'

```



**State Transitions in Practice:**



**Example 1: Network Request**



```javascript

function fetchUser(id) {

  // Returns a pending promise

  const promise = fetch(`/api/users/${id}`)

    .then(response => {

      if (!response.ok) {

        throw new Error(`HTTP ${response.status}`);

      }

      return response.json(); // Still pending

    })

    .then(user => {

      // Promise fulfilled with user data

      return user;

    })

    .catch(error => {

      // Promise rejected with error

      throw error;

    });

  

  return promise;

}



// Usage

const userPromise = fetchUser(1); // Pending

console.log(userPromise); // Promise { <pending> }



userPromise

  .then(user => {

    // Fulfilled

    console.log('User loaded:', user);

  })

  .catch(error => {

    // Rejected

    console.error('Failed to load user:', error);

  });

```



**Example 2: Multiple State Transitions**



```javascript

// Step-by-step state transitions

const promise = new Promise((resolve, reject) => {

  console.log('1. Promise created (pending)');

  

  setTimeout(() => {

    console.log('2. About to resolve...');

    resolve('Success');

    console.log('3. Promise fulfilled');

  }, 1000);

});



console.log('Initial state: pending');



promise.then(value => {

  console.log('4. Handler executed with:', value);

});



// Output:

// 1. Promise created (pending)

// Initial state: pending

// (1 second later)

// 2. About to resolve...

// 3. Promise fulfilled

// 4. Handler executed with: Success

```



**Settled vs Pending:**



```javascript

// "Settled" means either fulfilled or rejected (not pending)



function isSettled(promise) {

  return Promise.race([

    promise.then(() => true, () => true),

    new Promise(resolve => setTimeout(() => resolve(false), 0))

  ]);

}



const settled = Promise.resolve('done');

const pending = new Promise(() => {});



isSettled(settled).then(result => {

  console.log('Settled?', result); // true

});



isSettled(pending).then(result => {

  console.log('Pending?', !result); // true

});

```



**Handling All States:**



```javascript

function handlePromise(promise) {

  // Show loading (pending)

  showLoadingSpinner();

  

  promise

    .then(value => {

      // Fulfilled

      hideLoadingSpinner();

      displaySuccess(value);

    })

    .catch(error => {

      // Rejected

      hideLoadingSpinner();

      displayError(error);

    })

    .finally(() => {

      // Always runs (fulfilled or rejected)

      enableButtons();

    });

}



// Usage

const dataPromise = fetchData();

handlePromise(dataPromise);

```



**State Transitions with async/await:**



```javascript

async function processData() {

  try {

    // Promise returned by fetch starts in pending

    const response = await fetch('/api/data'); // Waits for fulfilled

    

    // If fulfilled, continue

    const data = await response.json();

    return data; // Returns fulfilled promise with data

    

  } catch (error) {

    // If rejected, catch block runs

    console.error('Error:', error);

    throw error; // Returns rejected promise

  }

}



// The async function itself returns a promise

const resultPromise = processData(); // Pending

console.log(resultPromise); // Promise { <pending> }



resultPromise

  .then(data => console.log('Success:', data)) // Fulfilled

  .catch(error => console.error('Failed:', error)); // Rejected

```



**Common Patterns:**



**1. Creating Pre-Settled Promises:**



```javascript

// Immediately fulfilled

const fulfilled = Promise.resolve('value');



// Immediately rejected

const rejected = Promise.reject(new Error('error'));



// Use for testing or wrapping sync values

function getUserFromCache(id) {

  const cached = cache.get(id);

  

  if (cached) {

    return Promise.resolve(cached); // Already fulfilled

  }

  

  return fetch(`/api/users/${id}`); // Pending promise

}

```



**2. Converting Callbacks to Promises:**



```javascript

function readFilePromise(path) {

  return new Promise((resolve, reject) => {

    // Starts in pending state

    

    fs.readFile(path, 'utf8', (error, data) => {

      if (error) {

        reject(error); // Transition to rejected

      } else {

        resolve(data); // Transition to fulfilled

      }

    });

  });

}



// Usage

const filePromise = readFilePromise('file.txt'); // Pending

filePromise

  .then(content => console.log('Content:', content)) // Fulfilled

  .catch(error => console.error('Error:', error)); // Rejected

```



**3. State-Based UI Updates:**



```javascript

class DataLoader {

  constructor() {

    this.state = 'idle'; // Not started yet

  }

  

  async load() {

    this.state = 'loading'; // Similar to pending

    this.updateUI();

    

    try {

      const data = await fetchData();

      this.state = 'success'; // Similar to fulfilled

      this.data = data;

    } catch (error) {

      this.state = 'error'; // Similar to rejected

      this.error = error;

    }

    

    this.updateUI();

  }

  

  updateUI() {

    if (this.state === 'loading') {

      showSpinner();

    } else if (this.state === 'success') {

      hideSpinner();

      displayData(this.data);

    } else if (this.state === 'error') {

      hideSpinner();

      displayError(this.error);

    }

  }

}

```



**Error States:**



```javascript

// Different ways to reject

const promise1 = new Promise((resolve, reject) => {

  reject(new Error('Error object')); // ✅ Best practice

});



const promise2 = new Promise((resolve, reject) => {

  reject('String error'); // ⚠️ Works but not recommended

});



const promise3 = new Promise((resolve, reject) => {

  throw new Error('Thrown error'); // ✅ Automatically rejected

});



const promise4 = Promise.reject(new Error('Immediate reject')); // ✅



// All transition to rejected state

```



**Unhandled Rejections:**



```javascript

// ❌ Unhandled rejection warning

const promise = Promise.reject(new Error('Oops'));

// Warning: Unhandled promise rejection



// ✅ Always handle rejections

Promise.reject(new Error('Oops'))

  .catch(error => console.error('Handled:', error));



// ✅ Or use global handler

window.addEventListener('unhandledrejection', event => {

  console.error('Unhandled rejection:', event.reason);

  event.preventDefault(); // Prevent default warning

});



process.on('unhandledRejection', (reason, promise) => {

  console.error('Unhandled rejection at:', promise, 'reason:', reason);

});

```



**Best Practices:**

- Promises start in **pending** state

- **Resolve** for success, **reject** for failure

- State is **immutable** once settled

- Always handle both fulfilled and rejected states

- Use `.catch()` to handle rejection

- Use `.finally()` for cleanup regardless of state

- Create Error objects for rejections (not strings)

- Monitor unhandled rejections in production

- Understand state to debug async flows



**Key Takeaways:**

- Three states: **pending**, **fulfilled**, **rejected**

- Pending → Fulfilled (via resolve)

- Pending → Rejected (via reject)

- Once settled (fulfilled/rejected), state cannot change

- Fulfilled promises have a value

- Rejected promises have a reason (error)

- Settled = fulfilled OR rejected (not pending)

- Understanding states is crucial for async error handling





</details>
<details><summary>53. What is the difference between Promise.all() and Promise.race()?</summary>






**Answer:**

`Promise.all()` waits for all promises to fulfill (or any to reject) and returns an array of results, while `Promise.race()` returns as soon as any promise settles (fulfilled or rejected), with that promise's result.



**Promise.all() - All or Nothing:**



**Syntax:** `Promise.all(iterable)`



**Behavior:**

- Waits for **all** promises to fulfill

- Returns array of results in same order

- Rejects immediately if **any** promise rejects

- Use for parallel operations that all must succeed



```javascript

const promise1 = Promise.resolve(1);

const promise2 = Promise.resolve(2);

const promise3 = Promise.resolve(3);



Promise.all([promise1, promise2, promise3])

  .then(results => {

    console.log(results); // [1, 2, 3]

    // All promises fulfilled

  })

  .catch(error => {

    console.error('At least one failed:', error);

  });



// Real-world example: Load multiple resources

Promise.all([

  fetch('/api/user'),

  fetch('/api/posts'),

  fetch('/api/comments')

])

  .then(responses => Promise.all(responses.map(r => r.json())))

  .then(([user, posts, comments]) => {

    console.log('All data loaded:', { user, posts, comments });

  })

  .catch(error => {

    console.error('Failed to load data:', error);

  });

```



**Promise.all() Rejection:**



```javascript

// If ANY promise rejects, Promise.all() rejects immediately

const promises = [

  Promise.resolve('Success 1'),

  Promise.reject('Error!'), // This causes rejection

  Promise.resolve('Success 2')

];



Promise.all(promises)

  .then(results => {

    console.log('All succeeded:', results); // Never runs

  })

  .catch(error => {

    console.error('Failed:', error); // 'Error!'

    // Other promises are ignored

  });



// Only the first rejection is caught

const promises2 = [

  Promise.reject('Error 1'),

  Promise.reject('Error 2'),

  Promise.resolve('Success')

];



Promise.all(promises2)

  .catch(error => {

    console.error(error); // 'Error 1' (first rejection)

  });

```



**Promise.race() - First to Finish:**



**Syntax:** `Promise.race(iterable)`



**Behavior:**

- Returns as soon as **any** promise settles

- Settles with the value/reason of the first settled promise

- Other promises continue but are ignored

- Use for timeouts or fastest response



```javascript

const slow = new Promise(resolve => 

  setTimeout(() => resolve('slow'), 2000)

);

const fast = new Promise(resolve => 

  setTimeout(() => resolve('fast'), 100)

);



Promise.race([slow, fast])

  .then(result => {

    console.log('Winner:', result); // 'fast'

    // Slow promise still runs but result is ignored

  });



// Real-world example: Request with timeout

const dataPromise = fetch('/api/data');

const timeoutPromise = new Promise((_, reject) =>

  setTimeout(() => reject(new Error('Timeout')), 5000)

);



Promise.race([dataPromise, timeoutPromise])

  .then(response => response.json())

  .then(data => console.log('Data:', data))

  .catch(error => console.error('Failed or timed out:', error));

```



**Key Differences:**



| Feature | Promise.all() | Promise.race() |

|---------|---------------|----------------|

| **Waits for** | All promises | First promise |

| **Returns** | Array of all results | Single result (first) |

| **Fulfills when** | All fulfill | First fulfills |

| **Rejects when** | Any rejects | First rejects |

| **Use case** | All operations needed | First response wins |

| **Result order** | Same as input order | N/A (single result) |



**Detailed Comparison:**



**1. Fulfillment:**



```javascript

// Promise.all - waits for all

const all = Promise.all([

  delay(100, 'A'),

  delay(200, 'B'),

  delay(50, 'C')

]);



all.then(results => {

  console.log(results); // ['A', 'B', 'C'] after 200ms

  // Waits for slowest (200ms)

});



// Promise.race - first to finish

const race = Promise.race([

  delay(100, 'A'),

  delay(200, 'B'),

  delay(50, 'C')

]);



race.then(result => {

  console.log(result); // 'C' after 50ms

  // Returns fastest (50ms)

});



function delay(ms, value) {

  return new Promise(resolve => setTimeout(() => resolve(value), ms));

}

```



**2. Rejection:**



```javascript

// Promise.all - fails fast on ANY rejection

const all = Promise.all([

  delay(100, 'A'),

  Promise.reject('Error'), // Immediate rejection

  delay(200, 'B')

]);



all.catch(error => {

  console.error('All failed:', error); // 'Error' immediately

  // Doesn't wait for other promises

});



// Promise.race - returns first (fulfill or reject)

const race = Promise.race([

  delay(100, 'A'),

  Promise.reject('Error'), // Immediate rejection

  delay(200, 'B')

]);



race.catch(error => {

  console.error('Race failed:', error); // 'Error' immediately

  // First to settle (reject) wins

});

```



**Practical Use Cases:**



**Promise.all() Use Cases:**



**1. Load Multiple Resources:**



```javascript

async function loadDashboard() {

  try {

    const [user, posts, comments, stats] = await Promise.all([

      fetchUser(userId),

      fetchPosts(),

      fetchComments(),

      fetchStats()

    ]);

    

    return { user, posts, comments, stats };

  } catch (error) {

    console.error('Failed to load dashboard:', error);

  }

}



// Much faster than sequential loading

// Sequential: 2s + 2s + 1s + 1s = 6s

// Parallel: max(2s, 2s, 1s, 1s) = 2s

```



**2. Batch Operations:**



```javascript

async function createMultipleUsers(userDataArray) {

  const promises = userDataArray.map(userData => 

    createUser(userData)

  );

  

  try {

    const users = await Promise.all(promises);

    console.log('All users created:', users);

    return users;

  } catch (error) {

    console.error('Failed to create some users:', error);

    // If one fails, all fail

  }

}

```



**3. Parallel File Processing:**



```javascript

const fs = require('fs').promises;



async function processFiles(filePaths) {

  const readPromises = filePaths.map(path => 

    fs.readFile(path, 'utf8')

  );

  

  try {

    const contents = await Promise.all(readPromises);

    

    // Process all contents

    const processed = contents.map(content => 

      processContent(content)

    );

    

    return processed;

  } catch (error) {

    console.error('Failed to read files:', error);

  }

}

```



**4. Validation:**



```javascript

async function validateForm(formData) {

  // Run all validations in parallel

  const validations = await Promise.all([

    validateEmail(formData.email),

    validatePassword(formData.password),

    validateUsername(formData.username),

    checkUsernameAvailable(formData.username)

  ]);

  

  // All validations must pass

  return validations.every(result => result.valid);

}

```



**Promise.race() Use Cases:**



**1. Timeout Wrapper:**



```javascript

function fetchWithTimeout(url, timeout = 5000) {

  const fetchPromise = fetch(url);

  const timeoutPromise = new Promise((_, reject) =>

    setTimeout(() => reject(new Error('Request timeout')), timeout)

  );

  

  return Promise.race([fetchPromise, timeoutPromise]);

}



// Usage

try {

  const response = await fetchWithTimeout('/api/data', 3000);

  const data = await response.json();

  console.log('Data:', data);

} catch (error) {

  if (error.message === 'Request timeout') {

    console.error('Request timed out');

  } else {

    console.error('Request failed:', error);

  }

}

```



**2. First Successful Response:**



```javascript

async function fetchFromMultipleSources() {

  const urls = [

    'https://api1.example.com/data',

    'https://api2.example.com/data',

    'https://api3.example.com/data'

  ];

  

  try {

    // Use first successful response

    const response = await Promise.race(urls.map(url => fetch(url)));

    return await response.json();

  } catch (error) {

    console.error('All sources failed:', error);

  }

}

```



**3. User Interaction Timeout:**



```javascript

async function getUserInput() {

  const userInputPromise = waitForUserClick();

  const timeoutPromise = delay(10000, 'timeout');

  

  const result = await Promise.race([

    userInputPromise,

    timeoutPromise

  ]);

  

  if (result === 'timeout') {

    console.log('User took too long');

    return null;

  }

  

  return result;

}

```



**4. Cache with Fallback:**



```javascript

async function getDataWithCache(key) {

  const cachePromise = getFromCache(key);

  const networkPromise = fetchFromNetwork(key);

  

  // Return whichever resolves first

  try {

    const data = await Promise.race([cachePromise, networkPromise]);

    console.log('Got data from:', data.source);

    return data;

  } catch (error) {

    console.error('Both failed:', error);

  }

}

```



**Advanced Patterns:**



**1. Promise.all() with Error Handling:**



```javascript

// Wrap each promise to handle errors individually

async function allWithErrorHandling(promises) {

  const wrappedPromises = promises.map(promise =>

    promise

      .then(value => ({ status: 'fulfilled', value }))

      .catch(error => ({ status: 'rejected', reason: error }))

  );

  

  return Promise.all(wrappedPromises);

}



// Usage

const results = await allWithErrorHandling([

  fetchUser(1),

  fetchUser(2),

  fetchUser(3)

]);



results.forEach((result, index) => {

  if (result.status === 'fulfilled') {

    console.log(`User ${index + 1}:`, result.value);

  } else {

    console.error(`User ${index + 1} failed:`, result.reason);

  }

});



// Modern alternative: Promise.allSettled()

const results2 = await Promise.allSettled([

  fetchUser(1),

  fetchUser(2),

  fetchUser(3)

]);

```



**2. Race with All Results:**



```javascript

// Get first result but track all

function raceWithAll(promises) {

  const results = [];

  let firstResult;

  let firstError;

  

  const wrappers = promises.map((promise, index) =>

    promise

      .then(value => {

        results[index] = { status: 'fulfilled', value };

        if (firstResult === undefined) {

          firstResult = value;

        }

        return value;

      })

      .catch(error => {

        results[index] = { status: 'rejected', reason: error };

        if (firstError === undefined) {

          firstError = error;

        }

        throw error;

      })

  );

  

  return Promise.race(wrappers).then(

    value => ({ winner: value, results }),

    error => ({ winner: error, results })

  );

}

```



**3. Batch with Concurrency Limit:**



```javascript

// Process promises in batches (not all at once)

async function promiseAllWithLimit(promises, limit) {

  const results = [];

  const executing = [];

  

  for (const [index, promise] of promises.entries()) {

    const p = Promise.resolve(promise).then(value => {

      results[index] = value;

      return value;

    });

    

    results.push(p);

    

    if (limit <= promises.length) {

      const e = p.then(() => executing.splice(executing.indexOf(e), 1));

      executing.push(e);

      

      if (executing.length >= limit) {

        await Promise.race(executing);

      }

    }

  }

  

  return Promise.all(results);

}



// Process max 5 at a time

const userIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const userPromises = userIds.map(id => fetchUser(id));

const users = await promiseAllWithLimit(userPromises, 5);

```



**Related Methods:**



**Promise.allSettled() - Like all() but doesn't fail:**



```javascript

const promises = [

  Promise.resolve('Success 1'),

  Promise.reject('Error'),

  Promise.resolve('Success 2')

];



const results = await Promise.allSettled(promises);

console.log(results);

// [

//   { status: 'fulfilled', value: 'Success 1' },

//   { status: 'rejected', reason: 'Error' },

//   { status: 'fulfilled', value: 'Success 2' }

// ]



// Use when you want all results regardless of failures

```



**Promise.any() - First fulfilled (ignores rejections):**



```javascript

const promises = [

  Promise.reject('Error 1'),

  Promise.resolve('Success'),

  Promise.reject('Error 2')

];



const result = await Promise.any(promises);

console.log(result); // 'Success'



// Only fails if ALL reject

const allFail = [

  Promise.reject('Error 1'),

  Promise.reject('Error 2')

];



try {

  await Promise.any(allFail);

} catch (error) {

  console.error('All failed:', error); // AggregateError

}

```



**Comparison Table:**



| Method | Fulfills When | Rejects When | Use When |

|--------|---------------|--------------|----------|

| `Promise.all()` | All fulfill | Any rejects | Need all results |

| `Promise.race()` | First settles | First rejects | First response wins |

| `Promise.allSettled()` | All settle | Never (always fulfills) | Want all outcomes |

| `Promise.any()` | First fulfills | All reject | Any success is enough |



**Performance Considerations:**



```javascript

// Sequential (slow) - 6 seconds total

const user = await fetchUser(1);      // 2s

const posts = await fetchPosts();     // 2s

const comments = await fetchComments(); // 2s



// Promise.all (fast) - 2 seconds total (parallel)

const [user, posts, comments] = await Promise.all([

  fetchUser(1),      // 2s

  fetchPosts(),      // 2s

  fetchComments()    // 2s

]);



// Promise.race - 0.5 seconds (fastest)

const fastest = await Promise.race([

  fetchFromServer1(), // 2s

  fetchFromServer2(), // 0.5s ← wins

  fetchFromServer3()  // 1s

]);

```



**Common Mistakes:**



**1. Using race when you need all:**



```javascript

// ❌ Wrong - only gets first result

const result = await Promise.race([

  fetchUser(1),

  fetchPosts(),

  fetchComments()

]);

// Missing other data!



// ✅ Correct - gets all results

const [user, posts, comments] = await Promise.all([

  fetchUser(1),

  fetchPosts(),

  fetchComments()

]);

```



**2. Not handling all errors:**



```javascript

// ❌ One failure stops everything

await Promise.all([

  fetchUser(1),

  fetchUser(2),  // Fails

  fetchUser(3)   // Never processed

]);



// ✅ Handle errors individually

const results = await Promise.allSettled([

  fetchUser(1),

  fetchUser(2),

  fetchUser(3)

]);

```



**Best Practices:**

- Use **Promise.all()** for parallel operations (all needed)

- Use **Promise.race()** for timeouts or fastest response

- Use **Promise.allSettled()** when all outcomes matter

- Use **Promise.any()** when any success is sufficient

- Handle errors appropriately for each method

- Consider concurrency limits for many promises

- Monitor performance in production

- Document expected behavior for team



**Key Takeaways:**

- **Promise.all()**: Waits for all, rejects if any fails

- **Promise.race()**: Returns first to settle (fulfill or reject)

- all() returns array of results in order

- race() returns single result (first)

- all() is for parallel "must-have-all" operations

- race() is for timeouts and fastest-response scenarios

- allSettled() and any() are modern alternatives

- Understanding differences prevents bugs in async code





</details>
<details><summary>54. What is async/await?</summary>






**Answer:**

`async/await` is syntactic sugar built on top of Promises that makes asynchronous code look and behave like synchronous code. An `async` function always returns a Promise, and `await` pauses execution until a Promise resolves, making async code more readable and easier to debug.



**Basic Syntax:**



```javascript

// Function declared with async keyword

async function fetchData() {

  // await pauses execution until promise resolves

  const response = await fetch('/api/data');

  const data = await response.json();

  return data; // Automatically wrapped in Promise

}



// Equivalent using Promises

function fetchDataPromise() {

  return fetch('/api/data')

    .then(response => response.json())

    .then(data => data);

}



// Both return promises

fetchData().then(data => console.log(data));

fetchDataPromise().then(data => console.log(data));

```



**The async Keyword:**



```javascript

// async makes function return a Promise

async function getMessage() {

  return 'Hello'; // Automatically wrapped in Promise.resolve()

}



// Equivalent to:

function getMessagePromise() {

  return Promise.resolve('Hello');

}



// Both work the same

getMessage().then(msg => console.log(msg)); // 'Hello'

getMessagePromise().then(msg => console.log(msg)); // 'Hello'



// async function always returns Promise

async function getNumber() {

  return 42;

}



console.log(getNumber()); // Promise { 42 }



// Can also return Promise explicitly

async function getUser() {

  return Promise.resolve({ id: 1, name: 'John' });

}

```



**The await Keyword:**



```javascript

// await pauses execution until Promise settles

async function example() {

  console.log('1: Start');

  

  const result = await Promise.resolve('2: Resolved');

  console.log(result);

  

  console.log('3: End');

}



example();

console.log('4: After function call');



// Output:

// 1: Start

// 4: After function call

// 2: Resolved

// 3: End



// await only works inside async functions

function notAsync() {

  // const result = await fetch('/api/data'); // ❌ SyntaxError

}



// ✅ Must be in async function

async function isAsync() {

  const result = await fetch('/api/data'); // ✅ Works

}

```



**Error Handling:**



**Using try/catch:**



```javascript

async function fetchUser(id) {

  try {

    const response = await fetch(`/api/users/${id}`);

    

    if (!response.ok) {

      throw new Error(`HTTP ${response.status}`);

    }

    

    const user = await response.json();

    return user;

    

  } catch (error) {

    console.error('Error fetching user:', error);

    throw error; // Re-throw or handle

  }

}



// Usage

try {

  const user = await fetchUser(1);

  console.log('User:', user);

} catch (error) {

  console.error('Failed:', error);

}

```



**Multiple try/catch blocks:**



```javascript

async function loadData() {

  let user, posts;

  

  // Try user fetch

  try {

    user = await fetchUser(1);

    console.log('User loaded:', user);

  } catch (error) {

    console.error('User fetch failed:', error);

    user = null; // Provide default

  }

  

  // Try posts fetch (continues even if user failed)

  try {

    posts = await fetchPosts();

    console.log('Posts loaded:', posts);

  } catch (error) {

    console.error('Posts fetch failed:', error);

    posts = [];

  }

  

  return { user, posts };

}

```



**Sequential vs Parallel Execution:**



**Sequential (one after another):**



```javascript

// Waits for each operation before starting next

async function sequential() {

  console.time('sequential');

  

  const user = await fetchUser(1);        // 2 seconds

  const posts = await fetchPosts();       // 2 seconds

  const comments = await fetchComments(); // 2 seconds

  

  console.timeEnd('sequential'); // ~6 seconds

  

  return { user, posts, comments };

}

```



**Parallel (all at once):**



```javascript

// Starts all operations simultaneously

async function parallel() {

  console.time('parallel');

  

  // Start all promises

  const [user, posts, comments] = await Promise.all([

    fetchUser(1),       // 2 seconds

    fetchPosts(),       // 2 seconds

    fetchComments()     // 2 seconds

  ]);

  

  console.timeEnd('parallel'); // ~2 seconds (much faster!)

  

  return { user, posts, comments };

}



// Alternative syntax

async function parallelAlt() {

  // Start all (don't await yet)

  const userPromise = fetchUser(1);

  const postsPromise = fetchPosts();

  const commentsPromise = fetchComments();

  

  // Now await all

  const user = await userPromise;

  const posts = await postsPromise;

  const comments = await commentsPromise;

  

  return { user, posts, comments };

}

```



**Conditional Await:**



```javascript

async function loadUserData(userId, includeDetails = false) {

  // Always load user

  const user = await fetchUser(userId);

  

  if (includeDetails) {

    // Only load if needed

    user.posts = await fetchPosts(userId);

    user.comments = await fetchComments(userId);

  }

  

  return user;

}



// Dependent operations

async function processOrder(orderId) {

  const order = await fetchOrder(orderId);

  

  if (order.status === 'pending') {

    // Only process if pending

    const payment = await processPayment(order);

    const shipment = await createShipment(order);

    return { order, payment, shipment };

  }

  

  return { order };

}

```



**Practical Examples:**



**1. API Request:**



```javascript

async function getUser(id) {

  try {

    const response = await fetch(`https://api.example.com/users/${id}`);

    

    if (!response.ok) {

      throw new Error(`HTTP error! status: ${response.status}`);

    }

    

    const user = await response.json();

    console.log('User:', user);

    return user;

    

  } catch (error) {

    console.error('Failed to fetch user:', error);

    return null;

  }

}



// Usage

const user = await getUser(1);

if (user) {

  displayUser(user);

} else {

  showError('User not found');

}

```



**2. Multiple API Calls:**



```javascript

async function loadDashboard(userId) {

  try {

    // Load all data in parallel

    const [user, posts, notifications, stats] = await Promise.all([

      fetchUser(userId),

      fetchUserPosts(userId),

      fetchNotifications(userId),

      fetchUserStats(userId)

    ]);

    

    return {

      user,

      posts,

      notifications,

      stats,

      loadedAt: new Date()

    };

    

  } catch (error) {

    console.error('Dashboard load failed:', error);

    throw error;

  }

}



// Usage

async function initDashboard() {

  showLoadingSpinner();

  

  try {

    const dashboardData = await loadDashboard(currentUserId);

    renderDashboard(dashboardData);

  } catch (error) {

    showError('Failed to load dashboard');

  } finally {

    hideLoadingSpinner();

  }

}

```



**3. Form Submission:**



```javascript

async function handleSubmit(event) {

  event.preventDefault();

  

  const formData = new FormData(event.target);

  const data = Object.fromEntries(formData);

  

  // Disable button

  submitButton.disabled = true;

  submitButton.textContent = 'Submitting...';

  

  try {

    const response = await fetch('/api/submit', {

      method: 'POST',

      headers: { 'Content-Type': 'application/json' },

      body: JSON.stringify(data)

    });

    

    if (!response.ok) {

      const error = await response.json();

      throw new Error(error.message);

    }

    

    const result = await response.json();

    showSuccess('Form submitted successfully!');

    return result;

    

  } catch (error) {

    showError(`Submission failed: ${error.message}`);

  } finally {

    // Re-enable button

    submitButton.disabled = false;

    submitButton.textContent = 'Submit';

  }

}



form.addEventListener('submit', handleSubmit);

```



**4. Retry Logic:**



```javascript

async function fetchWithRetry(url, options = {}, maxRetries = 3) {

  for (let i = 0; i < maxRetries; i++) {

    try {

      console.log(`Attempt ${i + 1}/${maxRetries}`);

      

      const response = await fetch(url, options);

      

      if (!response.ok) {

        throw new Error(`HTTP ${response.status}`);

      }

      

      return await response.json();

      

    } catch (error) {

      console.error(`Attempt ${i + 1} failed:`, error.message);

      

      // If last retry, throw error

      if (i === maxRetries - 1) {

        throw new Error(`Failed after ${maxRetries} attempts`);

      }

      

      // Exponential backoff

      const delay = Math.pow(2, i) * 1000;

      console.log(`Retrying in ${delay}ms...`);

      await new Promise(resolve => setTimeout(resolve, delay));

    }

  }

}



// Usage

try {

  const data = await fetchWithRetry('https://api.example.com/data');

  console.log('Data:', data);

} catch (error) {

  console.error('All retries failed:', error);

}

```



**5. Async Loops:**



```javascript

// Sequential processing

async function processUsersSequentially(userIds) {

  const results = [];

  

  for (const id of userIds) {

    const user = await fetchUser(id); // Waits for each

    const processed = await processUser(user);

    results.push(processed);

  }

  

  return results; // Slow: 10 users × 2s = 20s

}



// Parallel processing

async function processUsersParallel(userIds) {

  const promises = userIds.map(async (id) => {

    const user = await fetchUser(id);

    return await processUser(user);

  });

  

  return await Promise.all(promises); // Fast: ~2s

}



// Controlled concurrency

async function processUsersBatch(userIds, batchSize = 5) {

  const results = [];

  

  for (let i = 0; i < userIds.length; i += batchSize) {

    const batch = userIds.slice(i, i + batchSize);

    

    const batchResults = await Promise.all(

      batch.map(id => fetchUser(id))

    );

    

    results.push(...batchResults);

    console.log(`Processed batch ${i / batchSize + 1}`);

  }

  

  return results;

}

```



**6. Async Iteration:**



```javascript

// Async generator

async function* fetchPages(url) {

  let page = 1;

  let hasMore = true;

  

  while (hasMore) {

    const response = await fetch(`${url}?page=${page}`);

    const data = await response.json();

    

    yield data;

    

    hasMore = data.hasMore;

    page++;

  }

}



// Usage

async function loadAllPages() {

  for await (const pageData of fetchPages('/api/items')) {

    console.log('Page:', pageData);

    displayItems(pageData.items);

  }

}

```



**Top-Level await (ES2022):**



```javascript

// In modules, you can use await at top level

// file: data.js

export const users = await fetch('/api/users').then(r => r.json());

export const posts = await fetch('/api/posts').then(r => r.json());



// file: app.js

import { users, posts } from './data.js';

console.log('Data loaded:', users, posts);



// Before: had to wrap in async function

// (async () => {

//   const users = await fetchUsers();

//   console.log(users);

// })();

```



**Common Patterns:**



**1. Wrapper with Timeout:**



```javascript

function withTimeout(promise, ms) {

  return Promise.race([

    promise,

    new Promise((_, reject) =>

      setTimeout(() => reject(new Error('Timeout')), ms)

    )

  ]);

}



// Usage

async function fetchWithTimeout(url) {

  try {

    const response = await withTimeout(fetch(url), 5000);

    return await response.json();

  } catch (error) {

    if (error.message === 'Timeout') {

      console.error('Request timed out');

    }

    throw error;

  }

}

```



**2. Async Reduce:**



```javascript

async function asyncReduce(array, asyncFn, initialValue) {

  let accumulator = initialValue;

  

  for (const item of array) {

    accumulator = await asyncFn(accumulator, item);

  }

  

  return accumulator;

}



// Usage

const userIds = [1, 2, 3, 4, 5];

const totalPosts = await asyncReduce(

  userIds,

  async (total, userId) => {

    const posts = await fetchUserPosts(userId);

    return total + posts.length;

  },

  0

);

console.log('Total posts:', totalPosts);

```



**3. Async Event Handler:**



```javascript

button.addEventListener('click', async (event) => {

  event.target.disabled = true;

  

  try {

    const data = await fetchData();

    displayData(data);

  } catch (error) {

    showError(error.message);

  } finally {

    event.target.disabled = false;

  }

});

```



**Common Mistakes:**



**1. Forgetting await:**



```javascript

// ❌ Doesn't wait (returns Promise)

async function getUser() {

  const user = fetchUser(1); // Missing await!

  console.log(user); // Promise { <pending> }

  return user.name; // Error: undefined

}



// ✅ Correct

async function getUser() {

  const user = await fetchUser(1);

  console.log(user); // { id: 1, name: 'John' }

  return user.name; // 'John'

}

```



**2. Using await in non-async function:**



```javascript

// ❌ SyntaxError

function getData() {

  const data = await fetchData(); // Error!

  return data;

}



// ✅ Must be async

async function getData() {

  const data = await fetchData();

  return data;

}

```



**3. Sequential when could be parallel:**



```javascript

// ❌ Slow - 6 seconds

async function loadData() {

  const user = await fetchUser();      // 2s

  const posts = await fetchPosts();    // 2s

  const comments = await fetchComments(); // 2s

  return { user, posts, comments };

}



// ✅ Fast - 2 seconds

async function loadData() {

  const [user, posts, comments] = await Promise.all([

    fetchUser(),

    fetchPosts(),

    fetchComments()

  ]);

  return { user, posts, comments };

}

```



**4. Not handling errors:**



```javascript

// ❌ Unhandled errors

async function riskyOperation() {

  const data = await fetchData(); // Might throw

  return data;

}



// ✅ Handle errors

async function safeOperation() {

  try {

    const data = await fetchData();

    return data;

  } catch (error) {

    console.error('Error:', error);

    return null; // or throw

  }

}

```



**5. Async in forEach:**



```javascript

// ❌ Doesn't wait for async operations

const userIds = [1, 2, 3];

userIds.forEach(async (id) => {

  const user = await fetchUser(id);

  console.log(user);

});

console.log('Done'); // Prints before users



// ✅ Use for...of

for (const id of userIds) {

  const user = await fetchUser(id);

  console.log(user);

}

console.log('Done'); // Prints after all users



// ✅ Or Promise.all

await Promise.all(

  userIds.map(id => fetchUser(id))

);

```



**Async/Await vs Promises:**



```javascript

// Promises

function loadUser(id) {

  return fetchUser(id)

    .then(user => fetchPosts(user.id))

    .then(posts => fetchComments(posts[0].id))

    .then(comments => comments)

    .catch(error => {

      console.error('Error:', error);

      throw error;

    });

}



// Async/await (more readable)

async function loadUser(id) {

  try {

    const user = await fetchUser(id);

    const posts = await fetchPosts(user.id);

    const comments = await fetchComments(posts[0].id);

    return comments;

  } catch (error) {

    console.error('Error:', error);

    throw error;

  }

}

```



**Best Practices:**

- Use **async/await** for cleaner, more readable async code

- Always use **try/catch** for error handling

- Run **independent operations in parallel** with Promise.all()

- Don't use await in loops unless sequential is required

- Handle errors at appropriate levels

- Use finally for cleanup operations

- Avoid mixing async/await with .then/.catch

- Consider top-level await in ES modules

- Test async error paths thoroughly



**Key Takeaways:**

- **async** function always returns a Promise

- **await** pauses execution until Promise resolves

- Works only inside async functions (or top-level in modules)

- Makes async code look synchronous

- Use **try/catch** for error handling

- Run independent operations in parallel (Promise.all)

- Cleaner than Promise chains

- Foundation of modern async JavaScript





</details>
<details><summary>55. What is the difference between setTimeout and setInterval?</summary>






**Answer:**

`setTimeout()` executes a function once after a specified delay, while `setInterval()` executes a function repeatedly at specified time intervals until cleared. setTimeout runs once, setInterval runs continuously.



**setTimeout() - Execute Once:**



**Syntax:** `setTimeout(callback, delay, arg1, arg2, ...)`



```javascript

// Basic usage

setTimeout(() => {

  console.log('Executed after 2 seconds');

}, 2000);



console.log('This runs immediately');



// Output:

// This runs immediately

// (2 seconds later)

// Executed after 2 seconds



// With arguments

setTimeout((name, age) => {

  console.log(`${name} is ${age} years old`);

}, 1000, 'John', 30);



// Store timer ID for clearing

const timerId = setTimeout(() => {

  console.log('This will execute');

}, 5000);



// Cancel before it runs

clearTimeout(timerId);

console.log('Timer cancelled');

```



**setInterval() - Execute Repeatedly:**



**Syntax:** `setInterval(callback, delay, arg1, arg2, ...)`



```javascript

// Basic usage - runs every second

let count = 0;



const intervalId = setInterval(() => {

  count++;

  console.log(`Count: ${count}`);

  

  // Stop after 5 executions

  if (count >= 5) {

    clearInterval(intervalId);

    console.log('Interval stopped');

  }

}, 1000);



// Output (every second):

// Count: 1

// Count: 2

// Count: 3

// Count: 4

// Count: 5

// Interval stopped



// With arguments

setInterval((message) => {

  console.log(message);

}, 2000, 'Hello every 2 seconds');

```



**Key Differences:**



| Feature | setTimeout | setInterval |

|---------|-----------|-------------|

| **Executions** | Once | Repeatedly |

| **When** | After delay | Every interval |

| **Stops** | Automatically after execution | Must call clearInterval() |

| **Use case** | Delayed action | Periodic updates |

| **Timing** | Delay + execution time | May drift if execution is slow |

| **Clear function** | clearTimeout() | clearInterval() |



**Timing Behavior:**



**setTimeout:**



```javascript

console.log('Start:', Date.now());



setTimeout(() => {

  console.log('Timeout:', Date.now());

  // Heavy operation

  for (let i = 0; i < 1000000000; i++) {}

  console.log('Done:', Date.now());

}, 1000);



// Timeline:

// 0ms: Start

// 1000ms: Timeout executes

// 3000ms: Done (after heavy operation)

// Next setTimeout would start fresh

```



**setInterval:**



```javascript

console.log('Start:', Date.now());



let count = 0;

const intervalId = setInterval(() => {

  console.log(`Execution ${++count}:`, Date.now());

  

  // Heavy operation (takes 500ms)

  const start = Date.now();

  while (Date.now() - start < 500) {}

  

  if (count >= 3) clearInterval(intervalId);

}, 1000);



// Timeline:

// 0ms: Start

// 1000ms: Execution 1 (takes 500ms until 1500ms)

// 2000ms: Execution 2 (takes 500ms until 2500ms)

// 3000ms: Execution 3 (takes 500ms until 3500ms)

// Note: Interval doesn't wait for execution to complete

```



**Practical Examples:**



**setTimeout Use Cases:**



**1. Delayed Action:**



```javascript

// Show notification, hide after 3 seconds

function showNotification(message) {

  const notification = document.createElement('div');

  notification.textContent = message;

  notification.className = 'notification';

  document.body.appendChild(notification);

  

  // Remove after 3 seconds

  setTimeout(() => {

    notification.remove();

  }, 3000);

}



showNotification('File saved successfully!');

```



**2. Debouncing:**



```javascript

let timeoutId;



function debounce(func, delay) {

  return function(...args) {

    clearTimeout(timeoutId);

    timeoutId = setTimeout(() => {

      func.apply(this, args);

    }, delay);

  };

}



// Usage: Search after user stops typing

const searchInput = document.getElementById('search');

const debouncedSearch = debounce((query) => {

  console.log('Searching for:', query);

  performSearch(query);

}, 300);



searchInput.addEventListener('input', (e) => {

  debouncedSearch(e.target.value);

});

```



**3. Async Operation Timeout:**



```javascript

function fetchWithTimeout(url, timeout = 5000) {

  return new Promise((resolve, reject) => {

    const timer = setTimeout(() => {

      reject(new Error('Request timeout'));

    }, timeout);

    

    fetch(url)

      .then(response => {

        clearTimeout(timer);

        resolve(response);

      })

      .catch(error => {

        clearTimeout(timer);

        reject(error);

      });

  });

}



// Usage

try {

  const response = await fetchWithTimeout('/api/data', 3000);

  const data = await response.json();

} catch (error) {

  console.error('Request failed or timed out:', error);

}

```



**4. Recursive setTimeout (Alternative to setInterval):**



```javascript

// Better than setInterval - waits for completion

function recursiveTimeout() {

  console.log('Task executed:', new Date().toLocaleTimeString());

  

  // Schedule next execution after this one completes

  setTimeout(recursiveTimeout, 1000);

}



// Start the cycle

recursiveTimeout();



// With async operations

async function poll() {

  try {

    const data = await fetchData();

    processData(data);

  } catch (error) {

    console.error('Error:', error);

  }

  

  // Wait 5 seconds before next poll

  setTimeout(poll, 5000);

}



poll();

```



**setInterval Use Cases:**



**1. Clock/Timer:**



```javascript

function updateClock() {

  const now = new Date();

  const timeString = now.toLocaleTimeString();

  document.getElementById('clock').textContent = timeString;

}



// Update every second

const clockInterval = setInterval(updateClock, 1000);

updateClock(); // Initial call



// Stop clock

// clearInterval(clockInterval);

```



**2. Countdown Timer:**



```javascript

function startCountdown(seconds) {

  let remaining = seconds;

  

  // Update immediately

  updateDisplay(remaining);

  

  const intervalId = setInterval(() => {

    remaining--;

    updateDisplay(remaining);

    

    if (remaining <= 0) {

      clearInterval(intervalId);

      console.log('Countdown finished!');

      onCountdownComplete();

    }

  }, 1000);

  

  return intervalId; // Return so it can be cancelled

}



function updateDisplay(seconds) {

  const minutes = Math.floor(seconds / 60);

  const secs = seconds % 60;

  console.log(`${minutes}:${secs.toString().padStart(2, '0')}`);

}



// Start 5-minute countdown

const timerId = startCountdown(300);



// Cancel if needed

// clearInterval(timerId);

```



**3. Polling:**



```javascript

// Check for updates every 30 seconds

const pollingInterval = setInterval(async () => {

  try {

    const updates = await checkForUpdates();

    

    if (updates.length > 0) {

      console.log('New updates:', updates);

      displayUpdates(updates);

    }

  } catch (error) {

    console.error('Polling error:', error);

  }

}, 30000);



// Stop polling when user leaves

window.addEventListener('beforeunload', () => {

  clearInterval(pollingInterval);

});

```



**4. Animation:**



```javascript

let position = 0;

const element = document.getElementById('box');



const animationInterval = setInterval(() => {

  position += 5;

  element.style.left = position + 'px';

  

  // Stop at 500px

  if (position >= 500) {

    clearInterval(animationInterval);

  }

}, 16); // ~60fps



// Note: requestAnimationFrame is better for animations

```



**Problems with setInterval:**



**1. Time Drift:**



```javascript

// setInterval doesn't account for execution time

let executionCount = 0;

const startTime = Date.now();



const driftInterval = setInterval(() => {

  executionCount++;

  

  // Simulate slow operation (100ms)

  const opStart = Date.now();

  while (Date.now() - opStart < 100) {}

  

  const elapsed = Date.now() - startTime;

  const expected = executionCount * 1000;

  const drift = elapsed - expected;

  

  console.log(`Execution ${executionCount}: drift = ${drift}ms`);

  

  if (executionCount >= 5) clearInterval(driftInterval);

}, 1000);



// Output shows increasing drift:

// Execution 1: drift = 100ms

// Execution 2: drift = 200ms

// Execution 3: drift = 300ms

// etc.

```



**2. Execution Stacking:**



```javascript

// If operation takes longer than interval

setInterval(async () => {

  console.log('Starting long operation...');

  

  // Operation takes 3 seconds

  await new Promise(resolve => setTimeout(resolve, 3000));

  

  console.log('Operation complete');

}, 1000);



// With 1-second interval but 3-second operation:

// Multiple operations may queue up

// Can cause memory issues and performance problems

```



**3. Cannot Pause/Resume Easily:**



```javascript

// setInterval can't be paused

let intervalId = setInterval(() => {

  console.log('Running...');

}, 1000);



// To "pause", must clear and restart

function pauseInterval() {

  clearInterval(intervalId);

  intervalId = null;

}



function resumeInterval() {

  if (!intervalId) {

    intervalId = setInterval(() => {

      console.log('Running...');

    }, 1000);

  }

}

```



**Better Pattern: Recursive setTimeout:**



```javascript

// ✅ Better than setInterval - waits for completion

let isRunning = true;



async function task() {

  if (!isRunning) return;

  

  console.log('Task start:', Date.now());

  

  try {

    // Async operation

    await performOperation();

    console.log('Task complete:', Date.now());

  } catch (error) {

    console.error('Task error:', error);

  }

  

  // Schedule next execution after this completes

  setTimeout(task, 1000);

}



// Start

task();



// Stop (clean)

function stop() {

  isRunning = false;

}



// Advantages:

// - No drift (each execution starts fresh)

// - No stacking (waits for completion)

// - Easy to pause/resume

// - Better error handling

```



**Clearing Timers:**



```javascript

// setTimeout

const timeoutId = setTimeout(() => {

  console.log('This will not run');

}, 5000);



clearTimeout(timeoutId); // Cancel before execution



// setInterval

const intervalId = setInterval(() => {

  console.log('Repeating...');

}, 1000);



// Stop after 5 seconds

setTimeout(() => {

  clearInterval(intervalId);

  console.log('Interval stopped');

}, 5000);



// Clear multiple timers

const timers = [];

timers.push(setTimeout(() => {}, 1000));

timers.push(setTimeout(() => {}, 2000));

timers.push(setInterval(() => {}, 3000));



// Clear all

timers.forEach(id => {

  clearTimeout(id); // Works for both setTimeout and setInterval

  clearInterval(id);

});

```



**Minimum Delay:**



```javascript

// Browsers enforce minimum delay (~4ms in modern browsers)

setTimeout(() => {

  console.log('Not instant');

}, 0);



console.log('This runs first');



// Output:

// This runs first

// Not instant



// Actual delay is usually 4-10ms, not 0ms

const start = Date.now();

setTimeout(() => {

  console.log('Delay:', Date.now() - start, 'ms'); // ~4-10ms

}, 0);

```



**Background Tab Throttling:**



```javascript

// Browsers throttle timers in background tabs

// Minimum delay becomes ~1000ms



let count = 0;

const start = Date.now();



setInterval(() => {

  count++;

  const elapsed = Date.now() - start;

  console.log(`Count: ${count}, Elapsed: ${elapsed}ms`);

}, 100);



// Active tab: ~100ms intervals

// Background tab: ~1000ms intervals (throttled)

```



**Modern Alternatives:**



**requestAnimationFrame (for animations):**



```javascript

// Better than setInterval for animations

function animate() {

  // Update animation

  element.style.left = position + 'px';

  position += 5;

  

  if (position < 500) {

    requestAnimationFrame(animate); // Request next frame

  }

}



animate();



// Advantages:

// - Synced with display refresh (~60fps)

// - Paused when tab inactive

// - Better performance

```



**Web Workers (for background tasks):**



```javascript

// Heavy computation without blocking UI

const worker = new Worker('worker.js');



worker.postMessage({ task: 'process', data: largeDataSet });



worker.onmessage = (event) => {

  console.log('Result:', event.data);

};



// worker.js

setInterval(() => {

  // Heavy processing

  const result = processData();

  postMessage(result);

}, 1000);

```



**Common Patterns:**



**1. Self-Cancelling Timeout:**



```javascript

function autoHideNotification(element, delay = 3000) {

  const timerId = setTimeout(() => {

    element.remove();

  }, delay);

  

  // Cancel on user interaction

  element.addEventListener('click', () => {

    clearTimeout(timerId);

    element.remove();

  }, { once: true });

}

```



**2. Conditional Interval:**



```javascript

let shouldContinue = true;



const intervalId = setInterval(() => {

  if (!shouldContinue) {

    clearInterval(intervalId);

    return;

  }

  

  console.log('Task running...');

}, 1000);



// Stop from anywhere

function stopTask() {

  shouldContinue = false;

}

```



**3. Interval with Max Executions:**



```javascript

function setIntervalWithLimit(callback, delay, maxExecutions) {

  let count = 0;

  

  const intervalId = setInterval(() => {

    count++;

    callback(count);

    

    if (count >= maxExecutions) {

      clearInterval(intervalId);

    }

  }, delay);

  

  return intervalId;

}



// Run 10 times then stop

setIntervalWithLimit((count) => {

  console.log('Execution:', count);

}, 1000, 10);

```



**4. Throttling with setTimeout:**



```javascript

function throttle(func, delay) {

  let timeoutId;

  let lastRun = 0;

  

  return function(...args) {

    const now = Date.now();

    const timeSinceLastRun = now - lastRun;

    

    clearTimeout(timeoutId);

    

    if (timeSinceLastRun >= delay) {

      func.apply(this, args);

      lastRun = now;

    } else {

      timeoutId = setTimeout(() => {

        func.apply(this, args);

        lastRun = Date.now();

      }, delay - timeSinceLastRun);

    }

  };

}



// Usage: Limit scroll event handling

const throttledScroll = throttle(() => {

  console.log('Scroll position:', window.scrollY);

}, 200);



window.addEventListener('scroll', throttledScroll);

```



**Best Practices:**

- Use **setTimeout** for one-time delayed actions

- Use **setInterval** for periodic tasks (but consider recursive setTimeout)

- Always **clear timers** when no longer needed

- **Recursive setTimeout** preferred over setInterval for async operations

- Use **requestAnimationFrame** for animations

- Handle **cleanup** in component unmount/page unload

- Be aware of **background tab throttling**

- Store timer IDs to enable cancellation

- Consider **memory leaks** from uncancelled timers



**Key Takeaways:**

- **setTimeout**: Executes once after delay

- **setInterval**: Executes repeatedly at intervals

- Clear with **clearTimeout()** and **clearInterval()**

- setInterval can drift or stack executions

- Recursive setTimeout is often better than setInterval

- Minimum delay is ~4ms, not 0ms

- Background tabs are throttled to ~1000ms

- Always clean up timers to prevent memory leaks





</details>
<details><summary>56. What is callback hell?</summary>






**Answer:**

Callback hell (also called "pyramid of doom") is a situation where callbacks are nested within callbacks multiple levels deep, making code difficult to read, maintain, and debug. It typically occurs when handling multiple asynchronous operations that depend on each other.



**Example of Callback Hell:**



```javascript

// ❌ Callback hell - deeply nested, hard to read

getUserData(userId, (error, user) => {

  if (error) {

    console.error('Error getting user:', error);

    return;

  }

  

  getUserPosts(user.id, (error, posts) => {

    if (error) {

      console.error('Error getting posts:', error);

      return;

    }

    

    getPostComments(posts[0].id, (error, comments) => {

      if (error) {

        console.error('Error getting comments:', error);

        return;

      }

      

      getCommentAuthor(comments[0].authorId, (error, author) => {

        if (error) {

          console.error('Error getting author:', error);

          return;

        }

        

        getAuthorProfile(author.id, (error, profile) => {

          if (error) {

            console.error('Error getting profile:', error);

            return;

          }

          

          // Finally can use the data!

          console.log('Profile:', profile);

        });

      });

    });

  });

});



// The dreaded pyramid shape → → → → →

```



**Real-World Example:**



```javascript

// ❌ Callback hell with file operations

fs.readFile('config.json', 'utf8', (err, config) => {

  if (err) {

    console.error('Config error:', err);

    return;

  }

  

  const parsedConfig = JSON.parse(config);

  

  fs.readFile(parsedConfig.dataFile, 'utf8', (err, data) => {

    if (err) {

      console.error('Data error:', err);

      return;

    }

    

    const processedData = processData(data);

    

    fs.writeFile('output.txt', processedData, (err) => {

      if (err) {

        console.error('Write error:', err);

        return;

      }

      

      fs.readFile('template.html', 'utf8', (err, template) => {

        if (err) {

          console.error('Template error:', err);

          return;

        }

        

        const html = populateTemplate(template, processedData);

        

        fs.writeFile('index.html', html, (err) => {

          if (err) {

            console.error('HTML write error:', err);

            return;

          }

          

          console.log('All done!');

        });

      });

    });

  });

});

```



**Problems with Callback Hell:**



**1. Readability:**

- Code grows horizontally (pyramid shape)

- Difficult to follow the flow

- Hard to understand at a glance



**2. Maintainability:**

- Hard to add new steps

- Difficult to modify existing logic

- Error-prone when making changes



**3. Error Handling:**

- Repetitive error handling code

- Easy to miss error cases

- Difficult to propagate errors



**4. Debugging:**

- Stack traces are confusing

- Hard to set breakpoints effectively

- Difficult to test individual steps



**Solutions to Callback Hell:**



**Solution 1: Named Functions (Extract callbacks):**



```javascript

// ✅ Better - named functions

function handleUser(error, user) {

  if (error) {

    console.error('Error getting user:', error);

    return;

  }

  getUserPosts(user.id, handlePosts);

}



function handlePosts(error, posts) {

  if (error) {

    console.error('Error getting posts:', error);

    return;

  }

  getPostComments(posts[0].id, handleComments);

}



function handleComments(error, comments) {

  if (error) {

    console.error('Error getting comments:', error);

    return;

  }

  console.log('Comments:', comments);

}



// Cleaner call chain

getUserData(userId, handleUser);



// Pros: Flatter, more readable

// Cons: Still callback-based, harder to pass data between functions

```



**Solution 2: Promises:**



```javascript

// ✅ Much better - Promise chain

getUserData(userId)

  .then(user => getUserPosts(user.id))

  .then(posts => getPostComments(posts[0].id))

  .then(comments => getCommentAuthor(comments[0].authorId))

  .then(author => getAuthorProfile(author.id))

  .then(profile => {

    console.log('Profile:', profile);

  })

  .catch(error => {

    console.error('Error:', error); // Single error handler!

  });



// Pros: Flat, readable, single error handler

// Cons: Still chaining, can be verbose

```



**Solution 3: Async/Await (Best Solution):**



```javascript

// ✅ Best - async/await

async function loadUserProfile(userId) {

  try {

    const user = await getUserData(userId);

    const posts = await getUserPosts(user.id);

    const comments = await getPostComments(posts[0].id);

    const author = await getCommentAuthor(comments[0].authorId);

    const profile = await getAuthorProfile(author.id);

    

    console.log('Profile:', profile);

    return profile;

  } catch (error) {

    console.error('Error:', error);

    throw error;

  }

}



loadUserProfile(userId);



// Pros: Looks synchronous, very readable, clean error handling

// Cons: None significant

```



**Before and After Comparison:**



**Callback Hell:**

```javascript

// ❌ Callback hell

authenticate(username, password, (authError, token) => {

  if (authError) return handleError(authError);

  

  getUser(token, (userError, user) => {

    if (userError) return handleError(userError);

    

    getPermissions(user.id, (permError, permissions) => {

      if (permError) return handleError(permError);

      

      loadDashboard(user, permissions, (dashError, dashboard) => {

        if (dashError) return handleError(dashError);

        

        render(dashboard);

      });

    });

  });

});

```



**With Promises:**

```javascript

// ✅ Promises

authenticate(username, password)

  .then(token => getUser(token))

  .then(user => getPermissions(user.id)

    .then(permissions => ({ user, permissions }))

  )

  .then(({ user, permissions }) => loadDashboard(user, permissions))

  .then(dashboard => render(dashboard))

  .catch(error => handleError(error));

```



**With Async/Await:**

```javascript

// ✅ Async/await (cleanest)

async function initDashboard() {

  try {

    const token = await authenticate(username, password);

    const user = await getUser(token);

    const permissions = await getPermissions(user.id);

    const dashboard = await loadDashboard(user, permissions);

    

    render(dashboard);

  } catch (error) {

    handleError(error);

  }

}



initDashboard();

```



**Converting Callbacks to Promises:**



```javascript

// Callback-based function

function readFileCallback(path, callback) {

  fs.readFile(path, 'utf8', callback);

}



// Convert to Promise

function readFilePromise(path) {

  return new Promise((resolve, reject) => {

    fs.readFile(path, 'utf8', (error, data) => {

      if (error) {

        reject(error);

      } else {

        resolve(data);

      }

    });

  });

}



// Or use Node.js util.promisify

const { promisify } = require('util');

const readFilePromise = promisify(fs.readFile);



// Usage

try {

  const data = await readFilePromise('file.txt', 'utf8');

  console.log(data);

} catch (error) {

  console.error('Error:', error);

}

```



**Modularizing Async Operations:**



```javascript

// Create reusable async modules

const userService = {

  async getUserData(userId) {

    const response = await fetch(`/api/users/${userId}`);

    if (!response.ok) throw new Error('User not found');

    return response.json();

  },

  

  async getUserPosts(userId) {

    const response = await fetch(`/api/users/${userId}/posts`);

    if (!response.ok) throw new Error('Posts not found');

    return response.json();

  },

  

  async getUserProfile(userId) {

    const user = await this.getUserData(userId);

    const posts = await this.getUserPosts(userId);

    return { ...user, posts };

  }

};



// Clean usage

async function displayUserProfile(userId) {

  try {

    const profile = await userService.getUserProfile(userId);

    renderProfile(profile);

  } catch (error) {

    showError(error.message);

  }

}

```



**Error Handling Comparison:**



**Callback Hell:**

```javascript

// ❌ Repetitive error handling

step1((err, result1) => {

  if (err) return handleError(err);

  

  step2(result1, (err, result2) => {

    if (err) return handleError(err);

    

    step3(result2, (err, result3) => {

      if (err) return handleError(err);

      

      finish(result3);

    });

  });

});

```



**Async/Await:**

```javascript

// ✅ Single try/catch

async function process() {

  try {

    const result1 = await step1();

    const result2 = await step2(result1);

    const result3 = await step3(result2);

    finish(result3);

  } catch (err) {

    handleError(err); // Catches all errors!

  }

}

```



**Parallel Operations:**



**Callback Hell (Difficult):**

```javascript

// ❌ Complex parallel execution with callbacks

let user, posts, comments;

let completed = 0;

const total = 3;



getUser((err, userData) => {

  if (err) return handleError(err);

  user = userData;

  if (++completed === total) finish();

});



getPosts((err, postsData) => {

  if (err) return handleError(err);

  posts = postsData;

  if (++completed === total) finish();

});



getComments((err, commentsData) => {

  if (err) return handleError(err);

  comments = commentsData;

  if (++completed === total) finish();

});



function finish() {

  console.log({ user, posts, comments });

}

```



**Async/Await (Simple):**

```javascript

// ✅ Clean parallel execution

async function loadAllData() {

  try {

    const [user, posts, comments] = await Promise.all([

      getUser(),

      getPosts(),

      getComments()

    ]);

    

    console.log({ user, posts, comments });

  } catch (err) {

    handleError(err);

  }

}

```



**Signs of Callback Hell:**




1. **Deep nesting** (> 3 levels)



2. **Pyramid shape** (indentation keeps growing)



3. **Repetitive error handling**



4. **Difficult to follow** logic flow



5. **Hard to modify** or add steps



6. **Variable scope issues**



7. **Closure complications**




**Prevention Strategies:**



**1. Keep callbacks shallow:**

```javascript

// Don't nest immediately - extract functions

function processStep1(data) {

  // Process

  processStep2(result);

}



function processStep2(data) {

  // Process

  processStep3(result);

}

```



**2. Use modern patterns:**

```javascript

// Prefer Promises and async/await

async function modernApproach() {

  const data = await fetchData();

  const processed = await processData(data);

  return await saveData(processed);

}

```



**3. Use libraries:**

```javascript

// Libraries like 'async' can help (legacy code)

const async = require('async');



async.waterfall([

  (callback) => getUser(userId, callback),

  (user, callback) => getPosts(user.id, callback),

  (posts, callback) => getComments(posts[0].id, callback)

], (err, comments) => {

  if (err) return console.error(err);

  console.log(comments);

});

```



**4. Promisify callback APIs:**

```javascript

// Convert old APIs to Promises

const { promisify } = require('util');



const readFileAsync = promisify(fs.readFile);

const writeFileAsync = promisify(fs.writeFile);



// Now can use with async/await

async function processFiles() {

  const data = await readFileAsync('input.txt', 'utf8');

  await writeFileAsync('output.txt', data.toUpperCase());

}

```



**Best Practices:**

- **Avoid deep nesting** - extract functions or use async/await

- **Use Promises** instead of callbacks for new code

- **Prefer async/await** for ultimate readability

- **Handle errors** at appropriate levels

- **Promisify** legacy callback-based APIs

- **Use Promise.all()** for parallel operations

- **Modularize** async operations into services

- **Keep functions focused** and single-purpose



**Key Takeaways:**

- Callback hell is **deeply nested callbacks** (pyramid shape)

- Makes code **hard to read, maintain, and debug**

- Caused by **sequential async operations** with callbacks

- **Promises** flatten the structure

- **Async/await** provides cleanest solution

- Modern JavaScript has largely solved this problem

- Converting to Promises/async-await is straightforward

- Essential to understand for legacy code maintenance





</details>
<details><summary>57. How do you handle errors in Promises?</summary>






**Answer:**

Errors in Promises are handled using `.catch()` for Promise chains, `try/catch` blocks with async/await, or the second argument of `.then()`. Proper error handling prevents unhandled rejections and ensures graceful failure recovery.



**Basic Error Handling Methods:**



**1. Using .catch():**



```javascript

// .catch() handles rejection

fetchUser(userId)

  .then(user => {

    console.log('User:', user);

    return user;

  })

  .catch(error => {

    console.error('Error:', error.message);

    // Handle error (show message, retry, etc.)

  });



// .catch() catches errors from any previous .then()

Promise.resolve()

  .then(() => {

    throw new Error('Something failed');

  })

  .then(() => {

    console.log('This is skipped');

  })

  .catch(error => {

    console.error('Caught:', error.message); // 'Something failed'

  });

```



**2. Using try/catch with async/await:**



```javascript

// Clean error handling with async/await

async function getUser(userId) {

  try {

    const response = await fetch(`/api/users/${userId}`);

    

    if (!response.ok) {

      throw new Error(`HTTP ${response.status}`);

    }

    

    const user = await response.json();

    return user;

    

  } catch (error) {

    console.error('Failed to get user:', error.message);

    throw error; // Re-throw or return default

  }

}



// Usage

try {

  const user = await getUser(1);

  console.log('User:', user);

} catch (error) {

  showError('Could not load user');

}

```



**3. Using .then() with two arguments:**



```javascript

// Second argument handles rejection (less common)

fetchUser(userId).then(

  user => {

    // Success handler

    console.log('Success:', user);

  },

  error => {

    // Error handler

    console.error('Error:', error);

  }

);



// Note: This doesn't catch errors thrown in success handler

fetchUser(userId).then(

  user => {

    throw new Error('Processing error'); // NOT caught by error handler!

  },

  error => {

    console.error('Error:', error); // Won't catch the above

  }

);



// ✅ Better: Use .catch() instead

fetchUser(userId)

  .then(user => {

    throw new Error('Processing error');

  })

  .catch(error => {

    console.error('Error:', error); // Catches all errors

  });

```



**Error Propagation:**



```javascript

// Errors propagate down the chain

fetchUser(1)

  .then(user => {

    console.log('User:', user);

    return fetchPosts(user.id); // If this fails...

  })

  .then(posts => {

    console.log('Posts:', posts);

    return fetchComments(posts[0].id); // ...these are skipped

  })

  .then(comments => {

    console.log('Comments:', comments);

  })

  .catch(error => {

    // ...error caught here

    console.error('Error in chain:', error);

  });



// Visualized:

// fetchUser → then (success) → fetchPosts (fails) → 

// then (skipped) → then (skipped) → catch (handles error)

```



**Error Recovery:**



```javascript

// Recover from error and continue chain

fetchUser(1)

  .catch(error => {

    console.error('User fetch failed:', error);

    return { id: 1, name: 'Guest' }; // Provide default

  })

  .then(user => {

    // This runs even if fetchUser failed

    console.log('User:', user); // Might be default

    return user;

  });



// Multiple recovery points

fetchPrimaryServer()

  .catch(error => {

    console.log('Primary failed, trying backup...');

    return fetchBackupServer();

  })

  .catch(error => {

    console.log('Backup failed, using cache...');

    return fetchFromCache();

  })

  .catch(error => {

    console.error('All sources failed:', error);

    throw new Error('Data unavailable');

  })

  .then(data => {

    console.log('Got data from some source:', data);

  });

```



**Re-throwing Errors:**



```javascript

// Catch, log, and re-throw

async function fetchData() {

  try {

    const response = await fetch('/api/data');

    return await response.json();

  } catch (error) {

    console.error('Fetch failed:', error);

    throw error; // Pass error to caller

  }

}



// Caller handles it

async function loadData() {

  try {

    const data = await fetchData();

    displayData(data);

  } catch (error) {

    showError('Failed to load data');

  }

}



// Transform errors

async function getUserData(id) {

  try {

    const response = await fetch(`/api/users/${id}`);

    

    if (response.status === 404) {

      throw new Error('User not found');

    } else if (!response.ok) {

      throw new Error(`Server error: ${response.status}`);

    }

    

    return await response.json();

  } catch (error) {

    if (error.message === 'Failed to fetch') {

      throw new Error('Network error - check your connection');

    }

    throw error; // Re-throw other errors

  }

}

```



**Handling Multiple Promises:**



**Promise.all() - Fails fast:**



```javascript

// If ANY promise rejects, Promise.all rejects

try {

  const [user, posts, comments] = await Promise.all([

    fetchUser(1),

    fetchPosts(),

    fetchComments()

  ]);

  

  console.log('All loaded:', { user, posts, comments });

} catch (error) {

  // Catches first rejection

  console.error('At least one failed:', error);

}



// Handle errors individually before Promise.all

const [user, posts, comments] = await Promise.all([

  fetchUser(1).catch(err => ({ error: err.message })),

  fetchPosts().catch(err => ({ error: err.message })),

  fetchComments().catch(err => ({ error: err.message }))

]);



// Check for errors

if (user.error) console.error('User failed:', user.error);

if (posts.error) console.error('Posts failed:', posts.error);

if (comments.error) console.error('Comments failed:', comments.error);

```



**Promise.allSettled() - Never rejects:**



```javascript

// Get results for all, regardless of success/failure

const results = await Promise.allSettled([

  fetchUser(1),

  fetchPosts(),

  fetchComments()

]);



results.forEach((result, index) => {

  if (result.status === 'fulfilled') {

    console.log(`Success ${index}:`, result.value);

  } else {

    console.error(`Failed ${index}:`, result.reason);

  }

});



// Practical example

async function loadDashboard() {

  const results = await Promise.allSettled([

    fetchUser(userId),

    fetchPosts(userId),

    fetchNotifications(userId),

    fetchStats(userId)

  ]);

  

  const [userResult, postsResult, notifResult, statsResult] = results;

  

  return {

    user: userResult.status === 'fulfilled' ? userResult.value : null,

    posts: postsResult.status === 'fulfilled' ? postsResult.value : [],

    notifications: notifResult.status === 'fulfilled' ? notifResult.value : [],

    stats: statsResult.status === 'fulfilled' ? statsResult.value : {}

  };

}

```



**Promise.any() - Rejects only if all reject:**



```javascript

try {

  // Returns first successful result

  const data = await Promise.any([

    fetchFromServer1(),

    fetchFromServer2(),

    fetchFromServer3()

  ]);

  

  console.log('Got data from first successful server:', data);

} catch (error) {

  // Only rejects if ALL promises reject

  console.error('All servers failed:', error);

  // error is AggregateError with all rejection reasons

  console.error('Reasons:', error.errors);

}

```



**Custom Error Types:**



```javascript

// Create custom error classes

class NetworkError extends Error {

  constructor(message) {

    super(message);

    this.name = 'NetworkError';

  }

}



class ValidationError extends Error {

  constructor(message, field) {

    super(message);

    this.name = 'ValidationError';

    this.field = field;

  }

}



// Use in promises

async function submitForm(data) {

  // Validation

  if (!data.email) {

    throw new ValidationError('Email is required', 'email');

  }

  

  try {

    const response = await fetch('/api/submit', {

      method: 'POST',

      body: JSON.stringify(data)

    });

    

    if (!response.ok) {

      throw new NetworkError(`HTTP ${response.status}`);

    }

    

    return await response.json();

  } catch (error) {

    if (error.name === 'TypeError' && error.message === 'Failed to fetch') {

      throw new NetworkError('Network connection failed');

    }

    throw error;

  }

}



// Handle different error types

try {

  await submitForm(formData);

} catch (error) {

  if (error instanceof ValidationError) {

    showFieldError(error.field, error.message);

  } else if (error instanceof NetworkError) {

    showNetworkError(error.message);

  } else {

    showGenericError('An unexpected error occurred');

  }

}

```



**Practical Error Handling Patterns:**



**1. Centralized Error Handler:**



```javascript

class ApiClient {

  async request(url, options = {}) {

    try {

      const response = await fetch(url, options);

      

      if (!response.ok) {

        throw await this.handleHttpError(response);

      }

      

      return await response.json();

    } catch (error) {

      throw this.handleError(error);

    }

  }

  

  async handleHttpError(response) {

    const data = await response.json().catch(() => ({}));

    

    switch (response.status) {

      case 400:

        return new ValidationError(data.message || 'Bad request');

      case 401:

        return new Error('Unauthorized - please log in');

      case 403:

        return new Error('Forbidden - insufficient permissions');

      case 404:

        return new Error('Resource not found');

      case 500:

        return new Error('Server error - please try again later');

      default:

        return new Error(`HTTP error ${response.status}`);

    }

  }

  

  handleError(error) {

    if (error.message === 'Failed to fetch') {

      return new NetworkError('Network error - check your connection');

    }

    return error;

  }

}



// Usage

const api = new ApiClient();



try {

  const user = await api.request('/api/users/1');

  console.log('User:', user);

} catch (error) {

  showError(error.message);

}

```



**2. Retry with Error Handling:**



```javascript

async function fetchWithRetry(url, maxRetries = 3) {

  let lastError;

  

  for (let i = 0; i < maxRetries; i++) {

    try {

      const response = await fetch(url);

      

      if (!response.ok) {

        throw new Error(`HTTP ${response.status}`);

      }

      

      return await response.json();

    } catch (error) {

      lastError = error;

      console.error(`Attempt ${i + 1} failed:`, error.message);

      

      // Don't retry on client errors (4xx)

      if (error.message.includes('HTTP 4')) {

        throw error;

      }

      

      // Last attempt - don't wait

      if (i < maxRetries - 1) {

        const delay = Math.pow(2, i) * 1000;

        await new Promise(resolve => setTimeout(resolve, delay));

      }

    }

  }

  

  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);

}



// Usage

try {

  const data = await fetchWithRetry('/api/data');

  console.log('Data:', data);

} catch (error) {

  console.error('All retries failed:', error);

}

```



**3. Timeout with Error:**



```javascript

function withTimeout(promise, ms) {

  return Promise.race([

    promise,

    new Promise((_, reject) =>

      setTimeout(() => reject(new Error('Operation timed out')), ms)

    )

  ]);

}



// Usage

try {

  const data = await withTimeout(

    fetch('/api/slow-endpoint').then(r => r.json()),

    5000

  );

  console.log('Data:', data);

} catch (error) {

  if (error.message === 'Operation timed out') {

    console.error('Request took too long');

  } else {

    console.error('Request failed:', error);

  }

}

```



**4. Error Boundary Pattern (React-inspired):**



```javascript

async function withErrorBoundary(asyncFn, fallback) {

  try {

    return await asyncFn();

  } catch (error) {

    console.error('Error caught by boundary:', error);

    

    if (typeof fallback === 'function') {

      return fallback(error);

    }

    return fallback;

  }

}



// Usage

const user = await withErrorBoundary(

  () => fetchUser(userId),

  { id: userId, name: 'Guest' } // Fallback value

);



const posts = await withErrorBoundary(

  () => fetchPosts(),

  (error) => {

    console.log('Using cached posts');

    return getCachedPosts();

  }

);

```



**5. Conditional Error Handling:**



```javascript

async function loadData(options = {}) {

  const { throwOnError = false, defaultValue = null } = options;

  

  try {

    const response = await fetch('/api/data');

    

    if (!response.ok) {

      throw new Error(`HTTP ${response.status}`);

    }

    

    return await response.json();

  } catch (error) {

    console.error('Load failed:', error);

    

    if (throwOnError) {

      throw error;

    }

    

    return defaultValue;

  }

}



// Throw errors

try {

  const data = await loadData({ throwOnError: true });

  processData(data);

} catch (error) {

  handleError(error);

}



// Return default

const data = await loadData({ defaultValue: [] });

displayData(data); // Shows empty array if failed

```



**Unhandled Rejection Handling:**



**Browser:**



```javascript

// Global unhandled rejection handler

window.addEventListener('unhandledrejection', event => {

  console.error('Unhandled rejection:', event.reason);

  console.error('Promise:', event.promise);

  

  // Prevent default error output

  event.preventDefault();

  

  // Log to error tracking service

  logErrorToService({

    type: 'unhandled_rejection',

    error: event.reason,

    stack: event.reason?.stack

  });

  

  // Show user-friendly message

  showError('An unexpected error occurred');

});



// Example of unhandled rejection

fetch('/api/data')

  .then(r => r.json())

  .then(data => {

    throw new Error('Processing error');

  });

// No .catch() - triggers unhandledrejection event

```



**Node.js:**



```javascript

// Global unhandled rejection handler

process.on('unhandledRejection', (reason, promise) => {

  console.error('Unhandled Rejection at:', promise);

  console.error('Reason:', reason);

  

  // Log error

  logger.error('Unhandled promise rejection', {

    reason,

    stack: reason?.stack

  });

  

  // In production, might want to exit

  // process.exit(1);

});



// Handled rejection handler

process.on('rejectionHandled', (promise) => {

  console.log('Rejection was handled:', promise);

});

```



**Finally Block:**



```javascript

// .finally() runs regardless of success/failure

let isLoading = true;



fetchData()

  .then(data => {

    console.log('Data:', data);

    displayData(data);

  })

  .catch(error => {

    console.error('Error:', error);

    showError(error.message);

  })

  .finally(() => {

    isLoading = false;

    hideLoadingSpinner();

    console.log('Cleanup complete');

  });



// With async/await

async function loadData() {

  showLoadingSpinner();

  

  try {

    const data = await fetchData();

    displayData(data);

  } catch (error) {

    showError(error.message);

  } finally {

    hideLoadingSpinner(); // Always runs

  }

}

```



**Error Logging:**



```javascript

// Comprehensive error logging

async function fetchWithLogging(url) {

  const startTime = Date.now();

  

  try {

    console.log(`[${new Date().toISOString()}] Fetching: ${url}`);

    

    const response = await fetch(url);

    

    if (!response.ok) {

      throw new Error(`HTTP ${response.status}: ${response.statusText}`);

    }

    

    const data = await response.json();

    const duration = Date.now() - startTime;

    

    console.log(`[${new Date().toISOString()}] Success: ${url} (${duration}ms)`);

    

    return data;

  } catch (error) {

    const duration = Date.now() - startTime;

    

    console.error(`[${new Date().toISOString()}] Error: ${url} (${duration}ms)`);

    console.error('Error details:', {

      message: error.message,

      stack: error.stack,

      url,

      timestamp: new Date().toISOString()

    });

    

    // Send to monitoring service

    sendToMonitoring({

      type: 'fetch_error',

      url,

      error: error.message,

      duration

    });

    

    throw error;

  }

}

```



**Common Mistakes:**



**1. Forgetting .catch():**



```javascript

// ❌ Unhandled rejection

fetchData(); // If this fails, unhandled rejection warning



// ✅ Always add .catch()

fetchData().catch(error => console.error(error));



// Or use async/await with try/catch

try {

  await fetchData();

} catch (error) {

  console.error(error);

}

```



**2. Not returning in .then():**



```javascript

// ❌ Error not propagated

function getData() {

  fetchData()

    .then(data => data)

    .catch(error => {

      console.error(error); // Logs but doesn't propagate

    });

  

  return Promise.resolve(); // Returns wrong promise!

}



// ✅ Return the promise chain

function getData() {

  return fetchData()

    .then(data => data)

    .catch(error => {

      console.error(error);

      throw error; // Propagate error

    });

}

```



**3. Swallowing errors:**



```javascript

// ❌ Error disappears

fetchData()

  .catch(error => {

    console.log('Error occurred');

    // Error not re-thrown or handled

  })

  .then(() => {

    // This runs even if fetchData failed!

  });



// ✅ Re-throw or provide fallback

fetchData()

  .catch(error => {

    console.log('Error occurred');

    throw error; // Propagate

    // Or: return defaultValue; // Provide fallback

  })

  .then(data => {

    // Only runs if successful (or fallback provided)

  });

```



**4. Mixing error handling styles:**



```javascript

// ❌ Confusing mix of .catch() and try/catch

async function getData() {

  return fetch('/api/data')

    .then(r => r.json())

    .catch(error => console.error(error)); // Don't mix!

}



// ✅ Consistent style (prefer async/await)

async function getData() {

  try {

    const response = await fetch('/api/data');

    return await response.json();

  } catch (error) {

    console.error(error);

    throw error;

  }

}

```



**Best Practices:**

- Always handle errors with `.catch()` or `try/catch`

- Use `.finally()` for cleanup operations

- Re-throw errors if caller should handle them

- Provide meaningful error messages

- Use custom error classes for different error types

- Log errors with context (timestamp, URL, user, etc.)

- Set up global unhandled rejection handlers

- Test error paths thoroughly

- Consider fallback values for non-critical failures

- Don't swallow errors silently



**Key Takeaways:**

- Use `.catch()` for Promise chains, `try/catch` for async/await

- Errors propagate down Promise chains to nearest `.catch()`

- `.finally()` runs regardless of success/failure

- Always handle or propagate errors (no silent failures)

- Promise.allSettled() useful when all outcomes matter

- Custom error types enable specific error handling

- Global handlers catch unhandled rejections

- Proper error handling prevents crashes and improves UX





</details>
<details><summary>58. What is Promise chaining?</summary>






**Answer:**

Promise chaining is the practice of linking multiple asynchronous operations together using `.then()` calls, where each `.then()` returns a new Promise. This creates a sequence of operations where each step waits for the previous one to complete, passing data through the chain.



**Basic Concept:**



```javascript

// Basic chaining

fetchUser(1)

  .then(user => {

    console.log('User:', user.name);

    return user.id; // Return value for next .then()

  })

  .then(userId => {

    console.log('User ID:', userId);

    return fetchPosts(userId); // Return promise for next .then()

  })

  .then(posts => {

    console.log('Posts:', posts.length);

    return posts[0];

  })

  .then(firstPost => {

    console.log('First post:', firstPost.title);

  })

  .catch(error => {

    console.error('Error in chain:', error);

  });



// Each .then() returns a new Promise

const promise1 = fetchUser(1);

const promise2 = promise1.then(user => user.id);

const promise3 = promise2.then(id => fetchPosts(id));

// promise1, promise2, promise3 are all different Promise objects

```



**How Chaining Works:**



```javascript

// Sequential execution

Promise.resolve(1)

  .then(value => {

    console.log('Step 1:', value); // 1

    return value + 1; // Pass 2 to next .then()

  })

  .then(value => {

    console.log('Step 2:', value); // 2

    return value * 2; // Pass 4 to next .then()

  })

  .then(value => {

    console.log('Step 3:', value); // 4

    return value ** 2; // Pass 16 to next .then()

  })

  .then(value => {

    console.log('Final:', value); // 16

  });



// Output:

// Step 1: 1

// Step 2: 2

// Step 3: 4

// Final: 16

```



**Returning Values vs Promises:**



```javascript

// Returning regular value

fetchUser(1)

  .then(user => {

    return user.id; // Returns value, wrapped in Promise

  })

  .then(userId => {

    console.log('User ID:', userId); // Gets the value

  });



// Returning Promise (flattened automatically)

fetchUser(1)

  .then(user => {

    return fetchPosts(user.id); // Returns Promise

  })

  .then(posts => {

    console.log('Posts:', posts); // Gets resolved value, not Promise

  });



// NOT returning (undefined passed to next)

fetchUser(1)

  .then(user => {

    fetchPosts(user.id); // ❌ Forgot to return!

  })

  .then(posts => {

    console.log('Posts:', posts); // undefined

  });

```



**Practical Example: Sequential API Calls:**



```javascript

// Load user, then their posts, then first post's comments

function loadUserContent(userId) {

  return fetchUser(userId)

    .then(user => {

      console.log('Loaded user:', user.name);

      return fetchPosts(user.id);

    })

    .then(posts => {

      console.log('Loaded posts:', posts.length);

      if (posts.length === 0) {

        throw new Error('User has no posts');

      }

      return fetchComments(posts[0].id);

    })

    .then(comments => {

      console.log('Loaded comments:', comments.length);

      return comments;

    })

    .catch(error => {

      console.error('Failed to load content:', error);

      throw error;

    });

}



// Usage

loadUserContent(1)

  .then(comments => displayComments(comments))

  .catch(error => showError(error.message));

```



**Passing Multiple Values:**



```javascript

// Problem: Need data from multiple steps

fetchUser(1)

  .then(user => {

    return fetchPosts(user.id); // Lost user data!

  })

  .then(posts => {

    // Can't access user here

  });



// Solution 1: Return object

fetchUser(1)

  .then(user => {

    return fetchPosts(user.id)

      .then(posts => ({ user, posts })); // Combine data

  })

  .then(({ user, posts }) => {

    console.log(`${user.name} has ${posts.length} posts`);

  });



// Solution 2: Use Promise.all

fetchUser(1)

  .then(user => {

    return Promise.all([

      Promise.resolve(user), // Keep user

      fetchPosts(user.id)     // Fetch posts

    ]);

  })

  .then(([user, posts]) => {

    console.log(`${user.name} has ${posts.length} posts`);

  });



// Solution 3: Nested scope (avoid if possible)

fetchUser(1)

  .then(user => {

    return fetchPosts(user.id)

      .then(posts => {

        // user is accessible here via closure

        console.log(`${user.name} has ${posts.length} posts`);

        return { user, posts };

      });

  });



// Solution 4: async/await (clearest)

async function loadUserData(userId) {

  const user = await fetchUser(userId);

  const posts = await fetchPosts(user.id);

  console.log(`${user.name} has ${posts.length} posts`);

  return { user, posts };

}

```



**Chaining with Transformations:**



```javascript

// Transform data through the chain

fetch('/api/users')

  .then(response => response.json())

  .then(users => {

    // Filter active users

    return users.filter(user => user.active);

  })

  .then(activeUsers => {

    // Extract names

    return activeUsers.map(user => user.name);

  })

  .then(names => {

    // Sort alphabetically

    return names.sort();

  })

  .then(sortedNames => {

    console.log('Active users:', sortedNames);

  })

  .catch(error => {

    console.error('Error processing users:', error);

  });

```



**Conditional Chaining:**



```javascript

// Branch based on condition

fetchUser(userId)

  .then(user => {

    if (user.role === 'admin') {

      return fetchAdminData(user.id);

    } else {

      return fetchUserData(user.id);

    }

  })

  .then(data => {

    console.log('Data:', data);

  });



// Early return

fetchUser(userId)

  .then(user => {

    if (!user.active) {

      throw new Error('User is not active');

    }

    return user;

  })

  .then(user => {

    // Only runs if user is active

    return loadUserDashboard(user);

  })

  .catch(error => {

    console.error('Error:', error);

  });

```



**Error Handling in Chains:**



```javascript

// Error stops chain execution

Promise.resolve()

  .then(() => {

    console.log('Step 1');

    return 'result1';

  })

  .then(() => {

    console.log('Step 2');

    throw new Error('Step 2 failed');

  })

  .then(() => {

    console.log('Step 3'); // Skipped

  })

  .then(() => {

    console.log('Step 4'); // Skipped

  })

  .catch(error => {

    console.error('Error:', error.message); // Caught here

  });



// Output:

// Step 1

// Step 2

// Error: Step 2 failed



// Continue after error

fetchData()

  .then(processData)

  .catch(error => {

    console.error('Processing failed:', error);

    return defaultData; // Recover with default

  })

  .then(data => {

    // Continues with either processed data or default

    displayData(data);

  });

```



**Multiple Catch Blocks:**



```javascript

// Catch at different levels

fetchUser(userId)

  .then(user => fetchPosts(user.id))

  .catch(error => {

    console.error('Failed to get user or posts:', error);

    return []; // Return empty array to continue

  })

  .then(posts => fetchComments(posts[0]?.id))

  .catch(error => {

    console.error('Failed to get comments:', error);

    return []; // Return empty array

  })

  .then(comments => {

    // This always runs, even if earlier steps failed

    console.log('Comments:', comments);

  });

```



**Complex Chaining Example:**



```javascript

// Real-world example: User authentication flow

function authenticateAndLoadDashboard(username, password) {

  return authenticate(username, password)

    .then(token => {

      console.log('Authenticated, token:', token);

      localStorage.setItem('auth_token', token);

      return token;

    })

    .then(token => {

      return getUser(token);

    })

    .then(user => {

      console.log('User loaded:', user.name);

      return Promise.all([

        Promise.resolve(user),

        getUserPermissions(user.id),

        getUserPreferences(user.id)

      ]);

    })

    .then(([user, permissions, preferences]) => {

      console.log('All user data loaded');

      return {

        user,

        permissions,

        preferences

      };

    })

    .then(userData => {

      return loadDashboard(userData);

    })

    .then(dashboard => {

      console.log('Dashboard ready');

      renderDashboard(dashboard);

      return dashboard;

    })

    .catch(error => {

      console.error('Authentication/load failed:', error);

      

      if (error.message.includes('Invalid credentials')) {

        showError('Invalid username or password');

      } else if (error.message.includes('Network')) {

        showError('Network error - please try again');

      } else {

        showError('Failed to load dashboard');

      }

      

      throw error;

    })

    .finally(() => {

      hideLoadingSpinner();

    });

}

```



**Chaining vs Nesting:**



```javascript

// ❌ Nesting (callback hell with promises)

fetchUser(1)

  .then(user => {

    fetchPosts(user.id)

      .then(posts => {

        fetchComments(posts[0].id)

          .then(comments => {

            console.log('Comments:', comments);

          });

      });

  });



// ✅ Chaining (flat, readable)

fetchUser(1)

  .then(user => fetchPosts(user.id))

  .then(posts => fetchComments(posts[0].id))

  .then(comments => {

    console.log('Comments:', comments);

  })

  .catch(error => {

    console.error('Error:', error);

  });

```



**Parallel Operations in Chain:**



```javascript

// Combine sequential and parallel operations

fetchUser(userId)

  .then(user => {

    // Wait for user, then fetch multiple things in parallel

    return Promise.all([

      Promise.resolve(user),

      fetchPosts(user.id),

      fetchFriends(user.id),

      fetchNotifications(user.id)

    ]);

  })

  .then(([user, posts, friends, notifications]) => {

    console.log('All loaded:', { user, posts, friends, notifications });

    return { user, posts, friends, notifications };

  })

  .catch(error => {

    console.error('Error:', error);

  });

```



**Chaining with Finally:**



```javascript

// Finally always runs

let isLoading = true;



fetchData()

  .then(data => {

    console.log('Data:', data);

    return processData(data);

  })

  .then(processed => {

    console.log('Processed:', processed);

    return saveData(processed);

  })

  .catch(error => {

    console.error('Error:', error);

    throw error;

  })

  .finally(() => {

    isLoading = false;

    console.log('Cleanup complete');

    // Runs whether chain succeeded or failed

  });

```



**Chaining vs Async/Await:**



```javascript

// Promise chaining

function loadData() {

  return fetchUser(1)

    .then(user => fetchPosts(user.id))

    .then(posts => fetchComments(posts[0].id))

    .then(comments => comments)

    .catch(error => {

      console.error('Error:', error);

      throw error;

    });

}



// Async/await (equivalent, more readable)

async function loadData() {

  try {

    const user = await fetchUser(1);

    const posts = await fetchPosts(user.id);

    const comments = await fetchComments(posts[0].id);

    return comments;

  } catch (error) {

    console.error('Error:', error);

    throw error;

  }

}



// Both return promises

loadData()

  .then(comments => console.log('Comments:', comments))

  .catch(error => console.error('Failed:', error));

```



**Common Patterns:**



**1. Retry Chain:**



```javascript

function fetchWithRetry(url, retries = 3) {

  return fetch(url)

    .catch(error => {

      if (retries > 0) {

        console.log(`Retrying... (${retries} left)`);

        return fetchWithRetry(url, retries - 1);

      }

      throw error;

    });

}

```



**2. Waterfall (Sequential with Dependencies):**



```javascript

function waterfall(tasks) {

  let result;

  

  return tasks.reduce((chain, task) => {

    return chain.then(prevResult => {

      return task(prevResult);

    });

  }, Promise.resolve());

}



// Usage

waterfall([

  () => fetchUser(1),

  (user) => fetchPosts(user.id),

  (posts) => fetchComments(posts[0].id)

])

  .then(comments => console.log('Comments:', comments))

  .catch(error => console.error('Error:', error));

```



**3. Chain with Accumulation:**



```javascript

function processItems(items) {

  return items.reduce((chain, item) => {

    return chain.then(results => {

      return processItem(item)

        .then(result => [...results, result]);

    });

  }, Promise.resolve([]));

}



// Usage

processItems([1, 2, 3, 4, 5])

  .then(results => console.log('All results:', results));

```



**Best Practices:**

- Always **return** values or promises from `.then()`

- Keep chains **flat** (avoid nesting)

- Use `.catch()` at the end for error handling

- Use `.finally()` for cleanup

- Consider **async/await** for complex chains

- Pass data through the chain efficiently

- Handle errors at appropriate levels

- Keep each `.then()` focused on one task

- Use Promise.all() for parallel operations within chains



**Key Takeaways:**

- Promise chaining links async operations with `.then()`

- Each `.then()` returns a new Promise

- Return values are passed to next `.then()`

- Returning a Promise flattens it automatically

- Errors propagate to nearest `.catch()`

- Keeps async code flat and readable

- Alternative to callback hell

- Modern async/await is often cleaner for complex chains





</details>
<details><summary>59. What is the microtask queue?</summary>






**Answer:**

The microtask queue is a priority queue in JavaScript's event loop that holds callbacks from Promise resolutions, `queueMicrotask()`, `MutationObserver`, and `process.nextTick()` (Node.js). Microtasks have higher priority than macrotasks (setTimeout, setInterval) and all microtasks are processed before any macrotask executes.



**What Goes in the Microtask Queue:**




1. **Promise callbacks** (`.then()`, `.catch()`, `.finally()`)



2. **queueMicrotask()** callbacks



3. **MutationObserver** callbacks



4. **process.nextTick()** (Node.js - highest priority)




```javascript

// Promise callbacks go to microtask queue

Promise.resolve().then(() => {

  console.log('Microtask: Promise');

});



// queueMicrotask

queueMicrotask(() => {

  console.log('Microtask: queueMicrotask');

});



// MutationObserver

const observer = new MutationObserver(() => {

  console.log('Microtask: MutationObserver');

});



// Synchronous code runs first

console.log('Synchronous');



// Output order:

// Synchronous

// Microtask: Promise

// Microtask: queueMicrotask

// Microtask: MutationObserver

```



**Execution Order:**



```javascript

console.log('1: Script start');



setTimeout(() => {

  console.log('2: setTimeout (macrotask)');

}, 0);



Promise.resolve().then(() => {

  console.log('3: Promise (microtask)');

});



console.log('4: Script end');



// Output:

// 1: Script start

// 4: Script end

// 3: Promise (microtask)  ← Runs before setTimeout

// 2: setTimeout (macrotask)



// Explanation:

// 1. Synchronous code runs first (1, 4)

// 2. Call stack empties

// 3. ALL microtasks run (3)

// 4. Then ONE macrotask runs (2)

```



**Microtask Queue Processing:**



```

Event Loop Cycle:

┌─────────────────────────────────┐

│ 1. Execute synchronous code    │

├─────────────────────────────────┤

│ 2. Process ALL microtasks      │ ← Queue emptied completely

│    - Run one microtask          │

│    - Check queue again          │

│    - Repeat until empty         │

├─────────────────────────────────┤

│ 3. Render (if browser)          │

├─────────────────────────────────┤

│ 4. Process ONE macrotask        │ ← Only one per cycle

├─────────────────────────────────┤

│ 5. Back to step 2               │

└─────────────────────────────────┘

```



**Key Characteristic: Process ALL Microtasks:**



```javascript

// Microtasks can add more microtasks

Promise.resolve().then(() => {

  console.log('Microtask 1');

  

  // This new microtask runs before any macrotask

  Promise.resolve().then(() => {

    console.log('Microtask 2');

  });

});



setTimeout(() => {

  console.log('Macrotask');

}, 0);



console.log('Sync');



// Output:

// Sync

// Microtask 1

// Microtask 2  ← Added during microtask processing, still runs

// Macrotask    ← Only runs after ALL microtasks done

```



**Detailed Example:**



```javascript

console.log('A');



setTimeout(() => {

  console.log('B');

}, 0);



Promise.resolve()

  .then(() => {

    console.log('C');

  })

  .then(() => {

    console.log('D');

  });



setTimeout(() => {

  console.log('E');

}, 0);



Promise.resolve().then(() => {

  console.log('F');

});



console.log('G');



// Execution flow:

// 1. console.log('A') → prints 'A'

// 2. setTimeout(B) → queued as macrotask

// 3. Promise.then(C) → queued as microtask

// 4. setTimeout(E) → queued as macrotask

// 5. Promise.then(F) → queued as microtask

// 6. console.log('G') → prints 'G'

// 7. Stack empty → process microtasks

// 8. Run C → prints 'C', queues D as microtask

// 9. Run F → prints 'F'

// 10. Run D → prints 'D'

// 11. All microtasks done → process macrotask

// 12. Run B → prints 'B'

// 13. Process macrotasks again

// 14. Run E → prints 'E'



// Output: A → G → C → F → D → B → E

```



**Microtask Queue with Nested Promises:**



```javascript

Promise.resolve()

  .then(() => {

    console.log('Promise 1');

    

    Promise.resolve()

      .then(() => {

        console.log('Promise 1.1');

      })

      .then(() => {

        console.log('Promise 1.2');

      });

  })

  .then(() => {

    console.log('Promise 2');

  });



Promise.resolve().then(() => {

  console.log('Promise 3');

});



// Output:

// Promise 1

// Promise 3

// Promise 1.1

// Promise 2

// Promise 1.2



// Explanation:

// 1. Promise 1 microtask runs, queues Promise 1.1

// 2. Promise 3 microtask runs (was already queued)

// 3. Promise 1.1 runs, queues Promise 1.2

// 4. Promise 2 runs (from first chain's second .then())

// 5. Promise 1.2 runs

```



**Microtasks Can Starve Macrotasks:**



```javascript

// ⚠️ Infinite microtask loop - macrotasks never run!

function recursiveMicrotask() {

  Promise.resolve().then(() => {

    console.log('Microtask');

    recursiveMicrotask(); // Queues another microtask

  });

}



recursiveMicrotask();



setTimeout(() => {

  console.log('This will NEVER run!');

}, 0);



// Output:

// Microtask

// Microtask

// Microtask

// ... forever

// setTimeout never executes because microtasks keep getting added

```



**Practical Example: Animation:**



```javascript

// Using microtasks for immediate updates

function updateUI() {

  element.classList.add('loading');

  

  // Microtask - updates DOM immediately after current task

  Promise.resolve().then(() => {

    element.textContent = 'Processing...';

  });

  

  // Macrotask - runs later

  setTimeout(() => {

    element.textContent = 'Done';

    element.classList.remove('loading');

  }, 1000);

}



// Better alternative: queueMicrotask

function updateUIBetter() {

  element.classList.add('loading');

  

  queueMicrotask(() => {

    element.textContent = 'Processing...';

  });

  

  setTimeout(() => {

    element.textContent = 'Done';

    element.classList.remove('loading');

  }, 1000);

}

```



**queueMicrotask() API:**



```javascript

// Explicitly queue a microtask

queueMicrotask(() => {

  console.log('This is a microtask');

});



// Equivalent to:

Promise.resolve().then(() => {

  console.log('This is a microtask');

});



// Use case: Defer work until after current execution

function processData(data) {

  // Synchronous validation

  if (!data) {

    throw new Error('No data');

  }

  

  // Defer heavy processing

  queueMicrotask(() => {

    heavyProcessing(data);

  });

  

  return 'Processing started';

}

```



**MutationObserver (Microtask):**



```javascript

// MutationObserver uses microtask queue

const observer = new MutationObserver((mutations) => {

  console.log('DOM changed (microtask):', mutations.length);

});



observer.observe(document.body, { childList: true, subtree: true });



// Make multiple changes

document.body.appendChild(document.createElement('div'));

document.body.appendChild(document.createElement('div'));

document.body.appendChild(document.createElement('div'));



console.log('Sync code done');



// Output:

// Sync code done

// DOM changed (microtask): 3

// (Observer batches all changes into one microtask)

```



**Node.js: process.nextTick (Even Higher Priority):**



```javascript

// Node.js has special queue with higher priority than microtasks

console.log('1: Start');



setTimeout(() => {

  console.log('2: setTimeout');

}, 0);



Promise.resolve().then(() => {

  console.log('3: Promise');

});



process.nextTick(() => {

  console.log('4: nextTick');

});



console.log('5: End');



// Output (Node.js):

// 1: Start

// 5: End

// 4: nextTick      ← Highest priority

// 3: Promise       ← Microtask

// 2: setTimeout    ← Macrotask



// Priority: nextTick > microtask > macrotask

```



**Comparison with Macrotasks:**



```javascript

// Mix of microtasks and macrotasks

console.log('Start');



setTimeout(() => {

  console.log('setTimeout 1');

  

  Promise.resolve().then(() => {

    console.log('Promise in setTimeout 1');

  });

}, 0);



Promise.resolve().then(() => {

  console.log('Promise 1');

  

  setTimeout(() => {

    console.log('setTimeout in Promise 1');

  }, 0);

});



setTimeout(() => {

  console.log('setTimeout 2');

}, 0);



Promise.resolve().then(() => {

  console.log('Promise 2');

});



console.log('End');



// Output:

// Start

// End

// Promise 1

// Promise 2

// setTimeout 1

// Promise in setTimeout 1

// setTimeout 2

// setTimeout in Promise 1



// Explanation:

// 1. Sync: Start, End

// 2. All microtasks: Promise 1, Promise 2

// 3. First macrotask: setTimeout 1

// 4. Microtasks from setTimeout 1: Promise in setTimeout 1

// 5. Next macrotask: setTimeout 2

// 6. Last macrotask: setTimeout in Promise 1

```



**Use Cases:**



**1. Batching DOM Updates:**



```javascript

let updates = [];



function scheduleUpdate(update) {

  updates.push(update);

  

  // Batch all updates in one microtask

  if (updates.length === 1) {

    queueMicrotask(() => {

      console.log('Applying', updates.length, 'updates');

      updates.forEach(applyUpdate);

      updates = [];

    });

  }

}



scheduleUpdate('update 1');

scheduleUpdate('update 2');

scheduleUpdate('update 3');

console.log('Scheduled 3 updates');



// Output:

// Scheduled 3 updates

// Applying 3 updates (batched in one microtask)

```



**2. Promise-based Flow Control:**



```javascript

async function processItems(items) {

  for (const item of items) {

    // Each iteration processes in microtask

    await Promise.resolve(); // Yields to microtask queue

    processItem(item);

  }

}



// Keeps UI responsive by yielding between items

```



**3. Testing Async Code:**



```javascript

// Test that runs after all microtasks

async function test() {

  let result = null;

  

  Promise.resolve().then(() => {

    result = 'success';

  });

  

  // Wait for microtasks to complete

  await Promise.resolve();

  

  console.log('Result:', result); // 'success'

}

```



**Debugging Microtask Order:**



```javascript

function logWithContext(message, type) {

  console.log(`[${type}] ${message}`);

}



console.log('[Sync] Start');



setTimeout(() => {

  logWithContext('setTimeout 1', 'Macro');

}, 0);



Promise.resolve().then(() => {

  logWithContext('Promise 1', 'Micro');

  

  Promise.resolve().then(() => {

    logWithContext('Promise 1.1', 'Micro');

  });

});



queueMicrotask(() => {

  logWithContext('queueMicrotask', 'Micro');

});



Promise.resolve().then(() => {

  logWithContext('Promise 2', 'Micro');

});



setTimeout(() => {

  logWithContext('setTimeout 2', 'Macro');

}, 0);



console.log('[Sync] End');



// Output:

// [Sync] Start

// [Sync] End

// [Micro] Promise 1

// [Micro] queueMicrotask

// [Micro] Promise 2

// [Micro] Promise 1.1

// [Macro] setTimeout 1

// [Macro] setTimeout 2

```



**Best Practices:**

- Understand **microtasks run before macrotasks**

- Use **queueMicrotask()** for explicit microtask scheduling

- **Avoid infinite microtask loops** (can freeze the browser)

- Promises automatically use microtask queue

- Microtasks are for **high-priority, immediate** work

- Use macrotasks (setTimeout) for **deferred, lower-priority** work

- In Node.js, **process.nextTick** has even higher priority

- Batch operations in microtasks for performance



**Key Takeaways:**

- Microtask queue holds Promise callbacks and queueMicrotask

- **Higher priority** than macrotask queue (setTimeout, setInterval)

- **ALL** microtasks run before **ANY** macrotask

- Microtasks can add more microtasks (processed in same cycle)

- Can starve macrotasks if infinite loop created

- Essential for understanding Promise execution order

- Part of JavaScript event loop specification

- Use queueMicrotask() for explicit scheduling





</details>
<details><summary>60. What is the difference between microtask and macrotask?</summary>






**Answer:**

Microtasks (Promise callbacks, queueMicrotask) have higher priority and all microtasks execute before any macrotask. Macrotasks (setTimeout, setInterval, I/O) execute one at a time per event loop cycle. Microtasks are for immediate, high-priority work; macrotasks are for deferred, scheduled work.



**Key Differences:**



| Feature | Microtask | Macrotask |

|---------|-----------|-----------|

| **Priority** | Higher | Lower |

| **Execution** | ALL per cycle | ONE per cycle |

| **Examples** | Promise.then, queueMicrotask | setTimeout, setInterval |

| **When** | After current task, before render | After microtasks, after render |

| **Can add more** | Yes, all processed same cycle | Yes, processed next cycle |

| **Use for** | Immediate, high-priority work | Deferred, scheduled work |

| **Queue name** | Microtask queue | Callback/Task queue |



**Microtasks:**



Sources:

- `Promise.then()`, `.catch()`, `.finally()`

- `queueMicrotask()`

- `MutationObserver`

- `process.nextTick()` (Node.js)



```javascript

// Microtask examples

Promise.resolve().then(() => {

  console.log('Microtask: Promise');

});



queueMicrotask(() => {

  console.log('Microtask: queueMicrotask');

});



const observer = new MutationObserver(() => {

  console.log('Microtask: MutationObserver');

});

```



**Macrotasks:**



Sources:

- `setTimeout()`

- `setInterval()`

- `setImmediate()` (Node.js)

- `requestAnimationFrame()` (browser)

- I/O operations

- UI rendering events



```javascript

// Macrotask examples

setTimeout(() => {

  console.log('Macrotask: setTimeout');

}, 0);



setInterval(() => {

  console.log('Macrotask: setInterval');

}, 1000);



// Node.js

setImmediate(() => {

  console.log('Macrotask: setImmediate');

});

```



**Execution Order Demonstration:**



```javascript

console.log('1: Sync start');



// Macrotasks

setTimeout(() => {

  console.log('2: setTimeout 1');

}, 0);



setTimeout(() => {

  console.log('3: setTimeout 2');

}, 0);



// Microtasks

Promise.resolve().then(() => {

  console.log('4: Promise 1');

});



Promise.resolve().then(() => {

  console.log('5: Promise 2');

});



console.log('6: Sync end');



// Output:

// 1: Sync start       (synchronous)

// 6: Sync end         (synchronous)

// 4: Promise 1        (microtask - ALL run)

// 5: Promise 2        (microtask - ALL run)

// 2: setTimeout 1     (macrotask - ONE runs)

// 3: setTimeout 2     (macrotask - ONE runs)



// Event loop cycles:

// Cycle 1: Sync code → All microtasks → First macrotask

// Cycle 2: Second macrotask

```



**Processing ALL Microtasks vs ONE Macrotask:**



```javascript

// Microtasks keep adding more - ALL processed

Promise.resolve().then(() => {

  console.log('Micro 1');

  

  Promise.resolve().then(() => {

    console.log('Micro 1.1');

  });

});



Promise.resolve().then(() => {

  console.log('Micro 2');

});



setTimeout(() => {

  console.log('Macro 1');

}, 0);



setTimeout(() => {

  console.log('Macro 2');

}, 0);



// Output:

// Micro 1

// Micro 2

// Micro 1.1    ← Added during microtask, still runs

// Macro 1      ← Only ONE macrotask per cycle

// Macro 2      ← Next cycle



// Microtasks: 1 → 2 → 1.1 (all in one cycle)

// Macrotasks: 1 (cycle 1) → 2 (cycle 2)

```



**Complex Example:**



```javascript

console.log('Start');



setTimeout(() => {

  console.log('Macro 1');

  

  Promise.resolve().then(() => {

    console.log('Micro in Macro 1');

  });

  

  setTimeout(() => {

    console.log('Macro 1.1');

  }, 0);

}, 0);



Promise.resolve().then(() => {

  console.log('Micro 1');

  

  setTimeout(() => {

    console.log('Macro in Micro 1');

  }, 0);

  

  Promise.resolve().then(() => {

    console.log('Micro 1.1');

  });

});



setTimeout(() => {

  console.log('Macro 2');

}, 0);



Promise.resolve().then(() => {

  console.log('Micro 2');

});



console.log('End');



// Output:

// Start                  (sync)

// End                    (sync)

// Micro 1                (all microtasks)

// Micro 2                (all microtasks)

// Micro 1.1              (all microtasks)

// Macro 1                (one macrotask)

// Micro in Macro 1       (microtasks after macrotask)

// Macro 2                (next macrotask)

// Macro in Micro 1       (next macrotask)

// Macro 1.1              (next macrotask)



// Event loop cycles:

// 1. Sync: Start, End

// 2. Microtasks: Micro 1, Micro 2, Micro 1.1

// 3. Macrotask: Macro 1

// 4. Microtasks: Micro in Macro 1

// 5. Macrotask: Macro 2

// 6. Macrotask: Macro in Micro 1

// 7. Macrotask: Macro 1.1

```



**Visual Representation:**



```

Event Loop Iteration:



┌─────────────────────────────────────┐

│  Execute synchronous code           │

└─────────────────────────────────────┘

              ↓

┌─────────────────────────────────────┐

│  Process ALL microtasks             │

│  ┌───────────────────────────────┐  │

│  │ Run microtask 1               │  │

│  │ If it adds microtasks, add    │  │

│  │ to queue and process          │  │

│  └───────────────────────────────┘  │

│  ┌───────────────────────────────┐  │

│  │ Run microtask 2               │  │

│  └───────────────────────────────┘  │

│  ... until microtask queue empty    │

└─────────────────────────────────────┘

              ↓

┌─────────────────────────────────────┐

│  Render UI (browser only)           │

└─────────────────────────────────────┘

              ↓

┌─────────────────────────────────────┐

│  Process ONE macrotask              │

│  ┌───────────────────────────────┐  │

│  │ Run oldest macrotask          │  │

│  └───────────────────────────────┘  │

└─────────────────────────────────────┘

              ↓

        (Loop back to microtasks)

```



**Practical Implications:**



**1. Promise vs setTimeout Timing:**



```javascript

console.time('Promise');

Promise.resolve().then(() => {

  console.timeEnd('Promise');

});



console.time('setTimeout');

setTimeout(() => {

  console.timeEnd('setTimeout');

}, 0);



// Output:

// Promise: 0.1ms     (microtask - runs immediately)

// setTimeout: 4.5ms  (macrotask - minimum delay ~4ms)

```



**2. UI Responsiveness:**



```javascript

// ❌ Blocks UI - long synchronous operation

function processHeavyData(data) {

  for (let item of data) {

    heavyComputation(item); // Blocks!

  }

}



// ✅ Yields to UI - using macrotasks

async function processHeavyDataAsync(data) {

  for (let item of data) {

    heavyComputation(item);

    

    // Yield to event loop (let UI update)

    await new Promise(resolve => setTimeout(resolve, 0));

  }

}



// ⚠️ Using microtasks - still blocks!

async function processWithMicrotask(data) {

  for (let item of data) {

    heavyComputation(item);

    

    // Microtasks don't allow UI render

    await Promise.resolve();

  }

}

```



**3. Animation Timing:**



```javascript

// Microtask - runs before next paint

Promise.resolve().then(() => {

  element.style.opacity = '0';

  // Change applied before screen updates

});



// Macrotask - runs after paint

setTimeout(() => {

  element.style.opacity = '0';

  // Might see flash of old opacity

}, 0);



// requestAnimationFrame - syncs with paint (best for animations)

requestAnimationFrame(() => {

  element.style.opacity = '0';

  // Optimized for smooth animations

});

```



**4. Event Handler Behavior:**



```javascript

button.addEventListener('click', () => {

  console.log('Click handler start');

  

  Promise.resolve().then(() => {

    console.log('Microtask in click');

  });

  

  setTimeout(() => {

    console.log('Macrotask in click');

  }, 0);

  

  console.log('Click handler end');

});



// When clicked:

// Click handler start

// Click handler end

// Microtask in click    ← Before next macrotask

// Macrotask in click    ← Next event loop cycle

```



**Node.js Differences:**



```javascript

// Node.js has additional phases

console.log('Start');



setTimeout(() => {

  console.log('setTimeout');

}, 0);



setImmediate(() => {

  console.log('setImmediate');

});



Promise.resolve().then(() => {

  console.log('Promise');

});



process.nextTick(() => {

  console.log('nextTick');

});



console.log('End');



// Output (Node.js):

// Start

// End

// nextTick         (highest priority)

// Promise          (microtask)

// setTimeout       (timers phase)

// setImmediate     (check phase)



// Node.js event loop phases:

// 1. timers (setTimeout, setInterval)

// 2. pending callbacks

// 3. idle, prepare

// 4. poll (I/O)

// 5. check (setImmediate)

// 6. close callbacks

// Between each phase: process.nextTick → microtasks

```



**Starvation Example:**



```javascript

// Microtasks can starve macrotasks

let microCount = 0;



function addMicrotask() {

  microCount++;

  

  if (microCount < 5) {

    Promise.resolve().then(() => {

      console.log('Microtask', microCount);

      addMicrotask(); // Keeps adding microtasks

    });

  }

}



addMicrotask();



setTimeout(() => {

  console.log('Macrotask (runs after all microtasks)');

}, 0);



// Output:

// Microtask 1

// Microtask 2

// Microtask 3

// Microtask 4

// Macrotask (runs after all microtasks)



// If microCount limit removed, macrotask never runs!

```



**When to Use Each:**



**Use Microtasks (Promise, queueMicrotask) when:**

- Need immediate execution after current operation

- High-priority work that must complete before rendering

- Promise-based async operations

- Batching operations in same tick

- Need to run before any timer callbacks



**Use Macrotasks (setTimeout, setInterval) when:**

- Need to defer work to next event loop cycle

- Breaking up long-running operations

- Scheduling work for specific time

- Yielding to UI for responsiveness

- Lower-priority background work



```javascript

// Microtask: Immediate priority

function updateCriticalState() {

  Promise.resolve().then(() => {

    // Runs before any setTimeout, immediately after current task

    criticalStateUpdate();

  });

}



// Macrotask: Deferred work

function scheduleDeferredWork() {

  setTimeout(() => {

    // Runs in next cycle, after microtasks and render

    backgroundProcessing();

  }, 0);

}

```



**Testing Understanding:**



```javascript

// What's the output?

console.log('A');



setTimeout(() => console.log('B'), 0);

setTimeout(() => console.log('C'), 0);



Promise.resolve().then(() => console.log('D'));

Promise.resolve().then(() => console.log('E'));



console.log('F');



// Answer: A → F → D → E → B → C

// Explanation:

// Sync: A, F

// All microtasks: D, E

// First macrotask: B

// Second macrotask: C

```



**Best Practices:**

- Use **microtasks for immediate, critical** operations

- Use **macrotasks for deferred, scheduled** work

- Understand **all microtasks run** before any macrotask

- **Avoid infinite microtask loops** (can freeze browser)

- Use setTimeout(fn, 0) to **yield to UI**

- Promises automatically use microtask queue

- In Node.js, prefer **setImmediate over setTimeout(0)** for macrotasks

- Use **queueMicrotask** for explicit microtask scheduling



**Key Takeaways:**

- **Microtasks**: Higher priority, ALL processed per cycle

- **Macrotasks**: Lower priority, ONE processed per cycle

- Microtasks: Promise callbacks, queueMicrotask, MutationObserver

- Macrotasks: setTimeout, setInterval, I/O, UI events

- Order: sync code → all microtasks → render → one macrotask

- Microtasks can add more microtasks (processed same cycle)

- Understanding crucial for debugging async timing issues

- Core concept of JavaScript event loop



## ES6+ Features



</details>
<details><summary>61. What are template literals?</summary>






**Answer:**

Template literals (template strings) are string literals enclosed by backticks (`` ` ``) that support string interpolation, multi-line strings, and embedded expressions using `${}` syntax. They provide a cleaner and more powerful way to work with strings compared to regular string concatenation.



**Basic Syntax:**



```javascript

// Regular string

const regular = 'Hello, World!';



// Template literal

const template = `Hello, World!`;



// Both are strings

console.log(typeof regular);  // 'string'

console.log(typeof template); // 'string'

```



**String Interpolation:**



```javascript

// Old way - concatenation

const name = 'John';

const age = 30;

const message = 'Hello, my name is ' + name + ' and I am ' + age + ' years old.';



// ✅ Template literal - cleaner

const message = `Hello, my name is ${name} and I am ${age} years old.`;

console.log(message); // 'Hello, my name is John and I am 30 years old.'



// Any expression works

const a = 5;

const b = 10;

console.log(`Sum: ${a + b}`);          // 'Sum: 15'

console.log(`Product: ${a * b}`);      // 'Product: 50'

console.log(`Is greater? ${a > b}`);   // 'Is greater? false'

```



**Embedded Expressions:**



```javascript

// Function calls

function greet(name) {

  return `Hello, ${name.toUpperCase()}!`;

}

console.log(`Message: ${greet('john')}`); // 'Message: Hello, JOHN!'



// Object properties

const user = { name: 'Alice', age: 25 };

console.log(`User: ${user.name}, Age: ${user.age}`);



// Array methods

const numbers = [1, 2, 3, 4, 5];

console.log(`Total: ${numbers.reduce((a, b) => a + b)}`); // 'Total: 15'



// Conditional (ternary) operator

const age = 18;

console.log(`You are ${age >= 18 ? 'an adult' : 'a minor'}`);



// Complex expressions

const price = 29.99;

const quantity = 3;

const tax = 0.08;

console.log(`Total: $${(price * quantity * (1 + tax)).toFixed(2)}`);

// 'Total: $97.17'

```



**Multi-line Strings:**



```javascript

// Old way - concatenation with \n

const oldMultiline = 'Line 1\n' +

                     'Line 2\n' +

                     'Line 3';



// ✅ Template literal - natural multi-line

const newMultiline = `Line 1

Line 2

Line 3`;



console.log(newMultiline);

// Line 1

// Line 2

// Line 3



// HTML templates

const html = `

  <div class="card">

    <h2>${user.name}</h2>

    <p>${user.email}</p>

  </div>

`;



// SQL queries

const query = `

  SELECT *

  FROM users

  WHERE age > ${minAge}

    AND active = true

  ORDER BY created_at DESC

`;

```



**Preserves Whitespace:**



```javascript

// Indentation is preserved

const code = `

  function example() {

    console.log('Hello');

  }

`;



console.log(code);

// (includes leading spaces and newlines)



// Be careful with indentation

const html = `

    <div>

      <p>Content</p>

    </div>

`; // Includes the indentation!



// Use trim() if needed

const trimmedHtml = `

    <div>

      <p>Content</p>

    </div>

`.trim();

```



**Escaping Backticks:**



```javascript

// Escape backticks with backslash

const message = `This is a backtick: \``;

console.log(message); // 'This is a backtick: `'



// Nested template literals (no escape needed)

const outer = `Outer ${`Inner`}`;

console.log(outer); // 'Outer Inner'



// Code example in template

const codeExample = `Use \`console.log()\` to print`;

console.log(codeExample); // 'Use `console.log()` to print'

```



**Tagged Template Literals:**



```javascript

// Custom processing with tag functions

function highlight(strings, ...values) {

  return strings.reduce((result, str, i) => {

    return result + str + (values[i] ? `<mark>${values[i]}</mark>` : '');

  }, '');

}



const name = 'John';

const age = 30;

const result = highlight`Name: ${name}, Age: ${age}`;

console.log(result);

// 'Name: <mark>John</mark>, Age: <mark>30</mark>'



// strings: ['Name: ', ', Age: ', '']

// values: ['John', 30]

```



**Tagged Template Use Cases:**



**1. Sanitization/Escaping:**



```javascript

function html(strings, ...values) {

  return strings.reduce((result, str, i) => {

    const value = values[i];

    if (value == null) {

      return result + str;

    }

    

    // Escape HTML

    const escaped = String(value)

      .replace(/&/g, '&amp;')

      .replace(/</g, '&lt;')

      .replace(/>/g, '&gt;')

      .replace(/"/g, '&quot;')

      .replace(/'/g, '&#039;');

    

    return result + str + escaped;

  }, '');

}



const userInput = '<script>alert("XSS")</script>';

const safe = html`<div>${userInput}</div>`;

console.log(safe);

// '<div>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</div>'

```



**2. Internationalization (i18n):**



```javascript

function i18n(strings, ...values) {

  const translations = {

    'Hello, ': 'Bonjour, ',

    '! You have ': '! Vous avez ',

    ' messages.': ' messages.'

  };

  

  return strings.reduce((result, str, i) => {

    const translated = translations[str] || str;

    return result + translated + (values[i] || '');

  }, '');

}



const name = 'Marie';

const count = 5;

const message = i18n`Hello, ${name}! You have ${count} messages.`;

console.log(message);

// 'Bonjour, Marie! Vous avez 5 messages.'

```



**3. SQL Parameterization:**



```javascript

function sql(strings, ...values) {

  const query = strings.reduce((result, str, i) => {

    return result + str + (values[i] !== undefined ? `$${i + 1}` : '');

  }, '');

  

  return {

    text: query,

    values: values

  };

}



const userId = 123;

const minAge = 18;

const query = sql`

  SELECT * FROM users

  WHERE id = ${userId}

    AND age > ${minAge}

`;



console.log(query);

// {

//   text: 'SELECT * FROM users WHERE id = $1 AND age > $2',

//   values: [123, 18]

// }

```



**4. Styling (CSS-in-JS):**



```javascript

function css(strings, ...values) {

  return strings.reduce((result, str, i) => {

    return result + str + (values[i] || '');

  }, '');

}



const primaryColor = '#007bff';

const padding = '20px';



const styles = css`

  .button {

    background-color: ${primaryColor};

    padding: ${padding};

    border: none;

    border-radius: 4px;

  }

`;



console.log(styles);

// CSS string with interpolated values

```



**Practical Examples:**



**1. Building URLs:**



```javascript

const baseUrl = 'https://api.example.com';

const endpoint = 'users';

const userId = 123;

const query = 'active=true&sort=name';



const url = `${baseUrl}/${endpoint}/${userId}?${query}`;

console.log(url);

// 'https://api.example.com/users/123?active=true&sort=name'



// Dynamic API request

async function fetchUser(id) {

  const response = await fetch(`${baseUrl}/users/${id}`);

  return response.json();

}

```



**2. Generating HTML:**



```javascript

function createCard(user) {

  return `

    <div class="card">

      <img src="${user.avatar}" alt="${user.name}" />

      <h2>${user.name}</h2>

      <p>${user.bio}</p>

      <button data-id="${user.id}">Follow</button>

    </div>

  `;

}



const user = {

  id: 1,

  name: 'John Doe',

  avatar: '/avatars/john.jpg',

  bio: 'Software developer'

};



document.body.innerHTML = createCard(user);

```



**3. Logging and Debugging:**



```javascript

function log(message, data) {

  const timestamp = new Date().toISOString();

  console.log(`[${timestamp}] ${message}:`, data);

}



log('User logged in', { userId: 123, ip: '192.168.1.1' });

// '[2024-01-15T10:30:00.000Z] User logged in: { userId: 123, ip: '192.168.1.1' }'



// Error messages

function validateAge(age) {

  if (age < 18) {

    throw new Error(`Invalid age: ${age}. Must be 18 or older.`);

  }

}

```



**4. Dynamic Content:**



```javascript

function generateGreeting(name, time) {

  const hour = new Date().getHours();

  const greeting = hour < 12 ? 'Good morning' : 

                   hour < 18 ? 'Good afternoon' : 

                   'Good evening';

  

  return `${greeting}, ${name}! The current time is ${time}.`;

}



console.log(generateGreeting('Alice', '14:30'));

// 'Good afternoon, Alice! The current time is 14:30.'

```



**5. Configuration:**



```javascript

const config = {

  api: {

    url: 'https://api.example.com',

    version: 'v2',

    key: 'abc123'

  }

};



const endpoint = `${config.api.url}/${config.api.version}/users`;

const headers = {

  'Authorization': `Bearer ${config.api.key}`,

  'Content-Type': 'application/json'

};

```



**Comparison with String Concatenation:**



```javascript

const name = 'John';

const age = 30;

const city = 'New York';



// Concatenation - hard to read

const concat = 'My name is ' + name + ', I am ' + age + ' years old, and I live in ' + city + '.';



// Template literal - clean and readable

const template = `My name is ${name}, I am ${age} years old, and I live in ${city}.`;



// Performance: Nearly identical for simple cases

// Readability: Template literals win

```



**Nesting Template Literals:**



```javascript

// Template literals can be nested

const name = 'John';

const items = ['apple', 'banana', 'orange'];



const message = `Hello ${name}, you have ${items.length} items: ${

  items.map(item => `"${item}"`).join(', ')

}`;



console.log(message);

// 'Hello John, you have 3 items: "apple", "banana", "orange"'



// Complex nesting

const users = [

  { name: 'Alice', age: 25 },

  { name: 'Bob', age: 30 }

];



const html = `

  <ul>

    ${users.map(user => `

      <li>${user.name} (${user.age})</li>

    `).join('')}

  </ul>

`;

```



**Common Patterns:**



```javascript

// Conditional content

const status = 'active';

const message = `User is ${status === 'active' ? 'currently active' : 'inactive'}`;



// Optional content

const middleName = 'James';

const fullName = `John${middleName ? ` ${middleName}` : ''} Doe`;



// Pluralization

const count = 5;

const text = `You have ${count} ${count === 1 ? 'item' : 'items'}`;



// Number formatting

const price = 1234.56;

const formatted = `Price: $${price.toLocaleString('en-US', { minimumFractionDigits: 2 })}`;

// 'Price: $1,234.56'

```



**Best Practices:**

- Use template literals for **string interpolation**

- Prefer over concatenation for **readability**

- Great for **multi-line strings** (HTML, SQL, etc.)

- Use **tagged templates** for custom processing

- **Sanitize user input** to prevent XSS attacks

- Be aware of **whitespace preservation**

- Use `trim()` for **cleaner multi-line strings**

- Expressions in `${}` are **evaluated immediately**



**Key Takeaways:**

- Template literals use backticks (`` ` ``)

- Support **string interpolation** with `${expression}`

- Enable **multi-line strings** without \n

- Cleaner than string concatenation

- Support **any JavaScript expression** in ${}

- **Tagged templates** for custom processing

- Whitespace is preserved (including indentation)

- Part of ES6, widely supported in modern browsers



---



</details>
<details><summary>62. What is destructuring in JavaScript?</summary>




**Answer:**



Destructuring is an ES6 feature that allows extracting values from arrays or properties from objects into distinct variables using a convenient syntax. It provides a concise way to unpack values from data structures.



#### **Array Destructuring**



```javascript

// Basic array destructuring

const colors = ['red', 'green', 'blue'];

const [first, second, third] = colors;

console.log(first);   // 'red'

console.log(second);  // 'green'

console.log(third);   // 'blue'



// Skipping elements

const [primary, , tertiary] = colors;

console.log(primary);   // 'red'

console.log(tertiary);  // 'blue'



// Default values

const [a, b, c, d = 'yellow'] = colors;

console.log(d);  // 'yellow' (default when undefined)



// Rest pattern

const numbers = [1, 2, 3, 4, 5];

const [head, ...tail] = numbers;

console.log(head);  // 1

console.log(tail);  // [2, 3, 4, 5]



// Swapping variables

let x = 10, y = 20;

[x, y] = [y, x];

console.log(x, y);  // 20, 10



// Nested array destructuring

const nested = [1, [2, 3], 4];

const [num1, [num2, num3], num4] = nested;

console.log(num2);  // 2

```



#### **Object Destructuring**



```javascript

// Basic object destructuring

const user = {

  name: 'John',

  age: 30,

  email: 'john@example.com'

};



const { name, age, email } = user;

console.log(name);   // 'John'

console.log(age);    // 30

console.log(email);  // 'john@example.com'



// Renaming variables

const { name: userName, age: userAge } = user;

console.log(userName);  // 'John'

console.log(userAge);   // 30



// Default values

const { name, country = 'USA' } = user;

console.log(country);  // 'USA' (default)



// Nested object destructuring

const employee = {

  id: 101,

  info: {

    name: 'Alice',

    department: {

      name: 'Engineering',

      location: 'Building A'

    }

  }

};



const { 

  info: { 

    name, 

    department: { name: deptName, location } 

  } 

} = employee;

console.log(name);      // 'Alice'

console.log(deptName);  // 'Engineering'

console.log(location);  // 'Building A'



// Rest properties

const { id, ...otherInfo } = employee;

console.log(id);         // 101

console.log(otherInfo);  // { info: {...} }



// Computed property names

const key = 'name';

const { [key]: value } = user;

console.log(value);  // 'John'

```



#### **Function Parameter Destructuring**



```javascript

// Object parameters

function displayUser({ name, age, email = 'N/A' }) {

  console.log(`${name}, ${age} years old, ${email}`);

}



displayUser({ name: 'Bob', age: 25 });

// Output: "Bob, 25 years old, N/A"



// Array parameters

function sum([a, b]) {

  return a + b;

}

console.log(sum([10, 20]));  // 30



// Nested destructuring in parameters

function processOrder({ 

  orderId, 

  customer: { name, address: { city } } 

}) {

  console.log(`Order ${orderId} for ${name} in ${city}`);

}



processOrder({

  orderId: 'A123',

  customer: {

    name: 'Charlie',

    address: { city: 'New York', zip: '10001' }

  }

});

// Output: "Order A123 for Charlie in New York"



// With default values

function createUser({ 

  name = 'Guest', 

  role = 'user', 

  active = true 

} = {}) {

  return { name, role, active };

}



console.log(createUser());  // { name: 'Guest', role: 'user', active: true }

console.log(createUser({ name: 'Admin' }));  // { name: 'Admin', role: 'user', active: true }

```



#### **Practical Use Cases**



**1. API Response Handling:**

```javascript

// Extract only needed data from API response

async function fetchUser(userId) {

  const response = await fetch(`/api/users/${userId}`);

  const { data: { name, email, profile: { avatar } } } = await response.json();

  return { name, email, avatar };

}



// Multiple return values

function getCoordinates() {

  return { latitude: 40.7128, longitude: -74.0060 };

}

const { latitude, longitude } = getCoordinates();

```



**2. React Component Props:**

```javascript

// Clean component syntax

function UserCard({ name, age, email, avatar = '/default-avatar.png' }) {

  return (

    <div className="user-card">

      <img src={avatar} alt={name} />

      <h3>{name}</h3>

      <p>{age} years old</p>

      <p>{email}</p>

    </div>

  );

}



// Props with nested destructuring

function Profile({ user: { name, settings: { theme, language } } }) {

  return <div data-theme={theme} data-lang={language}>{name}</div>;

}

```



**3. Configuration Objects:**

```javascript

function initializeApp({

  apiUrl = 'https://api.example.com',

  timeout = 5000,

  retries = 3,

  headers = {},

  ...options

} = {}) {

  console.log(`API: ${apiUrl}, Timeout: ${timeout}ms`);

  console.log('Additional options:', options);

}



initializeApp({ apiUrl: 'https://custom-api.com', debug: true });

```



**4. Array Operations:**

```javascript

// Extracting from regex matches

const url = 'https://example.com:8080/path';

const [, protocol, domain, port, path] = 

  url.match(/^(https?):\/\/([^:\/]+):(\d+)(.*)$/) || [];



console.log(protocol, domain, port, path);

// 'https', 'example.com', '8080', '/path'



// Working with iterators

const map = new Map([['a', 1], ['b', 2]]);

for (const [key, value] of map) {

  console.log(`${key}: ${value}`);

}

```



**5. Module Imports:**

```javascript

// Import specific functions

import { useState, useEffect, useMemo } from 'react';



// Destructure from default import

import React, { Component, Fragment } from 'react';



// Rename imports

import { default as lodash, map as lodashMap } from 'lodash';

```



#### **Common Patterns and Best Practices**



```javascript

// 1. Handling optional chaining with destructuring

const user = null;

const { name = 'Guest' } = user || {};  // Safe destructuring

console.log(name);  // 'Guest'



// 2. Mixed array and object destructuring

const response = {

  status: 200,

  data: ['item1', 'item2', 'item3']

};

const { status, data: [first, ...rest] } = response;



// 3. Destructuring in loops

const users = [

  { id: 1, name: 'Alice' },

  { id: 2, name: 'Bob' }

];



users.forEach(({ id, name }) => {

  console.log(`${id}: ${name}`);

});



// 4. Conditional destructuring

const config = { mode: 'production' };

const { 

  mode, 

  debug = mode === 'development'  // Computed default

} = config;



// 5. Aliasing with defaults

const { 

  name: userName = 'Anonymous',

  age: userAge = 0 

} = {};

console.log(userName, userAge);  // 'Anonymous', 0

```



#### **Common Pitfalls**



```javascript

// 1. Destructuring null or undefined throws error

const obj = null;

// const { prop } = obj;  // TypeError!

const { prop } = obj || {};  // Safe with fallback



// 2. Cannot redeclare with let/const

let x = 10;

// let { x } = { x: 20 };  // SyntaxError: Identifier 'x' has already been declared

({ x } = { x: 20 });  // OK - assignment without declaration (note parentheses)



// 3. Mixing default values with renaming

const { name: userName = 'Guest' } = {};  // Correct

// const { name = 'Guest': userName } = {};  // Syntax error



// 4. Deep destructuring can fail if intermediate is undefined

const data = { user: null };

// const { user: { name } } = data;  // TypeError!

const { user: { name } = {} } = data || {};  // Safe



// 5. Rest pattern must be last

// const [...rest, last] = [1, 2, 3];  // SyntaxError

const [first, ...rest] = [1, 2, 3];  // Correct

```



#### **Performance Considerations**



```javascript

// Destructuring has minimal overhead

// Before (multiple property accesses)

function process(config) {

  const url = config.url;

  const method = config.method;

  const headers = config.headers;

  // ... use url, method, headers

}



// After (single destructuring)

function process(config) {

  const { url, method, headers } = config;

  // ... use url, method, headers

}



// Both have similar performance, but destructuring is more readable

```



#### **Comparison with Traditional Approach**



| Feature | Traditional | Destructuring |

|---------|-------------|---------------|

| **Syntax** | `const name = user.name;` | `const { name } = user;` |

| **Multiple vars** | Multiple lines | Single line |

| **Default values** | `\|\|` operator | Built-in syntax |

| **Renaming** | New variable needed | `{ name: newName }` |

| **Nested access** | Multiple dots | Nested pattern |

| **Array swapping** | Temp variable needed | `[a, b] = [b, a]` |

| **Readability** | Verbose | Concise |

| **Safety** | Manual checks | Pattern-based |



#### **Key Takeaways**



- **Concise syntax** for extracting values from arrays and objects

- Works with **arrays, objects, nested structures**, and **function parameters**

- Supports **default values, renaming, rest patterns**, and **computed properties**

- Enables **variable swapping** without temporary variables

- Common in **modern JavaScript** (React, ES modules, API handling)

- **Fails on null/undefined** - use fallbacks (`|| {}`) for safety

- **Rest pattern must be last** in destructuring assignment

- Greatly improves **code readability** and reduces boilerplate

- Works with **iterables** (arrays, Maps, Sets, strings)

- Combining destructuring with default parameters creates flexible APIs



---



</details>
<details><summary>63. What are classes in JavaScript?</summary>




**Answer:**



Classes in JavaScript are syntactic sugar over the existing prototype-based inheritance. Introduced in ES6, they provide a cleaner and more intuitive syntax for creating objects and implementing inheritance, similar to class-based languages like Java or C++.



#### **Basic Class Syntax**



```javascript

// Class declaration

class Person {

  // Constructor method

  constructor(name, age) {

    this.name = name;

    this.age = age;

  }

  

  // Instance method

  greet() {

    return `Hello, my name is ${this.name}`;

  }

  

  // Instance method

  getDetails() {

    return `${this.name} is ${this.age} years old`;

  }

}



// Creating instances

const person1 = new Person('Alice', 30);

const person2 = new Person('Bob', 25);



console.log(person1.greet());        // "Hello, my name is Alice"

console.log(person2.getDetails());   // "Bob is 25 years old"

console.log(person1 instanceof Person);  // true



// Class expression (less common)

const Animal = class {

  constructor(name) {

    this.name = name;

  }

};



// Named class expression

const Cat = class Feline {

  constructor(name) {

    this.name = name;

  }

};

```



#### **Constructor Method**



```javascript

class User {

  constructor(username, email) {

    // Initialize instance properties

    this.username = username;

    this.email = email;

    this.createdAt = new Date();

    

    // Validation in constructor

    if (!email.includes('@')) {

      throw new Error('Invalid email address');

    }

  }

}



const user = new User('john_doe', 'john@example.com');

console.log(user.username);   // 'john_doe'

console.log(user.createdAt);  // Current date



// Constructor is optional

class EmptyClass {

  // No constructor - default empty constructor is used

}



const instance = new EmptyClass();

```



#### **Instance Methods**



```javascript

class Calculator {

  constructor() {

    this.result = 0;

  }

  

  add(num) {

    this.result += num;

    return this;  // Method chaining

  }

  

  subtract(num) {

    this.result -= num;

    return this;

  }

  

  multiply(num) {

    this.result *= num;

    return this;

  }

  

  getResult() {

    return this.result;

  }

  

  reset() {

    this.result = 0;

    return this;

  }

}



// Method chaining

const calc = new Calculator();

const result = calc.add(10).multiply(2).subtract(5).getResult();

console.log(result);  // 15

```



#### **Static Methods and Properties**



```javascript

class MathHelper {

  // Static property

  static PI = 3.14159;

  

  // Static method - called on class, not instances

  static add(a, b) {

    return a + b;

  }

  

  static multiply(a, b) {

    return a * b;

  }

  

  static circleArea(radius) {

    return MathHelper.PI * radius * radius;

  }

}



// Call static methods on class itself

console.log(MathHelper.add(5, 3));           // 8

console.log(MathHelper.circleArea(5));       // 78.53975

console.log(MathHelper.PI);                  // 3.14159



const helper = new MathHelper();

// console.log(helper.add(5, 3));  // TypeError - not available on instance



// Common use case: Factory methods

class User {

  constructor(name, role) {

    this.name = name;

    this.role = role;

  }

  

  static createAdmin(name) {

    return new User(name, 'admin');

  }

  

  static createGuest(name) {

    return new User(name, 'guest');

  }

}



const admin = User.createAdmin('Alice');

const guest = User.createGuest('Bob');

console.log(admin.role);  // 'admin'

console.log(guest.role);  // 'guest'

```



#### **Getters and Setters**



```javascript

class Rectangle {

  constructor(width, height) {

    this._width = width;    // Convention: underscore for private-like

    this._height = height;

  }

  

  // Getter - accessed like a property

  get width() {

    return this._width;

  }

  

  // Setter - assigned like a property

  set width(value) {

    if (value > 0) {

      this._width = value;

    } else {

      throw new Error('Width must be positive');

    }

  }

  

  get height() {

    return this._height;

  }

  

  set height(value) {

    if (value > 0) {

      this._height = value;

    } else {

      throw new Error('Height must be positive');

    }

  }

  

  // Computed property using getter

  get area() {

    return this._width * this._height;

  }

  

  get perimeter() {

    return 2 * (this._width + this._height);

  }

}



const rect = new Rectangle(10, 5);

console.log(rect.width);      // 10 (getter)

console.log(rect.area);       // 50 (computed)



rect.width = 20;              // setter

console.log(rect.area);       // 100 (recomputed)



// rect.width = -5;  // Error: Width must be positive

```



#### **Class Inheritance with `extends`**



```javascript

// Parent class

class Animal {

  constructor(name, species) {

    this.name = name;

    this.species = species;

  }

  

  makeSound() {

    return `${this.name} makes a sound`;

  }

  

  describe() {

    return `${this.name} is a ${this.species}`;

  }

}



// Child class extends parent

class Dog extends Animal {

  constructor(name, breed) {

    // Must call super() before using 'this'

    super(name, 'Dog');  // Calls parent constructor

    this.breed = breed;

  }

  

  // Override parent method

  makeSound() {

    return `${this.name} barks: Woof! Woof!`;

  }

  

  // New method specific to Dog

  fetch() {

    return `${this.name} is fetching the ball`;

  }

  

  // Call parent method with super

  getFullDescription() {

    return `${super.describe()} of breed ${this.breed}`;

  }

}



const dog = new Dog('Buddy', 'Golden Retriever');

console.log(dog.makeSound());           // "Buddy barks: Woof! Woof!"

console.log(dog.describe());            // "Buddy is a Dog"

console.log(dog.fetch());               // "Buddy is fetching the ball"

console.log(dog.getFullDescription());  // "Buddy is a Dog of breed Golden Retriever"



// Inheritance chain

console.log(dog instanceof Dog);      // true

console.log(dog instanceof Animal);   // true

console.log(dog instanceof Object);   // true

```



#### **The `super` Keyword**



```javascript

class Vehicle {

  constructor(brand, model) {

    this.brand = brand;

    this.model = model;

  }

  

  start() {

    return `${this.brand} ${this.model} is starting`;

  }

  

  static info() {

    return 'This is a vehicle class';

  }

}



class Car extends Vehicle {

  constructor(brand, model, doors) {

    // super() calls parent constructor

    super(brand, model);

    this.doors = doors;

  }

  

  start() {

    // super.method() calls parent method

    const parentStart = super.start();

    return `${parentStart} with ${this.doors} doors`;

  }

  

  static info() {

    // super in static method calls parent static method

    return `${super.info()} - Extended to Car`;

  }

}



const car = new Car('Toyota', 'Camry', 4);

console.log(car.start());   // "Toyota Camry is starting with 4 doors"

console.log(Car.info());    // "This is a vehicle class - Extended to Car"

```



#### **Private Fields and Methods (ES2022)**



```javascript

class BankAccount {

  // Private fields (start with #)

  #balance = 0;

  #accountNumber;

  

  constructor(accountNumber, initialBalance = 0) {

    this.#accountNumber = accountNumber;

    this.#balance = initialBalance;

  }

  

  // Private method

  #validateAmount(amount) {

    return amount > 0 && Number.isFinite(amount);

  }

  

  // Public method accessing private members

  deposit(amount) {

    if (this.#validateAmount(amount)) {

      this.#balance += amount;

      return `Deposited $${amount}. New balance: $${this.#balance}`;

    }

    throw new Error('Invalid amount');

  }

  

  withdraw(amount) {

    if (this.#validateAmount(amount) && amount <= this.#balance) {

      this.#balance -= amount;

      return `Withdrew $${amount}. New balance: $${this.#balance}`;

    }

    throw new Error('Invalid amount or insufficient funds');

  }

  

  getBalance() {

    return this.#balance;

  }

}



const account = new BankAccount('ACC123', 1000);

console.log(account.deposit(500));      // "Deposited $500. New balance: $1500"

console.log(account.getBalance());      // 1500



// console.log(account.#balance);       // SyntaxError: Private field

// account.#validateAmount(100);        // SyntaxError: Private method

```



#### **Practical Use Cases**



**1. UI Components:**

```javascript

class Modal {

  constructor(title, content, options = {}) {

    this.title = title;

    this.content = content;

    this.isOpen = false;

    this.options = { dismissible: true, ...options };

  }

  

  open() {

    this.isOpen = true;

    this.render();

    this.attachEvents();

  }

  

  close() {

    this.isOpen = false;

    this.cleanup();

  }

  

  render() {

    console.log(`Rendering modal: ${this.title}`);

  }

  

  attachEvents() {

    if (this.options.dismissible) {

      console.log('Attaching close event handlers');

    }

  }

  

  cleanup() {

    console.log('Cleaning up modal resources');

  }

}



const confirmModal = new Modal('Confirm Action', 'Are you sure?');

confirmModal.open();

```



**2. Data Models:**

```javascript

class Product {

  #price;

  

  constructor(name, price, category) {

    this.name = name;

    this.#price = price;

    this.category = category;

    this.createdAt = new Date();

  }

  

  get price() {

    return this.#price;

  }

  

  set price(value) {

    if (value < 0) throw new Error('Price cannot be negative');

    this.#price = value;

  }

  

  get priceWithTax() {

    return this.#price * 1.1;  // 10% tax

  }

  

  applyDiscount(percentage) {

    this.#price *= (1 - percentage / 100);

  }

  

  toJSON() {

    return {

      name: this.name,

      price: this.#price,

      category: this.category,

      createdAt: this.createdAt

    };

  }

}



const laptop = new Product('Laptop', 1000, 'Electronics');

console.log(laptop.price);           // 1000

console.log(laptop.priceWithTax);    // 1100

laptop.applyDiscount(10);

console.log(laptop.price);           // 900

```



**3. Service Classes:**

```javascript

class ApiService {

  constructor(baseURL) {

    this.baseURL = baseURL;

    this.headers = {

      'Content-Type': 'application/json'

    };

  }

  

  setAuthToken(token) {

    this.headers['Authorization'] = `Bearer ${token}`;

  }

  

  async get(endpoint) {

    const response = await fetch(`${this.baseURL}${endpoint}`, {

      headers: this.headers

    });

    return response.json();

  }

  

  async post(endpoint, data) {

    const response = await fetch(`${this.baseURL}${endpoint}`, {

      method: 'POST',

      headers: this.headers,

      body: JSON.stringify(data)

    });

    return response.json();

  }

}



const api = new ApiService('https://api.example.com');

api.setAuthToken('abc123');

// api.get('/users/1').then(data => console.log(data));

```



#### **Key Takeaways**



- **Syntactic sugar** over prototype-based inheritance

- Provides **cleaner syntax** for constructor functions and inheritance

- **Constructor method** initializes instance properties

- **Instance methods** shared across all instances (on prototype)

- **Static methods/properties** belong to class itself, not instances

- **Getters/setters** provide controlled property access

- **`extends`** keyword enables inheritance from parent class

- **`super`** keyword accesses parent constructor and methods

- **Private fields (#)** enforce true encapsulation (ES2022)

- **Not hoisted** - must be declared before use

- Classes are **first-class citizens** (can be passed, returned, assigned)

- **`new` keyword required** to create instances

- **Method chaining** possible by returning `this`

- Common in **modern frameworks** (React class components, Angular services)

- Prefer **classes for complex objects** with shared behavior



---



</details>
<details><summary>64. What is the difference between class and function constructor?</summary>




**Answer:**



While JavaScript classes and function constructors both create objects and implement inheritance, they differ in syntax, behavior, and features. Classes (ES6+) provide cleaner syntax but are essentially syntactic sugar over function constructors.



#### **Syntax Comparison**



```javascript

// FUNCTION CONSTRUCTOR (ES5)

function Person(name, age) {

  this.name = name;

  this.age = age;

}



// Adding methods to prototype

Person.prototype.greet = function() {

  return `Hello, I'm ${this.name}`;

};



// Static method

Person.createGuest = function() {

  return new Person('Guest', 0);

};



const person1 = new Person('Alice', 30);

console.log(person1.greet());  // "Hello, I'm Alice"



// CLASS (ES6+)

class PersonClass {

  constructor(name, age) {

    this.name = name;

    this.age = age;

  }

  

  // Method automatically added to prototype

  greet() {

    return `Hello, I'm ${this.name}`;

  }

  

  // Static method

  static createGuest() {

    return new PersonClass('Guest', 0);

  }

}



const person2 = new PersonClass('Bob', 25);

console.log(person2.greet());  // "Hello, I'm Bob"

```



#### **Detailed Comparison Table**



| Feature | Function Constructor | Class |

|---------|---------------------|-------|

| **Syntax** | Function-based | Class keyword |

| **Hoisting** | Hoisted (can use before declaration) | Not hoisted (TDZ applies) |

| **Strict mode** | Non-strict by default | Always strict mode |

| **Methods** | Added to prototype manually | Defined inside class body |

| **`new` required** | Can be called without `new` | Must use `new` or throws error |

| **Inheritance** | Manual prototype manipulation | `extends` keyword |

| **Super** | Manual parent call | `super()` keyword |

| **Static methods** | Properties on function | `static` keyword |

| **Getters/Setters** | `Object.defineProperty` | Built-in syntax |

| **Private fields** | Closures or conventions | Native `#` syntax (ES2022) |

| **`typeof`** | 'function' | 'function' (classes are functions) |

| **Enumerable** | Methods enumerable by default | Methods non-enumerable |

| **Constructor property** | Yes | Yes |



#### **Hoisting Behavior**



```javascript

// FUNCTION CONSTRUCTOR - Hoisted

const p1 = new PersonFunc('Alice', 30);  // Works!



function PersonFunc(name, age) {

  this.name = name;

  this.age = age;

}



// CLASS - Not Hoisted (Temporal Dead Zone)

// const p2 = new PersonClass('Bob', 25);  // ReferenceError!



class PersonClass {

  constructor(name, age) {

    this.name = name;

    this.age = age;

  }

}



const p2 = new PersonClass('Bob', 25);  // Must declare first

```



#### **Calling Without `new`**



```javascript

// FUNCTION CONSTRUCTOR - Can be called without 'new' (but shouldn't)

function Animal(name) {

  this.name = name;

}



const animal1 = Animal('Dog');  // No error, but 'this' is global/undefined

console.log(animal1);           // undefined

console.log(window.name);       // 'Dog' (in non-strict mode)



// Better: Check for 'new' usage

function SafeAnimal(name) {

  if (!(this instanceof SafeAnimal)) {

    return new SafeAnimal(name);

  }

  this.name = name;

}



// CLASS - Must use 'new'

class AnimalClass {

  constructor(name) {

    this.name = name;

  }

}



// const animal2 = AnimalClass('Cat');  // TypeError: Class constructor cannot be invoked without 'new'

const animal2 = new AnimalClass('Cat');  // Correct

```



#### **Inheritance Comparison**



```javascript

// FUNCTION CONSTRUCTOR INHERITANCE

function Vehicle(brand) {

  this.brand = brand;

}



Vehicle.prototype.start = function() {

  return `${this.brand} is starting`;

};



function Car(brand, model) {

  Vehicle.call(this, brand);  // Call parent constructor

  this.model = model;

}



// Set up inheritance chain manually

Car.prototype = Object.create(Vehicle.prototype);

Car.prototype.constructor = Car;



// Override method

Car.prototype.start = function() {

  return `${this.brand} ${this.model} is starting`;

};



const car1 = new Car('Toyota', 'Camry');

console.log(car1.start());  // "Toyota Camry is starting"



// CLASS INHERITANCE - Much cleaner

class VehicleClass {

  constructor(brand) {

    this.brand = brand;

  }

  

  start() {

    return `${this.brand} is starting`;

  }

}



class CarClass extends VehicleClass {

  constructor(brand, model) {

    super(brand);  // Call parent constructor

    this.model = model;

  }

  

  start() {

    return `${this.brand} ${this.model} is starting`;

  }

}



const car2 = new CarClass('Honda', 'Accord');

console.log(car2.start());  // "Honda Accord is starting"

```



#### **Accessing Parent Methods**



```javascript

// FUNCTION CONSTRUCTOR

function ParentFunc() {}

ParentFunc.prototype.show = function() {

  return 'Parent method';

};



function ChildFunc() {}

ChildFunc.prototype = Object.create(ParentFunc.prototype);

ChildFunc.prototype.constructor = ChildFunc;



ChildFunc.prototype.show = function() {

  // Call parent method - verbose

  const parentResult = ParentFunc.prototype.show.call(this);

  return parentResult + ' + Child method';

};



// CLASS - Super keyword

class ParentClass {

  show() {

    return 'Parent method';

  }

}



class ChildClass extends ParentClass {

  show() {

    // Call parent method - clean

    return super.show() + ' + Child method';

  }

}



const child = new ChildClass();

console.log(child.show());  // "Parent method + Child method"

```



#### **Getters and Setters**



```javascript

// FUNCTION CONSTRUCTOR - Verbose

function Circle(radius) {

  let _radius = radius;  // Private via closure

  

  Object.defineProperty(this, 'radius', {

    get: function() {

      return _radius;

    },

    set: function(value) {

      if (value > 0) {

        _radius = value;

      }

    }

  });

  

  Object.defineProperty(this, 'area', {

    get: function() {

      return Math.PI * _radius * _radius;

    }

  });

}



const circle1 = new Circle(5);

console.log(circle1.area);  // 78.54



// CLASS - Clean syntax

class CircleClass {

  constructor(radius) {

    this._radius = radius;

  }

  

  get radius() {

    return this._radius;

  }

  

  set radius(value) {

    if (value > 0) {

      this._radius = value;

    }

  }

  

  get area() {

    return Math.PI * this._radius * this._radius;

  }

}



const circle2 = new CircleClass(5);

console.log(circle2.area);  // 78.54

```



#### **Static Methods**



```javascript

// FUNCTION CONSTRUCTOR

function MathUtil() {}



MathUtil.add = function(a, b) {

  return a + b;

};



MathUtil.PI = 3.14159;



console.log(MathUtil.add(5, 3));  // 8

console.log(MathUtil.PI);         // 3.14159



// CLASS

class MathUtilClass {

  static PI = 3.14159;

  

  static add(a, b) {

    return a + b;

  }

}



console.log(MathUtilClass.add(5, 3));  // 8

console.log(MathUtilClass.PI);         // 3.14159

```



#### **Private Members**



```javascript

// FUNCTION CONSTRUCTOR - Closures for privacy

function BankAccount(initialBalance) {

  // Private variable via closure

  let balance = initialBalance;

  

  // Public methods with closure access

  this.deposit = function(amount) {

    balance += amount;

    return balance;

  };

  

  this.getBalance = function() {

    return balance;

  };

}



const account1 = new BankAccount(1000);

console.log(account1.getBalance());  // 1000

account1.deposit(500);

console.log(account1.getBalance());  // 1500

// console.log(account1.balance);    // undefined (private)



// CLASS - Native private fields (ES2022)

class BankAccountClass {

  #balance;  // Private field

  

  constructor(initialBalance) {

    this.#balance = initialBalance;

  }

  

  deposit(amount) {

    this.#balance += amount;

    return this.#balance;

  }

  

  getBalance() {

    return this.#balance;

  }

}



const account2 = new BankAccountClass(1000);

console.log(account2.getBalance());  // 1000

account2.deposit(500);

console.log(account2.getBalance());  // 1500

// console.log(account2.#balance);   // SyntaxError (truly private)

```



#### **Method Enumerability**



```javascript

// FUNCTION CONSTRUCTOR - Methods enumerable

function UserFunc(name) {

  this.name = name;

}



UserFunc.prototype.greet = function() {

  return 'Hello';

};



const user1 = new UserFunc('Alice');



for (let key in user1) {

  console.log(key);  // 'name', 'greet' (method is enumerable)

}



// CLASS - Methods non-enumerable

class UserClass {

  constructor(name) {

    this.name = name;

  }

  

  greet() {

    return 'Hello';

  }

}



const user2 = new UserClass('Bob');



for (let key in user2) {

  console.log(key);  // Only 'name' (greet is non-enumerable)

}



console.log(Object.keys(user2));  // ['name']

```



#### **Performance Considerations**



```javascript

// Both have similar performance characteristics

// Methods on prototype (shared) vs instance methods (per object)



// FUNCTION CONSTRUCTOR - Prototype methods (good)

function PersonA(name) {

  this.name = name;

}

PersonA.prototype.greet = function() {  // Shared across instances

  return `Hello ${this.name}`;

};



// FUNCTION CONSTRUCTOR - Instance methods (memory inefficient)

function PersonB(name) {

  this.name = name;

  this.greet = function() {  // New function for each instance!

    return `Hello ${this.name}`;

  };

}



// CLASS - Methods on prototype (good, automatic)

class PersonC {

  constructor(name) {

    this.name = name;

  }

  greet() {  // Automatically on prototype (shared)

    return `Hello ${this.name}`;

  }

}



// Creating 1000 instances

const persons = [];

for (let i = 0; i < 1000; i++) {

  persons.push(new PersonC(`Person${i}`));

}

// All 1000 instances share the same greet method (efficient)

```



#### **When to Use Each**



**Use Function Constructors when:**

- Working with legacy ES5 codebases

- Need maximum browser compatibility (pre-ES6)

- Explicitly need hoisting behavior

- Building simple objects without inheritance



**Use Classes when:**

- Building modern applications (ES6+ environment)

- Need inheritance hierarchies

- Want cleaner, more readable syntax

- Using frameworks that prefer classes (React class components, Angular)

- Need private fields (ES2022+)

- Working with TypeScript (better type support for classes)



```javascript

// Modern recommendation: Use classes

class ModernAPI {

  #apiKey;

  

  constructor(apiKey) {

    this.#apiKey = apiKey;

  }

  

  async fetchData(endpoint) {

    const response = await fetch(endpoint, {

      headers: { 'Authorization': `Bearer ${this.#apiKey}` }

    });

    return response.json();

  }

}



// Legacy style: Function constructor

function LegacyAPI(apiKey) {

  let _apiKey = apiKey;  // Closure for privacy

  

  this.fetchData = function(endpoint) {

    return fetch(endpoint, {

      headers: { 'Authorization': 'Bearer ' + _apiKey }

    }).then(function(response) {

      return response.json();

    });

  };

}

```



#### **Key Takeaways**



- **Classes are syntactic sugar** over function constructors

- **Classes provide cleaner syntax** especially for inheritance

- Function constructors are **hoisted**, classes are **not**

- Classes **enforce `new`** keyword, function constructors don't

- Class methods are **non-enumerable** by default

- Classes enable **native private fields** (`#field`)

- **`super` keyword** in classes simplifies parent access

- Both create objects with **same prototype chain**

- Classes are **always in strict mode**

- **Modern codebases prefer classes** for readability and features

- Function constructors still relevant for **legacy support**

- Understanding both helps with **legacy code maintenance**

- Classes work better with **TypeScript and modern tooling**

- Performance is **essentially the same** for both approaches





</details>
<details><summary>63. What are classes in JavaScript?</summary>






</details>
<details><summary>64. What is the difference between class and function constructor?</summary>






---



</details>
<details><summary>65. What are modules in JavaScript?</summary>




**Answer:**



JavaScript modules are reusable pieces of code that can be exported from one file and imported into another. Introduced in ES6 (ES2015), modules provide a way to organize, encapsulate, and share code across different files, promoting better code organization, maintainability, and avoiding global namespace pollution.



#### **Module Basics**



```javascript

// FILE: math.js (Module exporting functionality)

export function add(a, b) {

  return a + b;

}



export function subtract(a, b) {

  return a - b;

}



export const PI = 3.14159;



// FILE: app.js (Module importing functionality)

import { add, subtract, PI } from './math.js';



console.log(add(5, 3));        // 8

console.log(subtract(10, 4));  // 6

console.log(PI);               // 3.14159

```



#### **Export Syntax**



**1. Named Exports:**

```javascript

// math-utils.js



// Export during declaration

export function multiply(a, b) {

  return a * b;

}



export const MAX_VALUE = 1000;



export class Calculator {

  add(a, b) {

    return a + b;

  }

}



// Export separately

function divide(a, b) {

  if (b === 0) throw new Error('Division by zero');

  return a / b;

}



const MIN_VALUE = 0;



export { divide, MIN_VALUE };



// Export with rename

function internalHelper() {

  return 'helper';

}



export { internalHelper as helper };

```



**2. Default Export:**

```javascript

// user.js



// Default export (one per module)

export default class User {

  constructor(name, email) {

    this.name = name;

    this.email = email;

  }

  

  greet() {

    return `Hello, ${this.name}`;

  }

}



// Alternative syntax

class Product {

  constructor(name, price) {

    this.name = name;

    this.price = price;

  }

}



export default Product;



// Default export with function

export default function authenticate(username, password) {

  // Authentication logic

  return true;

}



// Default export with value

export default 42;

```



**3. Mixed Exports:**

```javascript

// api.js



// Default export

export default class ApiClient {

  constructor(baseUrl) {

    this.baseUrl = baseUrl;

  }

  

  async fetch(endpoint) {

    return fetch(`${this.baseUrl}${endpoint}`);

  }

}



// Named exports alongside default

export const API_VERSION = 'v1';

export const TIMEOUT = 5000;



export function formatUrl(endpoint) {

  return `/api/${API_VERSION}${endpoint}`;

}

```



#### **Import Syntax**



**1. Named Imports:**

```javascript

// Import specific exports

import { add, subtract } from './math.js';



// Import with rename (aliasing)

import { add as sum, subtract as diff } from './math.js';



console.log(sum(5, 3));   // 8

console.log(diff(10, 4)); // 6



// Import all named exports as namespace

import * as MathUtils from './math.js';



console.log(MathUtils.add(5, 3));      // 8

console.log(MathUtils.PI);             // 3.14159

console.log(MathUtils.subtract(10, 4)); // 6



// Import only for side effects (no bindings)

import './init-polyfills.js';

```



**2. Default Imports:**

```javascript

// Import default export (can use any name)

import User from './user.js';

import MyUser from './user.js';  // Same thing, different name



const user = new User('Alice', 'alice@example.com');

console.log(user.greet());  // "Hello, Alice"



// Import default with named exports

import ApiClient, { API_VERSION, TIMEOUT } from './api.js';



const client = new ApiClient('https://api.example.com');

console.log(API_VERSION);  // 'v1'

```



**3. Dynamic Imports:**

```javascript

// Dynamic import returns a Promise

async function loadModule() {

  const module = await import('./heavy-module.js');

  module.default();  // Call default export

  module.namedFunction();  // Call named export

}



// Conditional loading

if (userWantsFeature) {

  import('./optional-feature.js')

    .then(module => {

      module.initialize();

    })

    .catch(err => {

      console.error('Failed to load module:', err);

    });

}



// Load based on user action

button.addEventListener('click', async () => {

  const { showModal } = await import('./modal.js');

  showModal('Hello World');

});



// Dynamic import with destructuring

const { add, multiply } = await import('./math.js');

console.log(add(5, 3));  // 8

```



**4. Re-exporting:**

```javascript

// utils/index.js - Barrel file



// Re-export everything from another module

export * from './string-utils.js';

export * from './array-utils.js';



// Re-export with rename

export { default as DateFormatter } from './date-formatter.js';



// Re-export specific items

export { validateEmail, validatePhone } from './validators.js';



// Re-export default as named

export { default as Logger } from './logger.js';



// Usage

import { formatString, sortArray, Logger } from './utils/index.js';

```



#### **Module Features and Characteristics**



```javascript

// 1. Modules are automatically in strict mode

// No need for 'use strict'



// 2. Modules have their own scope

let privateVariable = 'private';  // Not accessible outside module



export function getPrivate() {

  return privateVariable;  // Only accessible through exported function

}



// 3. Modules are singletons (executed once)

// FILE: counter.js

let count = 0;



export function increment() {

  count++;

}



export function getCount() {

  return count;

}



// FILE: app.js

import { increment, getCount } from './counter.js';

import { increment as inc2 } from './counter.js';



increment();   // count = 1

inc2();        // count = 2 (same module instance)

console.log(getCount());  // 2



// 4. Imports are hoisted

console.log(add(5, 3));  // Works! Import is hoisted

import { add } from './math.js';



// 5. Imports are read-only (live bindings)

// FILE: module.js

export let counter = 0;



export function increment() {

  counter++;

}



// FILE: app.js

import { counter, increment } from './module.js';



console.log(counter);  // 0

increment();

console.log(counter);  // 1 (live binding updated!)



// counter = 5;  // TypeError: Assignment to constant variable

```



#### **Module Patterns**



**1. Configuration Module:**

```javascript

// config.js

const config = {

  api: {

    baseUrl: process.env.API_URL || 'https://api.example.com',

    timeout: 5000,

    retries: 3

  },

  features: {

    darkMode: true,

    analytics: true

  }

};



export default config;



// Optional: Named exports for specific sections

export const apiConfig = config.api;

export const featureFlags = config.features;

```



**2. Service Module:**

```javascript

// user-service.js

class UserService {

  constructor() {

    this.users = [];

  }

  

  async fetchUsers() {

    const response = await fetch('/api/users');

    this.users = await response.json();

    return this.users;

  }

  

  getUserById(id) {

    return this.users.find(user => user.id === id);

  }

}



// Export singleton instance

export default new UserService();



// Usage

import userService from './user-service.js';

await userService.fetchUsers();

```



**3. Utility Module:**

```javascript

// string-utils.js

export function capitalize(str) {

  return str.charAt(0).toUpperCase() + str.slice(1);

}



export function truncate(str, length) {

  return str.length > length ? str.slice(0, length) + '...' : str;

}



export function slugify(str) {

  return str.toLowerCase().replace(/\s+/g, '-');

}



// Usage

import { capitalize, slugify } from './string-utils.js';

```



**4. Factory Module:**

```javascript

// logger-factory.js

export function createLogger(namespace) {

  return {

    log: (message) => console.log(`[${namespace}] ${message}`),

    error: (message) => console.error(`[${namespace}] ERROR: ${message}`),

    warn: (message) => console.warn(`[${namespace}] WARN: ${message}`)

  };

}



// Usage

import { createLogger } from './logger-factory.js';



const authLogger = createLogger('AUTH');

authLogger.log('User logged in');

```



#### **Using Modules in HTML**



```html

<!DOCTYPE html>

<html>

<head>

  <title>ES6 Modules</title>

</head>

<body>

  <!-- Type="module" enables ES6 module syntax -->

  <script type="module">

    import { add, multiply } from './math.js';

    

    console.log(add(5, 3));       // 8

    console.log(multiply(4, 7));  // 28

  </script>

  

  <!-- External module file -->

  <script type="module" src="./app.js"></script>

  

  <!-- Modules are deferred by default -->

  <!-- No need for defer attribute -->

</body>

</html>

```



#### **Module Loading Options**



```javascript

// 1. Preloading modules

// HTML: <link rel="modulepreload" href="./critical-module.js">



// 2. Lazy loading for performance

async function loadFeature() {

  if (!featureLoaded) {

    const module = await import('./feature.js');

    module.init();

    featureLoaded = true;

  }

}



// 3. Conditional loading based on environment

const logger = 

  process.env.NODE_ENV === 'production'

    ? await import('./prod-logger.js')

    : await import('./dev-logger.js');



// 4. Loading with fallback

let mathLib;

try {

  mathLib = await import('./advanced-math.js');

} catch (error) {

  mathLib = await import('./basic-math.js');

}

```



#### **Module vs Script Differences**



| Feature | Script | Module |

|---------|--------|--------|

| **Scope** | Global | Module (own scope) |

| **Strict mode** | Optional | Always enabled |

| **Top-level `this`** | `window` | `undefined` |

| **Import/Export** | Not supported | Supported |

| **Loading** | Synchronous | Asynchronous |

| **Execution** | Immediate | Deferred |

| **Multiple loads** | Multiple executions | Single execution (singleton) |

| **CORS** | No restriction | Must respect CORS |

| **File extension** | Any | Usually `.js` or `.mjs` |



#### **CommonJS vs ES Modules**



```javascript

// COMMONJS (Node.js traditional)

// export

module.exports = {

  add: function(a, b) { return a + b; },

  PI: 3.14159

};



// import

const math = require('./math');

console.log(math.add(5, 3));



// ES MODULES (Standard JavaScript)

// export

export function add(a, b) {

  return a + b;

}

export const PI = 3.14159;



// import

import { add, PI } from './math.js';

console.log(add(5, 3));



// Node.js supports both:

// - Use .mjs extension for ES modules

// - Or set "type": "module" in package.json

```



#### **Practical Use Cases**



**1. Code Organization:**

```javascript

// Project structure

// src/

//   components/

//     Button.js

//     Modal.js

//   services/

//     api.js

//     auth.js

//   utils/

//     validators.js

//     formatters.js

//   app.js



// app.js

import { Button, Modal } from './components/index.js';

import { apiService } from './services/api.js';

import { validateEmail } from './utils/validators.js';

```



**2. Tree Shaking (Dead Code Elimination):**

```javascript

// utils.js - Large utility library

export function usedFunction() {

  return 'I am used';

}



export function unusedFunction() {

  return 'I am never imported';

}



// app.js - Only import what you need

import { usedFunction } from './utils.js';



// Build tools (webpack, rollup) will remove unusedFunction

// from the final bundle (tree shaking)

```



**3. Dependency Management:**

```javascript

// Clear dependency declaration

import React from 'react';

import { BrowserRouter, Route } from 'react-router-dom';

import axios from 'axios';



// vs older approach with global variables

// <script src="react.js"></script>

// <script src="react-router.js"></script>

// <script src="axios.js"></script>

```



#### **Best Practices**



```javascript

// 1. One module = One responsibility

// ❌ Bad: Everything in one file

// utils.js with string, array, date, math utilities



// ✅ Good: Separate concerns

// string-utils.js

// array-utils.js

// date-utils.js



// 2. Use index.js for barrel exports

// utils/index.js

export * from './string-utils.js';

export * from './array-utils.js';



// Usage

import { capitalize, sortArray } from './utils/index.js';



// 3. Prefer named exports for better refactoring

export function fetchUser() { }  // Easy to find/rename

// vs

export default function() { }    // Can be imported with any name



// 4. Keep modules focused and small

// ✅ Good: Small, focused modules

export function validateEmail(email) {

  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

}



// 5. Use absolute imports (with build tools)

import Button from '@/components/Button';  // Clean

// vs

import Button from '../../../components/Button';  // Fragile

```



#### **Common Pitfalls**



```javascript

// 1. Circular dependencies

// a.js

import { b } from './b.js';

export const a = 'a' + b;



// b.js

import { a } from './a.js';

export const b = 'b' + a;  // Can cause issues!



// 2. Missing file extensions in browser

import { add } from './math';  // ❌ May not work in browser

import { add } from './math.js';  // ✅ Always include .js



// 3. Mixing default and named exports inconsistently

// Confusing:

export default User;

export { User };  // Different things!



// 4. Modifying imported values

import { config } from './config.js';

config.apiUrl = 'new-url';  // ❌ Don't mutate imported objects

```



#### **Key Takeaways**



- **Modules encapsulate code** in their own scope, avoiding global pollution

- **Export/import syntax** enables code sharing between files

- **Named exports** allow multiple exports per module

- **Default exports** provide a single main export per module

- **Dynamic imports** enable code splitting and lazy loading

- **Modules are singletons** - executed once and cached

- **Imports are hoisted** and create live bindings

- **Always in strict mode** - no need for 'use strict'

- **Deferred execution** in browsers (like defer attribute)

- **Tree shaking** removes unused exports from bundles

- **Better than scripts** for organizing large applications

- **Use `.mjs`** extension or `"type": "module"` in Node.js

- **CORS applies** to module loading in browsers

- Standard way to organize **modern JavaScript** applications



---



</details>
<details><summary>66. What is the difference between named export and default export?</summary>




**Answer:**



Named exports and default exports are two ways to export values from a JavaScript module. Named exports allow multiple exports per module with specific names, while default exports provide a single main export per module that can be imported with any name.



#### **Named Exports**



```javascript

// FILE: math.js



// Multiple named exports in one module

export function add(a, b) {

  return a + b;

}



export function subtract(a, b) {

  return a - b;

}



export const PI = 3.14159;



export class Calculator {

  multiply(a, b) {

    return a * b;

  }

}



// Alternative: Export at the end

function divide(a, b) {

  return a / b;

}



const E = 2.71828;



export { divide, E };

```



**Importing Named Exports:**

```javascript

// Must use exact names with curly braces

import { add, subtract, PI } from './math.js';



console.log(add(5, 3));    // 8

console.log(PI);           // 3.14159



// Import with aliasing (rename)

import { add as sum, subtract as diff } from './math.js';



console.log(sum(5, 3));    // 8

console.log(diff(10, 4));  // 6



// Import all named exports as namespace

import * as Math from './math.js';



console.log(Math.add(5, 3));       // 8

console.log(Math.PI);              // 3.14159

console.log(Math.Calculator);      // [class Calculator]



// Import specific items only

import { PI } from './math.js';  // Only PI, ignore others

```



#### **Default Exports**



```javascript

// FILE: user.js



// Only ONE default export per module

export default class User {

  constructor(name, email) {

    this.name = name;

    this.email = email;

  }

  

  greet() {

    return `Hello, ${this.name}`;

  }

}



// Alternative syntaxes for default export

class Product {

  constructor(name) {

    this.name = name;

  }

}

export default Product;



// Default export with function

export default function authenticate(username, password) {

  return true;

}



// Default export with anonymous function

export default function(data) {

  return data.map(item => item.id);

}



// Default export with value

export default 42;



// Default export with object

export default {

  version: '1.0.0',

  author: 'John Doe'

};

```



**Importing Default Exports:**

```javascript

// Can use ANY name (no curly braces)

import User from './user.js';

import MyUser from './user.js';      // Same import, different name

import UserClass from './user.js';   // Still works



const user1 = new User('Alice', 'alice@example.com');

const user2 = new MyUser('Bob', 'bob@example.com');



// Both create instances of the same class

console.log(user1.greet());  // "Hello, Alice"

console.log(user2.greet());  // "Hello, Bob"

```



#### **Combining Named and Default Exports**



```javascript

// FILE: api.js



// Default export

export default class ApiClient {

  constructor(baseUrl) {

    this.baseUrl = baseUrl;

  }

  

  async fetch(endpoint) {

    return fetch(`${this.baseUrl}${endpoint}`);

  }

}



// Named exports alongside default

export const API_VERSION = 'v1';

export const TIMEOUT = 5000;

export const MAX_RETRIES = 3;



export function formatEndpoint(path) {

  return `/api/${API_VERSION}${path}`;

}



export class ApiError extends Error {

  constructor(message, statusCode) {

    super(message);

    this.statusCode = statusCode;

  }

}

```



**Importing Mixed Exports:**

```javascript

// Import default and named together

import ApiClient, { API_VERSION, TIMEOUT, formatEndpoint } from './api.js';



// Use both

const client = new ApiClient('https://api.example.com');

console.log(API_VERSION);  // 'v1'

console.log(formatEndpoint('/users'));  // '/api/v1/users'



// Alternative: Separate imports

import ApiClient from './api.js';

import { API_VERSION, TIMEOUT } from './api.js';



// Import default with alias

import { default as Client, API_VERSION } from './api.js';

```



#### **Detailed Comparison**



| Feature | Named Export | Default Export |

|---------|-------------|----------------|

| **Quantity** | Multiple per module | One per module |

| **Syntax** | `export function foo()` | `export default function foo()` |

| **Import syntax** | `import { foo } from './module'` | `import foo from './module'` |

| **Import name** | Must match export name | Any name allowed |

| **Curly braces** | Required in import | Not used |

| **Renaming** | `import { foo as bar }` | Import with any name directly |

| **Namespace import** | `import * as NS` | Not directly (use `NS.default`) |

| **Anonymous exports** | Not allowed | Allowed |

| **Tree shaking** | Better (unused exports removed) | All or nothing |

| **Refactoring** | Easier (name changes detected) | Harder (any name valid) |

| **Discoverability** | Better (IDE autocomplete) | Depends on documentation |

| **Use case** | Utility libraries, multiple functions | Main class, single purpose |



#### **Export Syntax Variations**



```javascript

// NAMED EXPORTS



// 1. Inline exports

export const VERSION = '1.0.0';

export function helper() { }

export class MyClass { }



// 2. Separate export statement

const A = 1;

const B = 2;

function foo() { }



export { A, B, foo };



// 3. Export with rename

const internalName = 'value';

export { internalName as publicName };



// 4. Re-exporting from another module

export { foo, bar } from './other-module.js';

export * from './another-module.js';



// DEFAULT EXPORTS



// 1. Inline default export (anonymous)

export default function() { }

export default class { }



// 2. Inline default export (named)

export default function myFunc() { }

export default class MyClass { }



// 3. Separate default export

function myFunction() { }

export default myFunction;



// 4. Default export with object literal

export default {

  prop1: 'value',

  method() { }

};

```



#### **Practical Examples**



**1. Utility Library (Prefer Named Exports):**

```javascript

// string-utils.js

export function capitalize(str) {

  return str.charAt(0).toUpperCase() + str.slice(1);

}



export function truncate(str, length) {

  return str.length > length ? str.slice(0, length) + '...' : str;

}



export function slugify(str) {

  return str.toLowerCase().replace(/\s+/g, '-');

}



// Import only what you need

import { capitalize, slugify } from './string-utils.js';



// Tree shaking removes unused 'truncate' from bundle

```



**2. Main Class (Prefer Default Export):**

```javascript

// database.js

export default class Database {

  constructor(config) {

    this.config = config;

  }

  

  async connect() {

    // Connection logic

  }

  

  async query(sql) {

    // Query logic

  }

}



// Clear, single-purpose module

import Database from './database.js';



const db = new Database({ host: 'localhost' });

```



**3. Configuration (Named Exports Recommended):**

```javascript

// config.js

export const API_URL = 'https://api.example.com';

export const API_KEY = process.env.API_KEY;

export const TIMEOUT = 5000;

export const MAX_RETRIES = 3;



export const featureFlags = {

  darkMode: true,

  analytics: false

};



// Import specific configs

import { API_URL, TIMEOUT } from './config.js';

```



**4. React Components (Varies by Convention):**

```javascript

// Button.js - Default export (common in React)

export default function Button({ label, onClick }) {

  return <button onClick={onClick}>{label}</button>;

}



// Or with named export

export function Button({ label, onClick }) {

  return <button onClick={onClick}>{label}</button>;

}



// Mixed approach for components with helpers

export default function Modal({ children }) {

  return <div className="modal">{children}</div>;

}



export function ModalHeader({ title }) {

  return <div className="modal-header">{title}</div>;

}



export function ModalBody({ children }) {

  return <div className="modal-body">{children}</div>;

}



// Usage

import Modal, { ModalHeader, ModalBody } from './Modal';

```



#### **Common Patterns**



**1. Default Export with Named Constants:**

```javascript

// logger.js

class Logger {

  log(message) {

    console.log(`[LOG] ${message}`);

  }

  

  error(message) {

    console.error(`[ERROR] ${message}`);

  }

}



export default new Logger();  // Singleton instance



export const LOG_LEVELS = {

  DEBUG: 0,

  INFO: 1,

  WARN: 2,

  ERROR: 3

};



// Usage

import logger, { LOG_LEVELS } from './logger.js';

logger.log('Application started');

```



**2. Barrel Exports (Index Files):**

```javascript

// components/index.js

export { default as Button } from './Button.js';

export { default as Modal } from './Modal.js';

export { default as Input } from './Input.js';



// Or with named exports

export { Button } from './Button.js';

export { Modal } from './Modal.js';

export { Input } from './Input.js';



// Usage - Clean imports

import { Button, Modal, Input } from './components';

```



**3. Factory Pattern with Named Exports:**

```javascript

// factories.js

export function createUser(name, role) {

  return {

    name,

    role,

    createdAt: new Date()

  };

}



export function createAdmin(name) {

  return createUser(name, 'admin');

}



export function createGuest() {

  return createUser('Guest', 'guest');

}



// Usage

import { createAdmin, createGuest } from './factories.js';

```



#### **When to Use Each**



**Use Named Exports when:**

- Module exports multiple values

- Building utility libraries

- Want better tree shaking

- Need explicit names for refactoring

- Exporting configuration constants

- Creating barrel exports (index files)



```javascript

// ✅ Good use of named exports

// utils.js

export function formatDate(date) { }

export function parseDate(str) { }

export function isValidDate(date) { }

```



**Use Default Exports when:**

- Module has a single main purpose

- Exporting a class as the primary export

- One main function/component per file

- Following framework conventions (React components)

- Creating singleton instances



```javascript

// ✅ Good use of default export

// UserService.js

export default class UserService {

  async fetchUsers() { }

  async createUser(data) { }

}

```



**Avoid mixing unnecessarily:**

```javascript

// ❌ Confusing: Too many exports with unclear purpose

export default function main() { }

export function helper1() { }

export function helper2() { }

export const config = { };



// ✅ Better: Clear separation

// main.js (default)

export default function main() { }



// helpers.js (named)

export function helper1() { }

export function helper2() { }



// config.js (named)

export const config = { };

```



#### **Common Pitfalls**



```javascript

// 1. Can't have multiple default exports

export default class User { }

// export default class Admin { }  // ❌ SyntaxError



// 2. Default export can't be directly destructured in export

const config = { api: 'url' };

// export default { config };  // Works but not ideal

export { config as default };  // ✅ Explicit



// 3. Confusing when importing default with named

import User from './user.js';  // Default

import { User } from './user.js';  // Named - different import!



// 4. Namespace import includes default as 'default'

import * as Utils from './utils.js';

Utils.default();  // Access default export

Utils.namedExport();  // Access named export



// 5. Can't use destructuring directly with default

// import { greet } from './user.js';  // Only for named exports

import User from './user.js';

const { greet } = new User();  // Destructure after import

```



#### **Migration Between Export Types**



```javascript

// Converting named to default

// BEFORE (named)

export function authenticate() { }



import { authenticate } from './auth.js';



// AFTER (default)

export default function authenticate() { }



import authenticate from './auth.js';



// Converting default to named

// BEFORE (default)

export default class User { }



import User from './user.js';



// AFTER (named)

export class User { }



import { User } from './user.js';

```



#### **Key Takeaways**



- **Named exports** allow multiple exports with specific names

- **Default exports** provide one main export per module

- **Named** requires `{ }` and matching names in imports

- **Default** can be imported with any name without `{ }`

- Can **combine both** in a single module

- **Named exports** better for tree shaking and refactoring

- **Default exports** better for single-purpose modules

- **Named preferred** for utility libraries and configurations

- **Default preferred** for main classes and React components

- **Import syntax** differs significantly between the two

- **Named exports** improve IDE autocomplete and discoverability

- Choose based on **module purpose** and team conventions

- **Consistency** within a project is important

- Both are **statically analyzable** (no runtime evaluation)

- Modern best practice: **prefer named exports** when possible



---



</details>
<details><summary>67. What are symbols in JavaScript?</summary>




**Answer:**



Symbols are a primitive data type introduced in ES6 that represent unique, immutable identifiers. Every symbol value is unique, even if they have the same description. Symbols are primarily used as property keys for objects to avoid name collisions and to create non-enumerable properties.



#### **Creating Symbols**



```javascript

// Creating symbols

const sym1 = Symbol();

const sym2 = Symbol();



console.log(sym1 === sym2);  // false (each symbol is unique)



// Symbols with descriptions (for debugging)

const sym3 = Symbol('mySymbol');

const sym4 = Symbol('mySymbol');



console.log(sym3 === sym4);  // false (still unique, despite same description)

console.log(sym3.toString());  // "Symbol(mySymbol)"

console.log(sym3.description);  // "mySymbol"



// Symbols are primitives, not objects

console.log(typeof Symbol());  // "symbol"



// Cannot use 'new' with Symbol

// const sym = new Symbol();  // TypeError: Symbol is not a constructor

```



#### **Using Symbols as Object Keys**



```javascript

// Symbols as property keys

const id = Symbol('id');

const user = {

  name: 'Alice',

  [id]: 12345  // Symbol property using computed property name

};



console.log(user.name);  // 'Alice'

console.log(user[id]);   // 12345

console.log(user.id);    // undefined (not a string property)



// Adding symbol properties after creation

const email = Symbol('email');

user[email] = 'alice@example.com';



console.log(user[email]);  // 'alice@example.com'



// Symbol properties don't show up in normal iteration

for (let key in user) {

  console.log(key);  // Only logs 'name' (symbol properties skipped)

}



console.log(Object.keys(user));  // ['name']

console.log(Object.getOwnPropertyNames(user));  // ['name']



// To access symbol properties

console.log(Object.getOwnPropertySymbols(user));  // [Symbol(id), Symbol(email)]

console.log(Reflect.ownKeys(user));  // ['name', Symbol(id), Symbol(email)]

```



#### **Symbol Registry (Global Symbols)**



```javascript

// Symbol.for() creates/retrieves global symbols

const globalSym1 = Symbol.for('app.id');

const globalSym2 = Symbol.for('app.id');



console.log(globalSym1 === globalSym2);  // true (same global symbol)



// Regular symbols vs global symbols

const localSym = Symbol('app.id');

const globalSym = Symbol.for('app.id');



console.log(localSym === globalSym);  // false (different types)



// Symbol.keyFor() retrieves the key for global symbols

console.log(Symbol.keyFor(globalSym1));  // 'app.id'

console.log(Symbol.keyFor(localSym));    // undefined (not global)



// Use case: Cross-realm/cross-file unique identifiers

// FILE: module1.js

export const CACHE_KEY = Symbol.for('app.cache');



// FILE: module2.js

import { CACHE_KEY } from './module1.js';

const key = Symbol.for('app.cache');

console.log(CACHE_KEY === key);  // true

```



#### **Well-Known Symbols**



JavaScript provides built-in symbols that customize language behavior:



```javascript

// 1. Symbol.iterator - Make objects iterable

const collection = {

  items: ['a', 'b', 'c'],

  [Symbol.iterator]() {

    let index = 0;

    return {

      next: () => {

        if (index < this.items.length) {

          return { value: this.items[index++], done: false };

        }

        return { done: true };

      }

    };

  }

};



for (let item of collection) {

  console.log(item);  // 'a', 'b', 'c'

}



// 2. Symbol.toStringTag - Customize Object.prototype.toString()

class CustomClass {

  get [Symbol.toStringTag]() {

    return 'CustomClass';

  }

}



const instance = new CustomClass();

console.log(Object.prototype.toString.call(instance));  // '[object CustomClass]'



// 3. Symbol.hasInstance - Customize instanceof behavior

class MyArray {

  static [Symbol.hasInstance](instance) {

    return Array.isArray(instance);

  }

}



console.log([] instanceof MyArray);  // true

console.log({} instanceof MyArray);  // false



// 4. Symbol.toPrimitive - Control type conversion

const obj = {

  [Symbol.toPrimitive](hint) {

    if (hint === 'number') {

      return 42;

    }

    if (hint === 'string') {

      return 'Hello';

    }

    return true;  // default

  }

};



console.log(+obj);      // 42 (number hint)

console.log(`${obj}`);  // 'Hello' (string hint)

console.log(obj + '');  // 'true' (default hint)



// 5. Symbol.species - Customize derived object creation

class MyArray extends Array {

  static get [Symbol.species]() {

    return Array;  // map(), filter() return Array, not MyArray

  }

}



const myArr = new MyArray(1, 2, 3);

const mapped = myArr.map(x => x * 2);

console.log(mapped instanceof MyArray);  // false

console.log(mapped instanceof Array);    // true

```



#### **Practical Use Cases**



**1. Avoiding Property Name Collisions:**

```javascript

// Library A defines a property

const libraryA = {

  version: '1.0.0',

  _internal: 'Library A data'  // Might conflict with other code

};



// Library B might override it

const libraryB = {

  _internal: 'Library B data'  // Collision!

};



// Using symbols prevents conflicts

const internalA = Symbol('internal');

const internalB = Symbol('internal');



const safeLibraryA = {

  version: '1.0.0',

  [internalA]: 'Library A data'

};



const safeLibraryB = {

  version: '2.0.0',

  [internalB]: 'Library B data'

};



// No collision - different symbols

console.log(safeLibraryA[internalA]);  // 'Library A data'

console.log(safeLibraryB[internalB]);  // 'Library B data'

```



**2. Creating Private-Like Properties:**

```javascript

// Private-like properties using symbols

const _balance = Symbol('balance');

const _validateAmount = Symbol('validateAmount');



class BankAccount {

  constructor(initialBalance) {

    this[_balance] = initialBalance;

  }

  

  [_validateAmount](amount) {

    return amount > 0 && Number.isFinite(amount);

  }

  

  deposit(amount) {

    if (this[_validateAmount](amount)) {

      this[_balance] += amount;

      return this[_balance];

    }

    throw new Error('Invalid amount');

  }

  

  getBalance() {

    return this[_balance];

  }

}



const account = new BankAccount(1000);

console.log(account.getBalance());  // 1000



// Symbol properties not visible in normal access

console.log(account.balance);  // undefined

console.log(Object.keys(account));  // []



// But accessible if symbol is known

console.log(account[_balance]);  // 1000 (not truly private)

```



**3. Metadata and Configuration:**

```javascript

// Adding metadata without affecting normal properties

const CONFIG = Symbol('config');

const METADATA = Symbol('metadata');



class Component {

  constructor(name) {

    this.name = name;

    this[CONFIG] = {

      version: '1.0.0',

      internal: true

    };

    this[METADATA] = {

      createdAt: new Date(),

      author: 'System'

    };

  }

  

  toJSON() {

    // Symbol properties automatically excluded from JSON

    return {

      name: this.name

      // config and metadata not included

    };

  }

}



const comp = new Component('MyComponent');

console.log(JSON.stringify(comp));  // {"name":"MyComponent"}

console.log(comp[CONFIG]);  // { version: '1.0.0', internal: true }

```



**4. Implementing Custom Behaviors:**

```javascript

// Custom iterable range

class Range {

  constructor(start, end) {

    this.start = start;

    this.end = end;

  }

  

  [Symbol.iterator]() {

    let current = this.start;

    const end = this.end;

    

    return {

      next() {

        if (current <= end) {

          return { value: current++, done: false };

        }

        return { done: true };

      }

    };

  }

}



const range = new Range(1, 5);

console.log([...range]);  // [1, 2, 3, 4, 5]



for (let num of range) {

  console.log(num);  // 1, 2, 3, 4, 5

}

```



**5. Extending Built-in Objects:**

```javascript

// Safely extending Array without naming conflicts

const shuffle = Symbol('shuffle');



Array.prototype[shuffle] = function() {

  const arr = [...this];

  for (let i = arr.length - 1; i > 0; i--) {

    const j = Math.floor(Math.random() * (i + 1));

    [arr[i], arr[j]] = [arr[j], arr[i]];

  }

  return arr;

};



const numbers = [1, 2, 3, 4, 5];

console.log(numbers[shuffle]());  // Randomly shuffled array



// No conflict with other array properties/methods

```



#### **Symbol Properties and JSON**



```javascript

const id = Symbol('id');

const user = {

  name: 'Alice',

  age: 30,

  [id]: 12345

};



// Symbol properties ignored in JSON serialization

console.log(JSON.stringify(user));  // {"name":"Alice","age":30}



// Symbol properties not in Object.assign() by default

const copy = Object.assign({}, user);

console.log(copy[id]);  // undefined



// To copy symbol properties

const fullCopy = Object.assign({}, user, 

  Object.getOwnPropertySymbols(user).reduce((acc, sym) => {

    acc[sym] = user[sym];

    return acc;

  }, {})

);

console.log(fullCopy[id]);  // 12345

```



#### **Well-Known Symbols Reference**



| Symbol | Purpose |

|--------|---------|

| **Symbol.iterator** | Make object iterable (for...of) |

| **Symbol.asyncIterator** | Make object async iterable (for await...of) |

| **Symbol.hasInstance** | Customize `instanceof` behavior |

| **Symbol.toStringTag** | Customize `Object.prototype.toString()` |

| **Symbol.toPrimitive** | Control type coercion |

| **Symbol.species** | Specify constructor for derived objects |

| **Symbol.match** | Used by `String.prototype.match()` |

| **Symbol.replace** | Used by `String.prototype.replace()` |

| **Symbol.search** | Used by `String.prototype.search()` |

| **Symbol.split** | Used by `String.prototype.split()` |

| **Symbol.isConcatSpreadable** | Control array flattening in `concat()` |

| **Symbol.unscopables** | Exclude properties from `with` statement |



#### **Common Patterns**



```javascript

// 1. Constant values (enum-like)

const Status = {

  PENDING: Symbol('pending'),

  ACTIVE: Symbol('active'),

  INACTIVE: Symbol('inactive')

};



function setStatus(status) {

  if (status === Status.PENDING) {

    console.log('Status is pending');

  }

}



setStatus(Status.PENDING);



// 2. Private static properties

class Service {

  static #instances = new Map();

  static instanceKey = Symbol('instance');

  

  static getInstance(id) {

    if (!this.#instances.has(id)) {

      this.#instances.set(id, new Service(id));

    }

    return this.#instances.get(id);

  }

}



// 3. Hooks and lifecycle methods

const onInit = Symbol('onInit');

const onDestroy = Symbol('onDestroy');



class Component {

  constructor() {

    this[onInit]();

  }

  

  [onInit]() {

    console.log('Component initialized');

  }

  

  [onDestroy]() {

    console.log('Component destroyed');

  }

  

  destroy() {

    this[onDestroy]();

  }

}

```



#### **Key Takeaways**



- **Symbols are unique primitives** - each Symbol() creates a new unique value

- **Used as property keys** to avoid name collisions

- **Not enumerable** in for...in, Object.keys(), JSON.stringify()

- **Symbol.for()** creates global symbols shared across realms

- **Symbol.keyFor()** retrieves key for global symbols

- **Well-known symbols** customize built-in JavaScript behavior

- **Cannot use `new`** - Symbol is not a constructor

- **Description is optional** and only for debugging

- **Useful for metadata** that shouldn't appear in normal iteration

- **Not truly private** - accessible via Object.getOwnPropertySymbols()

- **ES6+ feature** - not available in older browsers without polyfill

- **Common use cases**: private-like properties, avoiding collisions, custom iterators, metadata storage

- **Symbol properties** excluded from most serialization/enumeration

- Prefer **true private fields (#)** for actual encapsulation (ES2022+)





</details>
<details><summary>65. What are modules in JavaScript?</summary>






</details>
<details><summary>66. What is the difference between named export and default export?</summary>






</details>
<details><summary>67. What are symbols in JavaScript?</summary>






---



</details>
<details><summary>68. What is the Set data structure?</summary>




**Answer:**



A Set is a built-in JavaScript collection that stores unique values of any type. Unlike arrays, Sets automatically remove duplicate values and provide efficient methods for adding, deleting, and checking for the existence of values. Sets maintain insertion order and are optimized for membership testing.



#### **Creating and Basic Operations**



```javascript

// Creating a Set

const set1 = new Set();

const set2 = new Set([1, 2, 3, 4, 5]);

const set3 = new Set('hello');  // Creates Set with unique characters



console.log(set2);  // Set(5) { 1, 2, 3, 4, 5 }

console.log(set3);  // Set(4) { 'h', 'e', 'l', 'o' } (duplicate 'l' removed)



// Adding values

const mySet = new Set();

mySet.add(1);

mySet.add(2);

mySet.add(3);

mySet.add(2);  // Duplicate - won't be added

console.log(mySet);  // Set(3) { 1, 2, 3 }



// Method chaining

mySet.add(4).add(5).add(6);

console.log(mySet.size);  // 6



// Checking existence

console.log(mySet.has(3));  // true

console.log(mySet.has(10)); // false



// Deleting values

mySet.delete(3);

console.log(mySet.has(3));  // false



// Size property

console.log(mySet.size);  // 5



// Clearing all values

mySet.clear();

console.log(mySet.size);  // 0

```



#### **Uniqueness and Value Equality**



```javascript

// Primitive values - compared by value

const numbers = new Set();

numbers.add(1);

numbers.add(1);

numbers.add('1');

console.log(numbers);  // Set(2) { 1, '1' } (different types)



// NaN is treated as equal to NaN

const set = new Set();

set.add(NaN);

set.add(NaN);

console.log(set.size);  // 1 (only one NaN)



// Objects - compared by reference

const obj1 = { id: 1 };

const obj2 = { id: 1 };

const objSet = new Set();

objSet.add(obj1);

objSet.add(obj2);

objSet.add(obj1);  // Duplicate reference

console.log(objSet.size);  // 2 (obj1 and obj2 are different objects)



// Same reference is duplicate

const user = { name: 'Alice' };

const users = new Set();

users.add(user);

users.add(user);

console.log(users.size);  // 1 (same reference)



// +0 and -0 are considered equal

const zeroSet = new Set();

zeroSet.add(0);

zeroSet.add(-0);

console.log(zeroSet.size);  // 1 (treated as same)

```



#### **Iterating Over Sets**



```javascript

const colors = new Set(['red', 'green', 'blue']);



// 1. for...of loop

for (let color of colors) {

  console.log(color);

}

// Output: 'red', 'green', 'blue'



// 2. forEach method

colors.forEach((value, valueAgain, set) => {

  console.log(value);

  // Note: value and valueAgain are the same (for API consistency with Map)

});



// 3. Iterator methods

console.log(colors.values());  // SetIterator { 'red', 'green', 'blue' }

console.log(colors.keys());    // Same as values() (for Map compatibility)

console.log(colors.entries()); // SetIterator { ['red', 'red'], ['green', 'green'], ['blue', 'blue'] }



// 4. Spread operator

const colorArray = [...colors];

console.log(colorArray);  // ['red', 'green', 'blue']



// 5. Array.from()

const colorArray2 = Array.from(colors);

console.log(colorArray2);  // ['red', 'green', 'blue']

```



#### **Common Use Cases**



**1. Removing Duplicates from Array:**

```javascript

// Most common Set use case

const numbers = [1, 2, 3, 2, 4, 3, 5, 1, 6];

const uniqueNumbers = [...new Set(numbers)];

console.log(uniqueNumbers);  // [1, 2, 3, 4, 5, 6]



// With strings

const words = ['apple', 'banana', 'apple', 'cherry', 'banana'];

const uniqueWords = [...new Set(words)];

console.log(uniqueWords);  // ['apple', 'banana', 'cherry']



// Chaining with other operations

const doubled = [...new Set(numbers)].map(n => n * 2);

console.log(doubled);  // [2, 4, 6, 8, 10, 12]

```



**2. Set Operations (Union, Intersection, Difference):**

```javascript

const setA = new Set([1, 2, 3, 4]);

const setB = new Set([3, 4, 5, 6]);



// Union - all unique values from both sets

const union = new Set([...setA, ...setB]);

console.log([...union]);  // [1, 2, 3, 4, 5, 6]



// Intersection - values in both sets

const intersection = new Set([...setA].filter(x => setB.has(x)));

console.log([...intersection]);  // [3, 4]



// Difference - values in A but not in B

const difference = new Set([...setA].filter(x => !setB.has(x)));

console.log([...difference]);  // [1, 2]



// Symmetric difference - values in A or B but not both

const symmetricDiff = new Set(

  [...setA].filter(x => !setB.has(x))

    .concat([...setB].filter(x => !setA.has(x)))

);

console.log([...symmetricDiff]);  // [1, 2, 5, 6]



// Subset check - all values in A are in B

const isSubset = [...setA].every(x => setB.has(x));

console.log(isSubset);  // false



// Superset check - all values in B are in A

const isSuperset = [...setB].every(x => setA.has(x));

console.log(isSuperset);  // false

```



**3. Tracking Unique Visitors/IDs:**

```javascript

// Track unique users

class UserTracker {

  constructor() {

    this.visitors = new Set();

  }

  

  trackVisit(userId) {

    this.visitors.add(userId);

  }

  

  hasVisited(userId) {

    return this.visitors.has(userId);

  }

  

  getUniqueVisitorCount() {

    return this.visitors.size;

  }

  

  getVisitors() {

    return [...this.visitors];

  }

}



const tracker = new UserTracker();

tracker.trackVisit('user1');

tracker.trackVisit('user2');

tracker.trackVisit('user1');  // Duplicate, not added

console.log(tracker.getUniqueVisitorCount());  // 2

console.log(tracker.hasVisited('user1'));      // true

```



**4. Efficient Membership Testing:**

```javascript

// Array lookup - O(n) time complexity

const allowedIds = [101, 102, 103, 104, 105, /* ... thousands more */];

console.log(allowedIds.includes(103));  // Slow for large arrays



// Set lookup - O(1) time complexity

const allowedIdsSet = new Set(allowedIds);

console.log(allowedIdsSet.has(103));  // Fast, constant time



// Practical example: Permission checking

class PermissionManager {

  constructor(permissions) {

    this.permissions = new Set(permissions);

  }

  

  hasPermission(permission) {

    return this.permissions.has(permission);  // O(1) lookup

  }

  

  grantPermission(permission) {

    this.permissions.add(permission);

  }

  

  revokePermission(permission) {

    this.permissions.delete(permission);

  }

}



const manager = new PermissionManager(['read', 'write', 'delete']);

console.log(manager.hasPermission('write'));  // true (fast)

```



**5. Filtering Unique Objects by Property:**

```javascript

// Remove duplicate objects by specific property

const users = [

  { id: 1, name: 'Alice' },

  { id: 2, name: 'Bob' },

  { id: 1, name: 'Alice Clone' },

  { id: 3, name: 'Charlie' }

];



// Track seen IDs

const seenIds = new Set();

const uniqueUsers = users.filter(user => {

  if (seenIds.has(user.id)) {

    return false;  // Duplicate ID

  }

  seenIds.add(user.id);

  return true;

});



console.log(uniqueUsers);

// [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Charlie' }]



// Alternative: Using Map for more control

const uniqueByIdMap = new Map(users.map(user => [user.id, user]));

const uniqueUsersAlt = [...uniqueByIdMap.values()];

```



**6. Tag/Category Management:**

```javascript

class Article {

  constructor(title, content) {

    this.title = title;

    this.content = content;

    this.tags = new Set();

  }

  

  addTag(tag) {

    this.tags.add(tag.toLowerCase());

    return this;

  }

  

  addTags(...tags) {

    tags.forEach(tag => this.addTag(tag));

    return this;

  }

  

  removeTag(tag) {

    this.tags.delete(tag.toLowerCase());

    return this;

  }

  

  hasTag(tag) {

    return this.tags.has(tag.toLowerCase());

  }

  

  getTags() {

    return [...this.tags];

  }

}



const article = new Article('JavaScript Guide', 'Content here');

article.addTags('javascript', 'es6', 'programming', 'JavaScript');  // Duplicate ignored

console.log(article.getTags());  // ['javascript', 'es6', 'programming']

console.log(article.hasTag('ES6'));  // true (case-insensitive)

```



#### **WeakSet - For Object-Only Collections**



```javascript

// WeakSet only holds objects (not primitives)

const weakSet = new WeakSet();



const obj1 = { id: 1 };

const obj2 = { id: 2 };



weakSet.add(obj1);

weakSet.add(obj2);

// weakSet.add(1);  // TypeError: Invalid value used in weak set



console.log(weakSet.has(obj1));  // true



// WeakSet allows garbage collection

// If obj1 has no other references, it can be GC'd

// weakSet.size is not available (no .size property)



// Use case: Tracking objects without preventing GC

class ObjectTracker {

  constructor() {

    this.tracked = new WeakSet();

  }

  

  track(obj) {

    this.tracked.add(obj);

  }

  

  isTracked(obj) {

    return this.tracked.has(obj);

  }

}



const tracker2 = new ObjectTracker();

let tempObj = { data: 'temporary' };

tracker2.track(tempObj);

console.log(tracker2.isTracked(tempObj));  // true



// When tempObj is no longer referenced elsewhere,

// it can be garbage collected (WeakSet doesn't prevent this)

tempObj = null;

```



#### **Performance Characteristics**



```javascript

// Set operations are generally O(1) for add, delete, has

const largeSet = new Set();



// Adding 1 million items - very fast

console.time('Set add');

for (let i = 0; i < 1000000; i++) {

  largeSet.add(i);

}

console.timeEnd('Set add');  // Fast



// Checking existence - O(1)

console.time('Set has');

console.log(largeSet.has(999999));

console.timeEnd('Set has');  // Very fast (constant time)



// Compare with Array

const largeArray = Array.from({ length: 1000000 }, (_, i) => i);



console.time('Array includes');

console.log(largeArray.includes(999999));

console.timeEnd('Array includes');  // Much slower (linear time)



// Iteration is O(n) for both

console.time('Set iteration');

for (let item of largeSet) {

  // Do nothing, just iterate

}

console.timeEnd('Set iteration');

```



#### **Set vs Array Comparison**



| Feature | Set | Array |

|---------|-----|-------|

| **Duplicates** | Automatically removed | Allowed |

| **Order** | Insertion order maintained | Index-based order |

| **Add operation** | `add()` - O(1) | `push()` - O(1) |

| **Search** | `has()` - O(1) | `includes()` - O(n) |

| **Delete** | `delete()` - O(1) | `splice()` - O(n) |

| **Index access** | Not supported | `arr[i]` - O(1) |

| **Size** | `size` property | `length` property |

| **Iteration** | for...of, forEach | for, for...of, forEach, map, filter |

| **Use case** | Unique values, membership tests | Ordered collections, index access |

| **Memory** | More efficient for unique values | Can waste memory with duplicates |

| **Methods** | add, delete, has, clear | push, pop, shift, unshift, splice, etc. |



#### **Converting Between Set and Array**



```javascript

// Array to Set

const arr = [1, 2, 3, 2, 1];

const set = new Set(arr);



// Set to Array - Method 1: Spread operator

const backToArray1 = [...set];

console.log(backToArray1);  // [1, 2, 3]



// Set to Array - Method 2: Array.from()

const backToArray2 = Array.from(set);

console.log(backToArray2);  // [1, 2, 3]



// Set to Array - Method 3: Manual iteration

const backToArray3 = [];

set.forEach(val => backToArray3.push(val));

console.log(backToArray3);  // [1, 2, 3]



// Using Set methods then converting back

const numbers2 = [1, 2, 3, 4, 5];

const doubled = [...new Set(numbers2)].map(n => n * 2);

const filtered = [...new Set(numbers2)].filter(n => n > 2);

```



#### **Advanced Patterns**



```javascript

// 1. Implementing a custom Set-like class with additional features

class EnhancedSet extends Set {

  union(otherSet) {

    return new EnhancedSet([...this, ...otherSet]);

  }

  

  intersection(otherSet) {

    return new EnhancedSet([...this].filter(x => otherSet.has(x)));

  }

  

  difference(otherSet) {

    return new EnhancedSet([...this].filter(x => !otherSet.has(x)));

  }

  

  isSubsetOf(otherSet) {

    return [...this].every(x => otherSet.has(x));

  }

  

  isSupersetOf(otherSet) {

    return [...otherSet].every(x => this.has(x));

  }

  

  toArray() {

    return [...this];

  }

}



const setX = new EnhancedSet([1, 2, 3]);

const setY = new EnhancedSet([3, 4, 5]);



console.log([...setX.union(setY)]);         // [1, 2, 3, 4, 5]

console.log([...setX.intersection(setY)]);  // [3]

console.log([...setX.difference(setY)]);    // [1, 2]



// 2. Memoization with Set for tracking computed values

const computed = new Set();



function expensiveOperation(id) {

  if (computed.has(id)) {

    console.log('Already computed:', id);

    return;

  }

  

  console.log('Computing:', id);

  // Expensive operation here

  computed.add(id);

}



expensiveOperation(1);  // "Computing: 1"

expensiveOperation(2);  // "Computing: 2"

expensiveOperation(1);  // "Already computed: 1"

```



#### **Common Pitfalls**



```javascript

// 1. Objects are compared by reference, not value

const set1 = new Set();

set1.add({ id: 1 });

set1.add({ id: 1 });

console.log(set1.size);  // 2 (different object references)



// Solution: Use primitive identifiers

const set2 = new Set();

set2.add(1);

set2.add(1);

console.log(set2.size);  // 1



// 2. Cannot access by index

const mySet2 = new Set([1, 2, 3]);

// console.log(mySet2[0]);  // undefined (no index access)

console.log([...mySet2][0]);  // 1 (convert to array first)



// 3. No direct way to map/filter Sets (must convert)

const nums = new Set([1, 2, 3, 4, 5]);

// nums.map(n => n * 2);  // TypeError: nums.map is not a function

const doubled2 = new Set([...nums].map(n => n * 2));



// 4. forEach valueAgain parameter is confusing

mySet2.forEach((value, valueAgain, set) => {

  console.log(value === valueAgain);  // true (same value twice for compatibility)

});



// 5. Adding arrays to Set doesn't flatten

const arrSet = new Set();

arrSet.add([1, 2]);

arrSet.add([1, 2]);

console.log(arrSet.size);  // 2 (different array references)

```



#### **When to Use Set**



**Use Set when:**

- Need to store unique values only

- Frequently checking for value existence

- Order of insertion matters but not index access

- Need efficient add/delete operations

- Working with primitive values

- Implementing mathematical set operations



**Use Array when:**

- Need duplicates

- Require index-based access

- Need array methods (map, filter, reduce)

- Order matters and you need sorting

- Working with complex transformations



```javascript

// ✅ Good use case for Set

function countUniqueWords(text) {

  const words = text.toLowerCase().match(/\b\w+\b/g);

  return new Set(words).size;

}



// ✅ Good use case for Array

function getTopScores(scores, count) {

  return scores.sort((a, b) => b - a).slice(0, count);

}

```



#### **Key Takeaways**



- **Set stores unique values** - duplicates automatically removed

- **O(1) time complexity** for add, delete, and has operations

- **Maintains insertion order** but no index access

- **Values compared by SameValueZero** (NaN === NaN, +0 === -0)

- **Objects compared by reference**, not by value

- **Iterable** with for...of, forEach, values(), keys(), entries()

- **Perfect for removing duplicates** from arrays

- **Efficient membership testing** compared to arrays

- **WeakSet** allows garbage collection of objects

- **No built-in map/filter** - convert to array first

- **size property** for number of elements (not .length)

- **Use for unique collections** where order matters but not index

- **Mathematical set operations** (union, intersection) require custom implementation

- Part of **ES6** - widely supported in modern environments

- Excellent for **performance-critical** membership checks



---



</details>
<details><summary>69. What is the Map data structure?</summary>




**Answer:**



A Map is a built-in JavaScript collection that stores key-value pairs where keys can be of any type (objects, functions, primitives). Unlike plain objects, Maps maintain insertion order, allow any value as a key, and provide better performance for frequent additions and deletions.



#### **Creating and Basic Operations**



```javascript

// Creating a Map

const map1 = new Map();

const map2 = new Map([

  ['name', 'Alice'],

  ['age', 30],

  ['city', 'New York']

]);



console.log(map2);  // Map(3) { 'name' => 'Alice', 'age' => 30, 'city' => 'New York' }



// Setting values

const myMap = new Map();

myMap.set('key1', 'value1');

myMap.set('key2', 'value2');

myMap.set('key3', 'value3');



// Method chaining

myMap.set('key4', 'value4').set('key5', 'value5');



// Getting values

console.log(myMap.get('key1'));  // 'value1'

console.log(myMap.get('unknown'));  // undefined



// Checking existence

console.log(myMap.has('key1'));  // true

console.log(myMap.has('key10')); // false



// Deleting entries

myMap.delete('key2');

console.log(myMap.has('key2'));  // false



// Size property

console.log(myMap.size);  // 4



// Clearing all entries

myMap.clear();

console.log(myMap.size);  // 0

```



#### **Any Type as Key**



```javascript

// Maps accept ANY type as key (major advantage over objects)



// 1. Object keys

const objKey1 = { id: 1 };

const objKey2 = { id: 2 };

const objectMap = new Map();



objectMap.set(objKey1, 'value for obj1');

objectMap.set(objKey2, 'value for obj2');



console.log(objectMap.get(objKey1));  // 'value for obj1'

console.log(objectMap.get({ id: 1 }));  // undefined (different object reference)



// 2. Function keys

function myFunc() {}

const funcMap = new Map();

funcMap.set(myFunc, 'function metadata');

console.log(funcMap.get(myFunc));  // 'function metadata'



// 3. Primitive keys (like objects)

const mixedMap = new Map();

mixedMap.set('string', 'string value');

mixedMap.set(42, 'number value');

mixedMap.set(true, 'boolean value');

mixedMap.set(undefined, 'undefined value');

mixedMap.set(null, 'null value');



console.log(mixedMap.get(42));  // 'number value'

console.log(mixedMap.get(true));  // 'boolean value'



// 4. NaN as key (works correctly in Map)

const nanMap = new Map();

nanMap.set(NaN, 'NaN value');

console.log(nanMap.get(NaN));  // 'NaN value' (works unlike in objects)



// Compare with regular objects

const obj = {};

obj[objKey1] = 'value';  // Converted to '[object Object]' string

obj[objKey2] = 'value2'; // Same string key, overwrites!

console.log(obj);  // { '[object Object]': 'value2' }

```



#### **Iterating Over Maps**



```javascript

const userMap = new Map([

  ['name', 'Alice'],

  ['age', 30],

  ['email', 'alice@example.com']

]);



// 1. for...of with entries (default)

for (let [key, value] of userMap) {

  console.log(`${key}: ${value}`);

}

// Output:

// name: Alice

// age: 30

// email: alice@example.com



// 2. for...of with entries() explicitly

for (let [key, value] of userMap.entries()) {

  console.log(key, value);

}



// 3. for...of with keys()

for (let key of userMap.keys()) {

  console.log(key);  // 'name', 'age', 'email'

}



// 4. for...of with values()

for (let value of userMap.values()) {

  console.log(value);  // 'Alice', 30, 'alice@example.com'

}



// 5. forEach method

userMap.forEach((value, key, map) => {

  console.log(`${key} => ${value}`);

});



// 6. Spread operator

const entries = [...userMap];

console.log(entries);  // [['name', 'Alice'], ['age', 30], ['email', 'alice@example.com']]



const keys = [...userMap.keys()];

console.log(keys);  // ['name', 'age', 'email']



const values = [...userMap.values()];

console.log(values);  // ['Alice', 30, 'alice@example.com']

```



#### **Common Use Cases**



**1. Caching/Memoization:**

```javascript

// Cache function results

class FunctionCache {

  constructor() {

    this.cache = new Map();

  }

  

  memoize(fn) {

    return (...args) => {

      const key = JSON.stringify(args);

      

      if (this.cache.has(key)) {

        console.log('Cache hit!');

        return this.cache.get(key);

      }

      

      console.log('Computing...');

      const result = fn(...args);

      this.cache.set(key, result);

      return result;

    };

  }

  

  clear() {

    this.cache.clear();

  }

}



const cache = new FunctionCache();

const expensiveCalculation = cache.memoize((a, b) => {

  return a + b;

});



console.log(expensiveCalculation(5, 3));  // "Computing..." then 8

console.log(expensiveCalculation(5, 3));  // "Cache hit!" then 8

```



**2. Associating Metadata with Objects:**

```javascript

// Store metadata for DOM elements or objects without modifying them

const elementMetadata = new Map();



function trackElement(element, data) {

  elementMetadata.set(element, {

    clicks: 0,

    lastInteraction: null,

    ...data

  });

}



function recordClick(element) {

  const metadata = elementMetadata.get(element);

  if (metadata) {

    metadata.clicks++;

    metadata.lastInteraction = new Date();

  }

}



// Usage (pseudo-code for DOM)

const button = document.createElement('button');

trackElement(button, { id: 'submit-btn' });

recordClick(button);

console.log(elementMetadata.get(button));  // { clicks: 1, lastInteraction: ..., id: 'submit-btn' }

```



**3. Counting Occurrences (Frequency Counter):**

```javascript

function countOccurrences(items) {

  const counter = new Map();

  

  for (let item of items) {

    counter.set(item, (counter.get(item) || 0) + 1);

  }

  

  return counter;

}



const fruits = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];

const fruitCount = countOccurrences(fruits);



console.log(fruitCount);  // Map(3) { 'apple' => 3, 'banana' => 2, 'cherry' => 1 }

console.log(fruitCount.get('apple'));  // 3



// Get most frequent item

const mostFrequent = [...fruitCount.entries()].reduce((max, entry) => 

  entry[1] > max[1] ? entry : max

);

console.log(mostFrequent);  // ['apple', 3]

```



**4. Grouping Data:**

```javascript

// Group objects by a property

function groupBy(array, keyFn) {

  const groups = new Map();

  

  for (let item of array) {

    const key = keyFn(item);

    if (!groups.has(key)) {

      groups.set(key, []);

    }

    groups.get(key).push(item);

  }

  

  return groups;

}



const users = [

  { name: 'Alice', role: 'admin' },

  { name: 'Bob', role: 'user' },

  { name: 'Charlie', role: 'admin' },

  { name: 'David', role: 'user' }

];



const byRole = groupBy(users, user => user.role);

console.log(byRole);

// Map(2) {

//   'admin' => [{ name: 'Alice', role: 'admin' }, { name: 'Charlie', role: 'admin' }],

//   'user' => [{ name: 'Bob', role: 'user' }, { name: 'David', role: 'user' }]

// }

```



**5. LRU Cache Implementation:**

```javascript

class LRUCache {

  constructor(capacity) {

    this.capacity = capacity;

    this.cache = new Map();

  }

  

  get(key) {

    if (!this.cache.has(key)) {

      return -1;

    }

    

    // Move to end (most recently used)

    const value = this.cache.get(key);

    this.cache.delete(key);

    this.cache.set(key, value);

    return value;

  }

  

  put(key, value) {

    // Remove if exists (to update position)

    if (this.cache.has(key)) {

      this.cache.delete(key);

    }

    

    // Add to end

    this.cache.set(key, value);

    

    // Remove oldest if over capacity

    if (this.cache.size > this.capacity) {

      const firstKey = this.cache.keys().next().value;

      this.cache.delete(firstKey);

    }

  }

}



const lru = new LRUCache(3);

lru.put(1, 'a');

lru.put(2, 'b');

lru.put(3, 'c');

console.log([...lru.cache]);  // [[1, 'a'], [2, 'b'], [3, 'c']]



lru.put(4, 'd');  // Removes 1 (oldest)

console.log([...lru.cache]);  // [[2, 'b'], [3, 'c'], [4, 'd']]



lru.get(2);  // Access 2, moves it to end

console.log([...lru.cache]);  // [[3, 'c'], [4, 'd'], [2, 'b']]

```



**6. Bidirectional Mapping:**

```javascript

class BiMap {

  constructor() {

    this.keyToValue = new Map();

    this.valueToKey = new Map();

  }

  

  set(key, value) {

    // Remove old mappings if they exist

    if (this.keyToValue.has(key)) {

      this.valueToKey.delete(this.keyToValue.get(key));

    }

    if (this.valueToKey.has(value)) {

      this.keyToValue.delete(this.valueToKey.get(value));

    }

    

    this.keyToValue.set(key, value);

    this.valueToKey.set(value, key);

  }

  

  getByKey(key) {

    return this.keyToValue.get(key);

  }

  

  getByValue(value) {

    return this.valueToKey.get(value);

  }

}



const bimap = new BiMap();

bimap.set('en', 'English');

bimap.set('es', 'Spanish');



console.log(bimap.getByKey('en'));       // 'English'

console.log(bimap.getByValue('Spanish')); // 'es'

```



#### **WeakMap - For Object-Only Keys**



```javascript

// WeakMap only accepts objects as keys

const weakMap = new WeakMap();



const obj1 = { id: 1 };

const obj2 = { id: 2 };



weakMap.set(obj1, 'data for obj1');

weakMap.set(obj2, 'data for obj2');

// weakMap.set('string', 'value');  // TypeError: Invalid value used as weak map key



console.log(weakMap.get(obj1));  // 'data for obj1'



// WeakMap allows garbage collection

// No .size, .clear(), or iteration methods



// Use case: Private data for objects

const privateData = new WeakMap();



class SecureUser {

  constructor(name, password) {

    this.name = name;  // Public

    privateData.set(this, { password });  // Private

  }

  

  authenticate(password) {

    return privateData.get(this).password === password;

  }

}



const user = new SecureUser('Alice', 'secret123');

console.log(user.name);  // 'Alice'

console.log(user.password);  // undefined (not accessible)

console.log(user.authenticate('secret123'));  // true



// When user is garbage collected, its private data is too

```



#### **Map vs Object Comparison**



| Feature | Map | Object |

|---------|-----|--------|

| **Key types** | Any type (objects, functions, primitives) | Strings and Symbols only |

| **Key order** | Insertion order guaranteed | Not guaranteed (numeric keys sorted) |

| **Size** | `map.size` (O(1)) | `Object.keys(obj).length` (O(n)) |

| **Iteration** | Directly iterable (for...of) | Need Object.keys/values/entries |

| **Performance** | Better for frequent add/delete | Better for small fixed structures |

| **Serialization** | No native JSON support | `JSON.stringify()` works |

| **Prototype** | Clean, no inherited keys | Has prototype chain |

| **Accidental keys** | No | Yes (`toString`, `constructor`, etc.) |

| **Default values** | None | Inherited from prototype |

| **Use case** | Dynamic key-value pairs | Fixed structure, property access |



```javascript

// Object quirks that Map avoids



// 1. Object keys are always strings (or symbols)

const obj = {};

obj[1] = 'number key';

obj['1'] = 'string key';  // Overwrites above!

console.log(obj);  // { '1': 'string key' }



const map = new Map();

map.set(1, 'number key');

map.set('1', 'string key');  // Different keys!

console.log(map);  // Map(2) { 1 => 'number key', '1' => 'string key' }



// 2. Object prototype pollution

const obj2 = {};

console.log(obj2.toString);  // [Function: toString] (inherited)



const map2 = new Map();

console.log(map2.get('toString'));  // undefined (clean)



// 3. Checking key existence

const obj3 = { hasOwnProperty: true };  // Shadows method!

// obj3.hasOwnProperty('key');  // TypeError



const map3 = new Map();

map3.set('hasOwnProperty', true);

map3.has('hasOwnProperty');  // Works fine

```



#### **Converting Between Map and Object**



```javascript

// Object to Map

const obj = { name: 'Alice', age: 30, city: 'NYC' };

const mapFromObj = new Map(Object.entries(obj));

console.log(mapFromObj);  // Map(3) { 'name' => 'Alice', 'age' => 30, 'city' => 'NYC' }



// Map to Object

const map = new Map([

  ['name', 'Bob'],

  ['age', 25]

]);



const objFromMap = Object.fromEntries(map);

console.log(objFromMap);  // { name: 'Bob', age: 25 }



// Alternative: Manual conversion

const objManual = {};

map.forEach((value, key) => {

  objManual[key] = value;

});

```



#### **Performance Characteristics**



```javascript

// Map is optimized for frequent additions/deletions

const iterations = 100000;



// Map performance

const map = new Map();

console.time('Map set');

for (let i = 0; i < iterations; i++) {

  map.set(i, i);

}

console.timeEnd('Map set');  // Fast



console.time('Map get');

for (let i = 0; i < iterations; i++) {

  map.get(i);

}

console.timeEnd('Map get');  // Fast



console.time('Map delete');

for (let i = 0; i < iterations; i++) {

  map.delete(i);

}

console.timeEnd('Map delete');  // Fast



// Object performance (comparable for small data)

const obj = {};

console.time('Object set');

for (let i = 0; i < iterations; i++) {

  obj[i] = i;

}

console.timeEnd('Object set');



// Map.size is O(1), Object.keys().length is O(n)

console.log(map.size);  // Instant

console.log(Object.keys(obj).length);  // Slower for large objects

```



#### **When to Use Map vs Object**



**Use Map when:**

- Keys are not strings/symbols

- Keys are unknown until runtime

- Need to iterate in insertion order

- Frequently adding/removing key-value pairs

- Need to know size efficiently

- Storing arbitrary key-value pairs



**Use Object when:**

- Keys are fixed and known

- Need JSON serialization

- Using as a record/struct with specific properties

- Need property access syntax (obj.prop)

- Small fixed structure



```javascript

// ✅ Good use case for Map

const userSessions = new Map();

function createSession(user) {

  userSessions.set(user, {

    startTime: Date.now(),

    lastActivity: Date.now()

  });

}



// ✅ Good use case for Object

const config = {

  apiUrl: 'https://api.example.com',

  timeout: 5000,

  retries: 3

};

```



#### **Key Takeaways**



- **Map stores key-value pairs** with any type as key

- **Maintains insertion order** for all keys

- **O(1) operations** for set, get, has, delete

- **size property** returns count in constant time

- **Any value as key** - objects, functions, primitives

- **Iterable by default** - works with for...of directly

- **No prototype pollution** - clean namespace

- **Better performance** for frequent add/delete operations

- **WeakMap** for object-only keys with garbage collection

- **No native JSON** serialization (use Object.fromEntries)

- **Preserves key types** unlike objects (1 vs '1')

- **Perfect for caching**, metadata, frequency counting

- **Use over objects** when keys are dynamic or non-string

- Part of **ES6** - widely supported

- **Predictable iteration order** unlike objects



---



</details>
<details><summary>70. What are iterators and generators?</summary>




**Answer:**



Iterators and generators are ES6 features that enable custom iteration behavior. An iterator is an object that provides a `next()` method for sequential access to values. A generator is a special function (using `function*` syntax) that can pause execution and yield multiple values over time, automatically creating an iterator.



#### **Iterators**



**Basic Iterator Concept:**

```javascript

// Iterator protocol: object with a next() method

// next() returns: { value: any, done: boolean }



const iterator = {

  current: 0,

  last: 5,

  

  next() {

    if (this.current <= this.last) {

      return { value: this.current++, done: false };

    } else {

      return { value: undefined, done: true };

    }

  }

};



console.log(iterator.next());  // { value: 0, done: false }

console.log(iterator.next());  // { value: 1, done: false }

console.log(iterator.next());  // { value: 2, done: false }

// ... continues until

console.log(iterator.next());  // { value: undefined, done: true }

```



**Iterable Protocol:**

```javascript

// Iterable: object with [Symbol.iterator]() method that returns an iterator



const iterable = {

  data: [1, 2, 3, 4, 5],

  

  [Symbol.iterator]() {

    let index = 0;

    const data = this.data;

    

    return {

      next() {

        if (index < data.length) {

          return { value: data[index++], done: false };

        } else {

          return { done: true };

        }

      }

    };

  }

};



// Now iterable works with for...of

for (let value of iterable) {

  console.log(value);  // 1, 2, 3, 4, 5

}



// Also works with spread operator

console.log([...iterable]);  // [1, 2, 3, 4, 5]



// And destructuring

const [first, second, ...rest] = iterable;

console.log(first, second, rest);  // 1, 2, [3, 4, 5]

```



**Custom Range Iterator:**

```javascript

class Range {

  constructor(start, end, step = 1) {

    this.start = start;

    this.end = end;

    this.step = step;

  }

  

  [Symbol.iterator]() {

    let current = this.start;

    const end = this.end;

    const step = this.step;

    

    return {

      next() {

        if (current <= end) {

          const value = current;

          current += step;

          return { value, done: false };

        }

        return { done: true };

      }

    };

  }

}



const range = new Range(1, 10, 2);

console.log([...range]);  // [1, 3, 5, 7, 9]



for (let num of range) {

  console.log(num);  // 1, 3, 5, 7, 9

}

```



#### **Generators**



**Basic Generator Syntax:**

```javascript

// Generator function uses function* syntax

function* simpleGenerator() {

  yield 1;

  yield 2;

  yield 3;

}



const gen = simpleGenerator();



console.log(gen.next());  // { value: 1, done: false }

console.log(gen.next());  // { value: 2, done: false }

console.log(gen.next());  // { value: 3, done: false }

console.log(gen.next());  // { value: undefined, done: true }



// Generators are iterable

for (let value of simpleGenerator()) {

  console.log(value);  // 1, 2, 3

}



console.log([...simpleGenerator()]);  // [1, 2, 3]

```



**Generator with Logic:**

```javascript

function* numberGenerator(max) {

  let num = 0;

  while (num < max) {

    yield num++;

  }

  return 'Done!';  // Return value not included in iteration

}



const nums = numberGenerator(5);

console.log([...nums]);  // [0, 1, 2, 3, 4]



// Return value accessible only via next()

const nums2 = numberGenerator(3);

console.log(nums2.next());  // { value: 0, done: false }

console.log(nums2.next());  // { value: 1, done: false }

console.log(nums2.next());  // { value: 2, done: false }

console.log(nums2.next());  // { value: 'Done!', done: true }

```



**Infinite Generators:**

```javascript

function* infiniteSequence() {

  let num = 0;

  while (true) {

    yield num++;

  }

}



const sequence = infiniteSequence();

console.log(sequence.next().value);  // 0

console.log(sequence.next().value);  // 1

console.log(sequence.next().value);  // 2



// Use with care - infinite loop if fully consumed!

// Take only what you need

function* take(iterable, count) {

  let taken = 0;

  for (let item of iterable) {

    if (taken++ >= count) return;

    yield item;

  }

}



console.log([...take(infiniteSequence(), 5)]);  // [0, 1, 2, 3, 4]

```



**Passing Values to Generators:**

```javascript

function* generatorWithInput() {

  const first = yield 'Ready';

  console.log('Received:', first);

  

  const second = yield 'Next';

  console.log('Received:', second);

  

  return 'Complete';

}



const gen2 = generatorWithInput();

console.log(gen2.next());         // { value: 'Ready', done: false }

console.log(gen2.next('Hello'));  // Logs "Received: Hello", returns { value: 'Next', done: false }

console.log(gen2.next('World'));  // Logs "Received: World", returns { value: 'Complete', done: true }

```



**Generator Delegation (yield*):**

```javascript

function* generator1() {

  yield 1;

  yield 2;

}



function* generator2() {

  yield 'a';

  yield 'b';

}



function* combinedGenerator() {

  yield* generator1();  // Delegate to generator1

  yield* generator2();  // Delegate to generator2

  yield 'final';

}



console.log([...combinedGenerator()]);  // [1, 2, 'a', 'b', 'final']



// yield* also works with any iterable

function* arrayGenerator() {

  yield* [1, 2, 3];

  yield* 'hello';  // Strings are iterable

  yield* new Set([4, 5, 6]);

}



console.log([...arrayGenerator()]);  // [1, 2, 3, 'h', 'e', 'l', 'l', 'o', 4, 5, 6]

```



#### **Practical Use Cases**



**1. Lazy Evaluation:**

```javascript

// Generate values on-demand without storing entire sequence

function* fibonacci() {

  let [prev, curr] = [0, 1];

  while (true) {

    yield curr;

    [prev, curr] = [curr, prev + curr];

  }

}



// Only compute what we need

const fib = fibonacci();

console.log(fib.next().value);  // 1

console.log(fib.next().value);  // 1

console.log(fib.next().value);  // 2

console.log(fib.next().value);  // 3

console.log(fib.next().value);  // 5



// Get first 10 Fibonacci numbers

console.log([...take(fibonacci(), 10)]);

// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

```



**2. Pagination/Chunking:**

```javascript

function* paginate(array, pageSize) {

  for (let i = 0; i < array.length; i += pageSize) {

    yield array.slice(i, i + pageSize);

  }

}



const items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

for (let page of paginate(items, 3)) {

  console.log(page);

}

// [1, 2, 3]

// [4, 5, 6]

// [7, 8, 9]

// [10]

```



**3. Async Operations (with async generators):**

```javascript

async function* fetchPages(url, maxPages) {

  for (let page = 1; page <= maxPages; page++) {

    const response = await fetch(`${url}?page=${page}`);

    const data = await response.json();

    yield data;

  }

}



// Usage (in async context)

async function processPages() {

  for await (let data of fetchPages('/api/users', 5)) {

    console.log('Processing page:', data);

    // Process each page as it arrives

  }

}

```



**4. State Machines:**

```javascript

function* trafficLight() {

  while (true) {

    yield 'RED';

    yield 'GREEN';

    yield 'YELLOW';

  }

}



const light = trafficLight();

console.log(light.next().value);  // 'RED'

console.log(light.next().value);  // 'GREEN'

console.log(light.next().value);  // 'YELLOW'

console.log(light.next().value);  // 'RED' (cycles)

```



**5. Tree Traversal:**

```javascript

class TreeNode {

  constructor(value, left = null, right = null) {

    this.value = value;

    this.left = left;

    this.right = right;

  }

  

  * inOrder() {

    if (this.left) yield* this.left.inOrder();

    yield this.value;

    if (this.right) yield* this.right.inOrder();

  }

  

  * preOrder() {

    yield this.value;

    if (this.left) yield* this.left.preOrder();

    if (this.right) yield* this.right.preOrder();

  }

  

  * postOrder() {

    if (this.left) yield* this.left.postOrder();

    if (this.right) yield* this.right.postOrder();

    yield this.value;

  }

}



const tree = new TreeNode(

  4,

  new TreeNode(2, new TreeNode(1), new TreeNode(3)),

  new TreeNode(6, new TreeNode(5), new TreeNode(7))

);



console.log([...tree.inOrder()]);    // [1, 2, 3, 4, 5, 6, 7]

console.log([...tree.preOrder()]);   // [4, 2, 1, 3, 6, 5, 7]

console.log([...tree.postOrder()]);  // [1, 3, 2, 5, 7, 6, 4]

```



**6. Data Streaming:**

```javascript

function* lineReader(text) {

  const lines = text.split('\n');

  for (let line of lines) {

    yield line.trim();

  }

}



const logData = `

  2024-01-01: User logged in

  2024-01-02: File uploaded

  2024-01-03: Error occurred

`;



for (let line of lineReader(logData)) {

  if (line) {

    console.log('Processing:', line);

  }

}

```



**7. Custom Iteration Logic:**

```javascript

class Collection {

  constructor(items) {

    this.items = items;

  }

  

  * [Symbol.iterator]() {

    for (let item of this.items) {

      yield item;

    }

  }

  

  * reversed() {

    for (let i = this.items.length - 1; i >= 0; i--) {

      yield this.items[i];

    }

  }

  

  * filtered(predicate) {

    for (let item of this.items) {

      if (predicate(item)) {

        yield item;

      }

    }

  }

  

  * mapped(fn) {

    for (let item of this.items) {

      yield fn(item);

    }

  }

}



const coll = new Collection([1, 2, 3, 4, 5]);



console.log([...coll]);                          // [1, 2, 3, 4, 5]

console.log([...coll.reversed()]);               // [5, 4, 3, 2, 1]

console.log([...coll.filtered(n => n > 2)]);     // [3, 4, 5]

console.log([...coll.mapped(n => n * 2)]);       // [2, 4, 6, 8, 10]

```



#### **Generator Methods**



```javascript

function* generatorWithMethods() {

  try {

    yield 1;

    yield 2;

    yield 3;

  } catch (error) {

    console.log('Caught:', error.message);

  } finally {

    console.log('Cleanup');

  }

}



const gen3 = generatorWithMethods();



// next() - Get next value

console.log(gen3.next());  // { value: 1, done: false }



// return() - Force generator to finish

console.log(gen3.return('Forced end'));  // Logs "Cleanup", returns { value: 'Forced end', done: true }

console.log(gen3.next());  // { value: undefined, done: true }



// throw() - Throw error into generator

const gen4 = generatorWithMethods();

console.log(gen4.next());  // { value: 1, done: false }

console.log(gen4.throw(new Error('Test error')));  // Logs "Caught: Test error" and "Cleanup"

```



#### **Iterator vs Generator Comparison**



| Feature | Iterator | Generator |

|---------|----------|-----------|

| **Syntax** | Object with `next()` method | `function*` with `yield` |

| **Creation** | Manual implementation | Automatic iterator creation |

| **State** | Manual state management | Automatic state preservation |

| **Complexity** | More verbose | Concise and readable |

| **Pause/Resume** | Manual control needed | Built-in with `yield` |

| **Return value** | In `next()` method | With `return` statement |

| **Error handling** | Manual | Try-catch works naturally |

| **Use case** | Low-level control | Most common use cases |



```javascript

// Same functionality - Iterator vs Generator



// ITERATOR (manual)

const manualIterator = {

  [Symbol.iterator]() {

    let count = 0;

    return {

      next() {

        if (count < 3) {

          return { value: count++, done: false };

        }

        return { done: true };

      }

    };

  }

};



// GENERATOR (automatic)

function* autoGenerator() {

  let count = 0;

  while (count < 3) {

    yield count++;

  }

}



console.log([...manualIterator]);  // [0, 1, 2]

console.log([...autoGenerator()]);  // [0, 1, 2]

```



#### **Built-in Iterables**



```javascript

// Many built-in types are iterable



// Arrays

for (let item of [1, 2, 3]) { }



// Strings

for (let char of 'hello') { }



// Maps

for (let [key, value] of new Map()) { }



// Sets

for (let value of new Set()) { }



// TypedArrays

for (let byte of new Uint8Array([1, 2, 3])) { }



// Arguments object

function test() {

  for (let arg of arguments) { }

}



// NodeList (DOM)

// for (let element of document.querySelectorAll('div')) { }

```



#### **Key Takeaways**



- **Iterators** provide sequential access via `next()` method

- **Generators** are functions that can pause and resume execution

- **`function*` syntax** defines a generator function

- **`yield` keyword** pauses generator and returns value

- **Generators automatically** implement iterator protocol

- **Lazy evaluation** - values computed on-demand

- **Memory efficient** for large/infinite sequences

- **State preservation** between yield points

- **`yield*` delegates** to another generator or iterable

- **Async generators** (`async function*`) for async iteration

- **Perfect for** pagination, streaming, infinite sequences

- **`return()` method** forces generator completion

- **`throw()` method** injects error into generator

- **Works with** for...of, spread operator, destructuring

- Part of **ES6** - widely supported

- **Simplifies** complex iteration logic significantly





</details>
<details><summary>68. What is the Set data structure?</summary>






</details>
<details><summary>69. What is the Map data structure?</summary>






</details>
<details><summary>70. What are iterators and generators?</summary>






## DOM & Events



---



</details>
<details><summary>71. What is the DOM?</summary>




**Answer:**



The DOM (Document Object Model) is a programming interface that represents HTML and XML documents as a tree structure of objects. It provides a structured representation of the document and defines methods for accessing and manipulating the document's content, structure, and styles. The DOM serves as a bridge between web pages and programming languages like JavaScript.



#### **DOM Structure**



```html

<!DOCTYPE html>

<html>

  <head>

    <title>My Page</title>

  </head>

  <body>

    <div id="container">

      <h1 class="title">Hello World</h1>

      <p>This is a paragraph.</p>

    </div>

  </body>

</html>

```



**DOM Tree Representation:**

```

Document

  └─ html (document.documentElement)

      ├─ head

      │   └─ title

      │       └─ "My Page" (text node)

      └─ body (document.body)

          └─ div#container

              ├─ h1.title

              │   └─ "Hello World" (text node)

              └─ p

                  └─ "This is a paragraph." (text node)

```



#### **DOM Node Types**



```javascript

// Different node types in the DOM

console.log(Node.ELEMENT_NODE);                // 1

console.log(Node.TEXT_NODE);                   // 3

console.log(Node.COMMENT_NODE);                // 8

console.log(Node.DOCUMENT_NODE);               // 9

console.log(Node.DOCUMENT_FRAGMENT_NODE);      // 11



// Accessing node types

const element = document.querySelector('h1');

console.log(element.nodeType);                 // 1 (ELEMENT_NODE)

console.log(element.nodeName);                 // "H1"

console.log(element.nodeValue);                // null (elements don't have nodeValue)



const textNode = element.firstChild;

console.log(textNode.nodeType);                // 3 (TEXT_NODE)

console.log(textNode.nodeName);                // "#text"

console.log(textNode.nodeValue);               // "Hello World"



// Document node

console.log(document.nodeType);                // 9 (DOCUMENT_NODE)

console.log(document.nodeName);                // "#document"

```



#### **Accessing DOM Elements**



```javascript

// 1. By ID (returns single element or null)

const container = document.getElementById('container');



// 2. By class name (returns HTMLCollection)

const titles = document.getElementsByClassName('title');

console.log(titles[0]);  // First element with class 'title'



// 3. By tag name (returns HTMLCollection)

const paragraphs = document.getElementsByTagName('p');

console.log(paragraphs.length);



// 4. Query selector (returns first match or null)

const firstTitle = document.querySelector('.title');

const firstPara = document.querySelector('p');

const divPara = document.querySelector('div p');  // CSS selectors



// 5. Query selector all (returns NodeList)

const allTitles = document.querySelectorAll('.title');

const allParas = document.querySelectorAll('p');



// Convert to array for array methods

const parasArray = Array.from(allParas);

parasArray.forEach(p => console.log(p.textContent));



// 6. Special selectors

const bodyElement = document.body;             // <body>

const htmlElement = document.documentElement;  // <html>

const headElement = document.head;             // <head>

```



#### **DOM Traversal**



```javascript

const container = document.getElementById('container');



// Parent navigation

console.log(container.parentNode);           // Parent node

console.log(container.parentElement);        // Parent element (same for elements)



// Child navigation

console.log(container.childNodes);           // All child nodes (including text nodes)

console.log(container.children);             // Only element children (HTMLCollection)

console.log(container.firstChild);           // First child node (might be text)

console.log(container.firstElementChild);    // First child element

console.log(container.lastChild);            // Last child node

console.log(container.lastElementChild);     // Last child element

console.log(container.hasChildNodes());      // true/false



// Sibling navigation

const h1 = document.querySelector('h1');

console.log(h1.nextSibling);                 // Next sibling node

console.log(h1.nextElementSibling);          // Next sibling element

console.log(h1.previousSibling);             // Previous sibling node

console.log(h1.previousElementSibling);      // Previous sibling element



// Ancestor checking

const p = document.querySelector('p');

console.log(container.contains(p));          // true (p is inside container)



// Closest ancestor matching selector

const closestDiv = p.closest('div');         // Finds nearest ancestor div

console.log(closestDiv.id);                  // 'container'

```



#### **Manipulating DOM Content**



```javascript

const element = document.querySelector('h1');



// 1. Text content (plain text only, safe from XSS)

console.log(element.textContent);            // "Hello World"

element.textContent = 'New Text';            // Sets text, HTML is escaped



// 2. innerHTML (can parse HTML, XSS risk if not sanitized)

console.log(element.innerHTML);              // "Hello World"

element.innerHTML = '<span>Formatted</span> Text';  // Parses HTML



// 3. innerText (similar to textContent, but respects CSS styling)

console.log(element.innerText);              // Visible text only

element.innerText = 'Visible Text';



// 4. outerHTML (includes the element itself)

console.log(element.outerHTML);              // "<h1>...</h1>"

element.outerHTML = '<h2>New Header</h2>';   // Replaces entire element



// Creating text nodes

const textNode = document.createTextNode('Pure text');

element.appendChild(textNode);

```



#### **Creating and Modifying Elements**



```javascript

// Creating elements

const newDiv = document.createElement('div');

const newPara = document.createElement('p');

const newText = document.createTextNode('Hello');



// Setting attributes

newDiv.id = 'new-container';

newDiv.className = 'container-class';

newDiv.setAttribute('data-id', '123');

newDiv.setAttribute('aria-label', 'Container');



// Setting content

newPara.textContent = 'This is a new paragraph';

newPara.innerHTML = '<strong>Bold text</strong> and normal text';



// Building structure

newDiv.appendChild(newPara);



// Inserting into DOM

document.body.appendChild(newDiv);           // Append to end of body

container.insertBefore(newDiv, container.firstChild);  // Insert at beginning



// Modern insertion methods

container.append(newDiv);                    // Append (can take multiple nodes/strings)

container.prepend(newDiv);                   // Prepend to start

newPara.before(newDiv);                      // Insert before element

newPara.after(newDiv);                       // Insert after element

newPara.replaceWith(newDiv);                 // Replace element



// Cloning elements

const clone = newDiv.cloneNode(false);       // Shallow clone (no children)

const deepClone = newDiv.cloneNode(true);    // Deep clone (with children)



// Removing elements

newDiv.remove();                             // Remove from DOM (modern)

container.removeChild(newDiv);               // Old method

```



#### **Working with Attributes**



```javascript

const element = document.querySelector('h1');



// Getting attributes

const id = element.getAttribute('id');

const className = element.getAttribute('class');

const dataValue = element.getAttribute('data-value');



// Setting attributes

element.setAttribute('id', 'main-title');

element.setAttribute('class', 'title primary');

element.setAttribute('data-index', '1');



// Removing attributes

element.removeAttribute('data-index');



// Checking attributes

console.log(element.hasAttribute('id'));     // true/false



// Direct property access (common attributes)

element.id = 'new-id';

element.className = 'new-class';

element.title = 'Tooltip text';



// Data attributes

element.dataset.userId = '123';              // Sets data-user-id

element.dataset.itemCount = '5';             // Sets data-item-count

console.log(element.dataset.userId);         // '123'



// Getting all attributes

const attrs = element.attributes;            // NamedNodeMap

for (let attr of attrs) {

  console.log(`${attr.name}: ${attr.value}`);

}

```



#### **Modifying Styles**



```javascript

const element = document.querySelector('h1');



// Inline styles

element.style.color = 'red';

element.style.fontSize = '24px';

element.style.backgroundColor = 'blue';      // camelCase for CSS properties

element.style.margin = '10px 20px';



// Getting computed styles (including CSS rules)

const styles = window.getComputedStyle(element);

console.log(styles.color);                   // 'rgb(255, 0, 0)'

console.log(styles.fontSize);                // '24px'

console.log(styles.marginTop);               // Computed margin



// Setting multiple styles

Object.assign(element.style, {

  color: 'blue',

  fontSize: '20px',

  padding: '10px'

});



// Removing inline styles

element.style.removeProperty('color');

element.style.color = '';                    // Alternative



// CSS Text

element.style.cssText = 'color: red; font-size: 24px; margin: 10px;';

console.log(element.style.cssText);

```



#### **Working with Classes**



```javascript

const element = document.querySelector('h1');



// className (string)

element.className = 'title primary';         // Sets all classes

console.log(element.className);              // 'title primary'



// classList (modern, recommended)

element.classList.add('active');             // Add class

element.classList.add('highlight', 'bold');  // Add multiple

element.classList.remove('primary');         // Remove class

element.classList.toggle('visible');         // Toggle (add if absent, remove if present)

element.classList.toggle('dark', true);      // Force add

element.classList.replace('title', 'heading');  // Replace class



// Checking classes

console.log(element.classList.contains('active'));  // true/false



// Iterate over classes

element.classList.forEach(className => {

  console.log(className);

});



// Convert to array

const classArray = [...element.classList];

```



#### **DOM Events (Basic)**



```javascript

const button = document.querySelector('button');



// Adding event listeners

button.addEventListener('click', function(event) {

  console.log('Button clicked!');

  console.log('Event type:', event.type);

  console.log('Target:', event.target);

});



// Named function for event handler

function handleClick(event) {

  console.log('Clicked:', event.target);

}

button.addEventListener('click', handleClick);



// Removing event listeners (must be same function reference)

button.removeEventListener('click', handleClick);



// Event options

button.addEventListener('click', handler, {

  once: true,      // Auto-remove after first trigger

  capture: false,  // Use bubbling phase (default)

  passive: true    // Won't call preventDefault()

});



// Multiple events

['mouseenter', 'mouseleave'].forEach(eventType => {

  button.addEventListener(eventType, event => {

    console.log(eventType);

  });

});

```



#### **DocumentFragment for Performance**



```javascript

// Creating many elements efficiently

function createList(items) {

  // Use DocumentFragment to minimize reflows

  const fragment = document.createDocumentFragment();

  

  items.forEach(item => {

    const li = document.createElement('li');

    li.textContent = item;

    fragment.appendChild(li);  // Append to fragment (in memory)

  });

  

  // Single DOM update

  document.querySelector('ul').appendChild(fragment);

}



createList(['Item 1', 'Item 2', 'Item 3', 'Item 4']);



// Without fragment (causes multiple reflows - slower)

function createListSlow(items) {

  const ul = document.querySelector('ul');

  items.forEach(item => {

    const li = document.createElement('li');

    li.textContent = item;

    ul.appendChild(li);  // Each append causes reflow

  });

}

```



#### **Practical Examples**



**1. Dynamic List Creation:**

```javascript

function renderUserList(users) {

  const container = document.getElementById('user-list');

  container.innerHTML = '';  // Clear existing

  

  users.forEach(user => {

    const userCard = document.createElement('div');

    userCard.className = 'user-card';

    userCard.innerHTML = `

      <h3>${user.name}</h3>

      <p>${user.email}</p>

      <button data-user-id="${user.id}">View Profile</button>

    `;

    container.appendChild(userCard);

  });

}



const users = [

  { id: 1, name: 'Alice', email: 'alice@example.com' },

  { id: 2, name: 'Bob', email: 'bob@example.com' }

];



renderUserList(users);

```



**2. Form Handling:**

```javascript

const form = document.querySelector('form');

const nameInput = document.getElementById('name');

const emailInput = document.getElementById('email');



form.addEventListener('submit', event => {

  event.preventDefault();  // Prevent default form submission

  

  const formData = {

    name: nameInput.value,

    email: emailInput.value

  };

  

  console.log('Form submitted:', formData);

  

  // Validate

  if (!formData.name) {

    nameInput.classList.add('error');

    return;

  }

  

  // Process form data

});

```



**3. Dynamic Content Update:**

```javascript

async function loadContent(url) {

  const container = document.getElementById('content');

  container.innerHTML = '<p>Loading...</p>';

  

  try {

    const response = await fetch(url);

    const data = await response.json();

    

    container.innerHTML = `

      <h2>${data.title}</h2>

      <p>${data.description}</p>

    `;

  } catch (error) {

    container.innerHTML = '<p class="error">Failed to load content</p>';

  }

}

```



#### **DOM Performance Considerations**



```javascript

// ❌ Bad: Multiple reflows

function inefficientUpdate() {

  const element = document.getElementById('box');

  element.style.width = '100px';   // Reflow

  element.style.height = '100px';  // Reflow

  element.style.margin = '10px';   // Reflow

}



// ✅ Good: Batch style changes

function efficientUpdate() {

  const element = document.getElementById('box');

  element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';  // Single reflow

}



// ✅ Good: Use CSS classes

function bestUpdate() {

  const element = document.getElementById('box');

  element.classList.add('box-sized');  // CSS handles all styles

}



// ❌ Bad: Reading and writing in loop

const elements = document.querySelectorAll('.item');

elements.forEach(el => {

  const height = el.offsetHeight;  // Triggers reflow (read)

  el.style.height = height + 10 + 'px';  // Triggers reflow (write)

});



// ✅ Good: Separate reads and writes

const heights = [];

elements.forEach(el => {

  heights.push(el.offsetHeight);  // Batch reads

});

elements.forEach((el, i) => {

  el.style.height = heights[i] + 10 + 'px';  // Batch writes

});

```



#### **Key Takeaways**



- **DOM is a tree structure** representing HTML documents

- **Nodes** include elements, text, comments, and documents

- **Access elements** via getElementById, querySelector, etc.

- **Navigate** with parentNode, children, nextSibling, etc.

- **Manipulate content** with textContent (safe) or innerHTML (flexible)

- **Create elements** with createElement, append with appendChild

- **Modern methods** (append, prepend, before, after) are cleaner

- **Attributes** accessed via getAttribute/setAttribute or direct properties

- **Styles** modified via element.style or classList

- **classList** preferred over className for class manipulation

- **DocumentFragment** improves performance for batch operations

- **Minimize reflows** by batching DOM updates

- **Event listeners** attach with addEventListener

- **DOM manipulation is expensive** - optimize for performance

- **XSS risk** with innerHTML - sanitize user input



---



</details>
<details><summary>72. What is event bubbling?</summary>




**Answer:**



Event bubbling is the process where an event triggered on a deeply nested element propagates upward through its ancestors in the DOM tree, triggering event handlers on parent elements. The event starts at the target element and "bubbles up" to the document root, allowing parent elements to respond to events from their children.



#### **Bubbling Mechanism**



```html

<div id="outer">

  <div id="middle">

    <button id="inner">Click Me</button>

  </div>

</div>

```



```javascript

// Event bubbling demonstration

const outer = document.getElementById('outer');

const middle = document.getElementById('middle');

const inner = document.getElementById('inner');



outer.addEventListener('click', () => {

  console.log('3. Outer div clicked');

});



middle.addEventListener('click', () => {

  console.log('2. Middle div clicked');

});



inner.addEventListener('click', () => {

  console.log('1. Button clicked');

});



// When button is clicked, console output:

// 1. Button clicked

// 2. Middle div clicked

// 3. Outer div clicked



// Event travels: button → middle div → outer div → document

```



#### **Event Flow Phases**



```javascript

// Three phases of event propagation:

// 1. CAPTURING PHASE (top-down)

// 2. TARGET PHASE (at target element)

// 3. BUBBLING PHASE (bottom-up)



const container = document.getElementById('container');

const button = document.querySelector('button');



// Capture phase listener (useCapture = true)

container.addEventListener('click', () => {

  console.log('Capture: Container');

}, true);



// Bubbling phase listener (useCapture = false, default)

container.addEventListener('click', () => {

  console.log('Bubble: Container');

}, false);



button.addEventListener('click', () => {

  console.log('Target: Button');

});



// Click button, output:

// Capture: Container  (capturing down)

// Target: Button      (at target)

// Bubble: Container   (bubbling up)

```



#### **Event Object Properties**



```javascript

button.addEventListener('click', function(event) {

  // Target: element that triggered the event

  console.log('event.target:', event.target);  // <button>

  

  // CurrentTarget: element with the listener attached

  console.log('event.currentTarget:', event.currentTarget);  // Same as 'this'

  

  // Event phase

  console.log('event.eventPhase:', event.eventPhase);

  // 1 = CAPTURING_PHASE, 2 = AT_TARGET, 3 = BUBBLING_PHASE

  

  // Bubbles flag

  console.log('event.bubbles:', event.bubbles);  // true

});



// Parent handler showing difference

container.addEventListener('click', function(event) {

  console.log('event.target:', event.target);          // <button> (original target)

  console.log('event.currentTarget:', event.currentTarget);  // <div> (current handler)

  console.log('this:', this);                          // <div> (same as currentTarget)

});

```



#### **Stopping Event Propagation**



```javascript

// 1. stopPropagation() - stops bubbling to parents

inner.addEventListener('click', function(event) {

  console.log('Button clicked');

  event.stopPropagation();  // Stops here, parents won't receive event

});



middle.addEventListener('click', () => {

  console.log('This will NOT run if stopPropagation is called');

});



// 2. stopImmediatePropagation() - stops bubbling AND other listeners on same element

inner.addEventListener('click', function(event) {

  console.log('First listener');

  event.stopImmediatePropagation();

});



inner.addEventListener('click', () => {

  console.log('This will NOT run');  // Skipped

});



// 3. Checking if propagation was stopped

middle.addEventListener('click', function(event) {

  if (event.cancelBubble) {  // Same as checking if stopPropagation was called

    console.log('Propagation was stopped');

  }

});

```



#### **Practical Use Cases**



**1. Event Delegation:**

```javascript

// Instead of attaching listener to each item

// Attach ONE listener to parent and use bubbling



const list = document.getElementById('todo-list');



// ❌ Inefficient: Multiple listeners

document.querySelectorAll('.todo-item').forEach(item => {

  item.addEventListener('click', handleClick);

});



// ✅ Efficient: Single listener with delegation

list.addEventListener('click', function(event) {

  // Check if clicked element is a todo item

  const todoItem = event.target.closest('.todo-item');

  

  if (todoItem) {

    console.log('Todo clicked:', todoItem.textContent);

    

    // Check specific actions

    if (event.target.classList.contains('delete-btn')) {

      deleteTodo(todoItem);

    } else if (event.target.classList.contains('complete-btn')) {

      toggleComplete(todoItem);

    }

  }

});



// Works for dynamically added items too!

function addTodoItem(text) {

  const li = document.createElement('li');

  li.className = 'todo-item';

  li.innerHTML = `

    ${text}

    <button class="complete-btn">✓</button>

    <button class="delete-btn">✗</button>

  `;

  list.appendChild(li);

  // No need to add event listeners!

}

```



**2. Modal/Overlay Closing:**

```javascript

// Close modal when clicking outside

const modal = document.getElementById('modal');

const modalContent = document.querySelector('.modal-content');



modal.addEventListener('click', function(event) {

  // Close if clicked on overlay (not content)

  if (event.target === modal) {

    closeModal();

  }

});



// Prevent closing when clicking inside modal content

modalContent.addEventListener('click', function(event) {

  event.stopPropagation();  // Don't bubble to modal overlay

});



// Alternative without stopPropagation

modal.addEventListener('click', function(event) {

  if (!modalContent.contains(event.target)) {

    closeModal();

  }

});

```



**3. Form Validation Bubbling:**

```javascript

const form = document.querySelector('form');



// Validate all inputs via bubbling

form.addEventListener('blur', function(event) {

  const input = event.target;

  

  if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {

    if (!input.value.trim()) {

      input.classList.add('error');

      showError(input, 'This field is required');

    } else {

      input.classList.remove('error');

      clearError(input);

    }

  }

}, true);  // Use capture to handle before individual handlers

```



**4. Table Row Actions:**

```javascript

const table = document.querySelector('table');



table.addEventListener('click', function(event) {

  const row = event.target.closest('tr');

  

  if (!row || !table.contains(row)) return;

  

  // Handle different button clicks

  if (event.target.matches('.edit-btn')) {

    editRow(row);

  } else if (event.target.matches('.delete-btn')) {

    deleteRow(row);

  } else if (event.target.matches('.view-btn')) {

    viewRowDetails(row);

  }

});

```



**5. Nested Component Communication:**

```javascript

// Parent component can listen to events from nested children

const app = document.getElementById('app');



app.addEventListener('custom-action', function(event) {

  console.log('Action from:', event.target);

  console.log('Action data:', event.detail);

});



// Child component dispatches custom event

const childButton = document.querySelector('.child-button');

childButton.addEventListener('click', function() {

  // Create and dispatch custom event (bubbles by default)

  const customEvent = new CustomEvent('custom-action', {

    bubbles: true,  // Enable bubbling

    detail: { action: 'buttonClick', value: 123 }

  });

  

  this.dispatchEvent(customEvent);

});

```



#### **Events That Don't Bubble**



```javascript

// Some events don't bubble by default:



// Focus events (non-bubbling)

input.addEventListener('focus', handler);    // Doesn't bubble

input.addEventListener('blur', handler);     // Doesn't bubble



// Use bubbling versions instead:

input.addEventListener('focusin', handler);  // Bubbles

input.addEventListener('focusout', handler); // Bubbles



// Other non-bubbling events:

// - load, unload

// - error

// - scroll (in some cases)

// - mouseenter, mouseleave (use mouseover, mouseout instead)



// Check if event bubbles

element.addEventListener('someEvent', function(event) {

  console.log('Bubbles:', event.bubbles);  // true/false

});

```



#### **Bubbling vs Capturing**



```javascript

const parent = document.getElementById('parent');

const child = document.getElementById('child');



// Capturing (top-down, parent first)

parent.addEventListener('click', () => {

  console.log('Parent - Capturing');

}, true);



child.addEventListener('click', () => {

  console.log('Child - Capturing');

}, true);



// Bubbling (bottom-up, child first)

child.addEventListener('click', () => {

  console.log('Child - Bubbling');

}, false);



parent.addEventListener('click', () => {

  console.log('Parent - Bubbling');

}, false);



// Click child, output:

// Parent - Capturing

// Child - Capturing

// Child - Bubbling

// Parent - Bubbling

```



#### **Common Pitfalls**



```javascript

// 1. Forgetting event.target vs event.currentTarget

parent.addEventListener('click', function(event) {

  console.log(event.target);          // Might be child element

  console.log(event.currentTarget);   // Always parent

  console.log(this);                  // Always parent (same as currentTarget)

});



// 2. Stopping propagation unnecessarily

button.addEventListener('click', function(event) {

  event.stopPropagation();  // Might break parent handlers

  // Be careful - this can break event delegation!

});



// 3. Not checking event.target in delegation

list.addEventListener('click', function(event) {

  // ❌ Assumes all clicks are on list items

  deleteItem(event.target);

  

  // ✅ Check if target is correct element

  if (event.target.matches('.list-item')) {

    deleteItem(event.target);

  }

});



// 4. Memory leaks with many listeners

// ❌ Creating thousands of listeners

items.forEach(item => {

  item.addEventListener('click', handler);

});



// ✅ Use delegation with one listener

container.addEventListener('click', function(event) {

  if (event.target.matches('.item')) {

    handler(event);

  }

});

```



#### **Performance Benefits**



```javascript

// Event delegation performance comparison



// Scenario: 1000 list items



// ❌ Individual listeners (1000 listeners)

function attachIndividualListeners() {

  const items = document.querySelectorAll('.item');

  items.forEach(item => {

    item.addEventListener('click', handleClick);

    item.addEventListener('mouseover', handleHover);

  });

  // Memory: High (2000 listeners)

  // Performance: Slower with many items

}



// ✅ Event delegation (1-2 listeners)

function attachDelegatedListeners() {

  const container = document.querySelector('.container');

  

  container.addEventListener('click', function(event) {

    if (event.target.matches('.item')) {

      handleClick(event);

    }

  });

  

  container.addEventListener('mouseover', function(event) {

    if (event.target.matches('.item')) {

      handleHover(event);

    }

  });

  // Memory: Low (2 listeners)

  // Performance: Fast, scales well

}

```



#### **Key Takeaways**



- **Event bubbling** propagates events from target to ancestors

- **Three phases**: capturing (down) → target → bubbling (up)

- **event.target** is the element that triggered the event

- **event.currentTarget** is the element with the listener

- **stopPropagation()** prevents bubbling to parents

- **stopImmediatePropagation()** stops all handlers

- **Event delegation** uses bubbling for efficient event handling

- **One listener on parent** better than many on children

- **Works with dynamic content** (elements added later)

- **Not all events bubble** (focus, blur, load, mouseenter/leave)

- **Bubbling enables** powerful patterns like event delegation

- **Performance benefit** with fewer listeners

- **Check event.target** in delegated handlers

- **Be careful with stopPropagation** - can break delegation

- Default for addEventListener is **bubbling phase** (useCapture=false)



---



</details>
<details><summary>73. What is event capturing?</summary>




**Answer:**



Event capturing (also called trickling) is the first phase of event propagation where an event travels from the document root down through ancestors to the target element. It's the opposite of bubbling - the event "captures" down the DOM tree before reaching the target. Capturing happens before the bubbling phase.



#### **Capturing Phase Flow**



```html

<div id="grandparent">

  <div id="parent">

    <button id="child">Click Me</button>

  </div>

</div>

```



```javascript

// Enabling capture phase with useCapture = true (third parameter)

const grandparent = document.getElementById('grandparent');

const parent = document.getElementById('parent');

const child = document.getElementById('child');



// Capture phase listeners (execute top-down)

grandparent.addEventListener('click', () => {

  console.log('1. Grandparent - Capturing');

}, true);  // true = capture phase



parent.addEventListener('click', () => {

  console.log('2. Parent - Capturing');

}, true);



child.addEventListener('click', () => {

  console.log('3. Child - Capturing');

}, true);



// When button is clicked:

// 1. Grandparent - Capturing (top level first)

// 2. Parent - Capturing

// 3. Child - Capturing (target last in capture phase)

```



#### **Complete Event Flow: Capture → Target → Bubble**



```javascript

const outer = document.getElementById('outer');

const inner = document.getElementById('inner');



// CAPTURE PHASE (true = useCapture)

outer.addEventListener('click', () => {

  console.log('1. Outer - CAPTURE (going down)');

}, true);



inner.addEventListener('click', () => {

  console.log('2. Inner - CAPTURE (reached target)');

}, true);



// TARGET PHASE (at the target element)

inner.addEventListener('click', () => {

  console.log('3. Inner - TARGET (at target)');

}, false);



// BUBBLING PHASE (false = useCapture, default)

inner.addEventListener('click', () => {

  console.log('4. Inner - BUBBLE (going up)');

}, false);



outer.addEventListener('click', () => {

  console.log('5. Outer - BUBBLE (back to top)');

}, false);



// Click inner button, output:

// 1. Outer - CAPTURE (going down)

// 2. Inner - CAPTURE (reached target)

// 3. Inner - TARGET (at target)

// 4. Inner - BUBBLE (going up)

// 5. Outer - BUBBLE (back to top)

```



#### **Capture with Options Object**



```javascript

const element = document.getElementById('element');



// Modern syntax with options object

element.addEventListener('click', handler, {

  capture: true,   // Enable capturing phase

  once: false,     // Can trigger multiple times

  passive: false   // Can call preventDefault()

});



// Equivalent to old syntax

element.addEventListener('click', handler, true);



// Bubbling phase (default)

element.addEventListener('click', handler, {

  capture: false  // Or just omit options entirely

});

```



#### **Event Phase Detection**



```javascript

function logPhase(event) {

  const phases = {

    0: 'NONE',

    1: 'CAPTURING_PHASE',

    2: 'AT_TARGET',

    3: 'BUBBLING_PHASE'

  };

  

  console.log(`

    Phase: ${phases[event.eventPhase]}

    Target: ${event.target.id}

    CurrentTarget: ${event.currentTarget.id}

  `);

}



parent.addEventListener('click', logPhase, true);   // Capture

child.addEventListener('click', logPhase, false);   // Bubble



// Click child:

// Phase: CAPTURING_PHASE, Target: child, CurrentTarget: parent

// Phase: AT_TARGET, Target: child, CurrentTarget: child

// Phase: BUBBLING_PHASE, Target: child, CurrentTarget: parent

```



#### **Stopping Propagation in Capture Phase**



```javascript

// Stop during capture phase

grandparent.addEventListener('click', function(event) {

  console.log('Grandparent captured event');

  event.stopPropagation();  // Stops here, won't reach child or bubble back

}, true);



parent.addEventListener('click', () => {

  console.log('This will NOT run');

}, true);



child.addEventListener('click', () => {

  console.log('This will NOT run either');

});



// Only "Grandparent captured event" will log

```



#### **Practical Use Cases for Capturing**



**1. Global Event Interception:**

```javascript

// Intercept all clicks before they reach targets

document.addEventListener('click', function(event) {

  console.log('Global click intercepted:', event.target);

  

  // Conditional stopping

  if (event.target.matches('.disabled')) {

    event.stopPropagation();  // Prevent any further handling

    event.preventDefault();

    console.log('Clicked on disabled element - blocked');

  }

}, true);  // Capture phase ensures this runs first

```



**2. Form Validation Before Submission:**

```javascript

const form = document.querySelector('form');



// Validate in capture phase (before individual field handlers)

form.addEventListener('submit', function(event) {

  const invalidFields = form.querySelectorAll(':invalid');

  

  if (invalidFields.length > 0) {

    event.stopPropagation();  // Stop event propagation

    event.preventDefault();    // Prevent form submission

    

    console.log('Form validation failed');

    invalidFields.forEach(field => {

      field.classList.add('error');

    });

  }

}, true);  // Capture phase

```



**3. Analytics/Logging:**

```javascript

// Log all interactions before they're processed

document.body.addEventListener('click', function(event) {

  // Analytics tracking in capture phase

  const analytics = {

    timestamp: Date.now(),

    target: event.target.tagName,

    id: event.target.id,

    classes: event.target.className

  };

  

  console.log('Analytics:', analytics);

  // Send to analytics service

  

  // Don't stop propagation - let event continue

}, true);

```



**4. Access Control/Permission Checking:**

```javascript

// Check permissions before allowing interactions

const restrictedArea = document.getElementById('admin-panel');



restrictedArea.addEventListener('click', function(event) {

  if (!userHasPermission()) {

    event.stopPropagation();

    event.preventDefault();

    

    showNotification('Access denied: Insufficient permissions');

    console.log('Blocked interaction with:', event.target);

  }

}, true);  // Capture ensures this check happens first

```



**5. Focus Management:**

```javascript

// Handle focus events in capture phase

document.addEventListener('focusin', function(event) {

  console.log('Element gaining focus:', event.target);

  

  // Close dropdowns when focus moves outside

  if (!dropdown.contains(event.target)) {

    closeDropdown();

  }

  

  // Track focus for accessibility

  updateFocusIndicator(event.target);

}, true);  // Use capture for focusin

```



**6. Preventing Default Actions Early:**

```javascript

// Prevent link navigation in certain conditions

document.addEventListener('click', function(event) {

  const link = event.target.closest('a');

  

  if (link && link.hostname !== window.location.hostname) {

    // External link

    if (!confirmExternalNavigation()) {

      event.preventDefault();

      event.stopPropagation();

      console.log('External navigation cancelled');

    }

  }

}, true);  // Capture phase intercepts before link navigation

```



#### **Capture vs Bubble Comparison**



| Feature | Capturing | Bubbling |

|---------|-----------|----------|

| **Direction** | Top-down (document → target) | Bottom-up (target → document) |

| **Phase order** | First (phase 1) | Last (phase 3) |

| **Default** | No (must explicitly enable) | Yes (default behavior) |

| **Use case** | Intercept before target | Delegate from children |

| **Common usage** | Less common | More common |

| **Enable with** | `true` or `{capture: true}` | `false` or omit |

| **stopPropagation** | Stops descending and bubbling | Stops ascending only |

| **Best for** | Global handlers, validation | Event delegation |



```javascript

// Visual comparison

element.addEventListener('click', captureHandler, true);   // Capture

element.addEventListener('click', bubbleHandler, false);   // Bubble (default)

element.addEventListener('click', bubbleHandler);          // Bubble (default)

```



#### **Removing Capture Listeners**



```javascript

function handler(event) {

  console.log('Event handled');

}



// Adding capture listener

element.addEventListener('click', handler, true);



// Removing - must match capture flag!

element.removeEventListener('click', handler, true);  // ✅ Correct



// This won't work:

element.removeEventListener('click', handler, false);  // ❌ Wrong - doesn't match

element.removeEventListener('click', handler);          // ❌ Wrong - doesn't match

```



#### **Mixed Capture and Bubble Handlers**



```javascript

const container = document.getElementById('container');

const button = document.querySelector('button');



// Same element can have both capture and bubble handlers

container.addEventListener('click', () => {

  console.log('Container - Capture (going down)');

}, true);



container.addEventListener('click', () => {

  console.log('Container - Bubble (going up)');

}, false);



button.addEventListener('click', () => {

  console.log('Button clicked');

});



// Click button, output:

// Container - Capture (going down)  ← Capture phase

// Button clicked                     ← Target phase

// Container - Bubble (going up)     ← Bubble phase

```



#### **Real-World Patterns**



**1. Modal Trap Focus:**

```javascript

// Trap focus within modal during capture

modal.addEventListener('focusin', function(event) {

  if (!modal.contains(event.target)) {

    event.stopPropagation();

    // Return focus to modal

    modal.querySelector('[tabindex="0"]').focus();

  }

}, true);

```



**2. Keyboard Shortcuts:**

```javascript

// Global keyboard shortcuts in capture

document.addEventListener('keydown', function(event) {

  // Ctrl+S to save

  if (event.ctrlKey && event.key === 's') {

    event.preventDefault();

    event.stopPropagation();

    saveDocument();

  }

  

  // ESC to close modals

  if (event.key === 'Escape') {

    closeAllModals();

  }

}, true);  // Capture ensures this runs before other handlers

```



**3. Drag and Drop Guard:**

```javascript

// Prevent accidental dragging in capture phase

document.addEventListener('dragstart', function(event) {

  if (!event.target.matches('[draggable="true"]')) {

    event.preventDefault();

    event.stopPropagation();

    console.log('Drag prevented for:', event.target);

  }

}, true);

```



#### **When to Use Capturing**



**Use Capturing when:**

- Need to intercept events before they reach targets

- Implementing global event handlers (analytics, logging)

- Validating before processing

- Enforcing access control

- Preventing default actions early

- Want to handle events before bubbling phase



**Use Bubbling when:**

- Implementing event delegation

- Handling events from children

- Most standard event handling

- Working with dynamic content

- Default behavior is sufficient



```javascript

// ✅ Good use of capturing: Global validation

form.addEventListener('input', function(event) {

  // Validate all inputs before individual handlers

  validateInput(event.target);

}, true);



// ✅ Good use of bubbling: Event delegation

list.addEventListener('click', function(event) {

  if (event.target.matches('.item')) {

    handleItemClick(event.target);

  }

}, false);

```



#### **Key Takeaways**



- **Capturing** is the first phase of event propagation (top-down)

- **Opposite of bubbling** - travels from document to target

- **Enabled with** `true` or `{capture: true}` parameter

- **Less common** than bubbling but useful for interception

- **Runs before** target and bubbling phases

- **stopPropagation()** in capture prevents target and bubbling

- **Both phases can coexist** on same element

- **Must match capture flag** when removing listeners

- **Use for** global handlers, validation, access control

- **Perfect for** intercepting events before processing

- **Event phase** detectable via event.eventPhase property

- **Bubbling is default** - must explicitly enable capturing

- **Capturing handlers** execute in document → target order

- Understanding both phases enables **powerful event patterns**

- **Rarely needed** in simple applications but crucial for complex UIs





</details>
<details><summary>71. What is the DOM?</summary>






</details>
<details><summary>72. What is event bubbling?</summary>






</details>
<details><summary>73. What is event capturing?</summary>






---



</details>
<details><summary>74. What is event delegation?</summary>




**Answer:**



Event delegation is a technique where instead of attaching event listeners to individual child elements, you attach a single event listener to a parent element and use event bubbling to handle events from child elements. This pattern leverages event propagation to handle events efficiently, especially for dynamic content.



#### **Basic Concept**



```javascript

// WITHOUT Event Delegation (inefficient)

const buttons = document.querySelectorAll('.button');

buttons.forEach(button => {

  button.addEventListener('click', function() {

    console.log('Button clicked:', this.textContent);

  });

});

// Problem: Creates N listeners for N buttons

// Problem: Doesn't work for dynamically added buttons



// WITH Event Delegation (efficient)

const container = document.querySelector('.button-container');

container.addEventListener('click', function(event) {

  // Check if clicked element is a button

  if (event.target.matches('.button')) {

    console.log('Button clicked:', event.target.textContent);

  }

});

// Solution: Only 1 listener

// Solution: Works for dynamically added buttons

```



#### **How Event Delegation Works**



```html

<ul id="todo-list">

  <li class="todo-item">Task 1 <button class="delete">Delete</button></li>

  <li class="todo-item">Task 2 <button class="delete">Delete</button></li>

  <li class="todo-item">Task 3 <button class="delete">Delete</button></li>

</ul>

```



```javascript

// Delegate to parent

const todoList = document.getElementById('todo-list');



todoList.addEventListener('click', function(event) {

  // event.target = the actual element clicked

  // event.currentTarget = the element with the listener (todoList)

  

  console.log('Clicked on:', event.target);

  console.log('Listener on:', event.currentTarget);

  

  // Check what was clicked

  if (event.target.classList.contains('delete')) {

    const todoItem = event.target.closest('.todo-item');

    todoItem.remove();

    console.log('Todo deleted');

  }

});



// Add new todo dynamically - delegation still works!

function addTodo(text) {

  const li = document.createElement('li');

  li.className = 'todo-item';

  li.innerHTML = `${text} <button class="delete">Delete</button>`;

  todoList.appendChild(li);

  // No need to attach new listener!

}



addTodo('Task 4');  // Delete button works automatically

```



#### **Matching Target Elements**



```javascript

const container = document.getElementById('container');



container.addEventListener('click', function(event) {

  const target = event.target;

  

  // 1. Using matches() - checks if element matches selector

  if (target.matches('.button')) {

    console.log('Button clicked');

  }

  

  // 2. Using classList.contains() - checks for specific class

  if (target.classList.contains('delete-btn')) {

    console.log('Delete button clicked');

  }

  

  // 3. Using closest() - finds nearest ancestor matching selector

  const listItem = target.closest('.list-item');

  if (listItem) {

    console.log('Clicked inside list item:', listItem);

  }

  

  // 4. Using tagName - check element type

  if (target.tagName === 'BUTTON') {

    console.log('Any button clicked');

  }

  

  // 5. Using dataset - check data attributes

  if (target.dataset.action === 'delete') {

    console.log('Delete action triggered');

  }

  

  // 6. Multiple conditions

  if (target.matches('button.primary') && !target.disabled) {

    console.log('Active primary button clicked');

  }

});

```



#### **Practical Examples**



**1. Todo List with Multiple Actions:**

```javascript

const todoList = document.getElementById('todos');



todoList.addEventListener('click', function(event) {

  const target = event.target;

  const todoItem = target.closest('.todo-item');

  

  if (!todoItem) return;  // Clicked outside todo items

  

  // Handle different button clicks

  if (target.classList.contains('complete-btn')) {

    todoItem.classList.toggle('completed');

    console.log('Todo marked as', todoItem.classList.contains('completed') ? 'complete' : 'incomplete');

  }

  else if (target.classList.contains('delete-btn')) {

    todoItem.remove();

    console.log('Todo deleted');

  }

  else if (target.classList.contains('edit-btn')) {

    const textSpan = todoItem.querySelector('.todo-text');

    const newText = prompt('Edit todo:', textSpan.textContent);

    if (newText) {

      textSpan.textContent = newText;

    }

  }

  else if (target.classList.contains('priority-btn')) {

    todoItem.dataset.priority = todoItem.dataset.priority === 'high' ? 'normal' : 'high';

    console.log('Priority changed to:', todoItem.dataset.priority);

  }

});



// Adding todos dynamically

function addTodo(text) {

  const li = document.createElement('li');

  li.className = 'todo-item';

  li.innerHTML = `

    <span class="todo-text">${text}</span>

    <button class="complete-btn">✓</button>

    <button class="edit-btn">✎</button>

    <button class="priority-btn">!</button>

    <button class="delete-btn">✗</button>

  `;

  todoList.appendChild(li);

}

```



**2. Data Table with Row Actions:**

```javascript

const table = document.querySelector('.data-table');



table.addEventListener('click', function(event) {

  const target = event.target;

  const row = target.closest('tr');

  

  if (!row || row.parentElement.tagName === 'THEAD') return;

  

  // Get row data

  const rowId = row.dataset.id;

  

  if (target.classList.contains('view-btn')) {

    viewDetails(rowId);

  }

  else if (target.classList.contains('edit-btn')) {

    editRow(rowId);

  }

  else if (target.classList.contains('delete-btn')) {

    if (confirm('Delete this row?')) {

      deleteRow(rowId);

      row.remove();

    }

  }

  else if (target.type === 'checkbox') {

    handleRowSelection(row, target.checked);

  }

  else {

    // Clicking anywhere else on row selects it

    selectRow(row);

  }

});



function viewDetails(id) {

  console.log('Viewing details for:', id);

  // Load and display details

}



function editRow(id) {

  console.log('Editing row:', id);

  // Open edit modal

}



function deleteRow(id) {

  console.log('Deleting row:', id);

  // API call to delete

}

```



**3. Navigation Menu with Submenus:**

```javascript

const nav = document.querySelector('.navigation');



nav.addEventListener('click', function(event) {

  const link = event.target.closest('a');

  

  if (!link) return;

  

  // Handle submenu toggles

  if (link.classList.contains('has-submenu')) {

    event.preventDefault();

    const submenu = link.nextElementSibling;

    submenu.classList.toggle('open');

    link.classList.toggle('active');

  }

  // Handle regular navigation

  else if (!link.classList.contains('disabled')) {

    console.log('Navigating to:', link.href);

    // Navigation happens naturally unless prevented

  }

});



// Close submenus when clicking outside

document.addEventListener('click', function(event) {

  if (!nav.contains(event.target)) {

    nav.querySelectorAll('.submenu.open').forEach(submenu => {

      submenu.classList.remove('open');

    });

  }

});

```



**4. Image Gallery with Lightbox:**

```javascript

const gallery = document.querySelector('.gallery');



gallery.addEventListener('click', function(event) {

  const thumbnail = event.target.closest('.thumbnail');

  

  if (thumbnail) {

    event.preventDefault();

    const fullImageUrl = thumbnail.dataset.fullsize;

    openLightbox(fullImageUrl);

  }

});



function openLightbox(imageUrl) {

  const lightbox = document.createElement('div');

  lightbox.className = 'lightbox';

  lightbox.innerHTML = `

    <div class="lightbox-content">

      <img src="${imageUrl}" alt="Full size">

      <button class="close-btn">✕</button>

    </div>

  `;

  

  document.body.appendChild(lightbox);

  

  // Delegate close action

  lightbox.addEventListener('click', function(event) {

    if (event.target === lightbox || event.target.classList.contains('close-btn')) {

      lightbox.remove();

    }

  });

}

```



**5. Form with Dynamic Fields:**

```javascript

const form = document.querySelector('.dynamic-form');



// Delegate all form interactions

form.addEventListener('click', function(event) {

  const target = event.target;

  

  // Add field button

  if (target.classList.contains('add-field')) {

    const fieldGroup = target.closest('.field-group');

    const newField = fieldGroup.cloneNode(true);

    newField.querySelector('input').value = '';

    fieldGroup.parentElement.appendChild(newField);

  }

  

  // Remove field button

  else if (target.classList.contains('remove-field')) {

    const fieldGroup = target.closest('.field-group');

    if (form.querySelectorAll('.field-group').length > 1) {

      fieldGroup.remove();

    }

  }

});



// Delegate validation

form.addEventListener('blur', function(event) {

  const input = event.target;

  

  if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {

    validateField(input);

  }

}, true);  // Use capture for blur events



function validateField(field) {

  if (field.required && !field.value.trim()) {

    field.classList.add('error');

    showError(field, 'This field is required');

  } else {

    field.classList.remove('error');

    clearError(field);

  }

}

```



**6. Card Grid with Filters:**

```javascript

const cardGrid = document.querySelector('.card-grid');

const filterBar = document.querySelector('.filter-bar');



// Delegate card interactions

cardGrid.addEventListener('click', function(event) {

  const card = event.target.closest('.card');

  

  if (!card) return;

  

  if (event.target.classList.contains('like-btn')) {

    card.classList.toggle('liked');

    updateLikeCount(card);

  }

  else if (event.target.classList.contains('share-btn')) {

    shareCard(card.dataset.id);

  }

  else if (event.target.classList.contains('bookmark-btn')) {

    card.classList.toggle('bookmarked');

  }

  else {

    // Clicking card itself opens details

    openCardDetails(card.dataset.id);

  }

});



// Delegate filter clicks

filterBar.addEventListener('click', function(event) {

  const filterBtn = event.target.closest('.filter-btn');

  

  if (filterBtn) {

    // Remove active from all

    filterBar.querySelectorAll('.filter-btn').forEach(btn => {

      btn.classList.remove('active');

    });

    

    // Add active to clicked

    filterBtn.classList.add('active');

    

    // Filter cards

    const category = filterBtn.dataset.category;

    filterCards(category);

  }

});

```



#### **Benefits of Event Delegation**



```javascript

// 1. MEMORY EFFICIENCY

// Without delegation: 1000 buttons = 1000 listeners

const buttons = document.querySelectorAll('.button');  // 1000 buttons

buttons.forEach(button => {

  button.addEventListener('click', handler);  // 1000 listeners

});



// With delegation: 1000 buttons = 1 listener

const container = document.querySelector('.container');

container.addEventListener('click', function(event) {

  if (event.target.matches('.button')) {

    handler(event);

  }

});  // Only 1 listener!



// 2. DYNAMIC CONTENT

// Works automatically with elements added later

function addButton(text) {

  const btn = document.createElement('button');

  btn.className = 'button';

  btn.textContent = text;

  container.appendChild(btn);

  // No need to attach listener - delegation handles it!

}



// 3. SIMPLIFIED CODE

// Single handler instead of multiple identical handlers

// Easier to maintain and update logic



// 4. PERFORMANCE

// Faster initialization (fewer listeners to attach)

// Better memory usage (fewer listener objects)

```



#### **Advanced Techniques**



**1. Event Delegation with Event Types:**

```javascript

const container = document.getElementById('container');



// Delegate multiple event types

['click', 'mouseover', 'mouseout'].forEach(eventType => {

  container.addEventListener(eventType, function(event) {

    const item = event.target.closest('.item');

    

    if (!item) return;

    

    switch(event.type) {

      case 'click':

        console.log('Item clicked');

        break;

      case 'mouseover':

        item.classList.add('hover');

        break;

      case 'mouseout':

        item.classList.remove('hover');

        break;

    }

  });

});

```



**2. Delegation with Custom Events:**

```javascript

const app = document.getElementById('app');



// Listen for custom events via delegation

app.addEventListener('item-selected', function(event) {

  console.log('Item selected:', event.detail);

  updateUI(event.detail);

});



// Child components can dispatch custom events

function selectItem(itemId) {

  const customEvent = new CustomEvent('item-selected', {

    bubbles: true,  // Must bubble for delegation

    detail: { id: itemId, timestamp: Date.now() }

  });

  

  this.dispatchEvent(customEvent);

}

```



**3. Delegation with Namespace Pattern:**

```javascript

const page = {

  init() {

    const container = document.getElementById('main');

    container.addEventListener('click', this.handleClick.bind(this));

  },

  

  handleClick(event) {

    const target = event.target;

    

    // Route to specific handlers

    if (target.matches('[data-action]')) {

      const action = target.dataset.action;

      const handler = this.actions[action];

      

      if (handler) {

        handler.call(this, event, target);

      }

    }

  },

  

  actions: {

    delete(event, target) {

      console.log('Delete action');

      const item = target.closest('.item');

      item.remove();

    },

    

    edit(event, target) {

      console.log('Edit action');

      const item = target.closest('.item');

      this.editItem(item);

    },

    

    share(event, target) {

      console.log('Share action');

      this.shareItem(target.dataset.id);

    }

  }

};



page.init();

```



**4. Preventing Delegation in Specific Cases:**

```javascript

container.addEventListener('click', function(event) {

  const target = event.target;

  

  // Skip if clicked on disabled elements

  if (target.disabled || target.classList.contains('disabled')) {

    return;

  }

  

  // Skip if in a "no-delegate" zone

  if (target.closest('.no-delegate')) {

    return;

  }

  

  // Process delegation

  if (target.matches('.action-btn')) {

    handleAction(target);

  }

});

```



#### **Common Pitfalls**



```javascript

// 1. Not checking if target exists

container.addEventListener('click', function(event) {

  // ❌ Might be null

  const item = event.target.closest('.item');

  item.classList.add('selected');  // Error if null!

  

  // ✅ Check first

  const itemSafe = event.target.closest('.item');

  if (itemSafe) {

    itemSafe.classList.add('selected');

  }

});



// 2. Using stopPropagation in child (breaks delegation)

button.addEventListener('click', function(event) {

  event.stopPropagation();  // ❌ Prevents delegation from working

});



// 3. Forgetting to check target type

container.addEventListener('click', function(event) {

  // ❌ Assumes all clicks are on buttons

  console.log(event.target.textContent);

  

  // ✅ Check before accessing

  if (event.target.matches('button')) {

    console.log(event.target.textContent);

  }

});



// 4. Attaching to wrong parent

document.body.addEventListener('click', function(event) {

  // ❌ Too broad - handles ALL clicks on page

  if (event.target.matches('.menu-item')) {

    // This will catch ALL .menu-item clicks everywhere

  }

});



// ✅ Attach to specific container

menu.addEventListener('click', function(event) {

  if (event.target.matches('.menu-item')) {

    // Only handles clicks in this menu

  }

});



// 5. Not considering event.target vs event.currentTarget

container.addEventListener('click', function(event) {

  console.log(this);                   // Always container (currentTarget)

  console.log(event.currentTarget);    // Always container

  console.log(event.target);           // Varies (actual clicked element)

});

```



#### **Performance Comparison**



```javascript

// Test with 1000 items



// METHOD 1: Individual listeners

console.time('Individual listeners');

const items1 = document.querySelectorAll('.item-individual');

items1.forEach(item => {

  item.addEventListener('click', function() {

    console.log('Clicked');

  });

});

console.timeEnd('Individual listeners');  // Slower, more memory



// METHOD 2: Event delegation

console.time('Event delegation');

const container = document.querySelector('.container-delegate');

container.addEventListener('click', function(event) {

  if (event.target.classList.contains('item-delegate')) {

    console.log('Clicked');

  }

});

console.timeEnd('Event delegation');  // Faster, less memory



// Memory usage comparison:

// Individual: ~1000 listener objects

// Delegation: 1 listener object

```



#### **When to Use Event Delegation**



**Use Event Delegation when:**

- Working with many similar elements

- Elements are added/removed dynamically

- Want to reduce memory usage

- Elements share similar event handling logic

- Building interactive lists, tables, or grids



**Don't Use Event Delegation when:**

- Only a few static elements

- Each element needs unique complex logic

- Performance of single listener matters

- Events don't bubble (focus, blur - use focusin/focusout instead)



```javascript

// ✅ Good for delegation

<ul id="menu">

  <li><a href="#">Item 1</a></li>

  <li><a href="#">Item 2</a></li>

  <!-- ... 100 more items ... -->

</ul>



menu.addEventListener('click', delegateHandler);



// ❌ Not ideal for delegation (too few elements)

<div id="header">

  <button id="login">Login</button>

  <button id="signup">Signup</button>

</div>



// Just attach directly

document.getElementById('login').addEventListener('click', loginHandler);

document.getElementById('signup').addEventListener('click', signupHandler);

```



#### **Key Takeaways**



- **Single listener on parent** handles events from children

- **Leverages event bubbling** to capture child events

- **Works with dynamic content** added after page load

- **Memory efficient** - fewer listeners needed

- **Use event.target** to identify clicked element

- **Use .closest()** to find ancestor matching selector

- **Check if target exists** before accessing properties

- **Don't stopPropagation** in child elements

- **Perfect for lists, tables, grids** with many items

- **Simplifies code** for similar event handlers

- **Better performance** with large numbers of elements

- **Common pattern** in modern JavaScript applications

- **Essential for SPAs** with dynamic content

- **Works with** click, mouseover, keydown, etc. (bubbling events)

- **Framework-agnostic** - works in vanilla JS and frameworks



---



</details>
<details><summary>75. What is the difference between event.preventDefault() and event.stopPropagation()?</summary>




**Answer:**



`event.preventDefault()` prevents the browser's default action for an event (like form submission or link navigation), while `event.stopPropagation()` stops the event from bubbling up to parent elements. They serve different purposes and can be used independently or together.



#### **event.preventDefault()**



Prevents the browser's default behavior for an event:



```javascript

// 1. Preventing form submission

const form = document.querySelector('form');

form.addEventListener('submit', function(event) {

  event.preventDefault();  // Stops form from submitting

  

  console.log('Form submission prevented');

  // Handle form with JavaScript instead

  const formData = new FormData(form);

  submitViaAjax(formData);

});



// 2. Preventing link navigation

const link = document.querySelector('a');

link.addEventListener('click', function(event) {

  event.preventDefault();  // Stops navigation to href

  

  console.log('Link clicked but not followed');

  // Custom navigation logic

  customNavigate(this.href);

});



// 3. Preventing checkbox toggle

const checkbox = document.querySelector('input[type="checkbox"]');

checkbox.addEventListener('click', function(event) {

  if (!userHasPermission()) {

    event.preventDefault();  // Prevents checking/unchecking

    alert('You do not have permission');

  }

});



// 4. Preventing text selection

const text = document.querySelector('.no-select');

text.addEventListener('mousedown', function(event) {

  event.preventDefault();  // Prevents text selection

});



// 5. Preventing context menu

document.addEventListener('contextmenu', function(event) {

  event.preventDefault();  // Prevents right-click menu

  showCustomContextMenu(event.pageX, event.pageY);

});

```



#### **event.stopPropagation()**



Stops the event from bubbling up to parent elements:



```javascript

// DOM structure

// <div id="outer">

//   <div id="middle">

//     <button id="inner">Click</button>

//   </div>

// </div>



const outer = document.getElementById('outer');

const middle = document.getElementById('middle');

const inner = document.getElementById('inner');



outer.addEventListener('click', () => {

  console.log('Outer clicked');

});



middle.addEventListener('click', () => {

  console.log('Middle clicked');

});



inner.addEventListener('click', (event) => {

  console.log('Inner clicked');

  event.stopPropagation();  // Stops bubbling to middle and outer

});



// Clicking button outputs only:

// "Inner clicked"

// (middle and outer handlers don't fire)

```



#### **Visual Comparison**



```javascript

// WITHOUT stopPropagation

document.getElementById('parent').addEventListener('click', () => {

  console.log('1. Parent');

});



document.getElementById('child').addEventListener('click', () => {

  console.log('2. Child');

});



// Click child, output:

// 2. Child

// 1. Parent (bubbled up)



// WITH stopPropagation

document.getElementById('parent').addEventListener('click', () => {

  console.log('1. Parent');

});



document.getElementById('child').addEventListener('click', (event) => {

  console.log('2. Child');

  event.stopPropagation();  // Stop here

});



// Click child, output:

// 2. Child

// (no "1. Parent" - stopped)

```



#### **Detailed Comparison**



| Feature | preventDefault() | stopPropagation() |

|---------|------------------|-------------------|

| **Purpose** | Prevent default browser action | Stop event bubbling |

| **Affects** | Browser behavior | Event propagation |

| **Examples** | Form submit, link navigation | Parent event handlers |

| **Event flow** | Continues normally | Stops at current element |

| **Target** | Browser default action | Parent/ancestor handlers |

| **Use case** | Custom behavior instead of default | Isolate event handling |

| **Bubbling** | Continues | Stops |

| **Default action** | Prevented | Still happens |

| **Check if used** | `event.defaultPrevented` | No built-in check |



#### **Practical Examples**



**1. Form Validation:**

```javascript

const form = document.querySelector('form');



form.addEventListener('submit', function(event) {

  event.preventDefault();  // Prevent form submission

  

  const email = document.getElementById('email').value;

  

  if (!isValidEmail(email)) {

    showError('Invalid email address');

    return;

  }

  

  // Submit via AJAX

  submitForm(new FormData(form));

});



function isValidEmail(email) {

  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

}

```



**2. Custom Dropdown:**

```javascript

const dropdown = document.querySelector('.dropdown');

const dropdownButton = dropdown.querySelector('.dropdown-button');

const dropdownMenu = dropdown.querySelector('.dropdown-menu');



// Open dropdown - stop propagation to prevent document close handler

dropdownButton.addEventListener('click', function(event) {

  event.stopPropagation();  // Don't trigger document click

  dropdownMenu.classList.toggle('open');

});



// Keep dropdown open when clicking inside

dropdownMenu.addEventListener('click', function(event) {

  event.stopPropagation();  // Don't trigger document click

});



// Close dropdown when clicking outside

document.addEventListener('click', function() {

  dropdownMenu.classList.remove('open');

});



// Prevent default for links in dropdown

dropdownMenu.addEventListener('click', function(event) {

  if (event.target.tagName === 'A') {

    event.preventDefault();  // Prevent navigation

    const action = event.target.dataset.action;

    handleAction(action);

    dropdownMenu.classList.remove('open');

  }

});

```



**3. Drag and Drop:**

```javascript

const draggable = document.querySelector('.draggable');



draggable.addEventListener('dragstart', function(event) {

  event.dataTransfer.setData('text/plain', this.id);

  // No preventDefault here - we want default drag behavior

});



const dropzone = document.querySelector('.dropzone');



dropzone.addEventListener('dragover', function(event) {

  event.preventDefault();  // Required to allow drop

  this.classList.add('drag-over');

});



dropzone.addEventListener('drop', function(event) {

  event.preventDefault();  // Prevent default (open as link)

  event.stopPropagation();  // Don't bubble to parent dropzones

  

  this.classList.remove('drag-over');

  const id = event.dataTransfer.getData('text/plain');

  const element = document.getElementById(id);

  this.appendChild(element);

});

```



**4. Modal Dialog:**

```javascript

const modal = document.querySelector('.modal');

const modalContent = document.querySelector('.modal-content');

const closeButton = document.querySelector('.close-modal');



// Close modal when clicking overlay

modal.addEventListener('click', function(event) {

  // Close if clicked directly on modal (not content)

  if (event.target === modal) {

    closeModal();

  }

});



// Prevent modal content clicks from closing

modalContent.addEventListener('click', function(event) {

  event.stopPropagation();  // Don't bubble to modal overlay

});



// Close button prevents default if it's a link

closeButton.addEventListener('click', function(event) {

  event.preventDefault();  // If it's an <a> tag

  closeModal();

});



function closeModal() {

  modal.classList.remove('open');

}

```



**5. Nested Clickable Elements:**

```javascript

// Card with multiple interactive elements

const card = document.querySelector('.card');

const likeButton = card.querySelector('.like-button');

const shareButton = card.querySelector('.share-button');



// Clicking card opens details

card.addEventListener('click', function() {

  openCardDetails(this.dataset.id);

});



// Like button stops propagation to prevent card click

likeButton.addEventListener('click', function(event) {

  event.stopPropagation();  // Don't open card

  toggleLike(card.dataset.id);

});



// Share button stops propagation and might prevent default

shareButton.addEventListener('click', function(event) {

  event.preventDefault();      // If it's a link

  event.stopPropagation();     // Don't open card

  shareCard(card.dataset.id);

});

```



**6. Custom Context Menu:**

```javascript

document.addEventListener('contextmenu', function(event) {

  event.preventDefault();  // Prevent browser context menu

  

  showCustomContextMenu(event.pageX, event.pageY);

});



const customMenu = document.querySelector('.custom-context-menu');



// Prevent menu clicks from closing menu

customMenu.addEventListener('click', function(event) {

  event.stopPropagation();  // Don't trigger document click

  

  // Handle menu item clicks

  if (event.target.classList.contains('menu-item')) {

    const action = event.target.dataset.action;

    handleContextAction(action);

    hideCustomContextMenu();

  }

});



// Close menu when clicking elsewhere

document.addEventListener('click', function() {

  hideCustomContextMenu();

});

```



#### **Using Both Together**



```javascript

// Common pattern: prevent default AND stop propagation

const link = document.querySelector('.special-link');



link.addEventListener('click', function(event) {

  event.preventDefault();      // Don't follow link

  event.stopPropagation();     // Don't trigger parent handlers

  

  // Custom handling

  console.log('Special link clicked');

  customAction();

});



// Example: Button inside clickable card

const cardContainer = document.querySelector('.card-container');

const actionButton = document.querySelector('.action-button');



cardContainer.addEventListener('click', function() {

  console.log('Card clicked');

});



actionButton.addEventListener('click', function(event) {

  event.preventDefault();      // If it's a link/submit button

  event.stopPropagation();     // Don't trigger card click

  

  performAction();

});

```



#### **Checking if Default was Prevented**



```javascript

document.addEventListener('click', function(event) {

  if (event.defaultPrevented) {

    console.log('Default action was prevented');

    // React accordingly

  }

});



const link = document.querySelector('a');

link.addEventListener('click', function(event) {

  event.preventDefault();

});



link.addEventListener('click', function(event) {

  console.log(event.defaultPrevented);  // true

});

```



#### **stopImmediatePropagation()**



Stops propagation AND prevents other handlers on same element:



```javascript

const button = document.querySelector('button');



button.addEventListener('click', function(event) {

  console.log('First handler');

  event.stopImmediatePropagation();  // Stop everything

});



button.addEventListener('click', function() {

  console.log('Second handler - will NOT run');

});



// Parent won't receive event either

document.body.addEventListener('click', function() {

  console.log('Body handler - will NOT run');

});



// Only outputs: "First handler"

```



#### **Common Mistakes**



```javascript

// 1. Using stopPropagation when not needed

button.addEventListener('click', function(event) {

  event.stopPropagation();  // ❌ Might break event delegation

  // Only use if you specifically need to prevent bubbling

});



// 2. Forgetting to check if preventDefault is needed

link.addEventListener('click', function(event) {

  // ❌ Doesn't prevent navigation

  console.log('Link clicked');

  customAction();

});



// ✅ Prevent navigation

link.addEventListener('click', function(event) {

  event.preventDefault();

  console.log('Link clicked');

  customAction();

});



// 3. Calling on wrong event object

function handleClick(e) {

  // ❌ Wrong variable

  event.preventDefault();

  

  // ✅ Correct

  e.preventDefault();

}



// 4. Trying to prevent non-cancelable events

window.addEventListener('scroll', function(event) {

  event.preventDefault();  // ❌ Does nothing - scroll isn't cancelable

});



// 5. Not understanding they're independent

form.addEventListener('submit', function(event) {

  event.stopPropagation();  // ❌ Doesn't prevent form submission!

  // Form still submits because default wasn't prevented

});



// ✅ Correct

form.addEventListener('submit', function(event) {

  event.preventDefault();  // Prevents submission

});

```



#### **Key Takeaways**



- **preventDefault()** stops browser's default action

- **stopPropagation()** stops event bubbling to parents

- **Different purposes** - can be used independently

- **Often used together** in interactive elements

- **preventDefault()** affects browser behavior

- **stopPropagation()** affects event flow

- **Check defaultPrevented** property to see if preventDefault was called

- **stopImmediatePropagation()** stops everything

- **Don't overuse stopPropagation** - can break event delegation

- **Always use preventDefault** to prevent default actions

- **Use stopPropagation** only when needed

- **Both are methods** on the event object

- **Neither affects** the other's functionality

- Understanding both is **essential** for event handling

- **Common in** forms, links, modals, dropdowns



---



</details>
<details><summary>76. What is the difference between innerHTML and textContent?</summary>




**Answer:**



`innerHTML` gets or sets the HTML markup inside an element, parsing HTML tags and rendering them, while `textContent` gets or sets only the text content, treating everything as plain text. `innerHTML` can execute scripts and is vulnerable to XSS attacks if not sanitized, whereas `textContent` is safe from XSS.



#### **Basic Differences**



```javascript

const div = document.querySelector('div');



// innerHTML - parses HTML tags

div.innerHTML = '<strong>Bold</strong> text';

// Result: Bold text (strong tag is rendered)

console.log(div.innerHTML);  // "<strong>Bold</strong> text"



// textContent - treats everything as plain text

div.textContent = '<strong>Bold</strong> text';

// Result: <strong>Bold</strong> text (tags shown as text)

console.log(div.textContent);  // "<strong>Bold</strong> text"

```



#### **Getting Content**



```html

<div id="example">

  <p>Hello <strong>World</strong></p>

  <span style="display: none;">Hidden</span>

</div>

```



```javascript

const example = document.getElementById('example');



// innerHTML - returns HTML markup

console.log(example.innerHTML);

// Output: "\n  <p>Hello <strong>World</strong></p>\n  <span style="display: none;">Hidden</span>\n"



// textContent - returns all text (including hidden)

console.log(example.textContent);

// Output: "Hello World Hidden" (including hidden span)



// innerText - returns visible text only (respects CSS)

console.log(example.innerText);

// Output: "Hello World" (hidden span excluded)

```



#### **Setting Content**



```javascript

const container = document.getElementById('container');



// 1. innerHTML - creates DOM elements

container.innerHTML = `

  <h2>Title</h2>

  <p>Paragraph text</p>

  <button>Click Me</button>

`;

// Creates actual HTML elements



// 2. textContent - escapes HTML

container.textContent = `

  <h2>Title</h2>

  <p>Paragraph text</p>

`;

// Shows literal text: "<h2>Title</h2><p>Paragraph text</p>"



// 3. Appending vs replacing

container.innerHTML += '<p>Added paragraph</p>';  // Adds to existing

container.textContent += 'Added text';  // Replaces all with text

```



#### **Security: XSS Vulnerability**



```javascript

// ❌ DANGEROUS with innerHTML (XSS vulnerability)

const userInput = '<img src=x onerror="alert(\'XSS Attack!\')">';

div.innerHTML = userInput;  // Script executes! ⚠️



// ✅ SAFE with textContent

div.textContent = userInput;

// Shows literal text: <img src=x onerror="alert('XSS Attack!')">



// ❌ DANGEROUS: User-generated content with innerHTML

function displayComment(comment) {

  const commentDiv = document.getElementById('comments');

  commentDiv.innerHTML = comment;  // ⚠️ User can inject scripts!

}



displayComment('<script>stealCookies()</script>');  // Executes!



// ✅ SAFE: User-generated content with textContent

function displayCommentSafe(comment) {

  const commentDiv = document.getElementById('comments');

  commentDiv.textContent = comment;  // Safe - no script execution

}



displayCommentSafe('<script>stealCookies()</script>');  // Shows as text



// ✅ SAFE: Sanitize if you must use innerHTML

function displayCommentSanitized(comment) {

  const commentDiv = document.getElementById('comments');

  commentDiv.innerHTML = DOMPurify.sanitize(comment);  // Use library

}

```



#### **Performance Comparison**



```javascript

const container = document.getElementById('container');



// innerHTML - slower (parses HTML, creates DOM)

console.time('innerHTML');

container.innerHTML = 'Simple text';

console.timeEnd('innerHTML');  // Slower



// textContent - faster (just sets text)

console.time('textContent');

container.textContent = 'Simple text';

console.timeEnd('textContent');  // Faster



// Performance difference with large content

const largeText = 'Text '.repeat(1000);



console.time('innerHTML large');

container.innerHTML = largeText;

console.timeEnd('innerHTML large');  // Much slower



console.time('textContent large');

container.textContent = largeText;

console.timeEnd('textContent large');  // Much faster

```



#### **Detailed Comparison Table**



| Feature | innerHTML | textContent | innerText |

|---------|-----------|-------------|-----------|

| **Content type** | HTML markup | Plain text | Visible text |

| **HTML parsing** | Yes | No | No |

| **Script execution** | Yes ⚠️ | No ✅ | No ✅ |

| **XSS risk** | High ⚠️ | None ✅ | None ✅ |

| **Performance** | Slower | Faster | Slower (triggers reflow) |

| **Hidden elements** | Included | Included | Excluded (respects CSS) |

| **Whitespace** | Preserved (in HTML) | All included | Collapsed |

| **Returns** | HTML string | All text | Rendered text |

| **Sets** | Parses HTML | Escapes HTML | Escapes HTML |

| **Use case** | Rendering HTML | Safe text display | User-visible text |

| **Browser support** | All | All | All (IE9+) |



#### **Practical Examples**



**1. Displaying User-Generated Content:**

```javascript

// ❌ NEVER do this with user input

function displayUserComment(comment) {

  document.getElementById('comment').innerHTML = comment;

  // User can inject: <img src=x onerror="alert('XSS')">

}



// ✅ SAFE: Use textContent

function displayUserCommentSafe(comment) {

  document.getElementById('comment').textContent = comment;

  // All HTML is escaped and shown as plain text

}



// ✅ SAFE: Create elements programmatically

function displayUserCommentBest(comment) {

  const commentDiv = document.getElementById('comment');

  commentDiv.textContent = '';  // Clear

  

  const p = document.createElement('p');

  p.textContent = comment;  // Safe

  commentDiv.appendChild(p);

}

```



**2. Template Rendering:**

```javascript

// innerHTML for trusted templates

function renderProduct(product) {

  const container = document.getElementById('product');

  

  // ✅ Safe: trusted template

  container.innerHTML = `

    <div class="product-card">

      <img src="${escapeHtml(product.image)}" alt="Product">

      <h3>${escapeHtml(product.name)}</h3>

      <p>${escapeHtml(product.description)}</p>

      <span class="price">$${product.price}</span>

    </div>

  `;

}



// Helper to escape HTML in data

function escapeHtml(text) {

  const div = document.createElement('div');

  div.textContent = text;

  return div.innerHTML;

}

```



**3. Clearing Content:**

```javascript

const container = document.getElementById('container');



// Both work for clearing

container.innerHTML = '';   // Clears all HTML

container.textContent = '';  // Clears all text (slightly faster)



// Performance comparison for clearing

console.time('Clear with innerHTML');

container.innerHTML = '';

console.timeEnd('Clear with innerHTML');



console.time('Clear with textContent');

container.textContent = '';

console.timeEnd('Clear with textContent');  // Usually faster

```



**4. Extracting Text:**

```javascript

const article = document.querySelector('article');



// Get all text including hidden elements

const allText = article.textContent;

console.log(allText);  // Includes hidden content



// Get only visible text

const visibleText = article.innerText;

console.log(visibleText);  // Only visible content



// Get HTML structure

const htmlContent = article.innerHTML;

console.log(htmlContent);  // HTML markup

```



**5. Building Lists:**

```javascript

const list = document.getElementById('list');



// ❌ Inefficient with innerHTML (recreates all elements)

function addItemsInefficient(items) {

  items.forEach(item => {

    list.innerHTML += `<li>${item}</li>`;  // Recreates entire list each time!

  });

}



// ✅ Better: Build string then set once

function addItemsBetter(items) {

  const html = items.map(item => `<li>${escapeHtml(item)}</li>`).join('');

  list.innerHTML = html;  // Set once

}



// ✅ Best: Use textContent with createElement

function addItemsBest(items) {

  const fragment = document.createDocumentFragment();

  items.forEach(item => {

    const li = document.createElement('li');

    li.textContent = item;  // Safe from XSS

    fragment.appendChild(li);

  });

  list.appendChild(fragment);

}

```



**6. Form Feedback:**

```javascript

const errorMessage = document.getElementById('error');



// Safe to use textContent for simple messages

function showError(message) {

  errorMessage.textContent = message;

  errorMessage.classList.add('visible');

}



// If you need formatting, use innerHTML with caution

function showFormattedError(message) {

  // ✅ Safe: trusted content only

  errorMessage.innerHTML = `

    <span class="icon">⚠️</span>

    <span class="message">${escapeHtml(message)}</span>

  `;

  errorMessage.classList.add('visible');

}

```



#### **innerText vs textContent**



```html

<div id="example">

  Hello <span style="display: none;">Hidden</span> World

  <style>body { color: black; }</style>

</div>

```



```javascript

const example = document.getElementById('example');



// textContent - returns ALL text (including hidden and <style>)

console.log(example.textContent);

// "Hello Hidden World body { color: black; }"



// innerText - returns only VISIBLE text

console.log(example.innerText);

// "Hello World"



// innerText is slower (triggers reflow to check visibility)

console.time('textContent');

for (let i = 0; i < 1000; i++) {

  const text = example.textContent;

}

console.timeEnd('textContent');  // Faster



console.time('innerText');

for (let i = 0; i < 1000; i++) {

  const text = example.innerText;

}

console.timeEnd('innerText');  // Slower

```



#### **When to Use Each**



**Use innerHTML when:**

- Rendering trusted HTML templates

- Need to create multiple elements at once

- Working with HTML from your own code

- Building complex DOM structures

- Content is sanitized or from trusted source



**Use textContent when:**

- Displaying user-generated content

- Security is a concern

- Only need plain text

- Performance matters

- Want to prevent any HTML rendering



**Use innerText when:**

- Need only visible text (respect CSS)

- Extracting display text

- Don't need hidden content

- Matching user perception of content



```javascript

// ✅ innerHTML: Trusted template

productDiv.innerHTML = `<h3>${safeName}</h3><p>${safeDesc}</p>`;



// ✅ textContent: User input

commentDiv.textContent = userComment;  // Safe from XSS



// ✅ innerText: Copy visible text

copyButton.addEventListener('click', () => {

  navigator.clipboard.writeText(article.innerText);

});

```



#### **Common Pitfalls**



```javascript

// 1. Using innerHTML with user input

// ❌ DANGEROUS

userDiv.innerHTML = userInput;  // XSS vulnerability!



// 2. Slow innerHTML appending

// ❌ Inefficient

for (let i = 0; i < 1000; i++) {

  list.innerHTML += `<li>Item ${i}</li>`;  // Recreates DOM 1000 times!

}



// 3. Not escaping data in templates

// ❌ VULNERABLE

div.innerHTML = `<p>${userData}</p>`;  // userData could contain scripts



// ✅ Escape user data

div.innerHTML = `<p>${escapeHtml(userData)}</p>`;



// 4. Using innerText when textContent is sufficient

// ❌ Slower

const text = element.innerText;  // Triggers reflow



// ✅ Faster

const text = element.textContent;  // No reflow



// 5. Forgetting innerHTML replaces all content

div.innerHTML = '<p>New content</p>';  // Removes all existing content

```



#### **Key Takeaways**



- **innerHTML** parses HTML, **textContent** treats as plain text

- **textContent** is **safer** - no XSS risk

- **innerHTML** can execute scripts - **never use with user input**

- **textContent** is **faster** for plain text

- **innerText** respects CSS visibility

- **innerHTML** useful for trusted templates

- **Always escape user data** before using in innerHTML

- **textContent** is preferred for security

- **innerHTML** replaces all existing content

- **textContent** includes hidden elements

- **innerText** triggers reflow (slower)

- Use **DOMPurify** or similar for sanitizing innerHTML

- **createElement + textContent** safest for dynamic content

- **Performance**: textContent > innerHTML for plain text

- **Security**: textContent > innerHTML for user content





</details>
<details><summary>74. What is event delegation?</summary>






</details>
<details><summary>75. What is the difference between event.preventDefault() and event.stopPropagation()?</summary>






</details>
<details><summary>76. What is the difference between innerHTML and textContent?</summary>






---



</details>
<details><summary>77. What is the difference between window and document?</summary>




**Answer:**



`window` is the global object representing the browser window and provides access to browser features (timers, location, history, localStorage), while `document` is a property of `window` representing the HTML document and providing access to the DOM tree. The window is the container; the document is the content inside it.



#### **Basic Relationship**



```javascript

// document is a property of window

console.log(window.document === document);  // true



// In global scope, 'document' is actually 'window.document'

console.log(document);         // Document object

console.log(window.document);  // Same Document object



// window is the global object

console.log(window.window === window);  // true

console.log(this === window);           // true (in global scope, non-strict)



// Global variables become properties of window

var globalVar = 'test';

console.log(window.globalVar);  // 'test'



// But document is not global in the same way

var document = 'test';  // ❌ Bad idea - shadows window.document

```



#### **Hierarchy**



```javascript

// Browser Object Model (BOM) hierarchy

// window (Browser Window)

//   ├─ document (HTML Document)

//   ├─ navigator (Browser info)

//   ├─ location (URL info)

//   ├─ history (Browser history)

//   ├─ screen (Screen properties)

//   ├─ localStorage (Storage)

//   └─ sessionStorage (Storage)



// document is part of window

console.log(window.document);        // Document

console.log(window.navigator);       // Navigator

console.log(window.location);        // Location



// document contains the DOM

console.log(document.documentElement);  // <html>

console.log(document.body);             // <body>

console.log(document.head);             // <head>

```



#### **Window Object Properties and Methods**



```javascript

// BROWSER WINDOW PROPERTIES

console.log(window.innerWidth);    // Viewport width (px)

console.log(window.innerHeight);   // Viewport height (px)

console.log(window.outerWidth);    // Browser window width

console.log(window.outerHeight);   // Browser window height



// BROWSER INFORMATION

console.log(window.navigator.userAgent);   // Browser/OS info

console.log(window.navigator.language);    // 'en-US'

console.log(window.navigator.onLine);      // true/false



// URL AND NAVIGATION

console.log(window.location.href);         // Full URL

console.log(window.location.hostname);     // 'example.com'

console.log(window.location.pathname);     // '/path/to/page'

window.location.href = 'https://google.com';  // Navigate



// HISTORY

window.history.back();                     // Go back

window.history.forward();                  // Go forward

window.history.go(-2);                     // Go back 2 pages



// SCREEN

console.log(window.screen.width);          // Screen width

console.log(window.screen.height);         // Screen height

console.log(window.screen.availWidth);     // Available width

console.log(window.screen.colorDepth);     // Color depth



// STORAGE

window.localStorage.setItem('key', 'value');

window.sessionStorage.setItem('key', 'value');



// TIMERS

const timeoutId = window.setTimeout(() => {

  console.log('Delayed');

}, 1000);



const intervalId = window.setInterval(() => {

  console.log('Repeating');

}, 1000);



window.clearTimeout(timeoutId);

window.clearInterval(intervalId);



// DIALOGS

window.alert('Alert message');

const confirmed = window.confirm('Are you sure?');

const userInput = window.prompt('Enter name:', 'Default');



// WINDOW CONTROL

window.open('https://google.com', '_blank');  // Open new window

window.close();                                // Close window

window.focus();                                // Focus window

window.blur();                                 // Unfocus window



// SCROLLING

window.scrollTo(0, 500);                       // Scroll to position

window.scrollBy(0, 100);                       // Scroll by amount

window.scroll(0, 0);                           // Scroll to top



// REQUEST ANIMATION FRAME

window.requestAnimationFrame(callback);

window.cancelAnimationFrame(id);



// FETCH API

window.fetch('https://api.example.com/data')

  .then(response => response.json())

  .then(data => console.log(data));

```



#### **Document Object Properties and Methods**



```javascript

// DOCUMENT PROPERTIES

console.log(document.title);              // Page title

console.log(document.URL);                // Document URL

console.log(document.domain);             // Domain name

console.log(document.referrer);           // Referring URL

console.log(document.lastModified);       // Last modified date

console.log(document.readyState);         // 'loading', 'interactive', 'complete'

console.log(document.characterSet);       // 'UTF-8'



// DOM TREE ACCESS

console.log(document.documentElement);    // <html> element

console.log(document.head);               // <head> element

console.log(document.body);               // <body> element



// SELECTING ELEMENTS

const el1 = document.getElementById('id');

const el2 = document.querySelector('.class');

const els = document.querySelectorAll('div');

const byClass = document.getElementsByClassName('class');

const byTag = document.getElementsByTagName('p');



// CREATING ELEMENTS

const div = document.createElement('div');

const text = document.createTextNode('Text');

const fragment = document.createDocumentFragment();

const comment = document.createComment('Comment');



// DOCUMENT MANIPULATION

document.title = 'New Title';             // Change title

document.body.style.background = 'blue';  // Style body



// FORMS

console.log(document.forms);              // All forms

console.log(document.images);             // All images

console.log(document.links);              // All links

console.log(document.scripts);            // All scripts



// DOCUMENT EVENTS

document.addEventListener('DOMContentLoaded', () => {

  console.log('DOM ready');

});



document.addEventListener('click', (e) => {

  console.log('Document clicked');

});



// COOKIES

document.cookie = 'name=value';

console.log(document.cookie);             // All cookies as string



// ACTIVE ELEMENT

console.log(document.activeElement);      // Currently focused element

```



#### **Comparison Table**



| Feature | window | document |

|---------|--------|----------|

| **Type** | Global object (BOM) | DOM object |

| **Represents** | Browser window | HTML document |

| **Scope** | Entire browser window | Document content only |

| **Parent** | Top-level global object | Property of window |

| **Access** | `window` or implicit | `document` or `window.document` |

| **Purpose** | Browser features/control | DOM manipulation |

| **Properties** | innerWidth, location, history | body, title, forms |

| **Methods** | setTimeout, alert, fetch | getElementById, createElement |

| **Events** | resize, scroll, load | DOMContentLoaded, click |

| **Global vars** | Attached here | Not attached |

| **Exists when** | Browser window open | Document loaded |



#### **Practical Examples**



**1. Window Events vs Document Events:**

```javascript

// Window events (browser-level)

window.addEventListener('resize', () => {

  console.log('Window resized:', window.innerWidth);

});



window.addEventListener('scroll', () => {

  console.log('Window scrolled:', window.scrollY);

});



window.addEventListener('load', () => {

  console.log('Everything loaded (images, CSS, etc.)');

});



// Document events (content-level)

document.addEventListener('DOMContentLoaded', () => {

  console.log('DOM ready (HTML parsed, scripts executed)');

  // Safe to manipulate DOM here

});



document.addEventListener('click', (e) => {

  console.log('Clicked on:', e.target);

});



document.addEventListener('keydown', (e) => {

  console.log('Key pressed:', e.key);

});

```



**2. Page Information:**

```javascript

// Using window for browser info

function getBrowserInfo() {

  return {

    windowSize: {

      width: window.innerWidth,

      height: window.innerHeight

    },

    screen: {

      width: window.screen.width,

      height: window.screen.height

    },

    url: window.location.href,

    userAgent: window.navigator.userAgent,

    online: window.navigator.onLine

  };

}



// Using document for content info

function getDocumentInfo() {

  return {

    title: document.title,

    url: document.URL,

    domain: document.domain,

    lastModified: document.lastModified,

    readyState: document.readyState,

    elementCount: document.querySelectorAll('*').length,

    images: document.images.length,

    links: document.links.length,

    forms: document.forms.length

  };

}



console.log(getBrowserInfo());

console.log(getDocumentInfo());

```



**3. Responsive Design:**

```javascript

// window for viewport dimensions

function checkViewport() {

  const width = window.innerWidth;

  

  if (width < 768) {

    console.log('Mobile view');

    document.body.classList.add('mobile');

  } else if (width < 1024) {

    console.log('Tablet view');

    document.body.classList.add('tablet');

  } else {

    console.log('Desktop view');

    document.body.classList.add('desktop');

  }

}



window.addEventListener('resize', checkViewport);

checkViewport();  // Initial check



// document for DOM manipulation

function adjustContent() {

  const isMobile = document.body.classList.contains('mobile');

  const nav = document.querySelector('.navigation');

  

  if (isMobile) {

    nav.classList.add('mobile-nav');

  } else {

    nav.classList.remove('mobile-nav');

  }

}

```



**4. Scroll Position:**

```javascript

// window for scroll position

function getScrollPosition() {

  return {

    x: window.scrollX || window.pageXOffset,  // Horizontal scroll

    y: window.scrollY || window.pageYOffset   // Vertical scroll

  };

}



// Scroll to top button

const scrollTopBtn = document.getElementById('scroll-top');



window.addEventListener('scroll', () => {

  const scrollPos = getScrollPosition();

  

  if (scrollPos.y > 300) {

    scrollTopBtn.style.display = 'block';

  } else {

    scrollTopBtn.style.display = 'none';

  }

});



scrollTopBtn.addEventListener('click', () => {

  window.scrollTo({

    top: 0,

    behavior: 'smooth'

  });

});

```



**5. Page Navigation:**

```javascript

// window.location for navigation

function navigateTo(url) {

  window.location.href = url;  // Navigate to URL

}



function reloadPage() {

  window.location.reload();    // Reload page

}



function goBack() {

  window.history.back();       // Go back in history

}



// document for internal navigation

function scrollToElement(id) {

  const element = document.getElementById(id);

  if (element) {

    element.scrollIntoView({ behavior: 'smooth' });

  }

}



// Hash navigation

window.addEventListener('hashchange', () => {

  const hash = window.location.hash.slice(1);  // Remove #

  const element = document.getElementById(hash);

  if (element) {

    element.scrollIntoView();

  }

});

```



**6. Fullscreen API:**

```javascript

// window for browser control

function toggleFullscreen() {

  if (!document.fullscreenElement) {

    // Enter fullscreen - use document method

    document.documentElement.requestFullscreen();

  } else {

    // Exit fullscreen - use document method

    document.exitFullscreen();

  }

}



// Listen on document for fullscreen events

document.addEventListener('fullscreenchange', () => {

  if (document.fullscreenElement) {

    console.log('Entered fullscreen');

  } else {

    console.log('Exited fullscreen');

  }

});



const fullscreenBtn = document.getElementById('fullscreen-btn');

fullscreenBtn.addEventListener('click', toggleFullscreen);

```



**7. Storage and Cookies:**

```javascript

// window for storage (persistent)

function saveToStorage(key, value) {

  window.localStorage.setItem(key, value);

}



function getFromStorage(key) {

  return window.localStorage.getItem(key);

}



// document for cookies (sent to server)

function setCookie(name, value, days) {

  const date = new Date();

  date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

  document.cookie = `${name}=${value};expires=${date.toUTCString()};path=/`;

}



function getCookie(name) {

  const cookies = document.cookie.split(';');

  for (let cookie of cookies) {

    const [key, value] = cookie.trim().split('=');

    if (key === name) return value;

  }

  return null;

}



// Usage

saveToStorage('theme', 'dark');

console.log(getFromStorage('theme'));  // 'dark'



setCookie('user', 'john', 7);

console.log(getCookie('user'));        // 'john'

```



**8. Modal with Window Dimensions:**

```javascript

// Use window for sizing, document for DOM

function centerModal() {

  const modal = document.getElementById('modal');

  const modalWidth = modal.offsetWidth;

  const modalHeight = modal.offsetHeight;

  

  // Use window dimensions to center

  const left = (window.innerWidth - modalWidth) / 2;

  const top = (window.innerHeight - modalHeight) / 2;

  

  modal.style.left = left + 'px';

  modal.style.top = top + 'px';

}



function showModal() {

  const modal = document.getElementById('modal');

  modal.style.display = 'block';

  centerModal();

}



// Recenter on window resize

window.addEventListener('resize', () => {

  const modal = document.getElementById('modal');

  if (modal.style.display === 'block') {

    centerModal();

  }

});

```



#### **Global Scope Differences**



```javascript

// window is the global object

var globalVar = 'test';

console.log(window.globalVar);  // 'test'



function globalFunc() {

  return 'function';

}

console.log(window.globalFunc());  // 'function'



// let/const are not added to window

let letVar = 'test';

const constVar = 'test';

console.log(window.letVar);     // undefined

console.log(window.constVar);   // undefined



// document is a property of window, not a scope

document.customProp = 'value';  // Can add properties

console.log(document.customProp);  // 'value'

console.log(window.document.customProp);  // 'value'

```



#### **Timing Differences**



```javascript

// window.onload - fires when everything is loaded

window.onload = function() {

  console.log('Window loaded (images, CSS, scripts)');

  // All resources loaded

};



// Or with addEventListener

window.addEventListener('load', () => {

  console.log('Everything loaded');

});



// document.DOMContentLoaded - fires when DOM is ready

document.addEventListener('DOMContentLoaded', () => {

  console.log('DOM ready (HTML parsed)');

  // DOM can be manipulated, but images may not be loaded

});



// Typical execution order:

// 1. DOMContentLoaded (DOM ready)

// 2. load (everything ready)

```



#### **Common Use Cases**



```javascript

// USE WINDOW FOR:

// - Browser dimensions

const width = window.innerWidth;



// - Timers

window.setTimeout(() => {}, 1000);



// - Navigation

window.location.href = '/page';



// - Browser info

const userAgent = window.navigator.userAgent;



// - Storage

window.localStorage.setItem('key', 'value');



// - Global functions

window.alert('Message');



// - AJAX/Fetch

window.fetch('/api/data');



// USE DOCUMENT FOR:

// - DOM access

const element = document.getElementById('id');



// - DOM creation

const div = document.createElement('div');



// - Document info

const title = document.title;



// - Cookies

document.cookie = 'name=value';



// - Active element

const focused = document.activeElement;



// - Forms/images

const forms = document.forms;



// - Document events

document.addEventListener('click', handler);

```



#### **Common Mistakes**



```javascript

// 1. Confusing window.onload with DOMContentLoaded

// ❌ Waiting too long

window.onload = function() {

  // Waits for all images/resources

  const element = document.getElementById('id');

};



// ✅ Use DOMContentLoaded for DOM manipulation

document.addEventListener('DOMContentLoaded', () => {

  // DOM ready, can manipulate immediately

  const element = document.getElementById('id');

});



// 2. Accessing document before it's ready

console.log(document.body);  // null if script in <head>



// ✅ Wait for DOM

document.addEventListener('DOMContentLoaded', () => {

  console.log(document.body);  // Now available

});



// 3. Using window methods on document

// ❌ Wrong

document.setTimeout(() => {}, 1000);  // TypeError



// ✅ Correct

window.setTimeout(() => {}, 1000);

setTimeout(() => {}, 1000);  // window is implicit



// 4. Trying to select elements from window

// ❌ Wrong

const el = window.getElementById('id');  // TypeError



// ✅ Correct

const el = document.getElementById('id');



// 5. Confusing window events with document events

// Window resize

window.addEventListener('resize', handler);  // ✅

document.addEventListener('resize', handler); // ❌ Won't work



// Document clicks

document.addEventListener('click', handler);  // ✅

window.addEventListener('click', handler);    // ✅ Also works (bubbles up)

```



#### **Modern API Considerations**



```javascript

// Some APIs are on window

console.log(window.fetch);            // Function

console.log(window.localStorage);     // Storage

console.log(window.sessionStorage);   // Storage

console.log(window.requestAnimationFrame);  // Function



// Some are on document

console.log(document.getElementById);      // Function

console.log(document.querySelector);       // Function

console.log(document.createElement);       // Function

console.log(document.cookie);             // String



// Some are on both (but behave differently)

window.addEventListener('load', handler);      // Window load

document.addEventListener('DOMContentLoaded', handler);  // DOM ready



// Console is typically on window

console.log(window.console === console);  // true

```



#### **Key Takeaways**



- **window** is the global browser object (BOM)

- **document** is a property of window (DOM)

- **window** represents the browser window itself

- **document** represents the HTML document content

- **Use window** for browser features (timers, navigation, storage)

- **Use document** for DOM manipulation (elements, content)

- **window is global** - all global variables attached here

- **document is not global** - it's a window property

- **window events**: resize, scroll, load

- **document events**: DOMContentLoaded, click, keydown

- **window.onload** fires after everything loads

- **DOMContentLoaded** fires when DOM is ready

- **document is part of window** (`window.document === document`)

- Both are **essential** for web development

- Understanding the difference enables **proper API usage**



---



</details>
<details><summary>78. What are different ways to select DOM elements?</summary>




**Answer:**



JavaScript provides multiple methods for selecting DOM elements, ranging from traditional methods like `getElementById()` to modern CSS-selector-based methods like `querySelector()` and `querySelectorAll()`. Each method has different use cases, performance characteristics, and return types.



#### **1. getElementById()**



Returns a single element with the specified ID (or null if not found):



```javascript

// HTML: <div id="header">Header</div>

const header = document.getElementById('header');

console.log(header);  // <div id="header">...</div>



// Case-sensitive

const el1 = document.getElementById('Header');  // null (wrong case)

const el2 = document.getElementById('header');  // Found



// Returns null if not found

const notFound = document.getElementById('nonexistent');

console.log(notFound);  // null



// Fastest selection method

// Only works on document, not on elements

const wrong = header.getElementById('other');  // TypeError

```



#### **2. getElementsByClassName()**



Returns a live HTMLCollection of elements with the specified class:



```javascript

// HTML: <div class="card">Card 1</div>

//       <div class="card">Card 2</div>

const cards = document.getElementsByClassName('card');

console.log(cards);  // HTMLCollection(2) [div.card, div.card]



// Access by index

console.log(cards[0]);  // First card

console.log(cards[1]);  // Second card



// Length property

console.log(cards.length);  // 2



// Live collection - updates automatically

console.log(cards.length);  // 2

const newCard = document.createElement('div');

newCard.className = 'card';

document.body.appendChild(newCard);

console.log(cards.length);  // 3 (automatically updated)



// Multiple classes (space-separated)

const special = document.getElementsByClassName('card special');



// Can be called on elements

const container = document.getElementById('container');

const containerCards = container.getElementsByClassName('card');



// Convert to array for array methods

const cardsArray = Array.from(cards);

cardsArray.forEach(card => console.log(card));

```



#### **3. getElementsByTagName()**



Returns a live HTMLCollection of elements with the specified tag name:



```javascript

// Get all paragraphs

const paragraphs = document.getElementsByTagName('p');

console.log(paragraphs);  // HTMLCollection of <p> elements



// Get all divs

const divs = document.getElementsByTagName('div');



// Get all links

const links = document.getElementsByTagName('a');



// Case-insensitive

const P = document.getElementsByTagName('P');  // Works

const p = document.getElementsByTagName('p');  // Same result



// Get all elements with '*'

const allElements = document.getElementsByTagName('*');

console.log(allElements.length);  // Total element count



// Live collection

console.log(divs.length);  // e.g., 5

const newDiv = document.createElement('div');

document.body.appendChild(newDiv);

console.log(divs.length);  // 6 (updated)



// Can be called on elements

const container = document.getElementById('container');

const containerDivs = container.getElementsByTagName('div');

```



#### **4. querySelector()**



Returns the first element matching a CSS selector (or null):



```javascript

// By ID (like getElementById, but with CSS selector)

const header = document.querySelector('#header');



// By class

const card = document.querySelector('.card');  // First .card



// By tag

const paragraph = document.querySelector('p');  // First <p>



// Complex selectors

const firstLink = document.querySelector('div a');  // First <a> inside <div>

const navLink = document.querySelector('.nav > a');  // Direct child

const activeItem = document.querySelector('.item.active');  // Multiple classes

const emailInput = document.querySelector('input[type="email"]');  // Attribute



// Pseudo-classes

const firstChild = document.querySelector('li:first-child');

const lastChild = document.querySelector('li:last-child');

const nthChild = document.querySelector('li:nth-child(3)');

const checked = document.querySelector('input:checked');

const disabled = document.querySelector('button:disabled');



// Returns null if not found

const notFound = document.querySelector('.nonexistent');

console.log(notFound);  // null



// Can be called on elements (scoped selection)

const container = document.querySelector('.container');

const cardInContainer = container.querySelector('.card');



// Combining selectors

const complex = document.querySelector('div.card:not(.disabled) > h2');

```



#### **5. querySelectorAll()**



Returns a static NodeList of all matching elements:



```javascript

// Get all elements with a class

const cards = document.querySelectorAll('.card');

console.log(cards);  // NodeList(2) [div.card, div.card]



// Access by index

console.log(cards[0]);

console.log(cards[1]);



// Length

console.log(cards.length);



// Static collection - does NOT update

console.log(cards.length);  // 2

const newCard = document.createElement('div');

newCard.className = 'card';

document.body.appendChild(newCard);

console.log(cards.length);  // Still 2 (not updated)



// forEach (NodeList has forEach)

cards.forEach(card => {

  console.log(card.textContent);

});



// Array methods (convert first)

const cardsArray = Array.from(cards);

const mapped = cardsArray.map(card => card.textContent);



// Or spread operator

const cardsArray2 = [...cards];



// Complex selectors

const links = document.querySelectorAll('nav a');

const activeItems = document.querySelectorAll('.item.active');

const inputs = document.querySelectorAll('input[type="text"]');

const visibleCards = document.querySelectorAll('.card:not(.hidden)');



// Returns empty NodeList if none found

const none = document.querySelectorAll('.nonexistent');

console.log(none);  // NodeList(0) []

console.log(none.length);  // 0



// Can be called on elements

const container = document.querySelector('.container');

const cardsInContainer = container.querySelectorAll('.card');

```



#### **6. getElementsByName()**



Returns a live NodeList of elements with the specified name attribute:



```javascript

// HTML: <input name="email" />

//       <input name="email" />

const emailInputs = document.getElementsByName('email');

console.log(emailInputs);  // NodeList(2)



// Commonly used for radio buttons

// HTML: <input type="radio" name="gender" value="male">

//       <input type="radio" name="gender" value="female">

const genderRadios = document.getElementsByName('gender');



// Find checked radio

const checked = Array.from(genderRadios).find(radio => radio.checked);

console.log(checked?.value);  // 'male' or 'female'



// Live NodeList

console.log(genderRadios.length);  // 2

```



#### **7. Special Selectors**



```javascript

// document.body - <body> element

const body = document.body;



// document.head - <head> element

const head = document.head;



// document.documentElement - <html> element

const html = document.documentElement;



// document.forms - All forms (HTMLCollection)

const forms = document.forms;

console.log(forms[0]);        // First form

console.log(forms['myForm']); // Form with name="myForm"



// document.images - All images

const images = document.images;



// document.links - All <a> with href

const links = document.links;



// document.scripts - All scripts

const scripts = document.scripts;



// document.activeElement - Currently focused element

const focused = document.activeElement;

console.log(focused.tagName);  // e.g., 'INPUT'

```



#### **8. Modern Methods**



```javascript

// closest() - find nearest ancestor matching selector

const button = document.querySelector('.delete-btn');

const card = button.closest('.card');  // Nearest .card ancestor

const container = button.closest('#container');



// matches() - check if element matches selector

const element = document.querySelector('.item');

console.log(element.matches('.item'));      // true

console.log(element.matches('.active'));    // false



if (element.matches('.active')) {

  console.log('Element is active');

}



// Element relationships

const parent = element.parentElement;           // Parent element

const children = element.children;              // Child elements (HTMLCollection)

const firstChild = element.firstElementChild;   // First child element

const lastChild = element.lastElementChild;     // Last child element

const nextSibling = element.nextElementSibling; // Next sibling

const prevSibling = element.previousElementSibling;  // Previous sibling

```



#### **Comparison Table**



| Method | Returns | Live/Static | CSS Selectors | Performance | Use Case |

|--------|---------|-------------|---------------|-------------|----------|

| **getElementById** | Element or null | N/A | No | Fastest | Single element by ID |

| **getElementsByClassName** | HTMLCollection | Live | No | Fast | Multiple by class |

| **getElementsByTagName** | HTMLCollection | Live | No | Fast | Multiple by tag |

| **querySelector** | Element or null | N/A | Yes | Moderate | First match, complex selector |

| **querySelectorAll** | NodeList | Static | Yes | Slower | All matches, complex selector |

| **getElementsByName** | NodeList | Live | No | Fast | By name attribute |



#### **Practical Examples**



**1. Form Validation:**

```javascript

// Select form and inputs

const form = document.querySelector('#registration-form');

const emailInput = form.querySelector('input[name="email"]');

const passwordInput = form.querySelector('input[type="password"]');

const submitButton = form.querySelector('button[type="submit"]');



// All required fields

const requiredFields = form.querySelectorAll('[required]');



requiredFields.forEach(field => {

  field.addEventListener('blur', () => {

    if (!field.value.trim()) {

      field.classList.add('error');

    }

  });

});

```



**2. Navigation Menu:**

```javascript

// Select navigation elements

const nav = document.querySelector('.navigation');

const navLinks = nav.querySelectorAll('a');

const activeLink = nav.querySelector('a.active');

const dropdowns = nav.querySelectorAll('.has-dropdown');



// Add event listeners

navLinks.forEach(link => {

  link.addEventListener('click', function(e) {

    // Remove active from all

    navLinks.forEach(l => l.classList.remove('active'));

    // Add to clicked

    this.classList.add('active');

  });

});

```



**3. Image Gallery:**

```javascript

// Select gallery elements

const gallery = document.getElementById('gallery');

const thumbnails = gallery.querySelectorAll('.thumbnail');

const lightbox = document.querySelector('.lightbox');

const lightboxImage = lightbox.querySelector('img');

const closeButton = lightbox.querySelector('.close');



thumbnails.forEach(thumb => {

  thumb.addEventListener('click', () => {

    const fullSrc = thumb.dataset.fullsize;

    lightboxImage.src = fullSrc;

    lightbox.classList.add('open');

  });

});

```



**4. Todo List:**

```javascript

// Select todo elements

const todoList = document.getElementById('todo-list');

const todoItems = todoList.querySelectorAll('.todo-item');

const addButton = document.querySelector('#add-todo');

const inputField = document.querySelector('#todo-input');



// Select by state

const completedTodos = todoList.querySelectorAll('.todo-item.completed');

const activeTodos = todoList.querySelectorAll('.todo-item:not(.completed)');



console.log(`Active: ${activeTodos.length}, Completed: ${completedTodos.length}`);

```



**5. Table Operations:**

```javascript

// Select table elements

const table = document.querySelector('.data-table');

const headers = table.querySelectorAll('thead th');

const rows = table.querySelectorAll('tbody tr');

const cells = table.querySelectorAll('tbody td');



// Select specific rows

const evenRows = table.querySelectorAll('tbody tr:nth-child(even)');

const oddRows = table.querySelectorAll('tbody tr:nth-child(odd)');



// Add zebra striping

evenRows.forEach(row => row.classList.add('even'));

oddRows.forEach(row => row.classList.add('odd'));



// Select by data attribute

const highPriorityRows = table.querySelectorAll('tr[data-priority="high"]');

```



**6. Dynamic Content:**

```javascript

// Select container

const container = document.getElementById('content');



// Add content dynamically

function addCard(title, content) {

  const card = document.createElement('div');

  card.className = 'card';

  card.innerHTML = `<h3>${title}</h3><p>${content}</p>`;

  container.appendChild(card);

}



addCard('Card 1', 'Content 1');

addCard('Card 2', 'Content 2');



// Select newly added cards

const cards = container.querySelectorAll('.card');  // Static snapshot

const cardsLive = container.getElementsByClassName('card');  // Live collection



console.log(cards.length);      // 2

console.log(cardsLive.length);  // 2



addCard('Card 3', 'Content 3');



console.log(cards.length);      // Still 2 (static)

console.log(cardsLive.length);  // 3 (live, updated)

```



#### **Performance Considerations**



```javascript

// FASTEST: getElementById

const el1 = document.getElementById('header');



// FAST: getElementsByClassName, getElementsByTagName

const els2 = document.getElementsByClassName('card');

const els3 = document.getElementsByTagName('div');



// MODERATE: querySelector (stops at first match)

const el4 = document.querySelector('.card');



// SLOWER: querySelectorAll (checks all elements)

const els5 = document.querySelectorAll('.card');



// For multiple selections with simple selectors, prefer:

// getElementsByClassName over querySelectorAll

const cards1 = document.getElementsByClassName('card');  // Faster

const cards2 = document.querySelectorAll('.card');       // Slower



// But querySelector* allows complex selectors:

const complex = document.querySelectorAll('div.card:not(.disabled) > h2');

// This flexibility often outweighs performance difference

```



#### **Best Practices**



```javascript

// 1. Use getElementById for unique IDs

const header = document.getElementById('header');  // ✅ Fastest



// 2. Use querySelector for complex selectors

const firstActiveCard = document.querySelector('.card.active');  // ✅



// 3. Use querySelectorAll for multiple matches

const allCards = document.querySelectorAll('.card');  // ✅



// 4. Cache selectors

// ❌ Bad: Selecting multiple times

for (let i = 0; i < 10; i++) {

  const cards = document.querySelectorAll('.card');  // Inefficient

}



// ✅ Good: Select once, reuse

const cards = document.querySelectorAll('.card');

for (let i = 0; i < 10; i++) {

  // Use cards

}



// 5. Scope selections to containers

// ❌ Less efficient

const buttons = document.querySelectorAll('.modal .button');



// ✅ More efficient

const modal = document.querySelector('.modal');

const buttons = modal.querySelectorAll('.button');



// 6. Convert HTMLCollection/NodeList for array methods

const cards = document.getElementsByClassName('card');

const cardsArray = Array.from(cards);

cardsArray.map(card => card.textContent);



// Or spread operator

const cardsArray2 = [...cards];

```



#### **Key Takeaways**



- **getElementById** is fastest for single element by ID

- **querySelector** uses CSS selectors, very flexible

- **querySelectorAll** returns static NodeList

- **getElementsByClassName/TagName** return live HTMLCollection

- **Live collections** update automatically

- **Static collections** are snapshots

- **querySelector** stops at first match (faster)

- **querySelectorAll** finds all matches

- **Cache selectors** for better performance

- **Scope selections** to containers when possible

- **Modern preference**: querySelector/querySelectorAll for flexibility

- **Use getElementById** when selecting by ID only

- **Convert collections** to arrays for array methods

- **NodeList has forEach**, HTMLCollection doesn't

- Understanding **return types** is crucial





</details>
<details><summary>77. What is the difference between window and document?</summary>






</details>
<details><summary>78. What are different ways to select DOM elements?</summary>






## Advanced Concepts



---



</details>
<details><summary>79. What is the `this` keyword?</summary>




**Answer:**



`this` is a special keyword in JavaScript that refers to the context in which a function is executed. Its value is determined by **how a function is called**, not where it's defined. `this` provides access to the object that is currently executing the code, enabling methods to access their parent object's properties and functions to be reusable across different objects.



#### **Basic Concept**



```javascript

// this refers to the object calling the method

const person = {

  name: 'John',

  greet: function() {

    console.log('Hello, ' + this.name);

  }

};



person.greet();  // 'Hello, John' - this refers to person



// Same function, different context

const anotherPerson = {

  name: 'Jane',

  greet: person.greet  // Reuse the same function

};



anotherPerson.greet();  // 'Hello, Jane' - this refers to anotherPerson

```



#### **1. Global Context**



```javascript

// In browsers (non-strict mode)

console.log(this);  // Window object



// In Node.js (top level)

console.log(this);  // {} (empty object or global)



function showThis() {

  console.log(this);

}



showThis();  // Window (browser, non-strict) or global (Node.js)



// In strict mode

'use strict';

function showThisStrict() {

  console.log(this);

}



showThisStrict();  // undefined

```



#### **2. Object Method Context**



```javascript

const user = {

  name: 'Alice',

  age: 25,

  getName: function() {

    return this.name;  // this = user

  },

  getInfo: function() {

    return `${this.name} is ${this.age} years old`;

  }

};



console.log(user.getName());   // 'Alice'

console.log(user.getInfo());   // 'Alice is 25 years old'



// Nested objects

const company = {

  name: 'TechCorp',

  employee: {

    name: 'Bob',

    getName: function() {

      return this.name;  // this = employee (immediate parent)

    }

  }

};



console.log(company.employee.getName());  // 'Bob' (not 'TechCorp')

```



#### **3. Constructor Function Context**



```javascript

function Person(name, age) {

  // this refers to the new object being created

  this.name = name;

  this.age = age;

  this.greet = function() {

    console.log(`Hi, I'm ${this.name}`);

  };

}



const person1 = new Person('John', 30);

const person2 = new Person('Jane', 25);



person1.greet();  // 'Hi, I'm John'

person2.greet();  // 'Hi, I'm Jane'



// Without 'new', this refers to global object (bad!)

const person3 = Person('Bob', 35);  // Forgot 'new'

console.log(person3);      // undefined

console.log(window.name);  // 'Bob' (polluted global!)

```



#### **4. Class Context**



```javascript

class Animal {

  constructor(name) {

    this.name = name;  // this = new instance

  }

  

  speak() {

    console.log(`${this.name} makes a sound`);

  }

  

  static info() {

    console.log(this);  // this = Animal class itself

  }

}



const dog = new Animal('Dog');

dog.speak();      // 'Dog makes a sound'

Animal.info();    // [class Animal]



// Instance vs Class

console.log(dog.name);     // 'Dog' (instance property)

console.log(Animal.name);  // 'Animal' (class name, not instance)

```



#### **5. Arrow Functions and this**



```javascript

// Arrow functions don't have their own 'this'

// They inherit 'this' from parent scope (lexical this)



const obj = {

  name: 'Object',

  

  // Regular function

  regularMethod: function() {

    console.log(this.name);  // 'Object'

    

    // Nested regular function loses context

    setTimeout(function() {

      console.log(this.name);  // undefined (this = Window or global)

    }, 100);

  },

  

  // Arrow function

  arrowMethod: function() {

    console.log(this.name);  // 'Object'

    

    // Nested arrow function keeps context

    setTimeout(() => {

      console.log(this.name);  // 'Object' (inherits from parent)

    }, 100);

  }

};



obj.regularMethod();

obj.arrowMethod();



// Arrow function as method (problem!)

const obj2 = {

  name: 'Object2',

  arrowAsMethod: () => {

    console.log(this.name);  // undefined (inherits from global scope)

  }

};



obj2.arrowAsMethod();  // 'this' is NOT obj2

```



#### **6. Event Handler Context**



```javascript

// In event handlers, 'this' refers to the element that received the event



const button = document.querySelector('button');



// Regular function

button.addEventListener('click', function() {

  console.log(this);  // <button> element

  this.classList.add('clicked');

  this.textContent = 'Clicked!';

});



// Arrow function (doesn't bind 'this')

button.addEventListener('click', () => {

  console.log(this);  // Window or parent scope, NOT button

  // this.classList.add('clicked');  // ❌ Won't work as expected

});



// Using event parameter

button.addEventListener('click', (event) => {

  console.log(event.target);  // <button> element

  event.target.classList.add('clicked');

});

```



#### **7. Explicit Binding (call, apply, bind)**



```javascript

function greet(greeting, punctuation) {

  console.log(`${greeting}, ${this.name}${punctuation}`);

}



const person = { name: 'John' };



// call() - invoke immediately with specific 'this'

greet.call(person, 'Hello', '!');  // 'Hello, John!'



// apply() - same as call but args as array

greet.apply(person, ['Hi', '.']);  // 'Hi, John.'



// bind() - create new function with bound 'this'

const greetPerson = greet.bind(person);

greetPerson('Hey', '?');  // 'Hey, John?'



// Partial application with bind

const greetJohn = greet.bind(person, 'Greetings');

greetJohn('!');  // 'Greetings, John!'



// Real-world example: method borrowing

const user1 = {

  name: 'Alice',

  greet: function() {

    console.log(`Hello, ${this.name}`);

  }

};



const user2 = { name: 'Bob' };



user1.greet.call(user2);  // 'Hello, Bob' (borrowed method)

```



#### **8. Common 'this' Pitfalls**



```javascript

// Problem 1: Method reference loses context

const person = {

  name: 'John',

  greet: function() {

    console.log(`Hi, ${this.name}`);

  }

};



person.greet();           // 'Hi, John' ✅

const greetFunc = person.greet;

greetFunc();              // 'Hi, undefined' ❌ (lost context)



// Solution 1: Use bind

const boundGreet = person.greet.bind(person);

boundGreet();             // 'Hi, John' ✅



// Solution 2: Arrow function wrapper

const wrappedGreet = () => person.greet();

wrappedGreet();           // 'Hi, John' ✅



// Problem 2: Callback functions lose context

const counter = {

  count: 0,

  increment: function() {

    this.count++;

    console.log(this.count);

  }

};



counter.increment();      // 1 ✅



setTimeout(counter.increment, 1000);  // NaN ❌ (lost context)



// Solution: Bind or arrow function

setTimeout(counter.increment.bind(counter), 1000);  // 2 ✅

setTimeout(() => counter.increment(), 1000);        // 2 ✅



// Problem 3: Nested functions

const obj = {

  name: 'Object',

  method: function() {

    console.log(this.name);  // 'Object' ✅

    

    function nested() {

      console.log(this.name);  // undefined ❌

    }

    nested();

  }

};



obj.method();



// Solution 1: Save 'this' reference

const obj2 = {

  name: 'Object2',

  method: function() {

    const self = this;  // Save reference

    function nested() {

      console.log(self.name);  // 'Object2' ✅

    }

    nested();

  }

};



// Solution 2: Use arrow function

const obj3 = {

  name: 'Object3',

  method: function() {

    const nested = () => {

      console.log(this.name);  // 'Object3' ✅ (lexical this)

    };

    nested();

  }

};

```



#### **Practical Examples**



**1. Object Methods:**

```javascript

const calculator = {

  value: 0,

  

  add: function(num) {

    this.value += num;

    return this;  // Return this for chaining

  },

  

  subtract: function(num) {

    this.value -= num;

    return this;

  },

  

  multiply: function(num) {

    this.value *= num;

    return this;

  },

  

  getValue: function() {

    return this.value;

  }

};



// Method chaining

const result = calculator

  .add(10)

  .multiply(2)

  .subtract(5)

  .getValue();



console.log(result);  // 15

```



**2. Event Handling:**

```javascript

class ToggleButton {

  constructor(element) {

    this.element = element;

    this.isOn = false;

    

    // Bind event handler to maintain 'this' context

    this.element.addEventListener('click', this.toggle.bind(this));

    

    // Alternative: arrow function (if not needing to remove listener)

    // this.element.addEventListener('click', () => this.toggle());

  }

  

  toggle() {

    this.isOn = !this.isOn;

    this.element.textContent = this.isOn ? 'ON' : 'OFF';

    this.element.classList.toggle('active', this.isOn);

    console.log(`Button is now ${this.isOn ? 'on' : 'off'}`);

  }

}



const button = document.querySelector('.toggle-btn');

const toggleBtn = new ToggleButton(button);

```



**3. Timer with Context:**

```javascript

class Timer {

  constructor(duration) {

    this.duration = duration;

    this.timeLeft = duration;

    this.intervalId = null;

  }

  

  start() {

    console.log('Timer started');

    

    // Use arrow function to preserve 'this'

    this.intervalId = setInterval(() => {

      this.timeLeft--;

      console.log(`Time left: ${this.timeLeft}`);

      

      if (this.timeLeft <= 0) {

        this.stop();

      }

    }, 1000);

  }

  

  stop() {

    clearInterval(this.intervalId);

    console.log('Timer stopped');

  }

  

  reset() {

    this.stop();

    this.timeLeft = this.duration;

  }

}



const timer = new Timer(5);

timer.start();

```



**4. DOM Manipulation:**

```javascript

class TodoList {

  constructor(containerElement) {

    this.container = containerElement;

    this.todos = [];

    this.setupEventListeners();

  }

  

  setupEventListeners() {

    // Use arrow functions to preserve 'this'

    this.container.addEventListener('click', (e) => {

      if (e.target.classList.contains('delete-btn')) {

        this.deleteTodo(e.target.dataset.id);

      }

      if (e.target.classList.contains('complete-btn')) {

        this.toggleComplete(e.target.dataset.id);

      }

    });

  }

  

  addTodo(text) {

    const todo = {

      id: Date.now(),

      text: text,

      completed: false

    };

    this.todos.push(todo);

    this.render();

  }

  

  deleteTodo(id) {

    this.todos = this.todos.filter(t => t.id !== Number(id));

    this.render();

  }

  

  toggleComplete(id) {

    const todo = this.todos.find(t => t.id === Number(id));

    if (todo) {

      todo.completed = !todo.completed;

      this.render();

    }

  }

  

  render() {

    this.container.innerHTML = this.todos.map(todo => `

      <div class="todo ${todo.completed ? 'completed' : ''}">

        <span>${todo.text}</span>

        <button class="complete-btn" data-id="${todo.id}">✓</button>

        <button class="delete-btn" data-id="${todo.id}">×</button>

      </div>

    `).join('');

  }

}



const todoList = new TodoList(document.getElementById('todo-container'));

todoList.addTodo('Learn JavaScript');

todoList.addTodo('Master this keyword');

```



**5. API Service:**

```javascript

class ApiService {

  constructor(baseUrl) {

    this.baseUrl = baseUrl;

    this.defaultHeaders = {

      'Content-Type': 'application/json'

    };

  }

  

  async get(endpoint) {

    const url = `${this.baseUrl}${endpoint}`;

    const response = await fetch(url, {

      headers: this.defaultHeaders

    });

    return response.json();

  }

  

  async post(endpoint, data) {

    const url = `${this.baseUrl}${endpoint}`;

    const response = await fetch(url, {

      method: 'POST',

      headers: this.defaultHeaders,

      body: JSON.stringify(data)

    });

    return response.json();

  }

  

  setAuthToken(token) {

    this.defaultHeaders['Authorization'] = `Bearer ${token}`;

  }

}



const api = new ApiService('https://api.example.com');

api.setAuthToken('my-token');



// Methods maintain 'this' context

api.get('/users')

  .then(users => console.log(users));

```



**6. React-like Component:**

```javascript

class Component {

  constructor(props) {

    this.props = props;

    this.state = {};

    

    // Bind methods to preserve 'this'

    this.handleClick = this.handleClick.bind(this);

    this.handleChange = this.handleChange.bind(this);

  }

  

  setState(newState) {

    this.state = { ...this.state, ...newState };

    this.render();

  }

  

  handleClick() {

    console.log('Clicked:', this.state.value);

  }

  

  handleChange(e) {

    this.setState({ value: e.target.value });

  }

  

  render() {

    // Render logic using this.state and this.props

    console.log('Rendering with state:', this.state);

  }

}



// Alternative: Use arrow functions (class fields)

class ModernComponent {

  constructor(props) {

    this.props = props;

    this.state = {};

  }

  

  // Arrow functions automatically bind 'this'

  handleClick = () => {

    console.log('Clicked:', this.state.value);

  }

  

  handleChange = (e) => {

    this.setState({ value: e.target.value });

  }

}

```



#### **'this' Determination Rules (Priority Order)**



```javascript

// 1. new binding (highest priority)

function Person(name) {

  this.name = name;  // this = new object

}

const p = new Person('John');



// 2. Explicit binding (call, apply, bind)

function greet() {

  console.log(this.name);

}

const obj = { name: 'Alice' };

greet.call(obj);  // this = obj



// 3. Implicit binding (method call)

const person = {

  name: 'Bob',

  greet: function() {

    console.log(this.name);  // this = person

  }

};

person.greet();



// 4. Default binding (lowest priority)

function defaultFunc() {

  console.log(this);  // this = global object (or undefined in strict mode)

}

defaultFunc();



// 5. Arrow functions (lexical, not dynamic)

// Arrow functions ignore all rules above and use lexical scope

const obj2 = {

  name: 'Charlie',

  greet: () => {

    console.log(this);  // this = outer scope, NOT obj2

  }

};

```



#### **Summary Table**



| Context | 'this' Value | Example |

|---------|-------------|---------|

| **Global** | Window/global | `console.log(this)` |

| **Function** | Window/undefined (strict) | `function f() { this }` |

| **Method** | Parent object | `obj.method()` |

| **Constructor** | New instance | `new Func()` |

| **Arrow function** | Lexical (outer scope) | `() => this` |

| **call/apply** | First argument | `func.call(obj)` |

| **bind** | Bound object | `func.bind(obj)` |

| **Event handler** | Event target | `element.addEventListener()` |

| **Class method** | Instance | `class { method() }` |

| **Static method** | Class itself | `class { static method() }` |



#### **Common Mistakes**



```javascript

// 1. Forgetting to bind

class MyClass {

  constructor() {

    this.value = 42;

  }

  

  method() {

    console.log(this.value);

  }

}



const obj = new MyClass();

setTimeout(obj.method, 1000);  // ❌ undefined



// Fix:

setTimeout(obj.method.bind(obj), 1000);  // ✅ 42



// 2. Arrow function as object method

const obj2 = {

  value: 42,

  method: () => {

    console.log(this.value);  // ❌ undefined (wrong scope)

  }

};



// Fix: Use regular function

const obj3 = {

  value: 42,

  method: function() {

    console.log(this.value);  // ✅ 42

  }

};



// 3. Reassigning methods

const calculator2 = {

  value: 10,

  getValue: function() {

    return this.value;

  }

};



const getValue = calculator2.getValue;

console.log(getValue());  // ❌ undefined (lost context)



// Fix:

const boundGetValue = calculator2.getValue.bind(calculator2);

console.log(boundGetValue());  // ✅ 10

```



#### **Key Takeaways**



- **'this' is determined by how a function is called**

- **Method call**: 'this' = object before the dot

- **Constructor**: 'this' = newly created object

- **Arrow functions**: 'this' = lexical scope (inherited)

- **Regular functions**: 'this' = calling context

- **Global context**: 'this' = window/global (or undefined in strict)

- **Use bind()** to permanently set 'this'

- **Use call/apply()** to set 'this' for one invocation

- **Event handlers**: 'this' = element (regular functions)

- **Arrow functions** don't have their own 'this'

- **Save reference** with `const self = this` pattern

- **Method chaining**: return 'this' from methods

- **Class methods**: usually need binding for callbacks

- Understanding **'this' is crucial** for OOP in JavaScript

- **Context loss** is a common bug source



---



</details>
<details><summary>80. How does `this` work in different contexts?</summary>




**Answer:**



The value of `this` in JavaScript depends entirely on the **execution context** - how and where a function is called. It follows specific binding rules with a priority hierarchy: `new` binding > explicit binding > implicit binding > default binding. Arrow functions are special and use lexical scoping instead.



#### **1. Global Context**



```javascript

// Browser (non-strict mode)

console.log(this);  // Window object

console.log(this === window);  // true



// Browser (strict mode)

'use strict';

console.log(this);  // Window (still Window at global level)



// Node.js

console.log(this);  // {} or global object



// Global function call

function showThis() {

  console.log(this);

}



showThis();  // Window (non-strict) or undefined (strict)



// With strict mode

'use strict';

function showThisStrict() {

  console.log(this);

}



showThisStrict();  // undefined

```



#### **2. Object Method Context (Implicit Binding)**



```javascript

const user = {

  name: 'Alice',

  age: 25,

  

  // Regular method

  greet: function() {

    console.log(`Hello, I'm ${this.name}`);

  },

  

  // Shorthand method

  getAge() {

    return this.age;

  },

  

  // Nested object

  address: {

    city: 'New York',

    getCity: function() {

      return this.city;  // 'this' refers to 'address', not 'user'

    }

  }

};



user.greet();         // 'Hello, I'm Alice' (this = user)

console.log(user.getAge());        // 25 (this = user)

console.log(user.address.getCity()); // 'New York' (this = address)



// Context is determined by call site

const greetFunc = user.greet;

greetFunc();  // 'Hello, I'm undefined' (lost context, this = global/undefined)

```



#### **3. Constructor Function Context**



```javascript

function Car(make, model) {

  // 'this' refers to the newly created object

  this.make = make;

  this.model = model;

  

  this.getInfo = function() {

    return `${this.make} ${this.model}`;

  };

}



const car1 = new Car('Toyota', 'Camry');

const car2 = new Car('Honda', 'Civic');



console.log(car1.getInfo());  // 'Toyota Camry' (this = car1)

console.log(car2.getInfo());  // 'Honda Civic' (this = car2)



// What 'new' does:

// 1. Creates a new empty object

// 2. Sets the object's prototype

// 3. Binds 'this' to the new object

// 4. Executes the constructor function

// 5. Returns the new object (unless constructor returns an object)



// Without 'new' - BAD!

const car3 = Car('Ford', 'Focus');  // Forgot 'new'

console.log(car3);         // undefined

console.log(window.make);  // 'Ford' (polluted global!)

```



#### **4. Class Context**



```javascript

class Person {

  constructor(name, age) {

    this.name = name;  // 'this' = new instance

    this.age = age;

  }

  

  // Instance method

  introduce() {

    console.log(`I'm ${this.name}, ${this.age} years old`);

  }

  

  // Static method

  static species() {

    console.log(this);  // 'this' = Person class itself

    return 'Homo sapiens';

  }

  

  // Getter

  get info() {

    return `${this.name} (${this.age})`;

  }

  

  // Setter

  set info(value) {

    const [name, age] = value.split(',');

    this.name = name.trim();

    this.age = parseInt(age);

  }

}



const person = new Person('John', 30);

person.introduce();  // 'this' = person instance



console.log(Person.species());  // 'this' = Person class

```



#### **5. Arrow Function Context (Lexical Binding)**



```javascript

// Arrow functions DON'T have their own 'this'

// They inherit 'this' from the enclosing scope



const obj = {

  name: 'Object',

  

  // Regular function

  regularMethod: function() {

    console.log('Regular:', this.name);  // 'Object'

    

    // Problem: nested function loses context

    function inner() {

      console.log('Inner regular:', this.name);  // undefined

    }

    inner();

    

    // Solution: arrow function

    const innerArrow = () => {

      console.log('Inner arrow:', this.name);  // 'Object' (lexical this)

    };

    innerArrow();

  },

  

  // Arrow function as method - PROBLEM!

  arrowMethod: () => {

    console.log('Arrow method:', this.name);  // undefined (lexical from global)

  }

};



obj.regularMethod();

obj.arrowMethod();  // ❌ 'this' is NOT obj



// Practical example: setTimeout

const counter = {

  count: 0,

  

  // Regular function

  incrementRegular: function() {

    setTimeout(function() {

      this.count++;  // ❌ 'this' is global/undefined, not counter

      console.log(this.count);

    }, 100);

  },

  

  // Arrow function solution

  incrementArrow: function() {

    setTimeout(() => {

      this.count++;  // ✅ 'this' is counter (lexical)

      console.log(this.count);

    }, 100);

  }

};



counter.incrementRegular();  // NaN

counter.incrementArrow();    // 1

```



#### **6. Explicit Binding (call, apply, bind)**



```javascript

function greet(greeting, punctuation) {

  return `${greeting}, ${this.name}${punctuation}`;

}



const person1 = { name: 'Alice' };

const person2 = { name: 'Bob' };



// call() - invoke with explicit 'this' and individual args

console.log(greet.call(person1, 'Hello', '!'));  // 'Hello, Alice!'

console.log(greet.call(person2, 'Hi', '.'));     // 'Hi, Bob.'



// apply() - invoke with explicit 'this' and array of args

console.log(greet.apply(person1, ['Hey', '?']));  // 'Hey, Alice?'

console.log(greet.apply(person2, ['Yo', '!']));   // 'Yo, Bob!'



// bind() - create new function with bound 'this'

const greetAlice = greet.bind(person1);

console.log(greetAlice('Greetings', '.'));  // 'Greetings, Alice.'



const greetBob = greet.bind(person2, 'Welcome');  // Partial application

console.log(greetBob('!'));  // 'Welcome, Bob!'



// Bind multiple times (first bind wins)

const bound1 = greet.bind(person1);

const bound2 = bound1.bind(person2);  // Doesn't change binding

console.log(bound2('Hi', '!'));  // 'Hi, Alice!' (still person1)

```



#### **7. Event Handler Context**



```javascript

const button = document.querySelector('#myButton');



// Regular function - 'this' is the element

button.addEventListener('click', function(event) {

  console.log(this);  // <button#myButton>

  console.log(this === event.target);  // true

  

  this.textContent = 'Clicked!';

  this.classList.add('active');

});



// Arrow function - 'this' is lexical (NOT the element)

button.addEventListener('click', (event) => {

  console.log(this);  // Window or outer scope, NOT button

  // this.textContent = 'Clicked!';  // ❌ Won't work

  

  // Use event.target instead

  event.target.textContent = 'Clicked!';  // ✅

});



// Class method as handler

class ButtonHandler {

  constructor(element) {

    this.element = element;

    this.clickCount = 0;

    

    // Need to bind to preserve class instance context

    this.element.addEventListener('click', this.handleClick.bind(this));

    

    // Or use arrow function property

    // this.element.addEventListener('click', this.handleClickArrow);

  }

  

  handleClick() {

    this.clickCount++;

    console.log(`Clicked ${this.clickCount} times`);

    this.element.textContent = `Clicks: ${this.clickCount}`;

  }

  

  // Arrow function property (automatically bound)

  handleClickArrow = () => {

    this.clickCount++;

    console.log(`Clicked ${this.clickCount} times`);

  }

}



const handler = new ButtonHandler(button);

```



#### **8. Array Methods Context**



```javascript

const numbers = [1, 2, 3, 4, 5];



// Array methods accept optional 'this' argument



const multiplier = {

  factor: 10,

  

  multiplyArray: function(arr) {

    // Without thisArg - 'this' is undefined in callback

    const result1 = arr.map(function(num) {

      return num * this.factor;  // ❌ this is undefined

    });

    

    // With thisArg - specify 'this' for callback

    const result2 = arr.map(function(num) {

      return num * this.factor;  // ✅ this is multiplier

    }, this);  // Pass 'this' as second argument

    

    // Or use arrow function (lexical this)

    const result3 = arr.map(num => num * this.factor);  // ✅

    

    return result3;

  }

};



console.log(multiplier.multiplyArray(numbers));  // [10, 20, 30, 40, 50]



// Another example

const person = {

  name: 'John',

  friends: ['Alice', 'Bob', 'Charlie'],

  

  greetFriends: function() {

    // Using arrow function

    this.friends.forEach(friend => {

      console.log(`${this.name} says hi to ${friend}`);

    });

    

    // Using thisArg

    this.friends.forEach(function(friend) {

      console.log(`${this.name} says hi to ${friend}`);

    }, this);

  }

};



person.greetFriends();

```



#### **9. Context in Callbacks**



```javascript

// Problem: callbacks lose context

const user = {

  name: 'Alice',

  friends: ['Bob', 'Charlie'],

  

  printFriends: function() {

    this.friends.forEach(function(friend) {

      // 'this' is undefined (strict) or global (non-strict)

      console.log(this.name + ' knows ' + friend);  // ❌

    });

  }

};



// Solutions:



// Solution 1: Save 'this' reference

const user1 = {

  name: 'Alice',

  friends: ['Bob', 'Charlie'],

  

  printFriends: function() {

    const self = this;  // Save reference

    this.friends.forEach(function(friend) {

      console.log(self.name + ' knows ' + friend);  // ✅

    });

  }

};



// Solution 2: Use bind

const user2 = {

  name: 'Alice',

  friends: ['Bob', 'Charlie'],

  

  printFriends: function() {

    this.friends.forEach(function(friend) {

      console.log(this.name + ' knows ' + friend);  // ✅

    }.bind(this));

  }

};



// Solution 3: Use arrow function

const user3 = {

  name: 'Alice',

  friends: ['Bob', 'Charlie'],

  

  printFriends: function() {

    this.friends.forEach(friend => {

      console.log(this.name + ' knows ' + friend);  // ✅

    });

  }

};



// Solution 4: Use thisArg parameter

const user4 = {

  name: 'Alice',

  friends: ['Bob', 'Charlie'],

  

  printFriends: function() {

    this.friends.forEach(function(friend) {

      console.log(this.name + ' knows ' + friend);  // ✅

    }, this);  // Pass 'this' as second argument

  }

};

```



#### **10. Context in Async Code**



```javascript

const asyncObject = {

  value: 42,

  

  // setTimeout loses context with regular function

  delayedLog1: function() {

    setTimeout(function() {

      console.log(this.value);  // ❌ undefined

    }, 1000);

  },

  

  // Fix with arrow function

  delayedLog2: function() {

    setTimeout(() => {

      console.log(this.value);  // ✅ 42

    }, 1000);

  },

  

  // Fix with bind

  delayedLog3: function() {

    setTimeout(function() {

      console.log(this.value);  // ✅ 42

    }.bind(this), 1000);

  },

  

  // async/await preserves 'this' in method

  async fetchData() {

    console.log(this.value);  // 42

    const data = await fetch('/api/data');

    console.log(this.value);  // Still 42 (async doesn't affect this)

    return data;

  },

  

  // Promise chain

  processData: function() {

    return fetch('/api/data')

      .then(response => response.json())

      .then(data => {

        // Arrow function preserves 'this'

        console.log(this.value, data);  // ✅

        return data;

      });

  }

};

```



#### **Binding Priority Rules**



```javascript

// Priority (highest to lowest):

// 1. new binding

// 2. Explicit binding (call, apply, bind)

// 3. Implicit binding (method call)

// 4. Default binding (global/undefined)



function test() {

  console.log(this.value);

}



const obj1 = { value: 1 };

const obj2 = { value: 2 };



// 1. New binding (highest)

function Constructor() {

  console.log(this);  // New object

}

new Constructor();  // 'this' is new instance



// 2. Explicit binding

test.call(obj1);  // 1 (explicit binding)



// 3. Implicit binding

obj2.test = test;

obj2.test();  // 2 (implicit binding)



// Priority test: explicit > implicit

const boundTest = test.bind(obj1);

obj2.boundTest = boundTest;

obj2.boundTest();  // 1 (explicit wins over implicit)



// new > bind

function Func() {

  this.value = 3;

}

const boundFunc = Func.bind(obj1);

const instance = new boundFunc();

console.log(instance.value);  // 3 (new wins, not obj1.value)

```



#### **Comparison Table**



| Context | 'this' Binding | Can be changed? | Example |

|---------|---------------|-----------------|---------|

| **Global function** | Global/undefined | Yes (call/apply/bind) | `function() { this }` |

| **Object method** | Parent object | Yes | `obj.method()` |

| **Constructor** | New instance | No | `new Func()` |

| **Arrow function** | Lexical scope | No | `() => this` |

| **call/apply** | First argument | N/A | `func.call(obj)` |

| **bind** | Bound object | No (permanent) | `func.bind(obj)` |

| **Event handler** | Target element | Yes | `element.addEventListener()` |

| **Strict mode** | undefined | Yes | `'use strict'; func()` |

| **Array method** | thisArg or undefined | Yes (thisArg) | `arr.forEach(fn, thisArg)` |



#### **Key Takeaways**



- **'this' depends on call site**, not definition site

- **Priority**: new > explicit > implicit > default

- **Arrow functions** use lexical 'this' (inherit from scope)

- **Regular functions** have dynamic 'this' (depends on caller)

- **Methods**: 'this' = object before dot

- **Constructors**: 'this' = new instance

- **Global**: 'this' = window/global (or undefined in strict)

- **call/apply**: set 'this' for one call

- **bind**: create permanently bound function

- **Event handlers**: 'this' = target element (regular functions)

- **Callbacks** often lose context (use arrow/bind)

- **Arrow functions** can't be bound with call/apply/bind

- **Save reference** with `self = this` pattern (old style)

- **Modern preference**: arrow functions for callbacks

- **Understanding context** prevents common bugs



---



</details>
<details><summary>81. What is strict mode?</summary>




**Answer:**



Strict mode is a way to opt into a restricted variant of JavaScript that eliminates some silent errors, fixes mistakes that make it difficult for JavaScript engines to optimize, and prohibits some syntax likely to be defined in future versions of ECMAScript. It's enabled by adding `'use strict';` at the beginning of a script or function.



#### **Enabling Strict Mode**



```javascript

// 1. Global strict mode (entire script)

'use strict';



let x = 10;

function myFunc() {

  // All code in this file is strict

}



// 2. Function strict mode (function scope only)

function strictFunc() {

  'use strict';

  // Only this function is strict

  let y = 20;

}



function normalFunc() {

  // This function is not strict

  z = 30;  // Creates global variable (sloppy mode)

}



// 3. Module strict mode (automatic in ES6 modules)

// In .mjs files or <script type="module">

// 'use strict' is implicit, no need to declare

export function moduleFunc() {

  // Automatically in strict mode

}



// 4. Class bodies (automatic)

class MyClass {

  // Class bodies are always in strict mode

  constructor() {

    // No need for 'use strict'

  }

}

```



#### **1. Prevents Accidental Globals**



```javascript

// Non-strict mode (sloppy mode)

function createGlobal() {

  accidentalGlobal = 'oops';  // Creates global variable

}

createGlobal();

console.log(window.accidentalGlobal);  // 'oops'



// Strict mode

'use strict';

function strictFunction() {

  accidentalGlobal = 'oops';  // ❌ ReferenceError: accidentalGlobal is not defined

}



// Must use var, let, or const

function correctWay() {

  'use strict';

  let properVariable = 'correct';  // ✅

  const another = 'also correct';  // ✅

}

```



#### **2. Assignments to Non-Writable Properties**



```javascript

'use strict';



// 1. Read-only properties

const obj = {};

Object.defineProperty(obj, 'readOnly', {

  value: 42,

  writable: false

});



obj.readOnly = 100;  // ❌ TypeError: Cannot assign to read only property



// 2. Non-extensible objects

const sealed = {};

Object.preventExtensions(sealed);

sealed.newProp = 'value';  // ❌ TypeError: Cannot add property



// 3. Getter-only properties

const obj2 = {

  get prop() {

    return 'value';

  }

};

obj2.prop = 'new value';  // ❌ TypeError: Cannot set property



// Non-strict mode: All above fail silently (no error)

```



#### **3. Deleting Variables, Functions, and Non-Configurable Properties**



```javascript

'use strict';



// Can't delete variables

let x = 10;

delete x;  // ❌ SyntaxError: Delete of an unqualified identifier



// Can't delete functions

function myFunc() {}

delete myFunc;  // ❌ SyntaxError



// Can't delete non-configurable properties

delete Object.prototype;  // ❌ TypeError



// CAN delete object properties (if configurable)

const obj = { prop: 'value' };

delete obj.prop;  // ✅ Works fine



// Non-strict mode: delete returns false silently

```



#### **4. Duplicate Parameter Names**



```javascript

// Non-strict mode: Last parameter wins

function sum(a, a, c) {

  return a + a + c;  // Uses last 'a'

}

console.log(sum(1, 2, 3));  // 7 (2 + 2 + 3)



// Strict mode: Syntax error

'use strict';

function strictSum(a, a, c) {  // ❌ SyntaxError: Duplicate parameter name

  return a + a + c;

}

```



#### **5. Octal Syntax**



```javascript

// Non-strict mode: Octal literals allowed

const octal1 = 010;  // 8 in decimal

const octal2 = 077;  // 63 in decimal



// Strict mode: Octal literals forbidden

'use strict';

const strictOctal = 010;  // ❌ SyntaxError: Octal literals are not allowed



// Use explicit octal notation

const modernOctal = 0o10;  // ✅ 8 in decimal (ES6+)

const binary = 0b1010;     // ✅ 10 in decimal

const hex = 0xFF;          // ✅ 255 in decimal

```



#### **6. 'this' in Functions**



```javascript

// Non-strict mode: 'this' is global object

function showThis() {

  console.log(this);

}

showThis();  // Window (browser) or global (Node.js)



// Strict mode: 'this' is undefined

'use strict';

function strictThis() {

  console.log(this);

}

strictThis();  // undefined



// Method calls still work

const obj = {

  method: function() {

    'use strict';

    console.log(this);  // obj (not affected)

  }

};

obj.method();  // obj



// Important for callbacks

function callback() {

  'use strict';

  console.log(this);  // undefined (not global)

}

setTimeout(callback, 100);

```



#### **7. Reserved Words**



```javascript

'use strict';



// These are reserved for future use

// ❌ SyntaxError in strict mode:

const implements = 10;

const interface = 20;

const let = 30;  // 'let' is now a keyword anyway

const package = 40;

const private = 50;

const protected = 60;

const public = 70;

const static = 80;  // 'static' is now a keyword

const yield = 90;   // 'yield' is now a keyword



// Also reserved:

// arguments, eval (can't be variable names or parameters)

```



#### **8. Arguments Object Restrictions**



```javascript

// Non-strict mode: arguments reflects parameter changes

function nonStrict(a) {

  a = 100;

  console.log(arguments[0]);  // 100 (linked to parameter)

}

nonStrict(1);



// Strict mode: arguments is independent

'use strict';

function strictFunc(a) {

  a = 100;

  console.log(arguments[0]);  // 1 (not linked)

}

strictFunc(1);



// Can't assign to arguments

'use strict';

function test() {

  arguments = [1, 2, 3];  // ❌ SyntaxError: Unexpected eval or arguments

}



// Can't use arguments.caller or arguments.callee

'use strict';

function factorial(n) {

  return n <= 1 ? 1 : n * arguments.callee(n - 1);  // ❌ TypeError

}

```



#### **9. eval() Restrictions**



```javascript

// Non-strict mode: eval can create variables in scope

function nonStrictEval() {

  eval('var x = 10');

  console.log(x);  // 10 (x created in function scope)

}



// Strict mode: eval has its own scope

'use strict';

function strictEval() {

  eval('var x = 10');

  console.log(x);  // ❌ ReferenceError: x is not defined

}



// Can't use 'eval' as variable name

'use strict';

const eval = 10;  // ❌ SyntaxError

function test(eval) {}  // ❌ SyntaxError

```



#### **10. with Statement Forbidden**



```javascript

// Non-strict mode: 'with' is allowed (but discouraged)

const obj = { x: 10, y: 20 };

with (obj) {

  console.log(x);  // 10

  console.log(y);  // 20

}



// Strict mode: 'with' is forbidden

'use strict';

with (obj) {  // ❌ SyntaxError: Strict mode code may not include a with statement

  console.log(x);

}



// Alternative: destructuring

const { x, y } = obj;

console.log(x, y);  // 10, 20

```



#### **Practical Examples**



**1. Preventing Typos:**

```javascript

'use strict';



const user = {

  firstName: 'John',

  lastName: 'Doe'

};



// Typo in property name

user.fistName = 'Jane';  // Creates new property (no error)



// But typo in variable name

fistName = 'Jane';  // ❌ ReferenceError (caught by strict mode)



// Should be:

user.firstName = 'Jane';  // ✅

```



**2. Safer this Binding:**

```javascript

'use strict';



class Button {

  constructor(element) {

    this.element = element;

    this.clickCount = 0;

    

    // Without bind, 'this' would be undefined in strict mode

    this.element.addEventListener('click', this.handleClick.bind(this));

  }

  

  handleClick() {

    // In strict mode, 'this' is undefined if not bound

    // Forces proper binding practices

    this.clickCount++;

    console.log(`Clicks: ${this.clickCount}`);

  }

}



const btn = new Button(document.querySelector('button'));

```



**3. Module Pattern:**

```javascript

'use strict';



const Module = (function() {

  // Private variables

  let privateVar = 0;

  

  function privateFunction() {

    privateVar++;

  }

  

  // Public API

  return {

    publicMethod: function() {

      privateFunction();

      return privateVar;

    },

    

    reset: function() {

      privateVar = 0;

    }

  };

})();



console.log(Module.publicMethod());  // 1

console.log(Module.privateVar);      // undefined (truly private)

```



**4. Constructor Safety:**

```javascript

'use strict';



function Person(name) {

  // In strict mode, forgetting 'new' doesn't pollute global

  this.name = name;  // TypeError if called without 'new'

}



const person1 = new Person('John');  // ✅ Works

const person2 = Person('Jane');      // ❌ TypeError: Cannot set property 'name' of undefined



// ES6 classes are always strict (safe by default)

class SafePerson {

  constructor(name) {

    this.name = name;

  }

}



const person3 = new SafePerson('Bob');  // ✅

const person4 = SafePerson('Alice');    // ❌ TypeError: Class constructor cannot be invoked without 'new'

```



#### **Benefits of Strict Mode**



```javascript

'use strict';



// 1. Catches common coding mistakes

function benefits() {

  // Typo creates global (non-strict)

  // ReferenceError in strict ✅

  

  // Duplicate params (non-strict ignores)

  // SyntaxError in strict ✅

  

  // Delete non-deletable (non-strict fails silently)

  // TypeError in strict ✅

}



// 2. Prevents unsafe actions

function safetyFeatures() {

  // Can't mess with eval scope

  // Can't use 'with' statement

  // Can't access caller/callee

}



// 3. Enables optimizations

function performance() {

  // Engines can optimize better

  // 'arguments' doesn't track parameters

  // No need to check for 'with' statement

  // 'this' boxing not needed

}



// 4. Future-proofs code

function futureProof() {

  // Reserved words enforced

  // Syntax that may change is forbidden

  // Prepares for future ECMAScript versions

}

```



#### **Mixing Strict and Non-Strict**



```javascript

// Global non-strict

function nonStrictFunc() {

  // This function is non-strict

  implicitGlobal = 'allowed';

}



function strictFunc() {

  'use strict';

  // This function is strict

  // implicitGlobal = 'error';  // ❌ ReferenceError

}



// Can use both in same file

nonStrictFunc();  // Creates global

strictFunc();     // Would error if uncommented



// Concatenation warning

// File 1 (strict): 'use strict'; ...

// File 2 (non-strict): ...

// If concatenated, File 2 becomes strict!

```



#### **Common Pitfalls**



```javascript

// 1. Forgetting 'use strict' in new code

function oldCode() {

  // Sloppy mode

  mistake = 'oops';  // Creates global

}



// 2. Using strict mode with old libraries

'use strict';

// oldLibrary.js might not work in strict mode



// 3. Concatenated files

// Strict mode in one file affects concatenated files



// 4. Function inside non-strict

function outer() {

  // Non-strict

  function inner() {

    'use strict';

    // Only inner is strict

  }

}

```



#### **Best Practices**



```javascript

// 1. Always use strict mode in new code

'use strict';



// 2. Use ES6 modules (automatically strict)

// module.js

export function myFunc() {

  // Automatically strict

}



// 3. Use modern classes (automatically strict)

class MyClass {

  // Automatically strict

}



// 4. Enable in build tools

// ESLint: "strict": ["error", "global"]

// Babel: transforms to strict mode



// 5. Use linters to catch issues

// ESLint will warn about non-strict issues

```



#### **Key Takeaways**



- **'use strict'** enables strict mode

- **Prevents accidental globals** (undeclared variables error)

- **Makes 'this' undefined** in functions (not global)

- **Catches silent errors** (assignments to read-only, deletes)

- **Forbids duplicate** parameter names

- **Restricts eval()** to its own scope

- **Bans 'with' statement** completely

- **Reserves future keywords** (implements, interface, etc.)

- **Makes arguments independent** of parameters

- **Can't delete** variables, functions, non-configurable properties

- **ES6 modules** are automatically strict

- **Classes** are automatically strict

- **Better optimization** by engines

- **Use globally** in new projects

- **Modern JavaScript** assumes strict mode





</details>
<details><summary>79. What is the `this` keyword?</summary>






</details>
<details><summary>80. How does `this` work in different contexts?</summary>






</details>
<details><summary>81. What is strict mode?</summary>






---



</details>
<details><summary>82. What is memoization?</summary>




**Answer:**



Memoization is an optimization technique that caches the results of expensive function calls and returns the cached result when the same inputs occur again. It trades memory for speed by storing previously computed values, avoiding redundant calculations. Memoization is particularly effective for pure functions with deterministic outputs and recursive algorithms.



#### **Basic Concept**



```javascript

// Without memoization - slow

function slowFibonacci(n) {

  if (n <= 1) return n;

  return slowFibonacci(n - 1) + slowFibonacci(n - 2);

}



console.time('slow');

console.log(slowFibonacci(40));  // Takes several seconds

console.timeEnd('slow');



// With memoization - fast

function memoizedFibonacci() {

  const cache = {};

  

  return function fib(n) {

    if (n in cache) {

      return cache[n];  // Return cached result

    }

    

    if (n <= 1) {

      return n;

    }

    

    // Calculate and cache

    cache[n] = fib(n - 1) + fib(n - 2);

    return cache[n];

  };

}



const fastFib = memoizedFibonacci();

console.time('fast');

console.log(fastFib(40));  // Nearly instant

console.timeEnd('fast');

```



#### **1. Simple Memoization Function**



```javascript

// Generic memoization function

function memoize(fn) {

  const cache = {};

  

  return function(...args) {

    const key = JSON.stringify(args);

    

    if (key in cache) {

      console.log('Returning from cache:', key);

      return cache[key];

    }

    

    console.log('Computing result for:', key);

    const result = fn.apply(this, args);

    cache[key] = result;

    return result;

  };

}



// Example: expensive calculation

function expensiveCalculation(n) {

  let sum = 0;

  for (let i = 0; i < 1000000; i++) {

    sum += n * i;

  }

  return sum;

}



const memoizedCalc = memoize(expensiveCalculation);



console.log(memoizedCalc(5));  // Computing... (slow)

console.log(memoizedCalc(5));  // From cache (instant)

console.log(memoizedCalc(10)); // Computing... (slow)

console.log(memoizedCalc(5));  // From cache (instant)

```



#### **2. Fibonacci with Memoization**



```javascript

// Recursive approach with memoization

function fibonacciMemo() {

  const cache = {};

  

  function fib(n) {

    if (n in cache) return cache[n];

    

    if (n <= 1) {

      return n;

    }

    

    cache[n] = fib(n - 1) + fib(n - 2);

    return cache[n];

  }

  

  return fib;

}



const fibonacci = fibonacciMemo();



console.log(fibonacci(10));  // 55

console.log(fibonacci(50));  // 12586269025 (instant)

console.log(fibonacci(100)); // Very large number (still instant)



// Alternative: using closure directly

const fib = (function() {

  const cache = {};

  

  return function fibonacci(n) {

    if (n in cache) return cache[n];

    if (n <= 1) return n;

    

    return cache[n] = fibonacci(n - 1) + fibonacci(n - 2);

  };

})();

```



#### **3. Factorial with Memoization**



```javascript

const factorial = (function() {

  const cache = { 0: 1, 1: 1 };

  

  return function fact(n) {

    if (n in cache) return cache[n];

    

    return cache[n] = n * fact(n - 1);

  };

})();



console.log(factorial(5));   // 120

console.log(factorial(10));  // 3628800

console.log(factorial(20));  // 2432902008176640000

console.log(factorial(15));  // Uses cached values from 20!

```



#### **4. Advanced Memoization with Custom Key**



```javascript

// Memoization with custom key generation

function memoizeWithKey(fn, keyGenerator) {

  const cache = new Map();

  

  return function(...args) {

    const key = keyGenerator ? keyGenerator(...args) : args[0];

    

    if (cache.has(key)) {

      return cache.get(key);

    }

    

    const result = fn.apply(this, args);

    cache.set(key, result);

    return result;

  };

}



// Example: Sum of array

function sumArray(arr) {

  return arr.reduce((sum, num) => sum + num, 0);

}



const memoizedSum = memoizeWithKey(sumArray, arr => arr.join(','));



console.log(memoizedSum([1, 2, 3]));  // Computing: 6

console.log(memoizedSum([1, 2, 3]));  // From cache: 6

console.log(memoizedSum([4, 5, 6]));  // Computing: 15

```



#### **5. Memoization with Expiration**



```javascript

// Memoization with TTL (Time To Live)

function memoizeWithTTL(fn, ttl = 5000) {

  const cache = new Map();

  

  return function(...args) {

    const key = JSON.stringify(args);

    const now = Date.now();

    

    if (cache.has(key)) {

      const { value, timestamp } = cache.get(key);

      

      if (now - timestamp < ttl) {

        console.log('Cache hit (fresh)');

        return value;

      } else {

        console.log('Cache expired');

        cache.delete(key);

      }

    }

    

    console.log('Computing result');

    const result = fn.apply(this, args);

    cache.set(key, { value: result, timestamp: now });

    return result;

  };

}



function fetchUserData(userId) {

  // Simulate API call

  return { id: userId, name: `User ${userId}`, timestamp: Date.now() };

}



const memoizedFetch = memoizeWithTTL(fetchUserData, 3000);



console.log(memoizedFetch(1));  // Computing

console.log(memoizedFetch(1));  // Cache hit

setTimeout(() => {

  console.log(memoizedFetch(1));  // Cache expired, recompute

}, 3500);

```



#### **6. Memoization with Size Limit (LRU Cache)**



```javascript

// LRU (Least Recently Used) cache

function memoizeWithLimit(fn, limit = 100) {

  const cache = new Map();

  

  return function(...args) {

    const key = JSON.stringify(args);

    

    // Move to end if exists (mark as recently used)

    if (cache.has(key)) {

      const value = cache.get(key);

      cache.delete(key);

      cache.set(key, value);

      return value;

    }

    

    // Compute result

    const result = fn.apply(this, args);

    

    // Remove oldest if at limit

    if (cache.size >= limit) {

      const firstKey = cache.keys().next().value;

      cache.delete(firstKey);

    }

    

    cache.set(key, result);

    return result;

  };

}



const memoizedCalc = memoizeWithLimit((x, y) => x * y, 3);



console.log(memoizedCalc(2, 3));  // 6

console.log(memoizedCalc(4, 5));  // 20

console.log(memoizedCalc(6, 7));  // 42

console.log(memoizedCalc(8, 9));  // 72 (evicts first entry)

console.log(memoizedCalc(2, 3));  // Recomputes (was evicted)

```



#### **7. Class Method Memoization**



```javascript

class Calculator {

  constructor() {

    // Memoize instance method

    this.expensiveOperation = this.memoize(this.expensiveOperation);

  }

  

  memoize(fn) {

    const cache = new Map();

    

    return function(...args) {

      const key = JSON.stringify(args);

      

      if (cache.has(key)) {

        return cache.get(key);

      }

      

      const result = fn.apply(this, args);

      cache.set(key, result);

      return result;

    };

  }

  

  expensiveOperation(n) {

    console.log(`Computing for ${n}...`);

    let result = 0;

    for (let i = 0; i < n * 1000000; i++) {

      result += i;

    }

    return result;

  }

}



const calc = new Calculator();

console.log(calc.expensiveOperation(10));  // Computing...

console.log(calc.expensiveOperation(10));  // From cache

```



#### **8. Decorator Pattern for Memoization**



```javascript

// Memoization decorator (ES7+ proposal)

function memoized(target, name, descriptor) {

  const original = descriptor.value;

  const cache = new Map();

  

  descriptor.value = function(...args) {

    const key = JSON.stringify(args);

    

    if (cache.has(key)) {

      return cache.get(key);

    }

    

    const result = original.apply(this, args);

    cache.set(key, result);

    return result;

  };

  

  return descriptor;

}



class MathOperations {

  @memoized

  factorial(n) {

    if (n <= 1) return 1;

    return n * this.factorial(n - 1);

  }

  

  @memoized

  fibonacci(n) {

    if (n <= 1) return n;

    return this.fibonacci(n - 1) + this.fibonacci(n - 2);

  }

}



// Without decorator support, use manual approach:

class MathOps {

  constructor() {

    this.factorialCache = new Map();

  }

  

  factorial(n) {

    if (this.factorialCache.has(n)) {

      return this.factorialCache.get(n);

    }

    

    const result = n <= 1 ? 1 : n * this.factorial(n - 1);

    this.factorialCache.set(n, result);

    return result;

  }

}

```



#### **Practical Examples**



**1. API Call Memoization:**

```javascript

function memoizeAsync(fn, ttl = 60000) {

  const cache = new Map();

  

  return async function(...args) {

    const key = JSON.stringify(args);

    const now = Date.now();

    

    if (cache.has(key)) {

      const { value, timestamp } = cache.get(key);

      if (now - timestamp < ttl) {

        console.log('Returning cached data');

        return value;

      }

      cache.delete(key);

    }

    

    console.log('Fetching fresh data');

    const result = await fn.apply(this, args);

    cache.set(key, { value: result, timestamp: now });

    return result;

  };

}



async function fetchUserProfile(userId) {

  const response = await fetch(`/api/users/${userId}`);

  return response.json();

}



const memoizedFetchUser = memoizeAsync(fetchUserProfile, 30000);



// First call - fetches from API

await memoizedFetchUser(123);



// Second call within 30s - returns cached

await memoizedFetchUser(123);



// After 30s - fetches again

```



**2. Complex Calculations:**

```javascript

// Memoized prime number checker

const isPrime = (function() {

  const cache = new Map();

  

  return function(num) {

    if (cache.has(num)) return cache.get(num);

    

    if (num <= 1) return cache.set(num, false).get(num);

    if (num === 2) return cache.set(num, true).get(num);

    if (num % 2 === 0) return cache.set(num, false).get(num);

    

    for (let i = 3; i <= Math.sqrt(num); i += 2) {

      if (num % i === 0) {

        return cache.set(num, false).get(num);

      }

    }

    

    return cache.set(num, true).get(num);

  };

})();



console.log(isPrime(17));    // true (computed)

console.log(isPrime(17));    // true (cached)

console.log(isPrime(97));    // true (computed)

console.log(isPrime(100));   // false (computed)

```



**3. React-like Component Optimization:**

```javascript

// Memoize expensive render calculations

function createComponent() {

  const renderCache = new Map();

  

  return {

    render(props) {

      const key = JSON.stringify(props);

      

      if (renderCache.has(key)) {

        console.log('Using cached render');

        return renderCache.get(key);

      }

      

      console.log('Computing render');

      // Expensive render calculation

      const rendered = this.expensiveRender(props);

      renderCache.set(key, rendered);

      return rendered;

    },

    

    expensiveRender(props) {

      // Complex calculations

      let result = '';

      for (let i = 0; i < 10000; i++) {

        result += props.text;

      }

      return result;

    }

  };

}



const component = createComponent();

component.render({ text: 'Hello' });  // Computing

component.render({ text: 'Hello' });  // Cached

component.render({ text: 'World' });  // Computing (different props)

```



**4. Search/Filter Memoization:**

```javascript

const searchService = {

  cache: new Map(),

  

  search(query, data) {

    const key = `${query}:${data.length}`;

    

    if (this.cache.has(key)) {

      console.log('Cache hit for:', query);

      return this.cache.get(key);

    }

    

    console.log('Searching for:', query);

    const results = data.filter(item => 

      item.toLowerCase().includes(query.toLowerCase())

    );

    

    this.cache.set(key, results);

    return results;

  },

  

  clearCache() {

    this.cache.clear();

  }

};



const data = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry'];



console.log(searchService.search('a', data));  // Searching...

console.log(searchService.search('a', data));  // Cache hit

console.log(searchService.search('e', data));  // Searching...

```



**5. Route Path Matching:**

```javascript

function createRouter() {

  const routeCache = new Map();

  

  return {

    matchRoute(path, routes) {

      if (routeCache.has(path)) {

        return routeCache.get(path);

      }

      

      for (const route of routes) {

        const regex = new RegExp(route.pattern);

        if (regex.test(path)) {

          routeCache.set(path, route);

          return route;

        }

      }

      

      return null;

    }

  };

}



const router = createRouter();

const routes = [

  { pattern: '^/users/\\d+$', handler: 'userHandler' },

  { pattern: '^/posts/\\d+$', handler: 'postHandler' }

];



console.log(router.matchRoute('/users/123', routes));  // Computed

console.log(router.matchRoute('/users/123', routes));  // Cached

```



#### **When to Use Memoization**



```javascript

// ✅ GOOD USE CASES:



// 1. Pure functions (deterministic)

const multiply = memoize((a, b) => a * b);



// 2. Expensive computations

const fibonacci = memoize(n => {

  if (n <= 1) return n;

  return fibonacci(n - 1) + fibonacci(n - 2);

});



// 3. Repeated API calls

const getUser = memoizeAsync(async id => {

  return fetch(`/api/users/${id}`).then(r => r.json());

});



// 4. Recursive algorithms

const factorialMemo = memoize(n => {

  if (n <= 1) return 1;

  return n * factorialMemo(n - 1);

});



// ❌ BAD USE CASES:



// 1. Impure functions (side effects)

const badExample1 = memoize(() => {

  console.log('Side effect');  // Side effect!

  return Math.random();        // Non-deterministic!

});



// 2. Functions with different results for same input

const badExample2 = memoize(() => new Date());  // Always different



// 3. Functions that modify arguments

const badExample3 = memoize(arr => {

  arr.push(1);  // Mutates input!

  return arr;

});



// 4. Fast, simple operations

const badExample4 = memoize((a, b) => a + b);  // Too simple, overhead not worth it

```



#### **Performance Considerations**



```javascript

// Benchmark: With vs Without Memoization

function benchmark() {

  // Without memoization

  function slowFib(n) {

    if (n <= 1) return n;

    return slowFib(n - 1) + slowFib(n - 2);

  }

  

  // With memoization

  const fastFib = (function() {

    const cache = {};

    return function fib(n) {

      if (n in cache) return cache[n];

      if (n <= 1) return n;

      return cache[n] = fib(n - 1) + fib(n - 2);

    };

  })();

  

  // Test

  console.time('Without memoization');

  console.log(slowFib(35));  // ~5-10 seconds

  console.timeEnd('Without memoization');

  

  console.time('With memoization');

  console.log(fastFib(35));  // ~1ms

  console.timeEnd('With memoization');

  

  // Fibonacci(35) without memo: ~59 million recursive calls

  // Fibonacci(35) with memo: 35 calls

}

```



#### **Common Patterns**



```javascript

// Pattern 1: IIFE with closure

const memoFunc1 = (function() {

  const cache = {};

  return function(n) {

    return cache[n] || (cache[n] = expensiveCalc(n));

  };

})();



// Pattern 2: Higher-order function

const memoFunc2 = memoize(expensiveCalc);



// Pattern 3: Class with private cache

class MemoService {

  #cache = new Map();

  

  compute(input) {

    if (this.#cache.has(input)) {

      return this.#cache.get(input);

    }

    const result = this.expensiveCalc(input);

    this.#cache.set(input, result);

    return result;

  }

  

  expensiveCalc(input) {

    // Heavy computation

  }

}



// Pattern 4: WeakMap for object keys

const memoFunc4 = (function() {

  const cache = new WeakMap();

  

  return function(obj) {

    if (cache.has(obj)) return cache.get(obj);

    

    const result = processObject(obj);

    cache.set(obj, result);

    return result;

  };

})();

```



#### **Key Takeaways**



- **Memoization** caches function results based on inputs

- **Trade memory for speed** - stores results to avoid recalculation

- **Best for pure functions** with deterministic outputs

- **Excellent for recursive** algorithms (Fibonacci, factorial)

- **Use Map/Object** for simple caching

- **Add TTL** for time-sensitive data

- **Implement LRU** to limit memory usage

- **Key generation** is critical for complex arguments

- **Avoid memoizing** impure functions or side effects

- **Performance gain** is significant for expensive operations

- **Not suitable** for simple, fast operations

- **Clear cache** when data changes

- **Async memoization** works for API calls

- **WeakMap** for object keys (allows garbage collection)

- **Understand trade-offs** between memory and computation



---



</details>
<details><summary>83. What is debouncing?</summary>




**Answer:**



Debouncing is a programming technique that limits the rate at which a function can execute. It delays function execution until after a certain amount of time has passed since the last time it was invoked. If the function is called again before the delay expires, the timer resets. This is particularly useful for handling events that fire rapidly, like scroll, resize, or input events.



#### **Basic Concept**



```javascript

// Without debouncing - function fires on every keystroke

function handleSearch(query) {

  console.log('Searching for:', query);

  // API call or expensive operation

}



// input.addEventListener('keyup', (e) => {

//   handleSearch(e.target.value);  // Fires hundreds of times!

// });



// With debouncing - function fires once user stops typing

function debounce(func, delay) {

  let timeoutId;

  

  return function(...args) {

    // Clear previous timer

    clearTimeout(timeoutId);

    

    // Set new timer

    timeoutId = setTimeout(() => {

      func.apply(this, args);

    }, delay);

  };

}



const debouncedSearch = debounce(handleSearch, 500);



// input.addEventListener('keyup', (e) => {

//   debouncedSearch(e.target.value);  // Fires once after 500ms of inactivity

// });

```



#### **1. Simple Debounce Implementation**



```javascript

function debounce(func, delay) {

  let timeoutId;

  

  return function(...args) {

    const context = this;

    

    // Clear existing timer

    clearTimeout(timeoutId);

    

    // Set new timer

    timeoutId = setTimeout(() => {

      func.apply(context, args);

    }, delay);

  };

}



// Usage

function logMessage(message) {

  console.log('Message:', message);

}



const debouncedLog = debounce(logMessage, 1000);



debouncedLog('Hello');   // Timer starts

debouncedLog('World');   // Timer resets

debouncedLog('!');       // Timer resets

// After 1 second of no calls: "Message: !"

```



#### **2. Debounce with Immediate Execution**



```javascript

// Execute immediately on first call, then debounce

function debounce(func, delay, immediate = false) {

  let timeoutId;

  

  return function(...args) {

    const context = this;

    const callNow = immediate && !timeoutId;

    

    clearTimeout(timeoutId);

    

    timeoutId = setTimeout(() => {

      timeoutId = null;

      if (!immediate) {

        func.apply(context, args);

      }

    }, delay);

    

    if (callNow) {

      func.apply(context, args);

    }

  };

}



// Usage

const debouncedClick = debounce(() => {

  console.log('Button clicked');

}, 1000, true);



// First click executes immediately

// Subsequent clicks within 1s are ignored

// After 1s, next click executes immediately again

```



#### **3. Debounce with Cancel**



```javascript

function debounce(func, delay) {

  let timeoutId;

  

  const debounced = function(...args) {

    clearTimeout(timeoutId);

    

    timeoutId = setTimeout(() => {

      func.apply(this, args);

    }, delay);

  };

  

  // Add cancel method

  debounced.cancel = function() {

    clearTimeout(timeoutId);

    timeoutId = null;

  };

  

  // Add flush method (execute immediately)

  debounced.flush = function() {

    if (timeoutId) {

      clearTimeout(timeoutId);

      func.apply(this);

    }

  };

  

  return debounced;

}



// Usage

const debouncedSave = debounce(() => {

  console.log('Saving...');

}, 2000);



debouncedSave();  // Starts timer

debouncedSave();  // Resets timer



// Cancel if needed

debouncedSave.cancel();  // Cancels pending execution



// Or execute immediately

debouncedSave.flush();   // Executes right now

```



#### **4. Promise-based Debounce**



```javascript

function debouncePromise(func, delay) {

  let timeoutId;

  let rejectPrevious = null;

  

  return function(...args) {

    return new Promise((resolve, reject) => {

      // Reject previous promise

      if (rejectPrevious) {

        rejectPrevious('Debounced');

      }

      

      rejectPrevious = reject;

      clearTimeout(timeoutId);

      

      timeoutId = setTimeout(async () => {

        rejectPrevious = null;

        try {

          const result = await func.apply(this, args);

          resolve(result);

        } catch (error) {

          reject(error);

        }

      }, delay);

    });

  };

}



// Usage with async function

async function searchAPI(query) {

  const response = await fetch(`/api/search?q=${query}`);

  return response.json();

}



const debouncedSearch = debouncePromise(searchAPI, 500);



// Only the last call resolves

debouncedSearch('abc').catch(err => console.log(err));  // "Debounced"

debouncedSearch('abcd').catch(err => console.log(err)); // "Debounced"

debouncedSearch('abcde').then(data => console.log(data)); // Resolves

```



#### **Practical Examples**



**1. Search Input:**

```javascript

// Search as user types

const searchInput = document.getElementById('search');

const resultsDiv = document.getElementById('results');



const performSearch = debounce(async function(query) {

  if (!query.trim()) {

    resultsDiv.innerHTML = '';

    return;

  }

  

  try {

    resultsDiv.innerHTML = 'Searching...';

    const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);

    const results = await response.json();

    

    resultsDiv.innerHTML = results.map(item => 

      `<div class="result">${item.title}</div>`

    ).join('');

  } catch (error) {

    resultsDiv.innerHTML = 'Error occurred';

  }

}, 300);



searchInput.addEventListener('input', (e) => {

  performSearch(e.target.value);

});



// User types "JavaScript"

// J - timer starts (300ms)

// a - timer resets (300ms)

// v - timer resets (300ms)

// ... continues for each letter

// After 300ms of no typing: API call executes once

```



**2. Window Resize:**

```javascript

// Recalculate layout on window resize

function recalculateLayout() {

  const width = window.innerWidth;

  const height = window.innerHeight;

  

  console.log('Recalculating layout:', width, height);

  

  // Expensive layout calculations

  document.querySelectorAll('.card').forEach(card => {

    card.style.width = width < 768 ? '100%' : '33.33%';

  });

}



const debouncedResize = debounce(recalculateLayout, 250);



window.addEventListener('resize', debouncedResize);



// Without debouncing: fires 100+ times during resize

// With debouncing: fires once after user stops resizing

```



**3. Auto-save Feature:**

```javascript

class Editor {

  constructor() {

    this.content = '';

    this.saveStatus = document.getElementById('save-status');

    

    // Debounced save function

    this.debouncedSave = debounce(() => this.saveContent(), 2000);

  }

  

  handleInput(value) {

    this.content = value;

    this.saveStatus.textContent = 'Unsaved changes...';

    this.debouncedSave();

  }

  

  async saveContent() {

    this.saveStatus.textContent = 'Saving...';

    

    try {

      await fetch('/api/save', {

        method: 'POST',

        headers: { 'Content-Type': 'application/json' },

        body: JSON.stringify({ content: this.content })

      });

      

      this.saveStatus.textContent = 'Saved ✓';

    } catch (error) {

      this.saveStatus.textContent = 'Save failed';

    }

  }

}



const editor = new Editor();

const textarea = document.getElementById('editor');



textarea.addEventListener('input', (e) => {

  editor.handleInput(e.target.value);

});

```



**4. Form Validation:**

```javascript

// Validate email as user types

const emailInput = document.getElementById('email');

const errorDiv = document.getElementById('email-error');



const validateEmail = debounce(function(email) {

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

  

  if (!email) {

    errorDiv.textContent = '';

    emailInput.classList.remove('valid', 'invalid');

    return;

  }

  

  if (emailRegex.test(email)) {

    errorDiv.textContent = '';

    emailInput.classList.remove('invalid');

    emailInput.classList.add('valid');

  } else {

    errorDiv.textContent = 'Invalid email format';

    emailInput.classList.remove('valid');

    emailInput.classList.add('invalid');

  }

}, 500);



emailInput.addEventListener('input', (e) => {

  validateEmail(e.target.value);

});

```



**5. Scroll Event:**

```javascript

// Show/hide header on scroll

const header = document.querySelector('.header');

let lastScrollY = window.scrollY;



const handleScroll = debounce(function() {

  const currentScrollY = window.scrollY;

  

  if (currentScrollY > lastScrollY && currentScrollY > 100) {

    // Scrolling down

    header.classList.add('hidden');

  } else {

    // Scrolling up

    header.classList.remove('hidden');

  }

  

  lastScrollY = currentScrollY;

}, 100);



window.addEventListener('scroll', handleScroll);

```



**6. API Rate Limiting:**

```javascript

// Prevent excessive API calls

class APIClient {

  constructor() {

    this.debouncedGet = debounce((url) => this.get(url), 1000);

  }

  

  async get(url) {

    console.log('Fetching:', url);

    const response = await fetch(url);

    return response.json();

  }

  

  // Public method uses debounced version

  async fetchData(endpoint) {

    return this.debouncedGet(endpoint);

  }

}



const client = new APIClient();



// Multiple rapid calls

client.fetchData('/api/users');  // Queued

client.fetchData('/api/users');  // Queued (cancels previous)

client.fetchData('/api/users');  // Queued (cancels previous)

// Only last call executes after 1 second

```



**7. Autocomplete:**

```javascript

// Autocomplete with debouncing

class Autocomplete {

  constructor(inputElement, suggestionsElement) {

    this.input = inputElement;

    this.suggestions = suggestionsElement;

    

    this.debouncedFetch = debounce(

      (query) => this.fetchSuggestions(query),

      300

    );

    

    this.input.addEventListener('input', (e) => {

      this.handleInput(e.target.value);

    });

  }

  

  handleInput(value) {

    if (value.length < 2) {

      this.suggestions.innerHTML = '';

      return;

    }

    

    this.debouncedFetch(value);

  }

  

  async fetchSuggestions(query) {

    this.suggestions.innerHTML = 'Loading...';

    

    try {

      const response = await fetch(`/api/autocomplete?q=${query}`);

      const data = await response.json();

      

      this.suggestions.innerHTML = data.map(item => 

        `<div class="suggestion">${item}</div>`

      ).join('');

    } catch (error) {

      this.suggestions.innerHTML = 'Error loading suggestions';

    }

  }

}



const autocomplete = new Autocomplete(

  document.getElementById('search-input'),

  document.getElementById('suggestions')

);

```



#### **Debounce vs Throttle Comparison**



```javascript

// Debounce: Execute after delay of inactivity

const debounced = debounce(() => {

  console.log('Debounced');

}, 1000);



// Rapid calls:

debounced(); // Timer starts

debounced(); // Timer resets

debounced(); // Timer resets

debounced(); // Timer resets

// Executes once after 1 second of no calls



// Throttle: Execute at most once per interval (covered in next question)

```



#### **Common Use Cases**



```javascript

// ✅ GOOD USE CASES for debouncing:



// 1. Search/autocomplete (wait for user to finish typing)

searchInput.addEventListener('input', debounce(search, 300));



// 2. Form validation (validate after user stops typing)

emailInput.addEventListener('input', debounce(validateEmail, 500));



// 3. Auto-save (save after user stops editing)

textarea.addEventListener('input', debounce(autoSave, 2000));



// 4. Window resize (recalculate after resize finishes)

window.addEventListener('resize', debounce(recalculate, 250));



// 5. API calls (prevent excessive requests)

button.addEventListener('click', debounce(fetchData, 1000));



// ❌ BAD USE CASES for debouncing:



// 1. Infinite scroll (use throttle instead)

// Need regular updates, not waiting for pause



// 2. Game controls (use direct handling)

// Need immediate response



// 3. Real-time updates (use direct handling or throttle)

// Need consistent updates



// 4. Analytics tracking (use throttle)

// Need regular tracking, not just at end

```



#### **Key Takeaways**



- **Debouncing** delays execution until after period of inactivity

- **Timer resets** on each function call

- **Execute once** after user stops triggering events

- **Perfect for search** and autocomplete

- **Reduces API calls** significantly

- **Improves performance** by avoiding excessive operations

- **Add immediate option** for first-call execution

- **Include cancel/flush** methods for control

- **Use for resize events** to avoid layout thrashing

- **Great for auto-save** features

- **Different from throttling** (throttle limits rate, debounce waits)

- **Delay should match** user behavior expectations

- **300-500ms common** for search inputs

- **1000-2000ms common** for auto-save

- **Understanding debouncing** is essential for performance optimization



---



</details>
<details><summary>84. What is throttling?</summary>




**Answer:**



Throttling is a technique that limits how often a function can execute over time. Unlike debouncing (which delays until inactivity), throttling ensures a function executes at most once per specified time interval, regardless of how many times it's called. The first call executes immediately, then subsequent calls are ignored until the interval passes. This is ideal for events that fire continuously, like scroll or mousemove.



#### **Basic Concept**



```javascript

// Without throttling - function fires constantly

function handleScroll() {

  console.log('Scroll position:', window.scrollY);

  // Can fire 100+ times per second!

}



// window.addEventListener('scroll', handleScroll);



// With throttling - function fires at most once per interval

function throttle(func, limit) {

  let inThrottle;

  

  return function(...args) {

    if (!inThrottle) {

      func.apply(this, args);

      inThrottle = true;

      

      setTimeout(() => {

        inThrottle = false;

      }, limit);

    }

  };

}



const throttledScroll = throttle(handleScroll, 1000);



// window.addEventListener('scroll', throttledScroll);

// Fires once per second, regardless of scroll speed

```



#### **1. Simple Throttle Implementation**



```javascript

function throttle(func, limit) {

  let inThrottle;

  

  return function(...args) {

    const context = this;

    

    if (!inThrottle) {

      func.apply(context, args);

      inThrottle = true;

      

      setTimeout(() => {

        inThrottle = false;

      }, limit);

    }

  };

}



// Usage

function logMessage(message) {

  console.log('Message:', message, Date.now());

}



const throttledLog = throttle(logMessage, 2000);



throttledLog('First');   // Executes immediately

throttledLog('Second');  // Ignored (within 2s)

throttledLog('Third');   // Ignored (within 2s)

// After 2 seconds, next call will execute

```



#### **2. Throttle with Trailing Call**



```javascript

// Execute first call immediately, last call after interval

function throttle(func, limit) {

  let inThrottle;

  let lastFunc;

  let lastRan;

  

  return function(...args) {

    const context = this;

    

    if (!inThrottle) {

      func.apply(context, args);

      lastRan = Date.now();

      inThrottle = true;

      

      setTimeout(() => {

        inThrottle = false;

      }, limit);

    } else {

      clearTimeout(lastFunc);

      lastFunc = setTimeout(() => {

        if (Date.now() - lastRan >= limit) {

          func.apply(context, args);

          lastRan = Date.now();

        }

      }, limit - (Date.now() - lastRan));

    }

  };

}



// First call: executes immediately

// Intermediate calls: ignored

// Last call: executes after interval

```



#### **3. Advanced Throttle with Options**



```javascript

function throttle(func, limit, options = {}) {

  let timeout;

  let previous = 0;

  

  const throttled = function(...args) {

    const now = Date.now();

    const context = this;

    

    // If leading is false, set previous on first call

    if (!previous && options.leading === false) {

      previous = now;

    }

    

    const remaining = limit - (now - previous);

    

    if (remaining <= 0 || remaining > limit) {

      if (timeout) {

        clearTimeout(timeout);

        timeout = null;

      }

      

      previous = now;

      func.apply(context, args);

    } else if (!timeout && options.trailing !== false) {

      timeout = setTimeout(() => {

        previous = options.leading === false ? 0 : Date.now();

        timeout = null;

        func.apply(context, args);

      }, remaining);

    }

  };

  

  throttled.cancel = function() {

    clearTimeout(timeout);

    previous = 0;

    timeout = null;

  };

  

  return throttled;

}



// Usage with options

const throttledFn = throttle(myFunc, 1000, {

  leading: true,   // Execute on first call

  trailing: true   // Execute after interval with last args

});

```



#### **4. RequestAnimationFrame Throttle**



```javascript

// Throttle to browser's paint cycle (~60fps)

function throttleRAF(func) {

  let rafId = null;

  let lastArgs = null;

  

  return function(...args) {

    lastArgs = args;

    

    if (rafId === null) {

      rafId = requestAnimationFrame(() => {

        func.apply(this, lastArgs);

        rafId = null;

      });

    }

  };

}



// Usage for animations/visual updates

const throttledAnimation = throttleRAF(function(scrollY) {

  // Update element position

  element.style.transform = `translateY(${scrollY}px)`;

});



window.addEventListener('scroll', () => {

  throttledAnimation(window.scrollY);

});

```



#### **Practical Examples**



**1. Infinite Scroll:**

```javascript

class InfiniteScroll {

  constructor(containerElement) {

    this.container = containerElement;

    this.loading = false;

    this.page = 1;

    

    // Throttle scroll handler to check at most every 200ms

    this.throttledScroll = throttle(() => this.checkScroll(), 200);

    

    window.addEventListener('scroll', this.throttledScroll);

  }

  

  checkScroll() {

    const scrollTop = window.scrollY;

    const windowHeight = window.innerHeight;

    const documentHeight = document.documentElement.scrollHeight;

    

    // Check if near bottom

    if (scrollTop + windowHeight >= documentHeight - 500) {

      this.loadMore();

    }

  }

  

  async loadMore() {

    if (this.loading) return;

    

    this.loading = true;

    console.log('Loading page:', this.page + 1);

    

    try {

      const response = await fetch(`/api/posts?page=${++this.page}`);

      const posts = await response.json();

      

      posts.forEach(post => {

        const div = document.createElement('div');

        div.className = 'post';

        div.textContent = post.title;

        this.container.appendChild(div);

      });

    } catch (error) {

      console.error('Error loading posts:', error);

    } finally {

      this.loading = false;

    }

  }

}



const infiniteScroll = new InfiniteScroll(document.getElementById('posts'));

```



**2. Mouse Movement Tracking:**

```javascript

// Track mouse position for parallax effect

const parallaxLayer = document.querySelector('.parallax-layer');



const updateParallax = throttle(function(e) {

  const mouseX = e.clientX;

  const mouseY = e.clientY;

  const windowWidth = window.innerWidth;

  const windowHeight = window.innerHeight;

  

  // Calculate offset (-50 to 50 pixels)

  const offsetX = ((mouseX / windowWidth) - 0.5) * 100;

  const offsetY = ((mouseY / windowHeight) - 0.5) * 100;

  

  parallaxLayer.style.transform = `translate(${offsetX}px, ${offsetY}px)`;

}, 50);  // Update at most 20 times per second



document.addEventListener('mousemove', updateParallax);



// Without throttling: fires 100+ times per second

// With throttling: fires 20 times per second (smooth, efficient)

```



**3. Scroll Progress Indicator:**

```javascript

const progressBar = document.querySelector('.progress-bar');



const updateProgress = throttle(function() {

  const windowHeight = window.innerHeight;

  const documentHeight = document.documentElement.scrollHeight;

  const scrollTop = window.scrollY;

  

  // Calculate progress percentage

  const maxScroll = documentHeight - windowHeight;

  const progress = (scrollTop / maxScroll) * 100;

  

  progressBar.style.width = `${Math.min(progress, 100)}%`;

}, 100);  // Update every 100ms



window.addEventListener('scroll', updateProgress);

```



**4. Button Click Protection:**

```javascript

// Prevent rapid clicking (e.g., submit button)

const submitButton = document.getElementById('submit-btn');



const handleSubmit = throttle(async function() {

  console.log('Submitting form...');

  

  const formData = new FormData(document.getElementById('myForm'));

  

  try {

    const response = await fetch('/api/submit', {

      method: 'POST',

      body: formData

    });

    

    const result = await response.json();

    console.log('Success:', result);

  } catch (error) {

    console.error('Error:', error);

  }

}, 2000);  // Allow submit once every 2 seconds



submitButton.addEventListener('click', (e) => {

  e.preventDefault();

  handleSubmit();

});

```



**5. Window Resize:**

```javascript

// Update layout during resize (not just after)

const updateLayout = throttle(function() {

  const width = window.innerWidth;

  

  console.log('Updating layout for width:', width);

  

  // Responsive adjustments

  const cards = document.querySelectorAll('.card');

  const columns = width < 768 ? 1 : width < 1024 ? 2 : 3;

  const cardWidth = `${100 / columns}%`;

  

  cards.forEach(card => {

    card.style.width = cardWidth;

  });

}, 250);  // Update every 250ms during resize



window.addEventListener('resize', updateLayout);



// Throttling provides continuous updates during resize

// Debouncing would only update after resize stops

```



**6. Game Loop / Animation:**

```javascript

class Game {

  constructor(canvas) {

    this.canvas = canvas;

    this.ctx = canvas.getContext('2d');

    this.mouseX = 0;

    this.mouseY = 0;

    

    // Throttle mouse tracking to game's update rate

    this.throttledMouseMove = throttle((x, y) => {

      this.mouseX = x;

      this.mouseY = y;

    }, 16);  // ~60fps

    

    canvas.addEventListener('mousemove', (e) => {

      this.throttledMouseMove(e.clientX, e.clientY);

    });

    

    this.startGameLoop();

  }

  

  startGameLoop() {

    const loop = () => {

      this.update();

      this.render();

      requestAnimationFrame(loop);

    };

    loop();

  }

  

  update() {

    // Game logic using this.mouseX, this.mouseY

  }

  

  render() {

    // Draw game state

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    this.ctx.fillStyle = 'blue';

    this.ctx.fillRect(this.mouseX - 25, this.mouseY - 25, 50, 50);

  }

}



const game = new Game(document.getElementById('game-canvas'));

```



**7. Analytics Tracking:**

```javascript

// Track scroll depth at intervals

class AnalyticsTracker {

  constructor() {

    this.maxScrollDepth = 0;

    this.milestones = [25, 50, 75, 100];

    this.tracked = new Set();

    

    this.throttledTrack = throttle(() => this.trackScrollDepth(), 1000);

    

    window.addEventListener('scroll', this.throttledTrack);

  }

  

  trackScrollDepth() {

    const windowHeight = window.innerHeight;

    const documentHeight = document.documentElement.scrollHeight;

    const scrollTop = window.scrollY;

    

    const scrollPercentage = Math.round(

      ((scrollTop + windowHeight) / documentHeight) * 100

    );

    

    this.maxScrollDepth = Math.max(this.maxScrollDepth, scrollPercentage);

    

    // Track milestones

    this.milestones.forEach(milestone => {

      if (this.maxScrollDepth >= milestone && !this.tracked.has(milestone)) {

        this.tracked.add(milestone);

        this.sendAnalytics('scroll_depth', milestone);

      }

    });

  }

  

  sendAnalytics(event, value) {

    console.log(`Analytics: ${event} = ${value}%`);

    // Send to analytics service

  }

}



const tracker = new AnalyticsTracker();

```



#### **Debounce vs Throttle Visual**



```javascript

// DEBOUNCE: Waits for silence

// Events:  | | | | |     | |         |

// Execute:                    ✓           ✓

// (Executes after events stop)



// THROTTLE: Regular intervals

// Events:  | | | | | | | | | | | | | | | |

// Execute: ✓       ✓       ✓       ✓

// (Executes at regular intervals)



// Example showing the difference

let debounceCount = 0;

let throttleCount = 0;



const debouncedFn = debounce(() => {

  console.log('Debounced:', ++debounceCount);

}, 1000);



const throttledFn = throttle(() => {

  console.log('Throttled:', ++throttleCount);

}, 1000);



// Simulate 100 rapid calls over 2 seconds

for (let i = 0; i < 100; i++) {

  setTimeout(() => {

    debouncedFn();  // Executes once after all calls

    throttledFn();  // Executes ~2 times (once per second)

  }, i * 20);

}

```



#### **When to Use What**



```javascript

// USE DEBOUNCING when you want to wait for user to finish:

// ✅ Search input (wait for typing to stop)

// ✅ Form validation (validate after user finishes)

// ✅ Auto-save (save after editing stops)

// ✅ Window resize (recalculate after resize finishes)



// USE THROTTLING when you want regular updates during activity:

// ✅ Scroll events (infinite scroll, progress bars)

// ✅ Mouse movement (parallax, tooltips)

// ✅ Window resize (live updates during resize)

// ✅ Game controls (regular input sampling)

// ✅ Analytics (periodic tracking)

// ✅ Button clicks (prevent rapid clicking)



// Example comparison

const searchInput = document.getElementById('search');



// Debounce: Search after user stops typing

searchInput.addEventListener('input', debounce((e) => {

  performSearch(e.target.value);

}, 500));



// Throttle: Show character count while typing

searchInput.addEventListener('input', throttle((e) => {

  updateCharCount(e.target.value.length);

}, 100));

```



#### **Performance Comparison**



```javascript

// Benchmark: Performance improvement

function benchmark() {

  let callCount = 0;

  

  // Normal function (no throttling)

  function normalFn() {

    callCount++;

  }

  

  // Throttled function

  let throttledCount = 0;

  const throttledFn = throttle(() => {

    throttledCount++;

  }, 100);

  

  // Simulate 1000 calls over 1 second

  const interval = setInterval(() => {

    normalFn();

    throttledFn();

  }, 1);

  

  setTimeout(() => {

    clearInterval(interval);

    console.log('Normal calls:', callCount);      // ~1000

    console.log('Throttled calls:', throttledCount); // ~10

    console.log('Reduction:', Math.round((1 - throttledCount / callCount) * 100) + '%');

  }, 1000);

}



// Result: 99% reduction in function executions

```



#### **Key Takeaways**



- **Throttling** limits execution rate over time

- **First call executes** immediately

- **Subsequent calls ignored** until interval passes

- **Regular intervals** regardless of call frequency

- **Perfect for scroll** and mousemove events

- **Different from debouncing** (throttle=regular, debounce=waits)

- **Use for infinite scroll** and progress tracking

- **Improves performance** by reducing executions

- **Add trailing option** to execute last call

- **Include cancel method** for cleanup

- **RequestAnimationFrame** good for visual updates

- **100-250ms common** for scroll events

- **50-100ms common** for mouse tracking

- **16ms (~60fps)** for animations

- **Understanding throttling** essential for smooth UX





</details>
<details><summary>82. What is memoization?</summary>






</details>
<details><summary>83. What is debouncing?</summary>






</details>
<details><summary>84. What is throttling?</summary>






---



</details>
<details><summary>85. What are Web Workers?</summary>




**Answer:**



Web Workers are a browser API that allows JavaScript code to run in background threads, separate from the main UI thread. They enable parallel processing and prevent heavy computations from blocking the user interface. Workers run in an isolated context without access to the DOM, communicating with the main thread through message passing. This is essential for performing CPU-intensive tasks without freezing the page.



#### **Basic Concept**



```javascript

// Main thread (main.js)

// Check if Web Workers are supported

if (window.Worker) {

  // Create a new worker

  const worker = new Worker('worker.js');

  

  // Send message to worker

  worker.postMessage({ task: 'calculate', value: 1000000 });

  

  // Receive message from worker

  worker.onmessage = function(e) {

    console.log('Result from worker:', e.data);

  };

  

  // Handle errors

  worker.onerror = function(error) {

    console.error('Worker error:', error.message);

  };

  

  // Terminate worker when done

  // worker.terminate();

} else {

  console.log('Web Workers not supported');

}



// Worker thread (worker.js)

// Listen for messages from main thread

self.onmessage = function(e) {

  const { task, value } = e.data;

  

  if (task === 'calculate') {

    // Perform heavy calculation

    let result = 0;

    for (let i = 0; i < value; i++) {

      result += i;

    }

    

    // Send result back to main thread

    self.postMessage({ result: result });

  }

};

```



#### **1. Creating and Using Workers**



```javascript

// main.js

class WorkerManager {

  constructor(workerPath) {

    this.worker = new Worker(workerPath);

    this.setupListeners();

  }

  

  setupListeners() {

    this.worker.onmessage = (e) => {

      console.log('Message from worker:', e.data);

    };

    

    this.worker.onerror = (error) => {

      console.error('Worker error:', error.message, error.filename, error.lineno);

    };

  }

  

  send(data) {

    this.worker.postMessage(data);

  }

  

  terminate() {

    this.worker.terminate();

    console.log('Worker terminated');

  }

}



// Usage

const manager = new WorkerManager('worker.js');

manager.send({ command: 'start', data: [1, 2, 3, 4, 5] });



// Later: cleanup

// manager.terminate();



// worker.js

self.onmessage = function(e) {

  const { command, data } = e.data;

  

  switch(command) {

    case 'start':

      const result = processData(data);

      self.postMessage({ status: 'complete', result });

      break;

    case 'stop':

      self.close(); // Terminate from inside worker

      break;

  }

};



function processData(data) {

  return data.map(x => x * 2);

}

```



#### **2. Dedicated Workers**



```javascript

// Main thread

const worker = new Worker('dedicated-worker.js');



worker.postMessage({

  action: 'process',

  data: { numbers: [1, 2, 3, 4, 5] }

});



worker.onmessage = (e) => {

  console.log('Processed:', e.data);

  // { action: 'process', result: [2, 4, 6, 8, 10] }

};



// dedicated-worker.js

self.addEventListener('message', (e) => {

  const { action, data } = e.data;

  

  if (action === 'process') {

    const result = data.numbers.map(n => n * 2);

    

    self.postMessage({

      action: action,

      result: result

    });

  }

});



// Error handling in worker

self.addEventListener('error', (e) => {

  console.error('Worker error:', e);

});

```



#### **3. Shared Workers**



```javascript

// Main thread (can be from multiple pages)

const sharedWorker = new SharedWorker('shared-worker.js');



// Start the port

sharedWorker.port.start();



// Send message

sharedWorker.port.postMessage({

  type: 'subscribe',

  id: 'page-1'

});



// Receive messages

sharedWorker.port.onmessage = (e) => {

  console.log('Message from shared worker:', e.data);

};



// shared-worker.js

const connections = [];



self.onconnect = function(e) {

  const port = e.ports[0];

  connections.push(port);

  

  port.onmessage = function(e) {

    const { type, id } = e.data;

    

    if (type === 'subscribe') {

      console.log('New connection:', id);

      

      // Broadcast to all connections

      connections.forEach(conn => {

        conn.postMessage({

          type: 'notification',

          message: `${id} joined`

        });

      });

    }

  };

  

  port.start();

};

```



#### **4. Inline Workers (Blob Workers)**



```javascript

// Create worker from inline code

function createInlineWorker(workerFunction) {

  const blob = new Blob(

    ['(' + workerFunction.toString() + ')()'],

    { type: 'application/javascript' }

  );

  

  const blobURL = URL.createObjectURL(blob);

  return new Worker(blobURL);

}



// Define worker logic as function

const workerFunction = function() {

  self.onmessage = function(e) {

    const result = e.data * e.data;

    self.postMessage(result);

  };

};



// Create and use inline worker

const inlineWorker = createInlineWorker(workerFunction);



inlineWorker.postMessage(5);



inlineWorker.onmessage = function(e) {

  console.log('Result:', e.data); // 25

};



// Cleanup

// URL.revokeObjectURL(worker);

// inlineWorker.terminate();

```



#### **5. Worker with Promise Wrapper**



```javascript

// Utility to wrap worker in Promise

class WorkerPromise {

  constructor(workerPath) {

    this.worker = new Worker(workerPath);

    this.taskId = 0;

    this.pendingTasks = new Map();

    

    this.worker.onmessage = (e) => {

      const { taskId, result, error } = e.data;

      const task = this.pendingTasks.get(taskId);

      

      if (task) {

        if (error) {

          task.reject(new Error(error));

        } else {

          task.resolve(result);

        }

        this.pendingTasks.delete(taskId);

      }

    };

  }

  

  execute(data) {

    return new Promise((resolve, reject) => {

      const taskId = this.taskId++;

      

      this.pendingTasks.set(taskId, { resolve, reject });

      this.worker.postMessage({ taskId, data });

    });

  }

  

  terminate() {

    this.worker.terminate();

    this.pendingTasks.forEach(task => {

      task.reject(new Error('Worker terminated'));

    });

    this.pendingTasks.clear();

  }

}



// Usage

const workerPromise = new WorkerPromise('promise-worker.js');



async function processData() {

  try {

    const result1 = await workerPromise.execute({ value: 10 });

    console.log('Result 1:', result1);

    

    const result2 = await workerPromise.execute({ value: 20 });

    console.log('Result 2:', result2);

  } catch (error) {

    console.error('Error:', error);

  }

}



processData();



// promise-worker.js

self.onmessage = function(e) {

  const { taskId, data } = e.data;

  

  try {

    // Perform calculation

    const result = data.value * 2;

    

    // Send success

    self.postMessage({ taskId, result });

  } catch (error) {

    // Send error

    self.postMessage({ taskId, error: error.message });

  }

};

```



#### **Practical Examples**



**1. Image Processing:**

```javascript

// Main thread

class ImageProcessor {

  constructor() {

    this.worker = new Worker('image-worker.js');

  }

  

  async processImage(imageData) {

    return new Promise((resolve, reject) => {

      this.worker.onmessage = (e) => {

        resolve(e.data.processedImage);

      };

      

      this.worker.onerror = (error) => {

        reject(error);

      };

      

      this.worker.postMessage({

        imageData: imageData,

        filter: 'grayscale'

      });

    });

  }

}



// Usage

const canvas = document.getElementById('canvas');

const ctx = canvas.getContext('2d');

const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);



const processor = new ImageProcessor();

const processed = await processor.processImage(imageData);



ctx.putImageData(processed, 0, 0);



// image-worker.js

self.onmessage = function(e) {

  const { imageData, filter } = e.data;

  

  if (filter === 'grayscale') {

    const data = imageData.data;

    

    for (let i = 0; i < data.length; i += 4) {

      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;

      data[i] = avg;     // Red

      data[i + 1] = avg; // Green

      data[i + 2] = avg; // Blue

      // data[i + 3] is alpha, leave unchanged

    }

  }

  

  self.postMessage({ processedImage: imageData });

};

```



**2. Data Processing:**

```javascript

// Main thread - processing large dataset

class DataWorker {

  constructor() {

    this.worker = new Worker('data-worker.js');

  }

  

  async processLargeDataset(data) {

    return new Promise((resolve) => {

      this.worker.onmessage = (e) => {

        resolve(e.data);

      };

      

      this.worker.postMessage({ data, operation: 'analyze' });

    });

  }

}



// Usage

const largeDataset = Array.from({ length: 1000000 }, (_, i) => ({

  id: i,

  value: Math.random() * 100

}));



const dataWorker = new DataWorker();



console.log('Processing started...');

const results = await dataWorker.processLargeDataset(largeDataset);

console.log('Results:', results);



// data-worker.js

self.onmessage = function(e) {

  const { data, operation } = e.data;

  

  if (operation === 'analyze') {

    // Heavy computation

    const sum = data.reduce((acc, item) => acc + item.value, 0);

    const avg = sum / data.length;

    const max = Math.max(...data.map(item => item.value));

    const min = Math.min(...data.map(item => item.value));

    

    self.postMessage({

      count: data.length,

      sum: sum,

      average: avg,

      max: max,

      min: min

    });

  }

};

```



**3. Prime Number Calculator:**

```javascript

// Main thread

const primeWorker = new Worker('prime-worker.js');



document.getElementById('calculate').addEventListener('click', () => {

  const max = parseInt(document.getElementById('max').value);

  const resultDiv = document.getElementById('result');

  

  resultDiv.textContent = 'Calculating...';

  

  primeWorker.postMessage({ max });

});



primeWorker.onmessage = function(e) {

  const { primes, count, time } = e.data;

  document.getElementById('result').textContent = 

    `Found ${count} primes in ${time}ms`;

  console.log('Primes:', primes);

};



// prime-worker.js

self.onmessage = function(e) {

  const { max } = e.data;

  const startTime = Date.now();

  

  const primes = findPrimes(max);

  const endTime = Date.now();

  

  self.postMessage({

    primes: primes,

    count: primes.length,

    time: endTime - startTime

  });

};



function findPrimes(max) {

  const primes = [];

  

  for (let num = 2; num <= max; num++) {

    let isPrime = true;

    

    for (let i = 2; i <= Math.sqrt(num); i++) {

      if (num % i === 0) {

        isPrime = false;

        break;

      }

    }

    

    if (isPrime) primes.push(num);

  }

  

  return primes;

}

```



**4. Progress Reporting:**

```javascript

// Main thread

const progressWorker = new Worker('progress-worker.js');

const progressBar = document.getElementById('progress');



progressWorker.onmessage = function(e) {

  const { type, progress, result } = e.data;

  

  if (type === 'progress') {

    progressBar.style.width = progress + '%';

    progressBar.textContent = progress + '%';

  } else if (type === 'complete') {

    console.log('Complete! Result:', result);

    progressBar.textContent = 'Done!';

  }

};



progressWorker.postMessage({ start: 0, end: 100000 });



// progress-worker.js

self.onmessage = function(e) {

  const { start, end } = e.data;

  let result = 0;

  

  for (let i = start; i < end; i++) {

    result += Math.sqrt(i);

    

    // Report progress every 1000 iterations

    if (i % 1000 === 0) {

      const progress = Math.round((i / end) * 100);

      self.postMessage({ type: 'progress', progress });

    }

  }

  

  self.postMessage({ type: 'complete', result });

};

```



**5. Worker Pool:**

```javascript

// Worker pool for parallel processing

class WorkerPool {

  constructor(workerPath, poolSize = 4) {

    this.workers = [];

    this.taskQueue = [];

    this.activeWorkers = 0;

    

    // Create worker pool

    for (let i = 0; i < poolSize; i++) {

      const worker = new Worker(workerPath);

      worker.onmessage = (e) => this.handleWorkerMessage(worker, e);

      this.workers.push({ worker, busy: false });

    }

  }

  

  execute(data) {

    return new Promise((resolve, reject) => {

      const task = { data, resolve, reject };

      

      const availableWorker = this.workers.find(w => !w.busy);

      

      if (availableWorker) {

        this.runTask(availableWorker, task);

      } else {

        this.taskQueue.push(task);

      }

    });

  }

  

  runTask(workerObj, task) {

    workerObj.busy = true;

    workerObj.currentTask = task;

    this.activeWorkers++;

    

    workerObj.worker.postMessage(task.data);

  }

  

  handleWorkerMessage(worker, e) {

    const workerObj = this.workers.find(w => w.worker === worker);

    

    if (workerObj.currentTask) {

      workerObj.currentTask.resolve(e.data);

      workerObj.busy = false;

      workerObj.currentTask = null;

      this.activeWorkers--;

      

      // Process next task in queue

      if (this.taskQueue.length > 0) {

        const nextTask = this.taskQueue.shift();

        this.runTask(workerObj, nextTask);

      }

    }

  }

  

  terminate() {

    this.workers.forEach(w => w.worker.terminate());

    this.workers = [];

  }

}



// Usage

const pool = new WorkerPool('calc-worker.js', 4);



// Process multiple tasks in parallel

const tasks = Array.from({ length: 20 }, (_, i) => i);

const promises = tasks.map(i => pool.execute({ value: i * 1000 }));



Promise.all(promises).then(results => {

  console.log('All tasks complete:', results);

  pool.terminate();

});

```



**6. File Processing:**

```javascript

// Process large file in chunks

class FileProcessor {

  constructor() {

    this.worker = new Worker('file-worker.js');

  }

  

  async processFile(file) {

    const chunkSize = 1024 * 1024; // 1MB chunks

    const chunks = Math.ceil(file.size / chunkSize);

    const results = [];

    

    for (let i = 0; i < chunks; i++) {

      const start = i * chunkSize;

      const end = Math.min(start + chunkSize, file.size);

      const chunk = file.slice(start, end);

      

      const arrayBuffer = await chunk.arrayBuffer();

      const result = await this.processChunk(arrayBuffer, i, chunks);

      results.push(result);

      

      // Update progress

      const progress = Math.round(((i + 1) / chunks) * 100);

      this.onProgress?.(progress);

    }

    

    return results;

  }

  

  processChunk(arrayBuffer, index, total) {

    return new Promise((resolve) => {

      this.worker.onmessage = (e) => resolve(e.data);

      this.worker.postMessage({

        chunk: arrayBuffer,

        index,

        total

      }, [arrayBuffer]); // Transfer ownership

    });

  }

}



// file-worker.js

self.onmessage = function(e) {

  const { chunk, index, total } = e.data;

  

  // Process the chunk

  const view = new Uint8Array(chunk);

  let checksum = 0;

  

  for (let i = 0; i < view.length; i++) {

    checksum += view[i];

  }

  

  self.postMessage({

    index,

    checksum,

    size: view.length

  });

};

```



#### **Worker Capabilities and Limitations**



```javascript

// WORKERS CAN:

// ✅ Access these APIs:

self.onmessage = function(e) {

  // - XMLHttpRequest / fetch

  fetch('/api/data');

  

  // - setTimeout / setInterval

  setTimeout(() => {}, 1000);

  

  // - IndexedDB

  // indexedDB.open('myDB');

  

  // - WebSockets

  // const ws = new WebSocket('ws://example.com');

  

  // - navigator object (subset)

  console.log(self.navigator.userAgent);

  

  // - importScripts (load other scripts)

  importScripts('util.js', 'helper.js');

  

  // - console methods

  console.log('Worker log');

};



// WORKERS CANNOT:

// ❌ Access these:

// - window object

// - document object

// - parent object

// - DOM manipulation

// - Most HTML5 APIs (Geolocation, etc.)

// - alert(), confirm(), prompt()

// - localStorage (use IndexedDB instead)



// Example: Import additional scripts in worker

// worker.js

importScripts('lib1.js', 'lib2.js');



self.onmessage = function(e) {

  // Can now use functions from lib1.js and lib2.js

  const result = someLibraryFunction(e.data);

  self.postMessage(result);

};

```



#### **Performance Considerations**



```javascript

// Benchmark: With vs Without Worker

function benchmark() {

  const iterations = 1000000000;

  

  // Without worker (blocks UI)

  console.time('Main thread (blocking)');

  let sum = 0;

  for (let i = 0; i < iterations; i++) {

    sum += i;

  }

  console.timeEnd('Main thread (blocking)');

  // UI is frozen during calculation

  

  // With worker (non-blocking)

  const worker = new Worker('calc-worker.js');

  

  console.time('Worker (non-blocking)');

  worker.postMessage({ iterations });

  worker.onmessage = function(e) {

    console.timeEnd('Worker (non-blocking)');

    console.log('Result:', e.data);

    // UI remains responsive

  };

}



// Consider overhead:

// - Worker creation time

// - Message passing overhead

// - Memory copying for large data



// Use Transferable Objects for large data

const largeArray = new Uint8Array(1024 * 1024 * 10); // 10MB

worker.postMessage({ data: largeArray }, [largeArray.buffer]);

// Array is transferred (moved), not copied

// largeArray is now unusable in main thread

```



#### **Key Takeaways**



- **Web Workers** run JavaScript in background threads

- **Prevent UI blocking** during heavy computations

- **No DOM access** - workers can't manipulate page

- **Message passing** via postMessage/onmessage

- **Dedicated workers** tied to single page

- **Shared workers** accessible from multiple pages/tabs

- **Transferable objects** for efficient large data transfer

- **importScripts** to load libraries in workers

- **Worker pool** for parallel task processing

- **Good for**: image processing, data analysis, cryptography

- **Overhead exists** - message passing has cost

- **Use for expensive** operations (>50ms)

- **Check support** with `if (window.Worker)`

- **Always terminate** workers when done

- **Essential for** maintaining smooth user experience



---



</details>
<details><summary>86. What is the difference between localStorage and sessionStorage?</summary>




**Answer:**



Both `localStorage` and `sessionStorage` are Web Storage APIs that store key-value pairs in the browser. The main difference is **persistence**: `localStorage` data persists indefinitely until explicitly cleared, while `sessionStorage` data is cleared when the page session ends (browser tab closes). Both have the same API and 5-10MB storage limit per origin, but different use cases and lifetimes.



#### **Basic Comparison**



```javascript

// localStorage - persists forever

localStorage.setItem('user', 'John');

console.log(localStorage.getItem('user')); // 'John'

// Still available after browser restart



// sessionStorage - cleared when tab closes

sessionStorage.setItem('tempUser', 'Jane');

console.log(sessionStorage.getItem('tempUser')); // 'Jane'

// Lost when tab/window closes



// Both use the same API

// setItem(key, value)

// getItem(key)

// removeItem(key)

// clear()

// key(index)

// length property

```



#### **1. Persistence Differences**



```javascript

// localStorage - survives:

// ✅ Browser restart

// ✅ Tab close/reopen

// ✅ Computer restart

// ✅ Indefinitely (until manually cleared)



localStorage.setItem('permanent', 'I will survive');

// Close browser, reopen, still there



// sessionStorage - cleared when:

// ❌ Tab is closed

// ❌ Browser is closed

// ❌ Page session ends

// ✅ Survives page refresh (F5)

// ✅ Survives navigation within same tab



sessionStorage.setItem('temporary', 'I will disappear');

// Close tab - data is gone



// Page refresh example

sessionStorage.setItem('counter', '0');



// After refresh:

let counter = parseInt(sessionStorage.getItem('counter') || '0');

counter++;

sessionStorage.setItem('counter', counter.toString());

// Counter persists across refreshes within same session

```



#### **2. Scope Differences**



```javascript

// localStorage - shared across:

// ✅ All tabs/windows from same origin

// ✅ All browser instances



// Tab 1

localStorage.setItem('shared', 'visible everywhere');



// Tab 2 (same origin)

console.log(localStorage.getItem('shared')); // 'visible everywhere'



// sessionStorage - isolated to:

// ❌ Only the specific tab/window

// ❌ Not shared between tabs



// Tab 1

sessionStorage.setItem('isolated', 'only in this tab');



// Tab 2 (same origin)

console.log(sessionStorage.getItem('isolated')); // null (not accessible)



// Duplicate tab (Ctrl+Shift+T or right-click > Duplicate)

// sessionStorage IS copied to the duplicate tab

```



#### **3. Complete API Usage**



```javascript

// SET ITEM

localStorage.setItem('name', 'John');

sessionStorage.setItem('name', 'Jane');



// GET ITEM

const localName = localStorage.getItem('name');    // 'John'

const sessionName = sessionStorage.getItem('name'); // 'Jane'

const missing = localStorage.getItem('nonexistent'); // null



// REMOVE ITEM

localStorage.removeItem('name');

sessionStorage.removeItem('name');



// CLEAR ALL

localStorage.clear();   // Removes all localStorage items

sessionStorage.clear(); // Removes all sessionStorage items



// KEY ACCESS (by index)

localStorage.setItem('a', '1');

localStorage.setItem('b', '2');

console.log(localStorage.key(0));  // 'a' or 'b' (order not guaranteed)

console.log(localStorage.key(1));  // 'b' or 'a'



// LENGTH

console.log(localStorage.length);   // Number of items

console.log(sessionStorage.length);



// ITERATE

for (let i = 0; i < localStorage.length; i++) {

  const key = localStorage.key(i);

  const value = localStorage.getItem(key);

  console.log(key, value);

}



// Object-like access (not recommended, but works)

localStorage.myKey = 'value';          // Same as setItem

console.log(localStorage.myKey);       // Same as getItem

delete localStorage.myKey;             // Same as removeItem

```



#### **4. Storing Complex Data**



```javascript

// localStorage/sessionStorage only store strings

// Must serialize objects



// STORING OBJECTS

const user = {

  id: 123,

  name: 'John Doe',

  email: 'john@example.com',

  preferences: {

    theme: 'dark',

    notifications: true

  }

};



// Convert to JSON string

localStorage.setItem('user', JSON.stringify(user));



// Retrieve and parse

const storedUser = JSON.parse(localStorage.getItem('user'));

console.log(storedUser.name);        // 'John Doe'

console.log(storedUser.preferences.theme); // 'dark'



// STORING ARRAYS

const todos = ['Task 1', 'Task 2', 'Task 3'];

localStorage.setItem('todos', JSON.stringify(todos));



const storedTodos = JSON.parse(localStorage.getItem('todos'));

console.log(storedTodos[0]); // 'Task 1'



// STORING DATES (special handling)

const now = new Date();

localStorage.setItem('timestamp', now.toISOString());



const storedDate = new Date(localStorage.getItem('timestamp'));

console.log(storedDate);



// HELPER FUNCTIONS

const storage = {

  set(key, value) {

    try {

      localStorage.setItem(key, JSON.stringify(value));

      return true;

    } catch (e) {

      console.error('Storage error:', e);

      return false;

    }

  },

  

  get(key, defaultValue = null) {

    try {

      const item = localStorage.getItem(key);

      return item ? JSON.parse(item) : defaultValue;

    } catch (e) {

      console.error('Parse error:', e);

      return defaultValue;

    }

  },

  

  remove(key) {

    localStorage.removeItem(key);

  },

  

  clear() {

    localStorage.clear();

  }

};



// Usage

storage.set('user', { name: 'John', age: 30 });

const user = storage.get('user');

```



#### **5. Storage Events**



```javascript

// Listen for storage changes (only fires in OTHER tabs/windows)

window.addEventListener('storage', (e) => {

  console.log('Storage changed:');

  console.log('Key:', e.key);           // Key that changed

  console.log('Old value:', e.oldValue); // Previous value

  console.log('New value:', e.newValue); // New value

  console.log('URL:', e.url);           // Page URL where change occurred

  console.log('Storage:', e.storageArea); // localStorage or sessionStorage

});



// Tab 1 - make change

localStorage.setItem('username', 'John');



// Tab 2 - receives event

// Event fires with details about the change



// Note: Event does NOT fire in the tab that made the change

// Only fires in other tabs/windows from same origin



// Practical example: Sync logout across tabs

window.addEventListener('storage', (e) => {

  if (e.key === 'logout') {

    console.log('User logged out in another tab');

    // Redirect to login page

    window.location.href = '/login';

  }

});



// In any tab, trigger logout

localStorage.setItem('logout', Date.now().toString());

localStorage.removeItem('logout'); // Clean up

```



#### **Practical Examples**



**1. User Preferences:**

```javascript

// localStorage for persistent preferences

class Preferences {

  static save(key, value) {

    const prefs = this.getAll();

    prefs[key] = value;

    localStorage.setItem('preferences', JSON.stringify(prefs));

  }

  

  static get(key, defaultValue = null) {

    const prefs = this.getAll();

    return prefs[key] ?? defaultValue;

  }

  

  static getAll() {

    const prefs = localStorage.getItem('preferences');

    return prefs ? JSON.parse(prefs) : {};

  }

  

  static clear() {

    localStorage.removeItem('preferences');

  }

}



// Usage

Preferences.save('theme', 'dark');

Preferences.save('fontSize', 16);

Preferences.save('language', 'en');



console.log(Preferences.get('theme'));     // 'dark'

console.log(Preferences.getAll());         // { theme: 'dark', fontSize: 16, ... }



// Apply theme on page load

document.addEventListener('DOMContentLoaded', () => {

  const theme = Preferences.get('theme', 'light');

  document.body.classList.add(`theme-${theme}`);

});

```



**2. Shopping Cart:**

```javascript

// localStorage for persistent cart

class ShoppingCart {

  constructor() {

    this.storageKey = 'shopping-cart';

  }

  

  getItems() {

    const cart = localStorage.getItem(this.storageKey);

    return cart ? JSON.parse(cart) : [];

  }

  

  addItem(product) {

    const items = this.getItems();

    const existing = items.find(item => item.id === product.id);

    

    if (existing) {

      existing.quantity++;

    } else {

      items.push({ ...product, quantity: 1 });

    }

    

    localStorage.setItem(this.storageKey, JSON.stringify(items));

  }

  

  removeItem(productId) {

    let items = this.getItems();

    items = items.filter(item => item.id !== productId);

    localStorage.setItem(this.storageKey, JSON.stringify(items));

  }

  

  getTotal() {

    const items = this.getItems();

    return items.reduce((sum, item) => sum + (item.price * item.quantity), 0);

  }

  

  clear() {

    localStorage.removeItem(this.storageKey);

  }

}



const cart = new ShoppingCart();

cart.addItem({ id: 1, name: 'Product 1', price: 29.99 });

console.log(cart.getTotal()); // 29.99

```



**3. Form Data Backup:**

```javascript

// sessionStorage for temporary form data

class FormBackup {

  constructor(formId) {

    this.formId = formId;

    this.storageKey = `form-backup-${formId}`;

  }

  

  save() {

    const form = document.getElementById(this.formId);

    const formData = new FormData(form);

    const data = Object.fromEntries(formData);

    

    sessionStorage.setItem(this.storageKey, JSON.stringify(data));

  }

  

  restore() {

    const saved = sessionStorage.getItem(this.storageKey);

    if (!saved) return false;

    

    const data = JSON.parse(saved);

    const form = document.getElementById(this.formId);

    

    Object.entries(data).forEach(([name, value]) => {

      const field = form.elements[name];

      if (field) field.value = value;

    });

    

    return true;

  }

  

  clear() {

    sessionStorage.removeItem(this.storageKey);

  }

}



// Usage

const formBackup = new FormBackup('contact-form');



// Auto-save on input

document.getElementById('contact-form').addEventListener('input', () => {

  formBackup.save();

});



// Restore on page load

window.addEventListener('DOMContentLoaded', () => {

  if (formBackup.restore()) {

    console.log('Form data restored');

  }

});



// Clear after successful submit

document.getElementById('contact-form').addEventListener('submit', (e) => {

  e.preventDefault();

  // Submit form...

  formBackup.clear();

});

```



**4. Authentication Token:**

```javascript

// localStorage for persistent login, sessionStorage for temporary

class Auth {

  static saveToken(token, remember = false) {

    if (remember) {

      localStorage.setItem('authToken', token);

      localStorage.setItem('tokenExpiry', Date.now() + (30 * 24 * 60 * 60 * 1000)); // 30 days

    } else {

      sessionStorage.setItem('authToken', token);

    }

  }

  

  static getToken() {

    // Check localStorage first

    const localToken = localStorage.getItem('authToken');

    if (localToken) {

      const expiry = localStorage.getItem('tokenExpiry');

      if (Date.now() < parseInt(expiry)) {

        return localToken;

      } else {

        this.clearToken(); // Expired

      }

    }

    

    // Check sessionStorage

    return sessionStorage.getItem('authToken');

  }

  

  static isAuthenticated() {

    return !!this.getToken();

  }

  

  static clearToken() {

    localStorage.removeItem('authToken');

    localStorage.removeItem('tokenExpiry');

    sessionStorage.removeItem('authToken');

  }

}



// Login

function login(username, password, rememberMe) {

  // API call...

  const token = 'abc123';

  Auth.saveToken(token, rememberMe);

}



// Check auth

if (Auth.isAuthenticated()) {

  // User is logged in

  const token = Auth.getToken();

  // Use token for API calls

}



// Logout

Auth.clearToken();

```



**5. Multi-Tab Synchronization:**

```javascript

// Sync state across tabs using localStorage + storage event

class TabSync {

  constructor(key) {

    this.key = key;

    this.listeners = [];

    

    window.addEventListener('storage', (e) => {

      if (e.key === this.key && e.newValue) {

        const data = JSON.parse(e.newValue);

        this.notifyListeners(data);

      }

    });

  }

  

  broadcast(data) {

    localStorage.setItem(this.key, JSON.stringify(data));

  }

  

  onChange(callback) {

    this.listeners.push(callback);

  }

  

  notifyListeners(data) {

    this.listeners.forEach(callback => callback(data));

  }

}



// Usage

const sync = new TabSync('app-state');



sync.onChange((data) => {

  console.log('State updated in another tab:', data);

  updateUI(data);

});



// Broadcast change

sync.broadcast({ user: 'John', status: 'online' });

```



#### **Comparison Table**



| Feature | localStorage | sessionStorage |

|---------|-------------|----------------|

| **Lifetime** | Permanent (until cleared) | Page session (tab closes) |

| **Scope** | All tabs/windows (same origin) | Single tab/window |

| **Survives refresh** | Yes | Yes |

| **Survives browser close** | Yes | No |

| **Survives tab close** | Yes | No |

| **Shared across tabs** | Yes | No |

| **Storage limit** | ~5-10MB | ~5-10MB |

| **API** | Same | Same |

| **Storage event** | Fires in other tabs | Fires in other tabs |

| **Use case** | Persistent data | Temporary data |



#### **Best Practices**



```javascript

// 1. Always handle quota exceeded errors

try {

  localStorage.setItem('key', 'value');

} catch (e) {

  if (e.name === 'QuotaExceededError') {

    console.error('Storage quota exceeded');

    // Clear old data or notify user

  }

}



// 2. Check for storage support

function storageAvailable(type) {

  try {

    const storage = window[type];

    const test = '__storage_test__';

    storage.setItem(test, test);

    storage.removeItem(test);

    return true;

  } catch (e) {

    return false;

  }

}



if (storageAvailable('localStorage')) {

  // localStorage is available

}



// 3. Namespace your keys

const APP_PREFIX = 'myapp_';



localStorage.setItem(APP_PREFIX + 'user', 'John');

localStorage.setItem(APP_PREFIX + 'settings', '{}');



// 4. Validate stored data

function getSafeItem(key, defaultValue) {

  try {

    const item = localStorage.getItem(key);

    return item ? JSON.parse(item) : defaultValue;

  } catch (e) {

    console.error('Invalid JSON:', e);

    return defaultValue;

  }

}



// 5. Clean up old data

function cleanupOldData() {

  const keys = [];

  for (let i = 0; i < localStorage.length; i++) {

    keys.push(localStorage.key(i));

  }

  

  keys.forEach(key => {

    if (key.startsWith('temp_')) {

      const timestamp = localStorage.getItem(key + '_timestamp');

      if (Date.now() - parseInt(timestamp) > 24 * 60 * 60 * 1000) {

        localStorage.removeItem(key);

        localStorage.removeItem(key + '_timestamp');

      }

    }

  });

}

```



#### **Key Takeaways**



- **localStorage** persists indefinitely

- **sessionStorage** cleared when tab closes

- **Same API** for both (setItem, getItem, removeItem, clear)

- **localStorage shared** across all tabs (same origin)

- **sessionStorage isolated** to single tab

- **5-10MB limit** for each (per origin)

- **Only strings** stored (use JSON for objects)

- **Storage events** fire in other tabs only

- **Use localStorage** for persistent preferences, cart

- **Use sessionStorage** for temporary form data, session state

- **Always try/catch** for quota errors

- **Validate data** when retrieving

- **Namespace keys** to avoid conflicts

- **Not secure** - don't store sensitive data

- **Synchronous API** - consider IndexedDB for large data



---



</details>
<details><summary>87. What are cookies?</summary>




**Answer:**



Cookies are small pieces of data (max 4KB) stored by the browser and sent with every HTTP request to the same domain. They're primarily used for session management, personalization, and tracking. Unlike localStorage/sessionStorage, cookies are automatically included in HTTP requests, making them essential for server-side authentication. They have configurable expiration, domain/path scope, and security attributes (HttpOnly, Secure, SameSite).



#### **Basic Cookie Operations**



```javascript

// SET COOKIE (basic)

document.cookie = "username=John";



// SET COOKIE with expiration

const expires = new Date();

expires.setDate(expires.getDate() + 7); // 7 days from now

document.cookie = `username=John; expires=${expires.toUTCString()}`;



// SET COOKIE with max-age (seconds)

document.cookie = "sessionId=abc123; max-age=3600"; // 1 hour



// SET COOKIE with path

document.cookie = "theme=dark; path=/";



// SET COOKIE with domain

document.cookie = "user=John; domain=.example.com";



// SET COOKIE with secure flag (HTTPS only)

document.cookie = "token=xyz; secure";



// SET COOKIE with HttpOnly (not accessible via JavaScript - must be set by server)

// document.cookie = "authToken=xyz; httpOnly"; // Doesn't work from JavaScript



// SET COOKIE with SameSite

document.cookie = "csrf=token; SameSite=Strict";



// GET ALL COOKIES

console.log(document.cookie); // "username=John; sessionId=abc123; theme=dark"



// DELETE COOKIE (set expiration to past)

document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/";

```



#### **1. Cookie Utility Functions**



```javascript

// Complete cookie utility

const Cookies = {

  // Set cookie

  set(name, value, options = {}) {

    let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;

    

    // Expiration

    if (options.days) {

      const expires = new Date();

      expires.setDate(expires.getDate() + options.days);

      cookieString += `; expires=${expires.toUTCString()}`;

    }

    

    if (options.maxAge) {

      cookieString += `; max-age=${options.maxAge}`;

    }

    

    // Path

    cookieString += `; path=${options.path || '/'}`;

    

    // Domain

    if (options.domain) {

      cookieString += `; domain=${options.domain}`;

    }

    

    // Secure

    if (options.secure) {

      cookieString += '; secure';

    }

    

    // SameSite

    if (options.sameSite) {

      cookieString += `; SameSite=${options.sameSite}`;

    }

    

    document.cookie = cookieString;

  },

  

  // Get cookie

  get(name) {

    const cookies = document.cookie.split('; ');

    

    for (const cookie of cookies) {

      const [key, value] = cookie.split('=');

      if (decodeURIComponent(key) === name) {

        return decodeURIComponent(value);

      }

    }

    

    return null;

  },

  

  // Get all cookies as object

  getAll() {

    const cookies = {};

    const cookieArray = document.cookie.split('; ');

    

    for (const cookie of cookieArray) {

      const [key, value] = cookie.split('=');

      if (key) {

        cookies[decodeURIComponent(key)] = decodeURIComponent(value);

      }

    }

    

    return cookies;

  },

  

  // Remove cookie

  remove(name, options = {}) {

    this.set(name, '', {

      ...options,

      maxAge: -1

    });

  },

  

  // Check if cookie exists

  has(name) {

    return this.get(name) !== null;

  }

};



// Usage

Cookies.set('username', 'John Doe', { days: 7 });

Cookies.set('theme', 'dark', { days: 365, path: '/' });

Cookies.set('sessionId', 'abc123', { maxAge: 3600 });



console.log(Cookies.get('username'));  // 'John Doe'

console.log(Cookies.getAll());         // { username: 'John Doe', theme: 'dark', ... }

console.log(Cookies.has('theme'));     // true



Cookies.remove('username');

```



#### **2. Cookie Attributes**



```javascript

// EXPIRES - specific date/time

const expires = new Date('2025-12-31');

Cookies.set('limited', 'value', { expires: expires.toUTCString() });



// MAX-AGE - seconds from now (preferred over expires)

Cookies.set('temp', 'value', { maxAge: 60 }); // 60 seconds



// PATH - cookie available only on specific path

Cookies.set('adminToken', 'xyz', { path: '/admin' });

// Available on /admin, /admin/users, etc.

// NOT available on / or /products



// DOMAIN - cookie available on domain and subdomains

Cookies.set('user', 'John', { domain: '.example.com' });

// Available on example.com, www.example.com, api.example.com



// SECURE - only sent over HTTPS

Cookies.set('authToken', 'secret', { secure: true });

// Won't be sent over HTTP connections



// HTTPONLY - not accessible via JavaScript (server-side only)

// Set-Cookie: sessionId=abc123; HttpOnly

// Cannot be set from JavaScript, only from server



// SAMESITE - CSRF protection

// Strict: Cookie only sent in first-party context

Cookies.set('csrf', 'token', { sameSite: 'Strict' });



// Lax: Cookie sent on top-level navigation

Cookies.set('session', 'xyz', { sameSite: 'Lax' });



// None: Cookie sent in all contexts (requires Secure)

Cookies.set('tracking', 'abc', { sameSite: 'None', secure: true });

```



#### **3. Storing Complex Data**



```javascript

// Cookies store strings only - serialize objects

const user = {

  id: 123,

  name: 'John Doe',

  role: 'admin'

};



// Store as JSON

Cookies.set('user', JSON.stringify(user), { days: 7 });



// Retrieve and parse

const storedUser = JSON.parse(Cookies.get('user'));

console.log(storedUser.name); // 'John Doe'



// Enhanced cookie utility with JSON support

const CookiesJSON = {

  set(name, value, options = {}) {

    const stringValue = typeof value === 'object' 

      ? JSON.stringify(value)

      : String(value);

    Cookies.set(name, stringValue, options);

  },

  

  get(name) {

    const value = Cookies.get(name);

    if (!value) return null;

    

    try {

      return JSON.parse(value);

    } catch (e) {

      return value; // Return as string if not JSON

    }

  }

};



// Usage

CookiesJSON.set('settings', { theme: 'dark', fontSize: 16 }, { days: 30 });

const settings = CookiesJSON.get('settings');

console.log(settings.theme); // 'dark'

```



#### **Practical Examples**



**1. Authentication Cookie:**

```javascript

class AuthCookies {

  static login(token, rememberMe = false) {

    const options = {

      path: '/',

      secure: true,

      sameSite: 'Strict'

    };

    

    if (rememberMe) {

      options.days = 30;

    } else {

      options.maxAge = 3600; // 1 hour

    }

    

    Cookies.set('authToken', token, options);

  }

  

  static getToken() {

    return Cookies.get('authToken');

  }

  

  static isAuthenticated() {

    return Cookies.has('authToken');

  }

  

  static logout() {

    Cookies.remove('authToken', { path: '/' });

  }

}



// Usage

AuthCookies.login('abc123', true); // Remember me

if (AuthCookies.isAuthenticated()) {

  const token = AuthCookies.getToken();

  // Use token for API calls

}

AuthCookies.logout();

```



**2. Consent Banner:**

```javascript

class CookieConsent {

  static COOKIE_NAME = 'cookie-consent';

  

  static hasConsent() {

    return Cookies.has(this.COOKIE_NAME);

  }

  

  static setConsent(categories) {

    Cookies.set(this.COOKIE_NAME, JSON.stringify(categories), {

      days: 365,

      path: '/',

      sameSite: 'Lax'

    });

  }

  

  static getConsent() {

    const consent = Cookies.get(this.COOKIE_NAME);

    return consent ? JSON.parse(consent) : null;

  }

  

  static showBanner() {

    if (this.hasConsent()) return;

    

    const banner = document.createElement('div');

    banner.className = 'cookie-banner';

    banner.innerHTML = `

      <p>We use cookies to improve your experience.</p>

      <button id="accept-all">Accept All</button>

      <button id="accept-necessary">Necessary Only</button>

    `;

    document.body.appendChild(banner);

    

    document.getElementById('accept-all').addEventListener('click', () => {

      this.setConsent({ necessary: true, analytics: true, marketing: true });

      banner.remove();

    });

    

    document.getElementById('accept-necessary').addEventListener('click', () => {

      this.setConsent({ necessary: true, analytics: false, marketing: false });

      banner.remove();

    });

  }

}



// On page load

CookieConsent.showBanner();

```



**3. Shopping Cart:**

```javascript

class CartCookies {

  static COOKIE_NAME = 'shopping-cart';

  static MAX_AGE = 7 * 24 * 60 * 60; // 7 days in seconds

  

  static getCart() {

    const cart = Cookies.get(this.COOKIE_NAME);

    return cart ? JSON.parse(cart) : [];

  }

  

  static saveCart(cart) {

    // Keep under 4KB limit

    const cartString = JSON.stringify(cart);

    if (cartString.length > 4000) {

      console.warn('Cart too large for cookie');

      // Consider using localStorage instead

      return false;

    }

    

    Cookies.set(this.COOKIE_NAME, cartString, {

      maxAge: this.MAX_AGE,

      path: '/',

      sameSite: 'Lax'

    });

    return true;

  }

  

  static addItem(item) {

    const cart = this.getCart();

    const existing = cart.find(i => i.id === item.id);

    

    if (existing) {

      existing.quantity++;

    } else {

      cart.push({ ...item, quantity: 1 });

    }

    

    this.saveCart(cart);

  }

  

  static removeItem(itemId) {

    let cart = this.getCart();

    cart = cart.filter(item => item.id !== itemId);

    this.saveCart(cart);

  }

  

  static clear() {

    Cookies.remove(this.COOKIE_NAME, { path: '/' });

  }

}



// Usage

CartCookies.addItem({ id: 1, name: 'Product 1', price: 29.99 });

console.log(CartCookies.getCart());

```



**4. Language Preference:**

```javascript

class LanguagePreference {

  static COOKIE_NAME = 'lang';

  

  static set(language) {

    Cookies.set(this.COOKIE_NAME, language, {

      days: 365,

      path: '/',

      sameSite: 'Lax'

    });

    

    // Apply language

    document.documentElement.lang = language;

    this.loadTranslations(language);

  }

  

  static get() {

    return Cookies.get(this.COOKIE_NAME) || 'en';

  }

  

  static loadTranslations(lang) {

    // Load language-specific content

    console.log(`Loading ${lang} translations`);

  }

}



// On page load

const lang = LanguagePreference.get();

LanguagePreference.set(lang);



// Language selector

document.getElementById('lang-select').addEventListener('change', (e) => {

  LanguagePreference.set(e.target.value);

});

```



**5. Session Tracking:**

```javascript

class SessionTracker {

  static init() {

    if (!this.getSessionId()) {

      this.createSession();

    }

    this.trackPageView();

  }

  

  static createSession() {

    const sessionId = this.generateId();

    Cookies.set('sessionId', sessionId, {

      maxAge: 30 * 60, // 30 minutes

      path: '/',

      sameSite: 'Lax'

    });

  }

  

  static getSessionId() {

    return Cookies.get('sessionId');

  }

  

  static trackPageView() {

    const sessionId = this.getSessionId();

    const pageViews = parseInt(Cookies.get('pageViews') || '0');

    

    Cookies.set('pageViews', String(pageViews + 1), {

      maxAge: 30 * 60,

      path: '/'

    });

    

    // Send to analytics

    console.log(`Session ${sessionId}: Page view ${pageViews + 1}`);

  }

  

  static generateId() {

    return Math.random().toString(36).substr(2, 9);

  }

}



// Initialize

SessionTracker.init();

```



#### **Cookies vs localStorage vs sessionStorage**



```javascript

// COOKIES:

// ✅ Sent with every HTTP request

// ✅ Can be set by server (Set-Cookie header)

// ✅ Configurable expiration

// ✅ HttpOnly flag (secure from JavaScript)

// ✅ Domain/path scoping

// ❌ 4KB size limit

// ❌ Increase request size

// Use for: Authentication, session management



// localStorage:

// ✅ 5-10MB storage

// ✅ Simple API

// ✅ Persists forever

// ✅ Not sent with requests

// ❌ No expiration

// ❌ Same origin only

// ❌ Synchronous

// Use for: Persistent user data, preferences



// sessionStorage:

// ✅ 5-10MB storage

// ✅ Tab-isolated

// ✅ Cleared on tab close

// ✅ Not sent with requests

// ❌ Not shared across tabs

// ❌ No expiration control

// Use for: Temporary session data

```



#### **Security Considerations**



```javascript

// 1. Always use Secure flag for sensitive cookies (HTTPS only)

Cookies.set('authToken', 'secret', {

  secure: true,

  sameSite: 'Strict'

});



// 2. Use HttpOnly for authentication (set from server)

// Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict



// 3. Use SameSite to prevent CSRF

Cookies.set('csrf-token', 'xyz', {

  sameSite: 'Strict',  // or 'Lax'

  secure: true

});



// 4. Never store sensitive data in cookies

// ❌ Bad

Cookies.set('creditCard', '1234-5678-9012-3456');

Cookies.set('password', 'mypassword');



// ✅ Good - store only tokens/IDs

Cookies.set('sessionId', 'abc123', {

  httpOnly: true,  // Set from server

  secure: true,

  sameSite: 'Strict'

});



// 5. Validate and sanitize cookie values

function sanitizeCookieValue(value) {

  // Remove potentially harmful characters

  return value.replace(/[;\s]/g, '');

}



// 6. Set appropriate expiration

Cookies.set('temp', 'value', { maxAge: 3600 }); // 1 hour only

```



#### **Key Takeaways**



- **Cookies** are small data (max 4KB) stored by browser

- **Sent with every** HTTP request to same domain

- **Essential for** server-side authentication

- **Configurable expiration** (expires, max-age)

- **Domain/path scoping** controls where cookie is sent

- **Secure flag** requires HTTPS

- **HttpOnly flag** prevents JavaScript access (server-only)

- **SameSite attribute** prevents CSRF attacks

- **Use for** authentication, session management, tracking

- **Not for** large data (use localStorage)

- **Always encode** values (special characters)

- **Security critical** - use Secure, HttpOnly, SameSite

- **Increase request size** - consider impact

- **Check size limit** (4KB per cookie, ~180 cookies per domain)

- **Modern preference**: localStorage for client-side data, cookies for auth





</details>
<details><summary>82. What is memoization?</summary>






</details>
<details><summary>83. What is debouncing?</summary>






</details>
<details><summary>84. What is throttling?</summary>






</details>
<details><summary>85. What are Web Workers?</summary>






</details>
<details><summary>86. What is the difference between localStorage and sessionStorage?</summary>






</details>
<details><summary>87. What are cookies?</summary>






---



</details>
<details><summary>88. What is JSON and how do you parse it?</summary>




**Answer:**



JSON (JavaScript Object Notation) is a lightweight, text-based data interchange format that's easy for humans to read and write, and easy for machines to parse and generate. It uses JavaScript object syntax but is language-independent. JSON supports strings, numbers, booleans, null, arrays, and objects. JavaScript provides `JSON.parse()` to convert JSON strings to JavaScript objects and `JSON.stringify()` to convert JavaScript objects to JSON strings.



#### **Basic JSON Syntax**



```javascript

// Valid JSON

const jsonString = `{

  "name": "John Doe",

  "age": 30,

  "isActive": true,

  "email": null,

  "hobbies": ["reading", "gaming", "coding"],

  "address": {

    "street": "123 Main St",

    "city": "New York",

    "zip": "10001"

  }

}`;



// JSON Rules:

// ✅ Property names MUST be in double quotes

// ✅ String values MUST use double quotes

// ✅ Supports: string, number, boolean, null, array, object

// ❌ No functions, undefined, Date objects, RegExp, or comments

// ❌ No trailing commas

// ❌ Single quotes not allowed for strings



// Invalid JSON examples:

// { name: "John" }              // ❌ Missing quotes on key

// { "name": 'John' }            // ❌ Single quotes

// { "age": undefined }          // ❌ undefined not allowed

// { "greet": function() {} }    // ❌ Functions not allowed

// { "items": [1, 2, 3,] }       // ❌ Trailing comma

```



#### **1. JSON.parse() - String to Object**



```javascript

// Basic parsing

const jsonString = '{"name":"John","age":30}';

const obj = JSON.parse(jsonString);



console.log(obj.name);  // 'John'

console.log(obj.age);   // 30

console.log(typeof obj); // 'object'



// Parsing arrays

const arrayString = '[1, 2, 3, 4, 5]';

const arr = JSON.parse(arrayString);

console.log(arr[0]);  // 1

console.log(Array.isArray(arr));  // true



// Parsing nested structures

const complexString = `{

  "user": {

    "id": 123,

    "profile": {

      "name": "John",

      "email": "john@example.com"

    }

  },

  "posts": [

    {"id": 1, "title": "First Post"},

    {"id": 2, "title": "Second Post"}

  ]

}`;



const data = JSON.parse(complexString);

console.log(data.user.profile.name);  // 'John'

console.log(data.posts[0].title);     // 'First Post'



// Parsing primitives

console.log(JSON.parse('"hello"'));   // 'hello'

console.log(JSON.parse('123'));       // 123

console.log(JSON.parse('true'));      // true

console.log(JSON.parse('null'));      // null

```



#### **2. JSON.stringify() - Object to String**



```javascript

// Basic stringification

const obj = {

  name: 'John',

  age: 30,

  isActive: true

};



const jsonString = JSON.stringify(obj);

console.log(jsonString);  // '{"name":"John","age":30,"isActive":true}'



// Stringify with indentation (pretty print)

const prettyJson = JSON.stringify(obj, null, 2);

console.log(prettyJson);

// {

//   "name": "John",

//   "age": 30,

//   "isActive": true

// }



// Stringify arrays

const arr = [1, 2, 3, { name: 'test' }];

console.log(JSON.stringify(arr));  // '[1,2,3,{"name":"test"}]'



// What gets stringified

const testObj = {

  string: 'hello',

  number: 42,

  boolean: true,

  null: null,

  array: [1, 2, 3],

  object: { nested: 'value' },

  

  // These are ignored or converted:

  undefined: undefined,        // Ignored in objects

  function: function() {},     // Ignored

  symbol: Symbol('test'),      // Ignored

  date: new Date(),            // Converted to ISO string

  regexp: /test/               // Converted to {}

};



console.log(JSON.stringify(testObj));

// {"string":"hello","number":42,"boolean":true,"null":null,

//  "array":[1,2,3],"object":{"nested":"value"},

//  "date":"2025-12-20T..."}



// Array stringification (undefined becomes null)

console.log(JSON.stringify([1, undefined, 3]));  // '[1,null,3]'

```



#### **3. JSON.parse() with Reviver Function**



```javascript

// Reviver function transforms parsed values

const jsonString = `{

  "name": "John",

  "age": 30,

  "birthdate": "1995-06-15",

  "salary": "50000",

  "metadata": "skip"

}`;



const obj = JSON.parse(jsonString, (key, value) => {

  // Convert date strings to Date objects

  if (key === 'birthdate') {

    return new Date(value);

  }

  

  // Convert string numbers to actual numbers

  if (key === 'salary') {

    return parseFloat(value);

  }

  

  // Skip certain properties

  if (key === 'metadata') {

    return undefined;  // Property will be omitted

  }

  

  // Return value unchanged for other keys

  return value;

});



console.log(obj.birthdate instanceof Date);  // true

console.log(typeof obj.salary);              // 'number'

console.log('metadata' in obj);              // false



// Real-world example: Parse dates

const apiResponse = `{

  "id": 1,

  "createdAt": "2025-01-01T12:00:00.000Z",

  "updatedAt": "2025-01-15T08:30:00.000Z"

}`;



const parsed = JSON.parse(apiResponse, (key, value) => {

  // Convert ISO date strings to Date objects

  if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T/.test(value)) {

    return new Date(value);

  }

  return value;

});



console.log(parsed.createdAt instanceof Date);  // true

console.log(parsed.createdAt.getFullYear());    // 2025

```



#### **4. JSON.stringify() with Replacer Function**



```javascript

// Replacer function filters/transforms values

const user = {

  id: 123,

  name: 'John',

  password: 'secret123',

  email: 'john@example.com',

  creditCard: '1234-5678-9012-3456',

  age: 30

};



// Filter out sensitive data

const safeJson = JSON.stringify(user, (key, value) => {

  // Remove sensitive fields

  if (key === 'password' || key === 'creditCard') {

    return undefined;  // Omit from output

  }

  return value;

});



console.log(safeJson);

// {"id":123,"name":"John","email":"john@example.com","age":30}



// Transform values

const transformed = JSON.stringify(user, (key, value) => {

  // Mask credit card numbers

  if (key === 'creditCard') {

    return '****-****-****-' + value.slice(-4);

  }

  // Convert strings to uppercase

  if (typeof value === 'string') {

    return value.toUpperCase();

  }

  return value;

});



// Replacer with array (whitelist properties)

const selected = JSON.stringify(user, ['id', 'name', 'email']);

console.log(selected);  // {"id":123,"name":"John","email":"john@example.com"}

```



#### **5. Error Handling**



```javascript

// JSON.parse() throws SyntaxError for invalid JSON

function safeParse(jsonString, defaultValue = null) {

  try {

    return JSON.parse(jsonString);

  } catch (error) {

    console.error('JSON parse error:', error.message);

    return defaultValue;

  }

}



// Invalid JSON examples

console.log(safeParse('invalid json'));           // null

console.log(safeParse("{name: 'John'}"));         // null (single quotes)

console.log(safeParse('{"age": undefined}'));     // null (undefined)

console.log(safeParse('{"items": [1,2,3,]}'));    // null (trailing comma)



// JSON.stringify() errors

const circular = { name: 'John' };

circular.self = circular;  // Circular reference



try {

  JSON.stringify(circular);

} catch (error) {

  console.error('Stringify error:', error.message);

  // TypeError: Converting circular structure to JSON

}



// Safe stringify with error handling

function safeStringify(obj, fallback = '{}') {

  try {

    return JSON.stringify(obj);

  } catch (error) {

    console.error('Stringify error:', error.message);

    return fallback;

  }

}

```



#### **6. Working with Dates**



```javascript

// Date serialization/deserialization

const data = {

  name: 'Event',

  date: new Date('2025-12-31'),

  timestamp: Date.now()

};



// Dates are converted to ISO strings

const jsonString = JSON.stringify(data);

console.log(jsonString);

// {"name":"Event","date":"2025-12-31T00:00:00.000Z","timestamp":1735689600000}



// Parse back with date conversion

const parsed = JSON.parse(jsonString);

console.log(typeof parsed.date);  // 'string' (not Date!)



// Convert date strings back to Date objects

const restored = JSON.parse(jsonString, (key, value) => {

  if (key === 'date' && typeof value === 'string') {

    return new Date(value);

  }

  return value;

});



console.log(restored.date instanceof Date);  // true



// Custom date handling

class DateAwareJSON {

  static stringify(obj) {

    return JSON.stringify(obj, (key, value) => {

      if (value instanceof Date) {

        return { __type: 'Date', value: value.toISOString() };

      }

      return value;

    });

  }

  

  static parse(str) {

    return JSON.parse(str, (key, value) => {

      if (value && value.__type === 'Date') {

        return new Date(value.value);

      }

      return value;

    });

  }

}



const obj = { name: 'Test', created: new Date() };

const json = DateAwareJSON.stringify(obj);

const parsed2 = DateAwareJSON.parse(json);

console.log(parsed2.created instanceof Date);  // true

```



#### **Practical Examples**



**1. API Data Handling:**

```javascript

// Fetch and parse JSON from API

async function fetchUserData(userId) {

  try {

    const response = await fetch(`/api/users/${userId}`);

    

    if (!response.ok) {

      throw new Error(`HTTP error! status: ${response.status}`);

    }

    

    // response.json() internally uses JSON.parse()

    const userData = await response.json();

    

    return userData;

  } catch (error) {

    console.error('Error fetching user data:', error);

    return null;

  }

}



// Send JSON to API

async function updateUserData(userId, data) {

  try {

    const response = await fetch(`/api/users/${userId}`, {

      method: 'PUT',

      headers: {

        'Content-Type': 'application/json'

      },

      body: JSON.stringify(data)  // Convert object to JSON string

    });

    

    const result = await response.json();

    return result;

  } catch (error) {

    console.error('Error updating user:', error);

    return null;

  }

}



// Usage

const user = await fetchUserData(123);

console.log(user.name);



await updateUserData(123, { name: 'John Updated' });

```



**2. Local Storage with JSON:**

```javascript

// Store complex objects in localStorage

class StorageHelper {

  static set(key, value) {

    try {

      const jsonString = JSON.stringify(value);

      localStorage.setItem(key, jsonString);

      return true;

    } catch (error) {

      console.error('Storage error:', error);

      return false;

    }

  }

  

  static get(key, defaultValue = null) {

    try {

      const jsonString = localStorage.getItem(key);

      return jsonString ? JSON.parse(jsonString) : defaultValue;

    } catch (error) {

      console.error('Parse error:', error);

      return defaultValue;

    }

  }

  

  static remove(key) {

    localStorage.removeItem(key);

  }

  

  static clear() {

    localStorage.clear();

  }

}



// Usage

const settings = {

  theme: 'dark',

  fontSize: 16,

  notifications: {

    email: true,

    push: false

  }

};



StorageHelper.set('userSettings', settings);

const retrieved = StorageHelper.get('userSettings');

console.log(retrieved.theme);  // 'dark'

```



**3. Deep Cloning Objects:**

```javascript

// Quick deep clone using JSON (with limitations)

const original = {

  name: 'John',

  age: 30,

  hobbies: ['reading', 'gaming'],

  address: {

    street: '123 Main St',

    city: 'New York'

  }

};



// Deep clone (simple objects only)

const clone = JSON.parse(JSON.stringify(original));



clone.address.city = 'Los Angeles';

console.log(original.address.city);  // 'New York' (not affected)

console.log(clone.address.city);     // 'Los Angeles'



// Limitations of JSON cloning

const complexObj = {

  date: new Date(),

  func: function() {},

  regex: /test/,

  undefined: undefined,

  symbol: Symbol('test')

};



const cloned = JSON.parse(JSON.stringify(complexObj));

console.log(cloned);

// {

//   date: "2025-12-20T..." (converted to string)

//   regex: {} (lost pattern)

//   // func, undefined, symbol are omitted

// }



// For complex objects, use structuredClone() or libraries

const betterClone = structuredClone(original);

```



**4. Configuration Files:**

```javascript

// Load and parse configuration

async function loadConfig(configPath) {

  try {

    const response = await fetch(configPath);

    const configText = await response.text();

    

    // Parse with defaults

    const config = JSON.parse(configText, (key, value) => {

      // Convert environment-specific values

      if (key === 'debug' && value === 'auto') {

        return process.env.NODE_ENV !== 'production';

      }

      return value;

    });

    

    return config;

  } catch (error) {

    console.error('Config load error:', error);

    return getDefaultConfig();

  }

}



function getDefaultConfig() {

  return {

    apiUrl: 'http://localhost:3000',

    timeout: 5000,

    debug: false

  };

}



// Usage

const config = await loadConfig('/config.json');

console.log(config.apiUrl);

```



**5. Form Data Serialization:**

```javascript

// Convert form data to JSON

class FormSerializer {

  static serialize(form) {

    const formData = new FormData(form);

    const obj = {};

    

    for (const [key, value] of formData.entries()) {

      // Handle multiple values (checkboxes)

      if (obj[key]) {

        if (!Array.isArray(obj[key])) {

          obj[key] = [obj[key]];

        }

        obj[key].push(value);

      } else {

        obj[key] = value;

      }

    }

    

    return JSON.stringify(obj);

  }

  

  static deserialize(jsonString, form) {

    try {

      const obj = JSON.parse(jsonString);

      

      Object.entries(obj).forEach(([name, value]) => {

        const field = form.elements[name];

        if (field) {

          if (field.type === 'checkbox') {

            field.checked = value;

          } else if (field.type === 'radio') {

            const radio = form.querySelector(`input[name="${name}"][value="${value}"]`);

            if (radio) radio.checked = true;

          } else {

            field.value = value;

          }

        }

      });

      

      return true;

    } catch (error) {

      console.error('Deserialize error:', error);

      return false;

    }

  }

}



// Usage

const form = document.getElementById('myForm');

const json = FormSerializer.serialize(form);



// Save to localStorage

localStorage.setItem('formBackup', json);



// Restore later

const saved = localStorage.getItem('formBackup');

FormSerializer.deserialize(saved, form);

```



**6. Data Transformation Pipeline:**

```javascript

// Transform API data with JSON

class DataTransformer {

  static transform(jsonString, transformations) {

    let data = JSON.parse(jsonString);

    

    transformations.forEach(transform => {

      data = transform(data);

    });

    

    return data;

  }

  

  static addTimestamps(data) {

    return {

      ...data,

      processedAt: new Date().toISOString()

    };

  }

  

  static filterSensitive(data) {

    const { password, ssn, creditCard, ...safe } = data;

    return safe;

  }

  

  static normalizeKeys(data) {

    const normalized = {};

    for (const [key, value] of Object.entries(data)) {

      const normalizedKey = key.toLowerCase().replace(/\s+/g, '_');

      normalized[normalizedKey] = value;

    }

    return normalized;

  }

}



// Usage

const apiResponse = '{"Name":"John","Age":30,"Password":"secret"}';



const transformed = DataTransformer.transform(apiResponse, [

  DataTransformer.normalizeKeys,

  DataTransformer.filterSensitive,

  DataTransformer.addTimestamps

]);



console.log(transformed);

// {

//   name: "John",

//   age: 30,

//   processedAt: "2025-12-20T..."

// }

```



**7. JSON Schema Validation:**

```javascript

// Basic JSON validation

class JSONValidator {

  static validate(jsonString, schema) {

    try {

      const data = JSON.parse(jsonString);

      return this.validateObject(data, schema);

    } catch (error) {

      return { valid: false, errors: ['Invalid JSON'] };

    }

  }

  

  static validateObject(data, schema) {

    const errors = [];

    

    for (const [key, rules] of Object.entries(schema)) {

      const value = data[key];

      

      // Required check

      if (rules.required && value === undefined) {

        errors.push(`${key} is required`);

        continue;

      }

      

      if (value !== undefined) {

        // Type check

        if (rules.type && typeof value !== rules.type) {

          errors.push(`${key} must be ${rules.type}`);

        }

        

        // Min/Max for numbers

        if (rules.type === 'number') {

          if (rules.min !== undefined && value < rules.min) {

            errors.push(`${key} must be at least ${rules.min}`);

          }

          if (rules.max !== undefined && value > rules.max) {

            errors.push(`${key} must be at most ${rules.max}`);

          }

        }

        

        // String length

        if (rules.type === 'string' && rules.minLength) {

          if (value.length < rules.minLength) {

            errors.push(`${key} must be at least ${rules.minLength} characters`);

          }

        }

      }

    }

    

    return {

      valid: errors.length === 0,

      errors

    };

  }

}



// Usage

const userSchema = {

  name: { type: 'string', required: true, minLength: 2 },

  age: { type: 'number', required: true, min: 0, max: 150 },

  email: { type: 'string', required: true }

};



const jsonData = '{"name":"Jo","age":30,"email":"john@example.com"}';

const result = JSONValidator.validate(jsonData, userSchema);



if (!result.valid) {

  console.log('Validation errors:', result.errors);

  // ["name must be at least 2 characters"]

}

```



#### **JSON Best Practices**



```javascript

// 1. Always handle parse errors

function parseJSON(jsonString) {

  try {

    return { success: true, data: JSON.parse(jsonString) };

  } catch (error) {

    return { success: false, error: error.message };

  }

}



// 2. Validate before parsing (optional)

function isValidJSON(str) {

  try {

    JSON.parse(str);

    return true;

  } catch (e) {

    return false;

  }

}



if (isValidJSON(userInput)) {

  const data = JSON.parse(userInput);

}



// 3. Use replacer to control serialization

const sensitiveData = {

  username: 'john',

  password: 'secret',

  token: 'abc123'

};



const safe = JSON.stringify(sensitiveData, ['username']);

// Only includes username



// 4. Pretty print for debugging

const debugJson = JSON.stringify(data, null, 2);

console.log(debugJson);



// 5. Handle circular references

function stringifyWithCircular(obj) {

  const seen = new WeakSet();

  

  return JSON.stringify(obj, (key, value) => {

    if (typeof value === 'object' && value !== null) {

      if (seen.has(value)) {

        return '[Circular]';

      }

      seen.add(value);

    }

    return value;

  });

}



// 6. Use Content-Type header

fetch('/api/data', {

  method: 'POST',

  headers: {

    'Content-Type': 'application/json'  // Important!

  },

  body: JSON.stringify({ key: 'value' })

});

```



#### **Common Mistakes**



```javascript

// 1. Forgetting to parse/stringify

// ❌ Bad

localStorage.setItem('user', { name: 'John' });  // Stores "[object Object]"



// ✅ Good

localStorage.setItem('user', JSON.stringify({ name: 'John' }));



// 2. Not handling errors

// ❌ Bad

const data = JSON.parse(userInput);  // Throws on invalid JSON



// ✅ Good

try {

  const data = JSON.parse(userInput);

} catch (error) {

  console.error('Invalid JSON:', error);

}



// 3. Assuming JSON preserves types

const obj = { date: new Date(), func: () => {} };

const clone = JSON.parse(JSON.stringify(obj));

// date is now a string, func is missing!



// 4. Not using Content-Type header

// ❌ Bad

fetch('/api', {

  method: 'POST',

  body: JSON.stringify(data)  // Server might not parse correctly

});



// ✅ Good

fetch('/api', {

  method: 'POST',

  headers: { 'Content-Type': 'application/json' },

  body: JSON.stringify(data)

});



// 5. Circular references

const obj = { name: 'test' };

obj.self = obj;

// JSON.stringify(obj);  // ❌ Throws error

```



#### **Key Takeaways**



- **JSON** is text-based data interchange format

- **Language-independent** but uses JavaScript syntax

- **JSON.parse()** converts string to object

- **JSON.stringify()** converts object to string

- **Supports**: string, number, boolean, null, array, object

- **Does NOT support**: functions, undefined, Date, RegExp, Symbol

- **Property names** must be double-quoted

- **String values** must use double quotes

- **No trailing commas** allowed

- **Reviver function** transforms parsed values

- **Replacer function** filters/transforms stringified values

- **Always handle** parse errors (try/catch)

- **Dates become strings** - need manual conversion

- **Circular references** throw errors

- **Deep clone trick** works for simple objects only

- **Essential for APIs** and data storage





</details>
<details><summary>88. What is JSON and how do you parse it?</summary>






---



</details>
<details><summary>89. What is the difference between synchronous and asynchronous code?</summary>




**Answer:**



Synchronous code executes sequentially, blocking each line until the current operation completes before moving to the next. Asynchronous code allows operations to run in the background without blocking the main thread, enabling other code to execute while waiting for long-running tasks (like API calls, file I/O, or timers) to complete. JavaScript is single-threaded but uses the event loop, callback queue, and Web APIs to handle asynchronous operations efficiently.



#### **Basic Concept**



```javascript

// SYNCHRONOUS - Blocks execution

console.log('1. First');

console.log('2. Second');

console.log('3. Third');

// Output (in order): 1. First, 2. Second, 3. Third



// ASYNCHRONOUS - Non-blocking

console.log('1. First');



setTimeout(() => {

  console.log('2. Second (async)');

}, 0);



console.log('3. Third');

// Output: 1. First, 3. Third, 2. Second (async)

// Even with 0ms delay, setTimeout is asynchronous

```



#### **1. Synchronous Code Execution**



```javascript

// Synchronous execution - each line waits for previous to complete

function synchronousExample() {

  console.log('Start');

  

  // Blocking operation

  const result = heavyCalculation(); // Must complete before next line

  console.log('Result:', result);

  

  console.log('End');

}



function heavyCalculation() {

  let sum = 0;

  for (let i = 0; i < 1000000000; i++) {

    sum += i;

  }

  return sum;

}



synchronousExample();

// Output (in order):

// Start

// Result: 499999999500000000 (after waiting)

// End



// Problem: UI freezes during heavy calculation

// User cannot interact with page until calculation completes

```



#### **2. Asynchronous Code with Callbacks**



```javascript

// Asynchronous execution with callbacks

function asyncExample() {

  console.log('Start');

  

  // Non-blocking - continues immediately

  setTimeout(() => {

    console.log('Async operation completed');

  }, 2000);

  

  console.log('End');

}



asyncExample();

// Output:

// Start

// End

// Async operation completed (after 2 seconds)



// Multiple async operations

console.log('1');



setTimeout(() => console.log('2 - timeout 0ms'), 0);

setTimeout(() => console.log('3 - timeout 100ms'), 100);



Promise.resolve().then(() => console.log('4 - promise'));



console.log('5');



// Output:

// 1

// 5

// 4 - promise (microtask - higher priority)

// 2 - timeout 0ms (macrotask)

// 3 - timeout 100ms (macrotask)

```



#### **3. Asynchronous Code with Promises**



```javascript

// Promise-based asynchronous code

function fetchUserData(userId) {

  return new Promise((resolve, reject) => {

    // Simulate API call

    setTimeout(() => {

      if (userId > 0) {

        resolve({ id: userId, name: 'John Doe', email: 'john@example.com' });

      } else {

        reject(new Error('Invalid user ID'));

      }

    }, 1000);

  });

}



// Using promises

console.log('Fetching user...');



fetchUserData(123)

  .then(user => {

    console.log('User:', user);

    return fetchUserData(456); // Chain another async operation

  })

  .then(user2 => {

    console.log('User 2:', user2);

  })

  .catch(error => {

    console.error('Error:', error);

  });



console.log('Request sent, continuing...');



// Output:

// Fetching user...

// Request sent, continuing...

// User: { id: 123, name: 'John Doe', ... } (after 1 second)

// User 2: { id: 456, name: 'John Doe', ... } (after 2 seconds total)

```



#### **4. Asynchronous Code with Async/Await**



```javascript

// Modern async/await syntax (built on promises)

async function getUserData(userId) {

  // Simulate API call

  return new Promise(resolve => {

    setTimeout(() => {

      resolve({ id: userId, name: 'John Doe' });

    }, 1000);

  });

}



async function displayUserInfo() {

  console.log('Start fetching...');

  

  try {

    // Looks synchronous but is asynchronous

    const user = await getUserData(123);

    console.log('User:', user);

    

    const user2 = await getUserData(456);

    console.log('User 2:', user2);

    

    console.log('All data fetched');

  } catch (error) {

    console.error('Error:', error);

  }

}



displayUserInfo();

console.log('Function called, continuing...');



// Output:

// Start fetching...

// Function called, continuing...

// User: { id: 123, name: 'John Doe' } (after 1 second)

// User 2: { id: 456, name: 'John Doe' } (after 2 seconds total)

// All data fetched

```



#### **5. Event Loop and Execution Model**



```javascript

// Understanding the event loop

console.log('1 - Synchronous');



setTimeout(() => {

  console.log('2 - Macrotask (setTimeout)');

}, 0);



Promise.resolve().then(() => {

  console.log('3 - Microtask (Promise)');

});



queueMicrotask(() => {

  console.log('4 - Microtask (queueMicrotask)');

});



console.log('5 - Synchronous');



// Output:

// 1 - Synchronous

// 5 - Synchronous

// 3 - Microtask (Promise)

// 4 - Microtask (queueMicrotask)

// 2 - Macrotask (setTimeout)



// Execution order:

// 1. Synchronous code (call stack)

// 2. Microtasks (Promise callbacks, queueMicrotask)

// 3. Macrotasks (setTimeout, setInterval, I/O)

// 4. Render (if needed)

// 5. Repeat



// Event Loop Phases:

// ┌───────────────────────────┐

// │        Call Stack         │ ← Synchronous code executes here

// └───────────────────────────┘

//              ↓

// ┌───────────────────────────┐

// │    Microtask Queue        │ ← Promises, queueMicrotask

// │  (higher priority)        │

// └───────────────────────────┘

//              ↓

// ┌───────────────────────────┐

// │    Macrotask Queue        │ ← setTimeout, setInterval, I/O

// │  (lower priority)         │

// └───────────────────────────┘

```



#### **Practical Examples**



**1. Synchronous vs Asynchronous File Reading:**



```javascript

// SYNCHRONOUS (Node.js example - blocks execution)

function readFileSync() {

  console.log('Start reading file...');

  

  // Blocks until file is read (if this were real fs.readFileSync)

  const data = '/* file content */'; // Simulated blocking operation

  

  console.log('File content:', data);

  console.log('Done reading file');

}



readFileSync();

console.log('After file read'); // Must wait for file read to complete



// Output:

// Start reading file...

// File content: /* file content */

// Done reading file

// After file read



// ASYNCHRONOUS (Node.js example - non-blocking)

function readFileAsync() {

  console.log('Start reading file...');

  

  // Simulated async file read

  setTimeout(() => {

    const data = '/* file content */';

    console.log('File content:', data);

    console.log('Done reading file');

  }, 100);

}



readFileAsync();

console.log('After initiating file read'); // Doesn't wait



// Output:

// Start reading file...

// After initiating file read

// File content: /* file content */ (after delay)

// Done reading file

```



**2. API Requests Comparison:**



```javascript

// SYNCHRONOUS-STYLE (not recommended - for comparison)

function fetchUserSync(userId) {

  console.log(`Fetching user ${userId}...`);

  

  // Blocks until complete

  let result;

  const xhr = new XMLHttpRequest();

  xhr.open('GET', `/api/users/${userId}`, false); // false = synchronous

  xhr.send();

  

  if (xhr.status === 200) {

    result = JSON.parse(xhr.responseText);

  }

  

  console.log(`User ${userId} fetched`);

  return result;

}



// This blocks the browser - BAD!

// const user1 = fetchUserSync(1);

// const user2 = fetchUserSync(2);



// ASYNCHRONOUS with async/await (recommended)

async function fetchUserAsync(userId) {

  console.log(`Fetching user ${userId}...`);

  

  const response = await fetch(`/api/users/${userId}`);

  const user = await response.json();

  

  console.log(`User ${userId} fetched`);

  return user;

}



// Non-blocking - can fetch in parallel

async function fetchMultipleUsers() {

  console.log('Start fetching users...');

  

  // Parallel execution

  const [user1, user2, user3] = await Promise.all([

    fetchUserAsync(1),

    fetchUserAsync(2),

    fetchUserAsync(3)

  ]);

  

  console.log('All users fetched:', user1, user2, user3);

}



fetchMultipleUsers();

console.log('Fetching in progress...'); // Doesn't wait

```



**3. Sequential vs Parallel Async Operations:**



```javascript

// SEQUENTIAL (slower - waits for each)

async function sequentialFetch() {

  console.time('Sequential');

  

  const user1 = await fetch('/api/users/1').then(r => r.json());

  const user2 = await fetch('/api/users/2').then(r => r.json());

  const user3 = await fetch('/api/users/3').then(r => r.json());

  

  console.timeEnd('Sequential'); // ~3 seconds (1s + 1s + 1s)

  return [user1, user2, user3];

}



// PARALLEL (faster - runs simultaneously)

async function parallelFetch() {

  console.time('Parallel');

  

  const [user1, user2, user3] = await Promise.all([

    fetch('/api/users/1').then(r => r.json()),

    fetch('/api/users/2').then(r => r.json()),

    fetch('/api/users/3').then(r => r.json())

  ]);

  

  console.timeEnd('Parallel'); // ~1 second (all at once)

  return [user1, user2, user3];

}



// Sequential: 3 seconds total

// Parallel: 1 second total (3x faster!)

```



**4. Error Handling:**



```javascript

// SYNCHRONOUS error handling

function syncOperation() {

  try {

    console.log('Start');

    

    if (Math.random() > 0.5) {

      throw new Error('Sync error');

    }

    

    console.log('Success');

  } catch (error) {

    console.error('Caught:', error.message);

  }

}



syncOperation();



// ASYNCHRONOUS error handling with Promises

function asyncOperation() {

  return new Promise((resolve, reject) => {

    setTimeout(() => {

      if (Math.random() > 0.5) {

        reject(new Error('Async error'));

      } else {

        resolve('Success');

      }

    }, 1000);

  });

}



asyncOperation()

  .then(result => console.log(result))

  .catch(error => console.error('Caught:', error.message));



// ASYNCHRONOUS error handling with async/await

async function handleAsyncOperation() {

  try {

    const result = await asyncOperation();

    console.log(result);

  } catch (error) {

    console.error('Caught:', error.message);

  }

}



handleAsyncOperation();

```



**5. Real-World Example: Data Processing Pipeline:**



```javascript

// Process data synchronously (blocks UI)

function processDataSync(data) {

  console.log('Processing started...');

  

  // Heavy computation - blocks everything

  const filtered = data.filter(item => item.value > 50);

  const mapped = filtered.map(item => ({ ...item, processed: true }));

  const sorted = mapped.sort((a, b) => b.value - a.value);

  

  console.log('Processing complete');

  return sorted;

}



// Process data asynchronously (non-blocking)

async function processDataAsync(data) {

  console.log('Processing started...');

  

  // Break into chunks, process with delays

  const result = [];

  const chunkSize = 1000;

  

  for (let i = 0; i < data.length; i += chunkSize) {

    const chunk = data.slice(i, i + chunkSize);

    

    // Process chunk

    const processed = chunk

      .filter(item => item.value > 50)

      .map(item => ({ ...item, processed: true }));

    

    result.push(...processed);

    

    // Yield to browser (allow UI updates)

    await new Promise(resolve => setTimeout(resolve, 0));

  }

  

  // Final sort

  result.sort((a, b) => b.value - a.value);

  

  console.log('Processing complete');

  return result;

}



// Large dataset

const largeData = Array.from({ length: 100000 }, (_, i) => ({

  id: i,

  value: Math.random() * 100

}));



// Synchronous: blocks UI for entire duration

// const result1 = processDataSync(largeData); // UI frozen



// Asynchronous: allows UI updates during processing

processDataAsync(largeData).then(result => {

  console.log('Result ready:', result.length, 'items');

});

console.log('UI remains responsive...'); // This logs immediately

```



**6. Callback Hell vs Modern Async:**



```javascript

// CALLBACK HELL (pyramid of doom)

function callbackHell() {

  getUser(123, (user, error) => {

    if (error) {

      console.error(error);

      return;

    }

    

    getPosts(user.id, (posts, error) => {

      if (error) {

        console.error(error);

        return;

      }

      

      getComments(posts[0].id, (comments, error) => {

        if (error) {

          console.error(error);

          return;

        }

        

        console.log('Comments:', comments);

      });

    });

  });

}



// MODERN ASYNC/AWAIT (clean and readable)

async function modernAsync() {

  try {

    const user = await getUser(123);

    const posts = await getPosts(user.id);

    const comments = await getComments(posts[0].id);

    

    console.log('Comments:', comments);

  } catch (error) {

    console.error(error);

  }

}



// Helper functions returning promises

function getUser(id) {

  return fetch(`/api/users/${id}`).then(r => r.json());

}



function getPosts(userId) {

  return fetch(`/api/posts?userId=${userId}`).then(r => r.json());

}



function getComments(postId) {

  return fetch(`/api/comments?postId=${postId}`).then(r => r.json());

}

```



**7. Combining Sync and Async:**



```javascript

class DataManager {

  constructor() {

    this.cache = new Map();

  }

  

  // Synchronous cache check

  getCached(key) {

    return this.cache.get(key); // Immediate return

  }

  

  // Asynchronous data fetching

  async fetchData(key) {

    // Check cache synchronously first

    const cached = this.getCached(key);

    if (cached) {

      console.log('Cache hit:', key);

      return cached;

    }

    

    // Fetch asynchronously if not cached

    console.log('Cache miss, fetching:', key);

    const data = await fetch(`/api/data/${key}`).then(r => r.json());

    

    // Update cache synchronously

    this.cache.set(key, data);

    

    return data;

  }

  

  // Synchronous cache invalidation

  clearCache(key) {

    if (key) {

      this.cache.delete(key);

    } else {

      this.cache.clear();

    }

  }

}



// Usage

const manager = new DataManager();



// First call - async fetch

const data1 = await manager.fetchData('users');

console.log(data1);



// Second call - sync cache hit

const data2 = await manager.fetchData('users');

console.log(data2); // Returns immediately from cache

```



#### **Performance Comparison**



```javascript

// Benchmark: Synchronous vs Asynchronous

async function benchmark() {

  // Simulate API calls (1 second each)

  function apiCall() {

    return new Promise(resolve => {

      setTimeout(() => resolve('data'), 1000);

    });

  }

  

  // SYNCHRONOUS-STYLE (sequential)

  console.time('Sequential');

  await apiCall();

  await apiCall();

  await apiCall();

  console.timeEnd('Sequential'); // ~3000ms

  

  // ASYNCHRONOUS (parallel)

  console.time('Parallel');

  await Promise.all([

    apiCall(),

    apiCall(),

    apiCall()

  ]);

  console.timeEnd('Parallel'); // ~1000ms

  

  console.log('Parallel is 3x faster!');

}



benchmark();

```



#### **When to Use Each**



```javascript

// USE SYNCHRONOUS when:

// ✅ Operations are fast (<16ms)

// ✅ Operations must complete before next step

// ✅ Working with in-memory data

// ✅ Simple calculations



// Examples:

const sum = numbers.reduce((a, b) => a + b, 0); // Sync - fast

const filtered = array.filter(x => x > 10);      // Sync - fast

const validated = validateForm(data);             // Sync - immediate



// USE ASYNCHRONOUS when:

// ✅ Network requests (API calls)

// ✅ File I/O operations

// ✅ Database queries

// ✅ Heavy computations (>50ms)

// ✅ Timers/delays

// ✅ User interactions that shouldn't block UI



// Examples:

const data = await fetch('/api/data');           // Async - network

const file = await readFile('data.txt');         // Async - I/O

const result = await heavyComputation(bigData);  // Async - CPU-intensive

await new Promise(resolve => setTimeout(resolve, 1000)); // Async - timer

```



#### **Common Patterns**



```javascript

// 1. Promise.all for parallel execution

const [users, posts, comments] = await Promise.all([

  fetch('/api/users').then(r => r.json()),

  fetch('/api/posts').then(r => r.json()),

  fetch('/api/comments').then(r => r.json())

]);



// 2. Promise.race for timeout

const dataWithTimeout = await Promise.race([

  fetch('/api/data').then(r => r.json()),

  new Promise((_, reject) => 

    setTimeout(() => reject(new Error('Timeout')), 5000)

  )

]);



// 3. Promise.allSettled for handling failures

const results = await Promise.allSettled([

  fetch('/api/endpoint1'),

  fetch('/api/endpoint2'),

  fetch('/api/endpoint3')

]);



results.forEach((result, index) => {

  if (result.status === 'fulfilled') {

    console.log(`Request ${index} succeeded:`, result.value);

  } else {

    console.log(`Request ${index} failed:`, result.reason);

  }

});



// 4. Async iteration

async function* asyncGenerator() {

  yield await Promise.resolve(1);

  yield await Promise.resolve(2);

  yield await Promise.resolve(3);

}



for await (const value of asyncGenerator()) {

  console.log(value); // 1, 2, 3

}



// 5. Async queue processing

class AsyncQueue {

  constructor() {

    this.queue = [];

    this.processing = false;

  }

  

  async add(asyncTask) {

    this.queue.push(asyncTask);

    if (!this.processing) {

      await this.process();

    }

  }

  

  async process() {

    this.processing = true;

    

    while (this.queue.length > 0) {

      const task = this.queue.shift();

      await task();

    }

    

    this.processing = false;

  }

}



const queue = new AsyncQueue();

queue.add(async () => await fetch('/api/1'));

queue.add(async () => await fetch('/api/2'));

```



#### **Key Takeaways**



- **Synchronous** code executes sequentially and blocks

- **Asynchronous** code runs in background without blocking

- **JavaScript is single-threaded** but uses event loop

- **Event loop** manages async operations efficiently

- **Microtasks** (Promises) execute before macrotasks (setTimeout)

- **Callbacks** were first async solution (callback hell)

- **Promises** improved async code readability

- **Async/await** is syntactic sugar over Promises

- **Always use async** for network requests and I/O

- **Parallel execution** with Promise.all for performance

- **Sequential execution** when operations depend on each other

- **Error handling** differs: try/catch vs .catch()

- **Non-blocking code** keeps UI responsive

- **Use synchronous** for fast, in-memory operations

- **Understanding async** is essential for modern JavaScript



---



</details>
<details><summary>90. What are design patterns in JavaScript?</summary>




**Answer:**



Design patterns are reusable, proven solutions to common software design problems. They provide templates for writing code that is maintainable, scalable, and easier to understand. In JavaScript, design patterns help structure applications, manage complexity, and promote best practices. They're categorized into three main types: **Creational** (object creation), **Structural** (object composition), and **Behavioral** (object interaction and communication).



#### **Pattern Categories Overview**



```javascript

// CREATIONAL PATTERNS - Object creation mechanisms

// - Constructor Pattern

// - Factory Pattern

// - Singleton Pattern

// - Prototype Pattern

// - Builder Pattern



// STRUCTURAL PATTERNS - Object composition

// - Module Pattern

// - Revealing Module Pattern

// - Decorator Pattern

// - Facade Pattern

// - Proxy Pattern

// - Adapter Pattern

// - Composite Pattern



// BEHAVIORAL PATTERNS - Object communication

// - Observer Pattern (Pub/Sub)

// - Strategy Pattern

// - Command Pattern

// - Iterator Pattern

// - Mediator Pattern

// - Chain of Responsibility

// - State Pattern

// - Template Method Pattern

```



---



## **CREATIONAL PATTERNS**



### **1. Module Pattern**



The Module Pattern encapsulates private and public members, creating a clean API while hiding implementation details. It uses closures to maintain private state.



```javascript

// Basic Module Pattern

const ShoppingCart = (function() {

  // Private variables and functions

  let items = [];

  let total = 0;

  

  function calculateTotal() {

    total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);

    return total;

  }

  

  function validateItem(item) {

    return item && item.id && item.price > 0 && item.quantity > 0;

  }

  

  // Public API

  return {

    addItem(item) {

      if (!validateItem(item)) {

        throw new Error('Invalid item');

      }

      

      const existingItem = items.find(i => i.id === item.id);

      

      if (existingItem) {

        existingItem.quantity += item.quantity;

      } else {

        items.push({ ...item });

      }

      

      calculateTotal();

      console.log(`Added ${item.name} to cart`);

    },

    

    removeItem(itemId) {

      const index = items.findIndex(i => i.id === itemId);

      

      if (index !== -1) {

        const removed = items.splice(index, 1)[0];

        calculateTotal();

        console.log(`Removed ${removed.name} from cart`);

        return true;

      }

      

      return false;

    },

    

    updateQuantity(itemId, quantity) {

      const item = items.find(i => i.id === itemId);

      

      if (item && quantity > 0) {

        item.quantity = quantity;

        calculateTotal();

        return true;

      }

      

      return false;

    },

    

    getItems() {

      // Return copy to prevent external modification

      return items.map(item => ({ ...item }));

    },

    

    getTotal() {

      return total;

    },

    

    clear() {

      items = [];

      total = 0;

      console.log('Cart cleared');

    },

    

    getItemCount() {

      return items.reduce((count, item) => count + item.quantity, 0);

    }

  };

})();



// Usage

ShoppingCart.addItem({ id: 1, name: 'Laptop', price: 999.99, quantity: 1 });

ShoppingCart.addItem({ id: 2, name: 'Mouse', price: 29.99, quantity: 2 });



console.log('Items:', ShoppingCart.getItems());

console.log('Total:', ShoppingCart.getTotal()); // 1059.97

console.log('Count:', ShoppingCart.getItemCount()); // 3



// Private variables are inaccessible

// console.log(items); // ReferenceError: items is not defined

```



**Advanced Module Pattern with Configuration:**



```javascript

const DatabaseConnection = (function() {

  // Private state

  let connection = null;

  let config = {

    host: 'localhost',

    port: 5432,

    database: 'mydb',

    maxRetries: 3

  };

  

  let isConnected = false;

  let queryLog = [];

  

  // Private methods

  function log(message, type = 'INFO') {

    const timestamp = new Date().toISOString();

    const logEntry = `[${timestamp}] [${type}] ${message}`;

    queryLog.push(logEntry);

    console.log(logEntry);

  }

  

  function validateQuery(query) {

    if (typeof query !== 'string' || query.trim().length === 0) {

      throw new Error('Invalid query');

    }

  }

  

  async function executeQuery(query) {

    // Simulated database query

    return new Promise((resolve) => {

      setTimeout(() => {

        resolve({ success: true, data: [], query });

      }, 100);

    });

  }

  

  // Public API

  return {

    configure(options) {

      config = { ...config, ...options };

      log(`Configuration updated: ${JSON.stringify(options)}`);

      return this;

    },

    

    async connect() {

      if (isConnected) {

        log('Already connected', 'WARN');

        return true;

      }

      

      log(`Connecting to ${config.host}:${config.port}/${config.database}`);

      

      // Simulated connection

      await new Promise(resolve => setTimeout(resolve, 500));

      

      connection = { id: Date.now() };

      isConnected = true;

      log('Connected successfully');

      

      return true;

    },

    

    async disconnect() {

      if (!isConnected) {

        log('Not connected', 'WARN');

        return true;

      }

      

      log('Disconnecting...');

      await new Promise(resolve => setTimeout(resolve, 200));

      

      connection = null;

      isConnected = false;

      log('Disconnected');

      

      return true;

    },

    

    async query(sql) {

      if (!isConnected) {

        throw new Error('Not connected to database');

      }

      

      validateQuery(sql);

      log(`Executing query: ${sql}`);

      

      try {

        const result = await executeQuery(sql);

        log(`Query executed successfully`, 'SUCCESS');

        return result;

      } catch (error) {

        log(`Query failed: ${error.message}`, 'ERROR');

        throw error;

      }

    },

    

    getConnectionStatus() {

      return {

        connected: isConnected,

        connectionId: connection?.id,

        config: { ...config } // Return copy

      };

    },

    

    getQueryLog() {

      return [...queryLog]; // Return copy

    },

    

    clearLog() {

      queryLog = [];

      log('Query log cleared');

    }

  };

})();



// Usage

await DatabaseConnection

  .configure({ host: 'db.example.com', port: 3306 })

  .connect();



await DatabaseConnection.query('SELECT * FROM users');

await DatabaseConnection.query('INSERT INTO logs VALUES (...)');



console.log(DatabaseConnection.getConnectionStatus());

console.log(DatabaseConnection.getQueryLog());



await DatabaseConnection.disconnect();

```



---



### **2. Revealing Module Pattern**



Similar to Module Pattern but explicitly defines what to expose, making the public API more obvious.



```javascript

const UserManager = (function() {

  // Private variables

  let users = [];

  let currentUserId = 1;

  

  // Private functions

  function generateId() {

    return currentUserId++;

  }

  

  function validateUser(user) {

    if (!user.name || !user.email) {

      throw new Error('Name and email are required');

    }

    

    if (!isValidEmail(user.email)) {

      throw new Error('Invalid email format');

    }

    

    return true;

  }

  

  function isValidEmail(email) {

    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

  }

  

  function findUserById(id) {

    return users.find(u => u.id === id);

  }

  

  function findUserByEmail(email) {

    return users.find(u => u.email === email);

  }

  

  // Public functions

  function createUser(userData) {

    validateUser(userData);

    

    if (findUserByEmail(userData.email)) {

      throw new Error('User with this email already exists');

    }

    

    const user = {

      id: generateId(),

      name: userData.name,

      email: userData.email,

      role: userData.role || 'user',

      createdAt: new Date(),

      active: true

    };

    

    users.push(user);

    console.log(`User created: ${user.name} (${user.email})`);

    

    return { ...user };

  }

  

  function getUserById(id) {

    const user = findUserById(id);

    return user ? { ...user } : null;

  }

  

  function getAllUsers() {

    return users.map(u => ({ ...u }));

  }

  

  function updateUser(id, updates) {

    const user = findUserById(id);

    

    if (!user) {

      throw new Error('User not found');

    }

    

    if (updates.email && updates.email !== user.email) {

      if (findUserByEmail(updates.email)) {

        throw new Error('Email already in use');

      }

    }

    

    Object.assign(user, updates, { updatedAt: new Date() });

    console.log(`User updated: ${user.name}`);

    

    return { ...user };

  }

  

  function deleteUser(id) {

    const index = users.findIndex(u => u.id === id);

    

    if (index === -1) {

      throw new Error('User not found');

    }

    

    const deleted = users.splice(index, 1)[0];

    console.log(`User deleted: ${deleted.name}`);

    

    return true;

  }

  

  function deactivateUser(id) {

    const user = findUserById(id);

    

    if (!user) {

      throw new Error('User not found');

    }

    

    user.active = false;

    user.deactivatedAt = new Date();

    console.log(`User deactivated: ${user.name}`);

    

    return true;

  }

  

  function searchUsers(query) {

    const lowercaseQuery = query.toLowerCase();

    

    return users

      .filter(u => 

        u.name.toLowerCase().includes(lowercaseQuery) ||

        u.email.toLowerCase().includes(lowercaseQuery)

      )

      .map(u => ({ ...u }));

  }

  

  function getUserCount() {

    return {

      total: users.length,

      active: users.filter(u => u.active).length,

      inactive: users.filter(u => !u.active).length

    };

  }

  

  // Reveal public API (explicitly defined)

  return {

    create: createUser,

    getById: getUserById,

    getAll: getAllUsers,

    update: updateUser,

    delete: deleteUser,

    deactivate: deactivateUser,

    search: searchUsers,

    count: getUserCount

  };

})();



// Usage

const user1 = UserManager.create({

  name: 'John Doe',

  email: 'john@example.com',

  role: 'admin'

});



const user2 = UserManager.create({

  name: 'Jane Smith',

  email: 'jane@example.com'

});



console.log('User by ID:', UserManager.getById(1));

console.log('All users:', UserManager.getAll());



UserManager.update(1, { role: 'superadmin' });

UserManager.deactivate(2);



console.log('Search results:', UserManager.search('john'));

console.log('User count:', UserManager.count());

```



---



### **3. Singleton Pattern**



Ensures only one instance of a class exists and provides global access to it.



```javascript

// ES6 Class Singleton

class Database {

  constructor() {

    if (Database.instance) {

      return Database.instance;

    }

    

    this.connection = null;

    this.queries = [];

    this.connected = false;

    

    Database.instance = this;

  }

  

  connect(connectionString) {

    if (this.connected) {

      console.log('Already connected');

      return this;

    }

    

    console.log(`Connecting to: ${connectionString}`);

    this.connection = { url: connectionString, id: Date.now() };

    this.connected = true;

    

    return this;

  }

  

  disconnect() {

    if (!this.connected) {

      console.log('Not connected');

      return this;

    }

    

    console.log('Disconnecting...');

    this.connection = null;

    this.connected = false;

    

    return this;

  }

  

  query(sql) {

    if (!this.connected) {

      throw new Error('Not connected to database');

    }

    

    console.log(`Executing: ${sql}`);

    this.queries.push({ sql, timestamp: new Date() });

    

    return { success: true, data: [] };

  }

  

  getQueryHistory() {

    return [...this.queries];

  }

  

  static getInstance() {

    if (!Database.instance) {

      Database.instance = new Database();

    }

    return Database.instance;

  }

}



// Usage

const db1 = new Database();

db1.connect('mongodb://localhost:27017');

db1.query('SELECT * FROM users');



const db2 = new Database(); // Returns same instance

db2.query('SELECT * FROM posts');



console.log(db1 === db2); // true

console.log(db1.getQueryHistory()); // Contains queries from both db1 and db2



// Alternative: Using static getInstance

const db3 = Database.getInstance();

console.log(db1 === db3); // true

```



**Singleton with Lazy Initialization:**



```javascript

const ConfigManager = (function() {

  let instance;

  

  function createInstance() {

    // Private configuration

    let config = {

      apiUrl: 'https://api.example.com',

      timeout: 5000,

      retryAttempts: 3,

      environment: 'development'

    };

    

    let listeners = [];

    

    // Private methods

    function notifyListeners(key, value) {

      listeners.forEach(callback => callback(key, value));

    }

    

    // Public methods

    return {

      get(key) {

        return key ? config[key] : { ...config };

      },

      

      set(key, value) {

        const oldValue = config[key];

        config[key] = value;

        

        console.log(`Config updated: ${key} = ${value}`);

        notifyListeners(key, value);

        

        return this;

      },

      

      setMultiple(updates) {

        Object.keys(updates).forEach(key => {

          this.set(key, updates[key]);

        });

        return this;

      },

      

      reset() {

        config = {

          apiUrl: 'https://api.example.com',

          timeout: 5000,

          retryAttempts: 3,

          environment: 'development'

        };

        console.log('Config reset to defaults');

        return this;

      },

      

      onChange(callback) {

        listeners.push(callback);

        return () => {

          listeners = listeners.filter(cb => cb !== callback);

        };

      },

      

      getEnvironment() {

        return config.environment;

      },

      

      isProduction() {

        return config.environment === 'production';

      }

    };

  }

  

  return {

    getInstance() {

      if (!instance) {

        instance = createInstance();

        console.log('ConfigManager instance created');

      }

      return instance;

    }

  };

})();



// Usage

const config1 = ConfigManager.getInstance();

config1.set('apiUrl', 'https://api.production.com');

config1.set('environment', 'production');



const config2 = ConfigManager.getInstance(); // Same instance

console.log(config2.get('apiUrl')); // 'https://api.production.com'



console.log(config1 === config2); // true



// Listen to config changes

const unsubscribe = config1.onChange((key, value) => {

  console.log(`Config changed: ${key} = ${value}`);

});



config1.set('timeout', 10000); // Triggers listener

```



**Application-wide Singleton:**



```javascript

class AppState {

  constructor() {

    if (AppState.instance) {

      return AppState.instance;

    }

    

    this.state = {

      user: null,

      theme: 'light',

      language: 'en',

      notifications: [],

      isLoading: false

    };

    

    this.subscribers = new Map();

    this.history = [];

    

    AppState.instance = this;

  }

  

  getState() {

    return { ...this.state };

  }

  

  setState(updates) {

    const oldState = { ...this.state };

    this.state = { ...this.state, ...updates };

    

    this.history.push({

      timestamp: new Date(),

      oldState,

      newState: { ...this.state }

    });

    

    // Notify subscribers

    Object.keys(updates).forEach(key => {

      if (this.subscribers.has(key)) {

        this.subscribers.get(key).forEach(callback => {

          callback(this.state[key], oldState[key]);

        });

      }

    });

    

    return this;

  }

  

  subscribe(key, callback) {

    if (!this.subscribers.has(key)) {

      this.subscribers.set(key, []);

    }

    

    this.subscribers.get(key).push(callback);

    

    // Return unsubscribe function

    return () => {

      const callbacks = this.subscribers.get(key);

      const index = callbacks.indexOf(callback);

      if (index > -1) {

        callbacks.splice(index, 1);

      }

    };

  }

  

  login(user) {

    this.setState({ user, isLoading: false });

    console.log(`User logged in: ${user.name}`);

  }

  

  logout() {

    this.setState({ user: null });

    console.log('User logged out');

  }

  

  setTheme(theme) {

    this.setState({ theme });

  }

  

  addNotification(notification) {

    const notifications = [...this.state.notifications, {

      id: Date.now(),

      ...notification,

      timestamp: new Date()

    }];

    this.setState({ notifications });

  }

  

  clearNotifications() {

    this.setState({ notifications: [] });

  }

  

  getHistory() {

    return [...this.history];

  }

  

  static getInstance() {

    if (!AppState.instance) {

      AppState.instance = new AppState();

    }

    return AppState.instance;

  }

}



// Usage across application

const appState = AppState.getInstance();



// Subscribe to user changes

appState.subscribe('user', (newUser, oldUser) => {

  console.log('User changed:', newUser);

});



// Subscribe to theme changes

appState.subscribe('theme', (newTheme) => {

  document.body.className = `theme-${newTheme}`;

});



// Login

appState.login({ id: 1, name: 'John Doe', email: 'john@example.com' });



// Change theme

appState.setTheme('dark');



// Add notification

appState.addNotification({

  type: 'success',

  message: 'Profile updated successfully'

});



// Access from anywhere in app

const sameInstance = AppState.getInstance();

console.log(sameInstance.getState().user); // Same user

```



---



### **4. Factory Pattern**



Creates objects without specifying their exact classes, providing an interface for object creation.



```javascript

// Simple Factory

class UserFactory {

  static createUser(type, data) {

    switch (type) {

      case 'admin':

        return new AdminUser(data);

      case 'moderator':

        return new ModeratorUser(data);

      case 'customer':

        return new CustomerUser(data);

      case 'guest':

        return new GuestUser(data);

      default:

        throw new Error(`Unknown user type: ${type}`);

    }

  }

}



// Base User class

class User {

  constructor(data) {

    this.id = data.id;

    this.name = data.name;

    this.email = data.email;

    this.createdAt = new Date();

  }

  

  getInfo() {

    return {

      id: this.id,

      name: this.name,

      email: this.email,

      role: this.constructor.name.replace('User', '').toLowerCase()

    };

  }

}



// Specific user types

class AdminUser extends User {

  constructor(data) {

    super(data);

    this.permissions = ['read', 'write', 'delete', 'manage_users'];

  }

  

  canManageUsers() {

    return true;

  }

  

  canAccessAdminPanel() {

    return true;

  }

  

  canDeleteAnyContent() {

    return true;

  }

}



class ModeratorUser extends User {

  constructor(data) {

    super(data);

    this.permissions = ['read', 'write', 'delete'];

  }

  

  canManageUsers() {

    return false;

  }

  

  canAccessAdminPanel() {

    return false;

  }

  

  canDeleteAnyContent() {

    return true;

  }

}



class CustomerUser extends User {

  constructor(data) {

    super(data);

    this.permissions = ['read', 'write'];

    this.purchaseHistory = [];

  }

  

  canManageUsers() {

    return false;

  }

  

  canAccessAdminPanel() {

    return false;

  }

  

  canDeleteAnyContent() {

    return false;

  }

  

  addPurchase(purchase) {

    this.purchaseHistory.push(purchase);

  }

}



class GuestUser extends User {

  constructor(data) {

    super(data);

    this.permissions = ['read'];

  }

  

  canManageUsers() {

    return false;

  }

  

  canAccessAdminPanel() {

    return false;

  }

  

  canDeleteAnyContent() {

    return false;

  }

}



// Usage

const admin = UserFactory.createUser('admin', {

  id: 1,

  name: 'Admin User',

  email: 'admin@example.com'

});



const customer = UserFactory.createUser('customer', {

  id: 2,

  name: 'John Doe',

  email: 'john@example.com'

});



console.log(admin.getInfo());

console.log(admin.canManageUsers()); // true

console.log(customer.canManageUsers()); // false

```



**Advanced Factory with Registration:**



```javascript

class VehicleFactory {

  constructor() {

    this.vehicles = new Map();

  }

  

  // Register vehicle types

  register(type, vehicleClass) {

    if (this.vehicles.has(type)) {

      console.warn(`Vehicle type ${type} is already registered`);

    }

    this.vehicles.set(type, vehicleClass);

    return this;

  }

  

  // Create vehicle instance

  create(type, options) {

    const VehicleClass = this.vehicles.get(type);

    

    if (!VehicleClass) {

      throw new Error(`Vehicle type ${type} is not registered`);

    }

    

    return new VehicleClass(options);

  }

  

  // Check if type is registered

  isRegistered(type) {

    return this.vehicles.has(type);

  }

  

  // Get all registered types

  getRegisteredTypes() {

    return Array.from(this.vehicles.keys());

  }

}



// Base Vehicle class

class Vehicle {

  constructor(options) {

    this.brand = options.brand;

    this.model = options.model;

    this.year = options.year;

    this.price = options.price;

  }

  

  getInfo() {

    return `${this.year} ${this.brand} ${this.model} - $${this.price}`;

  }

}



// Specific vehicle types

class Car extends Vehicle {

  constructor(options) {

    super(options);

    this.type = 'car';

    this.doors = options.doors || 4;

    this.fuelType = options.fuelType || 'gasoline';

  }

  

  getDetails() {

    return `${this.getInfo()} | ${this.doors} doors, ${this.fuelType}`;

  }

}



class Motorcycle extends Vehicle {

  constructor(options) {

    super(options);

    this.type = 'motorcycle';

    this.engineCC = options.engineCC;

    this.hasABS = options.hasABS || false;

  }

  

  getDetails() {

    return `${this.getInfo()} | ${this.engineCC}cc, ABS: ${this.hasABS}`;

  }

}



class Truck extends Vehicle {

  constructor(options) {

    super(options);

    this.type = 'truck';

    this.cargoCapacity = options.cargoCapacity;

    this.axles = options.axles || 2;

  }

  

  getDetails() {

    return `${this.getInfo()} | Capacity: ${this.cargoCapacity}t, ${this.axles} axles`;

  }

}



class ElectricCar extends Car {

  constructor(options) {

    super({ ...options, fuelType: 'electric' });

    this.batteryCapacity = options.batteryCapacity;

    this.range = options.range;

  }

  

  getDetails() {

    return `${super.getDetails()} | Battery: ${this.batteryCapacity}kWh, Range: ${this.range}km`;

  }

}



// Create factory and register vehicle types

const factory = new VehicleFactory();



factory

  .register('car', Car)

  .register('motorcycle', Motorcycle)

  .register('truck', Truck)

  .register('electric', ElectricCar);



// Usage

const car = factory.create('car', {

  brand: 'Toyota',

  model: 'Camry',

  year: 2024,

  price: 28000,

  doors: 4,

  fuelType: 'hybrid'

});



const motorcycle = factory.create('motorcycle', {

  brand: 'Harley-Davidson',

  model: 'Street 750',

  year: 2024,

  price: 8000,

  engineCC: 750,

  hasABS: true

});



const electric = factory.create('electric', {

  brand: 'Tesla',

  model: 'Model 3',

  year: 2024,

  price: 45000,

  batteryCapacity: 75,

  range: 500

});



console.log(car.getDetails());

console.log(motorcycle.getDetails());

console.log(electric.getDetails());



console.log('Registered types:', factory.getRegisteredTypes());

```



**Real-World Factory: Logger Factory:**



```javascript

class LoggerFactory {

  static createLogger(type, config = {}) {

    const loggers = {

      console: ConsoleLogger,

      file: FileLogger,

      remote: RemoteLogger,

      multi: MultiLogger

    };

    

    const LoggerClass = loggers[type];

    

    if (!LoggerClass) {

      throw new Error(`Unknown logger type: ${type}`);

    }

    

    return new LoggerClass(config);

  }

}



// Base Logger

class Logger {

  constructor(config) {

    this.level = config.level || 'info';

    this.levels = {

      debug: 0,

      info: 1,

      warn: 2,

      error: 3

    };

  }

  

  shouldLog(level) {

    return this.levels[level] >= this.levels[this.level];

  }

  

  formatMessage(level, message, data) {

    const timestamp = new Date().toISOString();

    const dataStr = data ? ` | ${JSON.stringify(data)}` : '';

    return `[${timestamp}] [${level.toUpperCase()}] ${message}${dataStr}`;

  }

}



// Console Logger

class ConsoleLogger extends Logger {

  log(level, message, data) {

    if (!this.shouldLog(level)) return;

    

    const formatted = this.formatMessage(level, message, data);

    

    switch (level) {

      case 'debug':

        console.debug(formatted);

        break;

      case 'info':

        console.info(formatted);

        break;

      case 'warn':

        console.warn(formatted);

        break;

      case 'error':

        console.error(formatted);

        break;

    }

  }

  

  debug(message, data) { this.log('debug', message, data); }

  info(message, data) { this.log('info', message, data); }

  warn(message, data) { this.log('warn', message, data); }

  error(message, data) { this.log('error', message, data); }

}



// File Logger (simulated)

class FileLogger extends Logger {

  constructor(config) {

    super(config);

    this.filePath = config.filePath || 'app.log';

    this.logs = [];

  }

  

  log(level, message, data) {

    if (!this.shouldLog(level)) return;

    

    const formatted = this.formatMessage(level, message, data);

    this.logs.push(formatted);

    

    // In real implementation, write to file

    console.log(`[FILE: ${this.filePath}] ${formatted}`);

  }

  

  debug(message, data) { this.log('debug', message, data); }

  info(message, data) { this.log('info', message, data); }

  warn(message, data) { this.log('warn', message, data); }

  error(message, data) { this.log('error', message, data); }

  

  getLogs() {

    return [...this.logs];

  }

}



// Remote Logger (simulated)

class RemoteLogger extends Logger {

  constructor(config) {

    super(config);

    this.endpoint = config.endpoint || 'https://logs.example.com/api';

    this.buffer = [];

    this.batchSize = config.batchSize || 10;

  }

  

  async log(level, message, data) {

    if (!this.shouldLog(level)) return;

    

    const logEntry = {

      timestamp: new Date().toISOString(),

      level,

      message,

      data

    };

    

    this.buffer.push(logEntry);

    

    if (this.buffer.length >= this.batchSize) {

      await this.flush();

    }

  }

  

  async flush() {

    if (this.buffer.length === 0) return;

    

    const logsToSend = [...this.buffer];

    this.buffer = [];

    

    console.log(`[REMOTE: ${this.endpoint}] Sending ${logsToSend.length} logs`);

    

    // Simulated API call

    // await fetch(this.endpoint, {

    //   method: 'POST',

    //   body: JSON.stringify(logsToSend)

    // });

  }

  

  debug(message, data) { return this.log('debug', message, data); }

  info(message, data) { return this.log('info', message, data); }

  warn(message, data) { return this.log('warn', message, data); }

  error(message, data) { return this.log('error', message, data); }

}



// Multi Logger (logs to multiple destinations)

class MultiLogger extends Logger {

  constructor(config) {

    super(config);

    this.loggers = config.loggers || [];

  }

  

  log(level, message, data) {

    this.loggers.forEach(logger => {

      logger.log(level, message, data);

    });

  }

  

  debug(message, data) { this.log('debug', message, data); }

  info(message, data) { this.log('info', message, data); }

  warn(message, data) { this.log('warn', message, data); }

  error(message, data) { this.log('error', message, data); }

}



// Usage

const consoleLogger = LoggerFactory.createLogger('console', { level: 'debug' });

consoleLogger.info('Application started');

consoleLogger.debug('Debug information', { userId: 123 });



const fileLogger = LoggerFactory.createLogger('file', {

  level: 'warn',

  filePath: 'app.log'

});

fileLogger.warn('Warning message');

fileLogger.error('Error occurred', { code: 500 });



const remoteLogger = LoggerFactory.createLogger('remote', {

  level: 'info',

  endpoint: 'https://logs.example.com/api',

  batchSize: 5

});

remoteLogger.info('User logged in', { userId: 456 });



// Multi-logger (logs to console and file)

const multiLogger = LoggerFactory.createLogger('multi', {

  level: 'info',

  loggers: [

    LoggerFactory.createLogger('console'),

    LoggerFactory.createLogger('file', { filePath: 'combined.log' })

  ]

});

multiLogger.info('This goes to both console and file');

```



---



## **BEHAVIORAL PATTERNS**



### **5. Observer Pattern (Pub/Sub)**



Defines a one-to-many dependency where changes in one object notify multiple dependent objects.



```javascript

// Event Emitter / Observer Pattern

class EventEmitter {

  constructor() {

    this.events = new Map();

  }

  

  // Subscribe to event

  on(event, callback) {

    if (!this.events.has(event)) {

      this.events.set(event, []);

    }

    

    this.events.get(event).push(callback);

    

    // Return unsubscribe function

    return () => this.off(event, callback);

  }

  

  // Subscribe once (auto-unsubscribe after first call)

  once(event, callback) {

    const onceCallback = (...args) => {

      callback(...args);

      this.off(event, onceCallback);

    };

    

    return this.on(event, onceCallback);

  }

  

  // Unsubscribe from event

  off(event, callback) {

    if (!this.events.has(event)) return;

    

    if (callback) {

      const callbacks = this.events.get(event);

      const index = callbacks.indexOf(callback);

      if (index > -1) {

        callbacks.splice(index, 1);

      }

    } else {

      // Remove all listeners for this event

      this.events.delete(event);

    }

  }

  

  // Emit event

  emit(event, ...args) {

    if (!this.events.has(event)) return;

    

    const callbacks = this.events.get(event);

    callbacks.forEach(callback => {

      try {

        callback(...args);

      } catch (error) {

        console.error(`Error in event listener for ${event}:`, error);

      }

    });

  }

  

  // Get listener count

  listenerCount(event) {

    return this.events.has(event) ? this.events.get(event).length : 0;

  }

  

  // Remove all listeners

  removeAllListeners(event) {

    if (event) {

      this.events.delete(event);

    } else {

      this.events.clear();

    }

  }

  

  // Get all event names

  eventNames() {

    return Array.from(this.events.keys());

  }

}



// Usage

const emitter = new EventEmitter();



// Subscribe to events

emitter.on('user:login', (user) => {

  console.log(`User logged in: ${user.name}`);

});



emitter.on('user:login', (user) => {

  console.log(`Welcome back, ${user.name}!`);

});



emitter.on('user:logout', (user) => {

  console.log(`User logged out: ${user.name}`);

});



// Subscribe once

emitter.once('app:ready', () => {

  console.log('Application is ready (this will only log once)');

});



// Emit events

emitter.emit('user:login', { name: 'John Doe', id: 1 });

// Output:

// User logged in: John Doe

// Welcome back, John Doe!



emitter.emit('app:ready'); // Logs

emitter.emit('app:ready'); // Doesn't log (once)



emitter.emit('user:logout', { name: 'John Doe', id: 1 });



console.log('Listener count for user:login:', emitter.listenerCount('user:login')); // 2

```



**Advanced Observer: Store with State Management:**



```javascript

class Store extends EventEmitter {

  constructor(initialState = {}) {

    super();

    this.state = initialState;

    this.history = [{ ...initialState }];

    this.maxHistory = 50;

  }

  

  // Get current state

  getState() {

    return { ...this.state };

  }

  

  // Set state and notify observers

  setState(updates, silent = false) {

    const oldState = { ...this.state };

    this.state = { ...this.state, ...updates };

    

    // Add to history

    this.history.push({ ...this.state });

    if (this.history.length > this.maxHistory) {

      this.history.shift();

    }

    

    if (!silent) {

      // Emit specific change events

      Object.keys(updates).forEach(key => {

        this.emit(`change:${key}`, this.state[key], oldState[key]);

      });

      

      // Emit general change event

      this.emit('change', this.state, oldState);

    }

    

    return this;

  }

  

  // Subscribe to specific state property

  subscribe(key, callback) {

    return this.on(`change:${key}`, callback);

  }

  

  // Subscribe to all changes

  subscribeAll(callback) {

    return this.on('change', callback);

  }

  

  // Reset state

  reset(silent = false) {

    const initialState = this.history[0] || {};

    this.setState(initialState, silent);

    return this;

  }

  

  // Undo last state change

  undo() {

    if (this.history.length < 2) return this;

    

    this.history.pop(); // Remove current

    const previousState = this.history[this.history.length - 1];

    this.state = { ...previousState };

    

    this.emit('change', this.state, this.state);

    return this;

  }

  

  // Get state history

  getHistory() {

    return [...this.history];

  }

}



// Usage

const store = new Store({

  user: null,

  theme: 'light',

  notifications: []

});



// Subscribe to specific property

store.subscribe('user', (newUser, oldUser) => {

  console.log('User changed:', newUser);

});



store.subscribe('theme', (newTheme, oldTheme) => {

  console.log(`Theme changed from ${oldTheme} to ${newTheme}`);

  document.body.className = `theme-${newTheme}`;

});



// Subscribe to all changes

store.subscribeAll((newState, oldState) => {

  console.log('State updated:', newState);

});



// Update state

store.setState({ user: { name: 'John', id: 1 } });

store.setState({ theme: 'dark' });

store.setState({

  notifications: [

    { id: 1, message: 'Welcome!', type: 'info' }

  ]

});



console.log('Current state:', store.getState());

console.log('State history:', store.getHistory());

```



**Real-World Observer: Chat Application:**



```javascript

class ChatRoom extends EventEmitter {

  constructor(name) {

    super();

    this.name = name;

    this.users = new Map();

    this.messages = [];

    this.typingUsers = new Set();

  }

  

  // User joins room

  join(user) {

    if (this.users.has(user.id)) {

      console.log(`${user.name} is already in the room`);

      return;

    }

    

    this.users.set(user.id, user);

    

    this.emit('user:join', {

      user,

      room: this.name,

      userCount: this.users.size

    });

    

    console.log(`${user.name} joined ${this.name}`);

  }

  

  // User leaves room

  leave(userId) {

    const user = this.users.get(userId);

    

    if (!user) return;

    

    this.users.delete(userId);

    this.typingUsers.delete(userId);

    

    this.emit('user:leave', {

      user,

      room: this.name,

      userCount: this.users.size

    });

    

    console.log(`${user.name} left ${this.name}`);

  }

  

  // Send message

  sendMessage(userId, text) {

    const user = this.users.get(userId);

    

    if (!user) {

      throw new Error('User not in room');

    }

    

    const message = {

      id: Date.now(),

      userId,

      userName: user.name,

      text,

      timestamp: new Date()

    };

    

    this.messages.push(message);

    this.typingUsers.delete(userId);

    

    this.emit('message', message);

    this.emit('typing:stop', { userId, userName: user.name });

    

    return message;

  }

  

  // User typing indicator

  setTyping(userId, isTyping) {

    const user = this.users.get(userId);

    

    if (!user) return;

    

    if (isTyping) {

      this.typingUsers.add(userId);

      this.emit('typing:start', { userId, userName: user.name });

    } else {

      this.typingUsers.delete(userId);

      this.emit('typing:stop', { userId, userName: user.name });

    }

  }

  

  // Get room info

  getInfo() {

    return {

      name: this.name,

      userCount: this.users.size,

      messageCount: this.messages.length,

      users: Array.from(this.users.values()),

      typingUsers: Array.from(this.typingUsers)

    };

  }

  

  // Get messages

  getMessages(limit = 50) {

    return this.messages.slice(-limit);

  }

}



// Usage

const generalRoom = new ChatRoom('General');



// Setup listeners

generalRoom.on('user:join', ({ user, userCount }) => {

  console.log(`📢 ${user.name} joined the room (${userCount} users online)`);

});



generalRoom.on('user:leave', ({ user, userCount }) => {

  console.log(`📢 ${user.name} left the room (${userCount} users online)`);

});



generalRoom.on('message', (message) => {

  console.log(`💬 ${message.userName}: ${message.text}`);

});



generalRoom.on('typing:start', ({ userName }) => {

  console.log(`✏️  ${userName} is typing...`);

});



generalRoom.on('typing:stop', ({ userName }) => {

  console.log(`✏️  ${userName} stopped typing`);

});



// Simulate users

const john = { id: 1, name: 'John' };

const jane = { id: 2, name: 'Jane' };



generalRoom.join(john);

generalRoom.join(jane);



generalRoom.setTyping(john.id, true);

setTimeout(() => {

  generalRoom.sendMessage(john.id, 'Hello everyone!');

}, 1000);



setTimeout(() => {

  generalRoom.setTyping(jane.id, true);

}, 1500);



setTimeout(() => {

  generalRoom.sendMessage(jane.id, 'Hi John!');

}, 2500);



setTimeout(() => {

  generalRoom.leave(john.id);

}, 3000);



console.log('Room info:', generalRoom.getInfo());

```



---



### **6. Strategy Pattern**



Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.



```javascript

// Payment strategies

class PaymentStrategy {

  pay(amount) {

    throw new Error('pay() must be implemented');

  }

  

  validate() {

    throw new Error('validate() must be implemented');

  }

}



// Concrete strategies

class CreditCardStrategy extends PaymentStrategy {

  constructor(cardNumber, cvv, expiryDate) {

    super();

    this.cardNumber = cardNumber;

    this.cvv = cvv;

    this.expiryDate = expiryDate;

  }

  

  validate() {

    if (this.cardNumber.length !== 16) {

      throw new Error('Invalid card number');

    }

    

    if (this.cvv.length !== 3) {

      throw new Error('Invalid CVV');

    }

    

    const [month, year] = this.expiryDate.split('/');

    const expiry = new Date(2000 + parseInt(year), parseInt(month) - 1);

    

    if (expiry < new Date()) {

      throw new Error('Card expired');

    }

    

    return true;

  }

  

  pay(amount) {

    this.validate();

    console.log(`Processing credit card payment of $${amount}`);

    console.log(`Card: **** **** **** ${this.cardNumber.slice(-4)}`);

    

    // Simulate payment processing

    return {

      success: true,

      transactionId: `CC-${Date.now()}`,

      amount,

      method: 'Credit Card'

    };

  }

}



class PayPalStrategy extends PaymentStrategy {

  constructor(email, password) {

    super();

    this.email = email;

    this.password = password;

  }

  

  validate() {

    if (!this.email.includes('@')) {

      throw new Error('Invalid email');

    }

    

    if (this.password.length < 6) {

      throw new Error('Invalid password');

    }

    

    return true;

  }

  

  pay(amount) {

    this.validate();

    console.log(`Processing PayPal payment of $${amount}`);

    console.log(`PayPal account: ${this.email}`);

    

    return {

      success: true,

      transactionId: `PP-${Date.now()}`,

      amount,

      method: 'PayPal'

    };

  }

}



class CryptoStrategy extends PaymentStrategy {

  constructor(walletAddress, currency = 'BTC') {

    super();

    this.walletAddress = walletAddress;

    this.currency = currency;

  }

  

  validate() {

    if (this.walletAddress.length < 26) {

      throw new Error('Invalid wallet address');

    }

    

    return true;

  }

  

  pay(amount) {

    this.validate();

    console.log(`Processing ${this.currency} payment of $${amount}`);

    console.log(`Wallet: ${this.walletAddress.slice(0, 10)}...${this.walletAddress.slice(-10)}`);

    

    return {

      success: true,

      transactionId: `CRYPTO-${Date.now()}`,

      amount,

      method: `Cryptocurrency (${this.currency})`

    };

  }

}



// Context class that uses strategies

class ShoppingCart {

  constructor() {

    this.items = [];

    this.paymentStrategy = null;

  }

  

  addItem(item) {

    this.items.push(item);

    console.log(`Added: ${item.name} - $${item.price}`);

  }

  

  getTotal() {

    return this.items.reduce((sum, item) => sum + item.price, 0);

  }

  

  setPaymentStrategy(strategy) {

    this.paymentStrategy = strategy;

    console.log(`Payment method set: ${strategy.constructor.name}`);

  }

  

  checkout() {

    if (!this.paymentStrategy) {

      throw new Error('No payment method selected');

    }

    

    const total = this.getTotal();

    console.log(`\nCheckout Summary:`);

    console.log(`Items: ${this.items.length}`);

    console.log(`Total: $${total}\n`);

    

    const result = this.paymentStrategy.pay(total);

    

    if (result.success) {

      console.log(`\n✓ Payment successful!`);

      console.log(`Transaction ID: ${result.transactionId}`);

      this.items = []; // Clear cart

    }

    

    return result;

  }

}



// Usage

const cart = new ShoppingCart();



cart.addItem({ name: 'Laptop', price: 999.99 });

cart.addItem({ name: 'Mouse', price: 29.99 });

cart.addItem({ name: 'Keyboard', price: 79.99 });



// Pay with credit card

cart.setPaymentStrategy(

  new CreditCardStrategy('1234567890123456', '123', '12/25')

);

cart.checkout();



// New cart with PayPal

const cart2 = new ShoppingCart();

cart2.addItem({ name: 'Monitor', price: 299.99 });

cart2.setPaymentStrategy(

  new PayPalStrategy('user@example.com', 'password123')

);

cart2.checkout();



// New cart with Crypto

const cart3 = new ShoppingCart();

cart3.addItem({ name: 'Headphones', price: 149.99 });

cart3.setPaymentStrategy(

  new CryptoStrategy('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa', 'BTC')

);

cart3.checkout();

```



**Advanced Strategy: Sorting Algorithms:**



```javascript

class SortStrategy {

  sort(array) {

    throw new Error('sort() must be implemented');

  }

}



class BubbleSortStrategy extends SortStrategy {

  sort(array) {

    console.log('Using Bubble Sort');

    const arr = [...array];

    const n = arr.length;

    

    for (let i = 0; i < n - 1; i++) {

      for (let j = 0; j < n - i - 1; j++) {

        if (arr[j] > arr[j + 1]) {

          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];

        }

      }

    }

    

    return arr;

  }

}



class QuickSortStrategy extends SortStrategy {

  sort(array) {

    console.log('Using Quick Sort');

    return this.quickSort([...array]);

  }

  

  quickSort(arr) {

    if (arr.length <= 1) return arr;

    

    const pivot = arr[Math.floor(arr.length / 2)];

    const left = arr.filter(x => x < pivot);

    const middle = arr.filter(x => x === pivot);

    const right = arr.filter(x => x > pivot);

    

    return [...this.quickSort(left), ...middle, ...this.quickSort(right)];

  }

}



class MergeSortStrategy extends SortStrategy {

  sort(array) {

    console.log('Using Merge Sort');

    return this.mergeSort([...array]);

  }

  

  mergeSort(arr) {

    if (arr.length <= 1) return arr;

    

    const mid = Math.floor(arr.length / 2);

    const left = this.mergeSort(arr.slice(0, mid));

    const right = this.mergeSort(arr.slice(mid));

    

    return this.merge(left, right);

  }

  

  merge(left, right) {

    const result = [];

    let i = 0, j = 0;

    

    while (i < left.length && j < right.length) {

      if (left[i] <= right[j]) {

        result.push(left[i++]);

      } else {

        result.push(right[j++]);

      }

    }

    

    return result.concat(left.slice(i)).concat(right.slice(j));

  }

}



class Sorter {

  constructor(strategy) {

    this.strategy = strategy;

  }

  

  setStrategy(strategy) {

    this.strategy = strategy;

  }

  

  sort(array) {

    console.time('Sort time');

    const result = this.strategy.sort(array);

    console.timeEnd('Sort time');

    return result;

  }

}



// Usage

const data = [64, 34, 25, 12, 22, 11, 90, 88, 45, 50];



const sorter = new Sorter(new BubbleSortStrategy());

console.log('Bubble:', sorter.sort(data));



sorter.setStrategy(new QuickSortStrategy());

console.log('Quick:', sorter.sort(data));



sorter.setStrategy(new MergeSortStrategy());

console.log('Merge:', sorter.sort(data));

```



**Real-World Strategy: Compression:**



```javascript

class CompressionStrategy {

  compress(data) {

    throw new Error('compress() must be implemented');

  }

  

  decompress(data) {

    throw new Error('decompress() must be implemented');

  }

}



class ZipCompression extends CompressionStrategy {

  compress(data) {

    console.log('Compressing with ZIP...');

    // Simulated compression

    const compressed = {

      algorithm: 'ZIP',

      originalSize: data.length,

      compressedSize: Math.floor(data.length * 0.6),

      data: `ZIP:${data}`

    };

    console.log(`Compressed: ${compressed.originalSize} → ${compressed.compressedSize} bytes`);

    return compressed;

  }

  

  decompress(compressed) {

    console.log('Decompressing ZIP...');

    return compressed.data.replace('ZIP:', '');

  }

}



class GzipCompression extends CompressionStrategy {

  compress(data) {

    console.log('Compressing with GZIP...');

    const compressed = {

      algorithm: 'GZIP',

      originalSize: data.length,

      compressedSize: Math.floor(data.length * 0.5),

      data: `GZIP:${data}`

    };

    console.log(`Compressed: ${compressed.originalSize} → ${compressed.compressedSize} bytes`);

    return compressed;

  }

  

  decompress(compressed) {

    console.log('Decompressing GZIP...');

    return compressed.data.replace('GZIP:', '');

  }

}



class Brotli Compression extends CompressionStrategy {

  compress(data) {

    console.log('Compressing with Brotli...');

    const compressed = {

      algorithm: 'Brotli',

      originalSize: data.length,

      compressedSize: Math.floor(data.length * 0.4),

      data: `BROTLI:${data}`

    };

    console.log(`Compressed: ${compressed.originalSize} → ${compressed.compressedSize} bytes`);

    return compressed;

  }

  

  decompress(compressed) {

    console.log('Decompressing Brotli...');

    return compressed.data.replace('BROTLI:', '');

  }

}



class FileCompressor {

  constructor(strategy) {

    this.strategy = strategy;

  }

  

  setStrategy(strategy) {

    this.strategy = strategy;

  }

  

  compressFile(file) {

    console.log(`\nCompressing file: ${file.name}`);

    const compressed = this.strategy.compress(file.data);

    return {

      name: `${file.name}.${compressed.algorithm.toLowerCase()}`,

      ...compressed

    };

  }

  

  decompressFile(compressedFile) {

    console.log(`\nDecompressing file: ${compressedFile.name}`);

    const data = this.strategy.decompress(compressedFile);

    return {

      name: compressedFile.name.split('.').slice(0, -1).join('.'),

      data

    };

  }

}



// Usage

const file = {

  name: 'document.txt',

  data: 'This is some sample data that needs to be compressed'

};



const compressor = new FileCompressor(new ZipCompression());

let compressed = compressor.compressFile(file);



// Switch to GZIP

compressor.setStrategy(new GzipCompression());

compressed = compressor.compressFile(file);



// Switch to Brotli (best compression)

compressor.setStrategy(new BrotliCompression());

compressed = compressor.compressFile(file);



// Decompress

const decompressed = compressor.decompressFile(compressed);

console.log('\nDecompressed:', decompressed);

```



---



### **7. Decorator Pattern**



Adds new functionality to objects dynamically without modifying their structure. Wraps the original object to add new behavior.



```javascript

// Base component

class Coffee {

  cost() {

    return 5;

  }

  

  description() {

    return 'Simple Coffee';

  }

}



// Decorator base

class CoffeeDecorator {

  constructor(coffee) {

    this.coffee = coffee;

  }

  

  cost() {

    return this.coffee.cost();

  }

  

  description() {

    return this.coffee.description();

  }

}



// Concrete decorators

class MilkDecorator extends CoffeeDecorator {

  cost() {

    return this.coffee.cost() + 1;

  }

  

  description() {

    return `${this.coffee.description()} + Milk`;

  }

}



class SugarDecorator extends CoffeeDecorator {

  cost() {

    return this.coffee.cost() + 0.5;

  }

  

  description() {

    return `${this.coffee.description()} + Sugar`;

  }

}



class WhipCreamDecorator extends CoffeeDecorator {

  cost() {

    return this.coffee.cost() + 1.5;

  }

  

  description() {

    return `${this.coffee.description()} + Whip Cream`;

  }

}



class VanillaDecorator extends CoffeeDecorator {

  cost() {

    return this.coffee.cost() + 2;

  }

  

  description() {

    return `${this.coffee.description()} + Vanilla`;

  }

}



// Usage

let myCoffee = new Coffee();

console.log(`${myCoffee.description()} - $${myCoffee.cost()}`);

// Simple Coffee - $5



myCoffee = new MilkDecorator(myCoffee);

console.log(`${myCoffee.description()} - $${myCoffee.cost()}`);

// Simple Coffee + Milk - $6



myCoffee = new SugarDecorator(myCoffee);

console.log(`${myCoffee.description()} - $${myCoffee.cost()}`);

// Simple Coffee + Milk + Sugar - $6.5



myCoffee = new WhipCreamDecorator(myCoffee);

console.log(`${myCoffee.description()} - $${myCoffee.cost()}`);

// Simple Coffee + Milk + Sugar + Whip Cream - $8



// Create fancy coffee in one go

let fancyCoffee = new Coffee();

fancyCoffee = new MilkDecorator(fancyCoffee);

fancyCoffee = new VanillaDecorator(fancyCoffee);

fancyCoffee = new WhipCreamDecorator(fancyCoffee);

console.log(`${fancyCoffee.description()} - $${fancyCoffee.cost()}`);

// Simple Coffee + Milk + Vanilla + Whip Cream - $9.5

```



**Advanced Decorator: Logger Decorator:**



```javascript

// Function decorator

function logExecutionTime(target, propertyKey, descriptor) {

  const originalMethod = descriptor.value;

  

  descriptor.value = async function(...args) {

    console.log(`[${propertyKey}] Starting...`);

    const start = performance.now();

    

    try {

      const result = await originalMethod.apply(this, args);

      const end = performance.now();

      console.log(`[${propertyKey}] Completed in ${(end - start).toFixed(2)}ms`);

      return result;

    } catch (error) {

      const end = performance.now();

      console.log(`[${propertyKey}] Failed in ${(end - start).toFixed(2)}ms`);

      throw error;

    }

  };

  

  return descriptor;

}



function validateArgs(target, propertyKey, descriptor) {

  const originalMethod = descriptor.value;

  

  descriptor.value = function(...args) {

    console.log(`[${propertyKey}] Validating arguments:`, args);

    

    if (args.some(arg => arg === null || arg === undefined)) {

      throw new Error('Invalid arguments: null or undefined not allowed');

    }

    

    return originalMethod.apply(this, args);

  };

  

  return descriptor;

}



function memoize(target, propertyKey, descriptor) {

  const originalMethod = descriptor.value;

  const cache = new Map();

  

  descriptor.value = function(...args) {

    const key = JSON.stringify(args);

    

    if (cache.has(key)) {

      console.log(`[${propertyKey}] Cache hit for:`, args);

      return cache.get(key);

    }

    

    console.log(`[${propertyKey}] Cache miss, computing...`);

    const result = originalMethod.apply(this, args);

    cache.set(key, result);

    

    return result;

  };

  

  return descriptor;

}



// Without decorator support, use wrapper functions

function createLoggingDecorator(fn) {

  return function(...args) {

    console.log(`Calling ${fn.name} with:`, args);

    const result = fn.apply(this, args);

    console.log(`${fn.name} returned:`, result);

    return result;

  };

}



function createCachingDecorator(fn) {

  const cache = new Map();

  

  return function(...args) {

    const key = JSON.stringify(args);

    

    if (cache.has(key)) {

      console.log('Cache hit');

      return cache.get(key);

    }

    

    const result = fn.apply(this, args);

    cache.set(key, result);

    return result;

  };

}



// Usage

class Calculator {

  @validateArgs

  @memoize

  @logExecutionTime

  fibonacci(n) {

    if (n <= 1) return n;

    return this.fibonacci(n - 1) + this.fibonacci(n - 2);

  }

  

  @logExecutionTime

  async fetchData(url) {

    // Simulated API call

    await new Promise(resolve => setTimeout(resolve, 1000));

    return { data: `Data from ${url}` };

  }

}



// Without decorator support

function fibonacci(n) {

  if (n <= 1) return n;

  return fibonacci(n - 1) + fibonacci(n - 2);

}



const decoratedFib = createCachingDecorator(

  createLoggingDecorator(fibonacci)

);



console.log(decoratedFib(5));

console.log(decoratedFib(5)); // Cached

```



**Real-World Decorator: API Client:**



```javascript

class APIClient {

  async request(endpoint, options = {}) {

    const response = await fetch(endpoint, options);

    return response.json();

  }

}



// Decorator: Add authentication

class AuthDecorator {

  constructor(client, token) {

    this.client = client;

    this.token = token;

  }

  

  async request(endpoint, options = {}) {

    console.log('Adding authentication header');

    

    options.headers = {

      ...options.headers,

      'Authorization': `Bearer ${this.token}`

    };

    

    return this.client.request(endpoint, options);

  }

}



// Decorator: Add logging

class LoggingDecorator {

  constructor(client) {

    this.client = client;

  }

  

  async request(endpoint, options = {}) {

    console.log(`[API] ${options.method || 'GET'} ${endpoint}`);

    const start = Date.now();

    

    try {

      const result = await this.client.request(endpoint, options);

      const duration = Date.now() - start;

      console.log(`[API] Success (${duration}ms)`);

      return result;

    } catch (error) {

      const duration = Date.now() - start;

      console.log(`[API] Failed (${duration}ms):`, error.message);

      throw error;

    }

  }

}



// Decorator: Add retry logic

class RetryDecorator {

  constructor(client, maxRetries = 3, delay = 1000) {

    this.client = client;

    this.maxRetries = maxRetries;

    this.delay = delay;

  }

  

  async request(endpoint, options = {}) {

    let lastError;

    

    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {

      try {

        return await this.client.request(endpoint, options);

      } catch (error) {

        lastError = error;

        console.log(`Attempt ${attempt} failed, retrying...`);

        

        if (attempt < this.maxRetries) {

          await new Promise(resolve => setTimeout(resolve, this.delay));

        }

      }

    }

    

    throw lastError;

  }

}



// Decorator: Add caching

class CachingDecorator {

  constructor(client, ttl = 60000) {

    this.client = client;

    this.cache = new Map();

    this.ttl = ttl;

  }

  

  async request(endpoint, options = {}) {

    // Only cache GET requests

    if (options.method && options.method !== 'GET') {

      return this.client.request(endpoint, options);

    }

    

    const cacheKey = `${endpoint}:${JSON.stringify(options)}`;

    const cached = this.cache.get(cacheKey);

    

    if (cached && Date.now() - cached.timestamp < this.ttl) {

      console.log('Cache hit');

      return cached.data;

    }

    

    console.log('Cache miss');

    const data = await this.client.request(endpoint, options);

    

    this.cache.set(cacheKey, {

      data,

      timestamp: Date.now()

    });

    

    return data;

  }

}



// Decorator: Rate limiting

class RateLimitDecorator {

  constructor(client, maxRequests = 10, timeWindow = 60000) {

    this.client = client;

    this.maxRequests = maxRequests;

    this.timeWindow = timeWindow;

    this.requests = [];

  }

  

  async request(endpoint, options = {}) {

    const now = Date.now();

    

    // Remove old requests outside time window

    this.requests = this.requests.filter(time => now - time < this.timeWindow);

    

    if (this.requests.length >= this.maxRequests) {

      const oldestRequest = this.requests[0];

      const waitTime = this.timeWindow - (now - oldestRequest);

      console.log(`Rate limit exceeded, waiting ${waitTime}ms`);

      await new Promise(resolve => setTimeout(resolve, waitTime));

    }

    

    this.requests.push(now);

    return this.client.request(endpoint, options);

  }

}



// Usage: Stack decorators

let client = new APIClient();



// Add authentication

client = new AuthDecorator(client, 'my-secret-token');



// Add logging

client = new LoggingDecorator(client);



// Add retry logic

client = new RetryDecorator(client, 3, 1000);



// Add caching

client = new CachingDecorator(client, 60000);



// Add rate limiting

client = new RateLimitDecorator(client, 10, 60000);



// Now client has all features

// await client.request('/api/users');

// await client.request('/api/posts');

```



---



### **8. Proxy Pattern**



Provides a surrogate or placeholder for another object to control access to it.



```javascript

// Virtual Proxy - Lazy loading

class RealImage {

  constructor(filename) {

    this.filename = filename;

    this.loadFromDisk();

  }

  

  loadFromDisk() {

    console.log(`Loading image from disk: ${this.filename}`);

    // Simulate expensive operation

  }

  

  display() {

    console.log(`Displaying image: ${this.filename}`);

  }

}



class ImageProxy {

  constructor(filename) {

    this.filename = filename;

    this.realImage = null;

  }

  

  display() {

    // Lazy load: only create real image when needed

    if (!this.realImage) {

      this.realImage = new RealImage(this.filename);

    }

    this.realImage.display();

  }

}



// Usage

console.log('Creating proxy images...');

const image1 = new ImageProxy('photo1.jpg');

const image2 = new ImageProxy('photo2.jpg');

const image3 = new ImageProxy('photo3.jpg');



console.log('\nImages created, but not loaded yet\n');



console.log('Displaying first image:');

image1.display(); // Loads and displays



console.log('\nDisplaying first image again:');

image1.display(); // Just displays (already loaded)



console.log('\nDisplaying second image:');

image2.display(); // Loads and displays

```



**Protection Proxy - Access Control:**



```javascript

class BankAccount {

  constructor(owner, balance = 0) {

    this.owner = owner;

    this.balance = balance;

  }

  

  deposit(amount) {

    this.balance += amount;

    console.log(`Deposited $${amount}. New balance: $${this.balance}`);

  }

  

  withdraw(amount) {

    if (amount > this.balance) {

      console.log('Insufficient funds');

      return false;

    }

    

    this.balance -= amount;

    console.log(`Withdrew $${amount}. New balance: $${this.balance}`);

    return true;

  }

  

  getBalance() {

    return this.balance;

  }

}



class BankAccountProxy {

  constructor(account, currentUser) {

    this.account = account;

    this.currentUser = currentUser;

  }

  

  checkAccess(operation) {

    if (this.currentUser !== this.account.owner) {

      console.log(`Access denied: ${this.currentUser} cannot ${operation} ${this.account.owner}'s account`);

      return false;

    }

    return true;

  }

  

  deposit(amount) {

    if (!this.checkAccess('deposit to')) return false;

    return this.account.deposit(amount);

  }

  

  withdraw(amount) {

    if (!this.checkAccess('withdraw from')) return false;

    return this.account.withdraw(amount);

  }

  

  getBalance() {

    if (!this.checkAccess('view balance of')) return null;

    return this.account.getBalance();

  }

}



// Usage

const johnAccount = new BankAccount('John', 1000);

const johnProxy = new BankAccountProxy(johnAccount, 'John');

const hackerProxy = new BankAccountProxy(johnAccount, 'Hacker');



// John can access his account

johnProxy.deposit(500);    // ✓ Works

johnProxy.withdraw(200);   // ✓ Works

console.log('Balance:', johnProxy.getBalance()); // ✓ Works



// Hacker cannot access John's account

hackerProxy.withdraw(100); // ✗ Denied

hackerProxy.getBalance();  // ✗ Denied

```



**Logging Proxy - Track Access:**



```javascript

class DataStore {

  constructor() {

    this.data = new Map();

  }

  

  set(key, value) {

    this.data.set(key, value);

  }

  

  get(key) {

    return this.data.get(key);

  }

  

  delete(key) {

    return this.data.delete(key);

  }

  

  has(key) {

    return this.data.has(key);

  }

}



class DataStoreProxy {

  constructor(dataStore) {

    this.dataStore = dataStore;

    this.accessLog = [];

  }

  

  log(operation, key, value = null) {

    const logEntry = {

      timestamp: new Date(),

      operation,

      key,

      value

    };

    

    this.accessLog.push(logEntry);

    console.log(`[LOG] ${operation} - key: ${key}${value !== null ? `, value: ${value}` : ''}`);

  }

  

  set(key, value) {

    this.log('SET', key, value);

    return this.dataStore.set(key, value);

  }

  

  get(key) {

    this.log('GET', key);

    return this.dataStore.get(key);

  }

  

  delete(key) {

    this.log('DELETE', key);

    return this.dataStore.delete(key);

  }

  

  has(key) {

    this.log('HAS', key);

    return this.dataStore.has(key);

  }

  

  getAccessLog() {

    return [...this.accessLog];

  }

}



// Usage

const store = new DataStore();

const proxy = new DataStoreProxy(store);



proxy.set('user1', { name: 'John', age: 30 });

proxy.set('user2', { name: 'Jane', age: 25 });



console.log(proxy.get('user1'));

console.log(proxy.has('user2'));

proxy.delete('user1');



console.log('\nAccess Log:');

console.log(proxy.getAccessLog());

```



**Smart Proxy with ES6 Proxy:**



```javascript

// Modern JavaScript Proxy

const user = {

  name: 'John',

  age: 30,

  email: 'john@example.com'

};



// Validation proxy

const validationHandler = {

  set(target, property, value) {

    console.log(`Setting ${property} = ${value}`);

    

    // Validate age

    if (property === 'age') {

      if (typeof value !== 'number' || value < 0 || value > 150) {

        throw new Error('Invalid age');

      }

    }

    

    // Validate email

    if (property === 'email') {

      if (!value.includes('@')) {

        throw new Error('Invalid email');

      }

    }

    

    target[property] = value;

    return true;

  },

  

  get(target, property) {

    console.log(`Getting ${property}`);

    

    // Hide sensitive properties

    if (property === 'password') {

      return '***';

    }

    

    return target[property];

  }

};



const userProxy = new Proxy(user, validationHandler);



// Valid operations

userProxy.name = 'Jane'; // ✓ Works

userProxy.age = 25;      // ✓ Works



// Invalid operations

try {

  userProxy.age = -5; // ✗ Throws error

} catch (error) {

  console.error(error.message);

}



try {

  userProxy.email = 'invalid'; // ✗ Throws error

} catch (error) {

  console.error(error.message);

}



console.log(userProxy.name); // Gets value

```



**Caching Proxy:**



```javascript

class ExpensiveCalculator {

  calculate(n) {

    console.log(`Performing expensive calculation for ${n}...`);

    

    // Simulate expensive operation

    let result = 0;

    for (let i = 0; i <= n; i++) {

      result += i;

    }

    

    return result;

  }

}



const calculatorHandler = {

  cache: new Map(),

  

  get(target, property) {

    if (property === 'calculate') {

      return (n) => {

        // Check cache

        if (this.cache.has(n)) {

          console.log(`Cache hit for ${n}`);

          return this.cache.get(n);

        }

        

        // Calculate and cache

        console.log(`Cache miss for ${n}`);

        const result = target[property](n);

        this.cache.set(n, result);

        

        return result;

      };

    }

    

    return target[property];

  }

};



const calculator = new ExpensiveCalculator();

const cachedCalculator = new Proxy(calculator, calculatorHandler);



console.log(cachedCalculator.calculate(1000)); // Calculates

console.log(cachedCalculator.calculate(1000)); // Returns cached

console.log(cachedCalculator.calculate(2000)); // Calculates

console.log(cachedCalculator.calculate(2000)); // Returns cached

```



---



### **9. Facade Pattern**



Provides a simplified interface to a complex subsystem, hiding its complexity from clients.



```javascript

// Complex subsystems

class CPU {

  freeze() {

    console.log('CPU: Freezing processor');

  }

  

  jump(position) {

    console.log(`CPU: Jumping to position ${position}`);

  }

  

  execute() {

    console.log('CPU: Executing instructions');

  }

}



class Memory {

  load(position, data) {

    console.log(`Memory: Loading data at position ${position}`);

  }

}



class HardDrive {

  read(lba, size) {

    console.log(`HardDrive: Reading ${size} bytes from LBA ${lba}`);

    return 'boot data';

  }

}



// Facade - Simple interface

class ComputerFacade {

  constructor() {

    this.cpu = new CPU();

    this.memory = new Memory();

    this.hardDrive = new HardDrive();

  }

  

  start() {

    console.log('Starting computer...\n');

    

    this.cpu.freeze();

    this.memory.load(0, this.hardDrive.read(0, 1024));

    this.cpu.jump(0);

    this.cpu.execute();

    

    console.log('\nComputer started successfully!');

  }

}



// Usage - Simple for client

const computer = new ComputerFacade();

computer.start();



// Without facade, client would need to:

// const cpu = new CPU();

// const memory = new Memory();

// const hardDrive = new HardDrive();

// cpu.freeze();

// memory.load(0, hardDrive.read(0, 1024));

// cpu.jump(0);

// cpu.execute();

```



**Advanced Facade: Home Theater System:**



```javascript

// Complex subsystems

class Amplifier {

  on() {

    console.log('Amplifier: Powering on');

  }

  

  off() {

    console.log('Amplifier: Powering off');

  }

  

  setVolume(level) {

    console.log(`Amplifier: Setting volume to ${level}`);

  }

  

  setSurroundSound() {

    console.log('Amplifier: Setting surround sound mode');

  }

}



class DVDPlayer {

  on() {

    console.log('DVD Player: Powering on');

  }

  

  off() {

    console.log('DVD Player: Powering off');

  }

  

  play(movie) {

    console.log(`DVD Player: Playing "${movie}"`);

  }

  

  stop() {

    console.log('DVD Player: Stopping playback');

  }

  

  eject() {

    console.log('DVD Player: Ejecting disc');

  }

}



class Projector {

  on() {

    console.log('Projector: Powering on');

  }

  

  off() {

    console.log('Projector: Powering off');

  }

  

  wideScreenMode() {

    console.log('Projector: Setting widescreen mode');

  }

}



class Lights {

  dim(level) {

    console.log(`Lights: Dimming to ${level}%`);

  }

  

  on() {

    console.log('Lights: Turning on');

  }

}



class Screen {

  down() {

    console.log('Screen: Lowering screen');

  }

  

  up() {

    console.log('Screen: Raising screen');

  }

}



// Facade - Simplified interface

class HomeTheaterFacade {

  constructor() {

    this.amplifier = new Amplifier();

    this.dvdPlayer = new DVDPlayer();

    this.projector = new Projector();

    this.lights = new Lights();

    this.screen = new Screen();

  }

  

  watchMovie(movie) {

    console.log(`\n=== Starting Movie: "${movie}" ===\n`);

    

    this.lights.dim(10);

    this.screen.down();

    this.projector.on();

    this.projector.wideScreenMode();

    this.amplifier.on();

    this.amplifier.setSurroundSound();

    this.amplifier.setVolume(5);

    this.dvdPlayer.on();

    this.dvdPlayer.play(movie);

    

    console.log('\n=== Enjoy your movie! ===\n');

  }

  

  endMovie() {

    console.log('\n=== Ending Movie ===\n');

    

    this.dvdPlayer.stop();

    this.dvdPlayer.eject();

    this.dvdPlayer.off();

    this.amplifier.off();

    this.projector.off();

    this.screen.up();

    this.lights.on();

    

    console.log('\n=== Movie ended ===\n');

  }

  

  listenToMusic(source) {

    console.log(`\n=== Playing Music from ${source} ===\n`);

    

    this.lights.dim(30);

    this.amplifier.on();

    this.amplifier.setVolume(3);

    

    console.log('\n=== Enjoy your music! ===\n');

  }

  

  endMusic() {

    console.log('\n=== Stopping Music ===\n');

    

    this.amplifier.off();

    this.lights.on();

    

    console.log('\n=== Music stopped ===\n');

  }

}



// Usage

const homeTheater = new HomeTheaterFacade();



// Watch a movie

homeTheater.watchMovie('The Matrix');



// Later...

homeTheater.endMovie();



// Listen to music

homeTheater.listenToMusic('Spotify');



// Later...

homeTheater.endMusic();

```



**Real-World Facade: API Client:**



```javascript

// Complex API operations

class AuthService {

  async login(credentials) {

    console.log('AuthService: Logging in...');

    // API call

    return { token: 'jwt-token-123', userId: 1 };

  }

  

  async logout(token) {

    console.log('AuthService: Logging out...');

    // API call

  }

  

  async refreshToken(token) {

    console.log('AuthService: Refreshing token...');

    return { token: 'new-jwt-token-456' };

  }

}



class UserService {

  async getProfile(userId, token) {

    console.log(`UserService: Getting profile for user ${userId}...`);

    return { id: userId, name: 'John Doe', email: 'john@example.com' };

  }

  

  async updateProfile(userId, data, token) {

    console.log(`UserService: Updating profile for user ${userId}...`);

    return { ...data, id: userId };

  }

}



class DataService {

  async fetchData(endpoint, token) {

    console.log(`DataService: Fetching from ${endpoint}...`);

    return { data: [] };

  }

  

  async postData(endpoint, data, token) {

    console.log(`DataService: Posting to ${endpoint}...`);

    return { success: true };

  }

}



class StorageService {

  saveToken(token) {

    console.log('StorageService: Saving token to localStorage');

    localStorage.setItem('token', token);

  }

  

  getToken() {

    console.log('StorageService: Retrieving token from localStorage');

    return localStorage.getItem('token');

  }

  

  clearToken() {

    console.log('StorageService: Clearing token from localStorage');

    localStorage.removeItem('token');

  }

}



// Facade - Simplified API

class APIFacade {

  constructor() {

    this.authService = new AuthService();

    this.userService = new UserService();

    this.dataService = new DataService();

    this.storageService = new StorageService();

    this.currentToken = null;

    this.currentUserId = null;

  }

  

  async login(email, password) {

    try {

      const { token, userId } = await this.authService.login({ email, password });

      

      this.currentToken = token;

      this.currentUserId = userId;

      this.storageService.saveToken(token);

      

      // Automatically fetch user profile

      const profile = await this.userService.getProfile(userId, token);

      

      console.log('✓ Login successful');

      return { success: true, profile };

    } catch (error) {

      console.error('✗ Login failed:', error);

      return { success: false, error };

    }

  }

  

  async logout() {

    try {

      await this.authService.logout(this.currentToken);

      

      this.storageService.clearToken();

      this.currentToken = null;

      this.currentUserId = null;

      

      console.log('✓ Logout successful');

      return { success: true };

    } catch (error) {

      console.error('✗ Logout failed:', error);

      return { success: false, error };

    }

  }

  

  async updateProfile(data) {

    try {

      // Auto-refresh token if needed

      await this.ensureValidToken();

      

      const updated = await this.userService.updateProfile(

        this.currentUserId,

        data,

        this.currentToken

      );

      

      console.log('✓ Profile updated');

      return { success: true, profile: updated };

    } catch (error) {

      console.error('✗ Profile update failed:', error);

      return { success: false, error };

    }

  }

  

  async fetchPosts() {

    try {

      await this.ensureValidToken();

      

      const posts = await this.dataService.fetchData('/posts', this.currentToken);

      

      return { success: true, posts };

    } catch (error) {

      console.error('✗ Fetch posts failed:', error);

      return { success: false, error };

    }

  }

  

  async createPost(postData) {

    try {

      await this.ensureValidToken();

      

      const result = await this.dataService.postData('/posts', postData, this.currentToken);

      

      console.log('✓ Post created');

      return { success: true, result };

    } catch (error) {

      console.error('✗ Create post failed:', error);

      return { success: false, error };

    }

  }

  

  async ensureValidToken() {

    // Check if token needs refresh

    // For simplicity, just log

    console.log('Checking token validity...');

  }

  

  isAuthenticated() {

    return this.currentToken !== null;

  }

}



// Usage - Much simpler for client

const api = new APIFacade();



// Login

await api.login('user@example.com', 'password');



// Update profile

await api.updateProfile({ name: 'Jane Doe', bio: 'Developer' });



// Fetch posts

await api.fetchPosts();



// Create post

await api.createPost({ title: 'Hello World', content: 'My first post' });



// Logout

await api.logout();

```



---



### **10. Command Pattern**



Encapsulates a request as an object, allowing you to parameterize clients with different requests, queue requests, and support undoable operations.



```javascript

// Receiver - the actual object that performs actions

class Light {

  constructor(location) {

    this.location = location;

    this.isOn = false;

  }

  

  on() {

    this.isOn = true;

    console.log(`${this.location} light is ON`);

  }

  

  off() {

    this.isOn = false;

    console.log(`${this.location} light is OFF`);

  }

}



// Command interface

class Command {

  execute() {

    throw new Error('execute() must be implemented');

  }

  

  undo() {

    throw new Error('undo() must be implemented');

  }

}



// Concrete commands

class LightOnCommand extends Command {

  constructor(light) {

    super();

    this.light = light;

  }

  

  execute() {

    this.light.on();

  }

  

  undo() {

    this.light.off();

  }

}



class LightOffCommand extends Command {

  constructor(light) {

    super();

    this.light = light;

  }

  

  execute() {

    this.light.off();

  }

  

  undo() {

    this.light.on();

  }

}



// Invoker - triggers commands

class RemoteControl {

  constructor() {

    this.history = [];

  }

  

  submit(command) {

    command.execute();

    this.history.push(command);

  }

  

  undo() {

    if (this.history.length === 0) {

      console.log('Nothing to undo');

      return;

    }

    

    const command = this.history.pop();

    command.undo();

  }

}



// Usage

const livingRoomLight = new Light('Living Room');

const kitchenLight = new Light('Kitchen');



const livingRoomOn = new LightOnCommand(livingRoomLight);

const livingRoomOff = new LightOffCommand(livingRoomLight);

const kitchenOn = new LightOnCommand(kitchenLight);

const kitchenOff = new LightOffCommand(kitchenLight);



const remote = new RemoteControl();



remote.submit(livingRoomOn);  // Living Room light is ON

remote.submit(kitchenOn);      // Kitchen light is ON

remote.submit(livingRoomOff);  // Living Room light is OFF



remote.undo();  // Living Room light is ON (undoes last command)

remote.undo();  // Kitchen light is OFF

remote.undo();  // Living Room light is OFF

```



**Advanced Command: Text Editor:**



```javascript

class TextEditor {

  constructor() {

    this.content = '';

  }

  

  getContent() {

    return this.content;

  }

  

  setContent(content) {

    this.content = content;

  }

  

  insert(text, position) {

    this.content = 

      this.content.slice(0, position) + 

      text + 

      this.content.slice(position);

  }

  

  delete(position, length) {

    return this.content.slice(position, position + length);

  }

}



class EditorCommand {

  execute() {}

  undo() {}

  redo() {}

}



class InsertCommand extends EditorCommand {

  constructor(editor, text, position) {

    super();

    this.editor = editor;

    this.text = text;

    this.position = position;

  }

  

  execute() {

    this.editor.insert(this.text, this.position);

    console.log(`Inserted "${this.text}" at position ${this.position}`);

  }

  

  undo() {

    const before = this.editor.getContent();

    this.editor.setContent(

      before.slice(0, this.position) + 

      before.slice(this.position + this.text.length)

    );

    console.log(`Undid insert of "${this.text}"`);

  }

  

  redo() {

    this.execute();

  }

}



class DeleteCommand extends EditorCommand {

  constructor(editor, position, length) {

    super();

    this.editor = editor;

    this.position = position;

    this.length = length;

    this.deletedText = '';

  }

  

  execute() {

    const content = this.editor.getContent();

    this.deletedText = content.slice(this.position, this.position + this.length);

    this.editor.setContent(

      content.slice(0, this.position) + 

      content.slice(this.position + this.length)

    );

    console.log(`Deleted "${this.deletedText}" at position ${this.position}`);

  }

  

  undo() {

    this.editor.insert(this.deletedText, this.position);

    console.log(`Undid delete of "${this.deletedText}"`);

  }

  

  redo() {

    this.execute();

  }

}



class ReplaceCommand extends EditorCommand {

  constructor(editor, oldText, newText) {

    super();

    this.editor = editor;

    this.oldText = oldText;

    this.newText = newText;

  }

  

  execute() {

    const content = this.editor.getContent();

    this.editor.setContent(content.replace(this.oldText, this.newText));

    console.log(`Replaced "${this.oldText}" with "${this.newText}"`);

  }

  

  undo() {

    const content = this.editor.getContent();

    this.editor.setContent(content.replace(this.newText, this.oldText));

    console.log(`Undid replace`);

  }

  

  redo() {

    this.execute();

  }

}



class CommandManager {

  constructor() {

    this.history = [];

    this.currentIndex = -1;

  }

  

  execute(command) {

    // Remove any commands after current index (when editing after undo)

    this.history = this.history.slice(0, this.currentIndex + 1);

    

    command.execute();

    this.history.push(command);

    this.currentIndex++;

  }

  

  undo() {

    if (this.currentIndex < 0) {

      console.log('Nothing to undo');

      return false;

    }

    

    this.history[this.currentIndex].undo();

    this.currentIndex--;

    return true;

  }

  

  redo() {

    if (this.currentIndex >= this.history.length - 1) {

      console.log('Nothing to redo');

      return false;

    }

    

    this.currentIndex++;

    this.history[this.currentIndex].redo();

    return true;

  }

  

  getHistory() {

    return this.history.map((cmd, index) => ({

      index,

      command: cmd.constructor.name,

      current: index === this.currentIndex

    }));

  }

}



// Usage

const editor = new TextEditor();

const manager = new CommandManager();



manager.execute(new InsertCommand(editor, 'Hello', 0));

console.log('Content:', editor.getContent()); // "Hello"



manager.execute(new InsertCommand(editor, ' World', 5));

console.log('Content:', editor.getContent()); // "Hello World"



manager.execute(new ReplaceCommand(editor, 'World', 'JavaScript'));

console.log('Content:', editor.getContent()); // "Hello JavaScript"



manager.undo(); // Undo replace

console.log('Content:', editor.getContent()); // "Hello World"



manager.undo(); // Undo insert " World"

console.log('Content:', editor.getContent()); // "Hello"



manager.redo(); // Redo insert " World"

console.log('Content:', editor.getContent()); // "Hello World"



console.log('\nHistory:', manager.getHistory());

```



**Real-World Command: Task Queue:**



```javascript

class Task {

  constructor(name, action) {

    this.name = name;

    this.action = action;

    this.status = 'pending'; // pending, running, completed, failed

    this.result = null;

    this.error = null;

  }

  

  async execute() {

    this.status = 'running';

    console.log(`[TASK] Running: ${this.name}`);

    

    try {

      this.result = await this.action();

      this.status = 'completed';

      console.log(`[TASK] Completed: ${this.name}`);

      return this.result;

    } catch (error) {

      this.status = 'failed';

      this.error = error;

      console.error(`[TASK] Failed: ${this.name}`, error.message);

      throw error;

    }

  }

  

  getInfo() {

    return {

      name: this.name,

      status: this.status,

      result: this.result,

      error: this.error?.message

    };

  }

}



class TaskQueue {

  constructor(concurrency = 1) {

    this.queue = [];

    this.running = [];

    this.completed = [];

    this.failed = [];

    this.concurrency = concurrency;

    this.isPaused = false;

  }

  

  add(task) {

    this.queue.push(task);

    console.log(`[QUEUE] Added task: ${task.name} (${this.queue.length} in queue)`);

    

    this.processNext();

    return this;

  }

  

  async processNext() {

    if (this.isPaused) return;

    if (this.running.length >= this.concurrency) return;

    if (this.queue.length === 0) return;

    

    const task = this.queue.shift();

    this.running.push(task);

    

    try {

      await task.execute();

      this.completed.push(task);

    } catch (error) {

      this.failed.push(task);

    } finally {

      const index = this.running.indexOf(task);

      if (index > -1) {

        this.running.splice(index, 1);

      }

      

      // Process next task

      this.processNext();

    }

  }

  

  pause() {

    this.isPaused = true;

    console.log('[QUEUE] Paused');

  }

  

  resume() {

    this.isPaused = false;

    console.log('[QUEUE] Resumed');

    

    // Process pending tasks

    while (this.running.length < this.concurrency && this.queue.length > 0) {

      this.processNext();

    }

  }

  

  clear() {

    this.queue = [];

    console.log('[QUEUE] Cleared pending tasks');

  }

  

  getStatus() {

    return {

      queued: this.queue.length,

      running: this.running.length,

      completed: this.completed.length,

      failed: this.failed.length,

      total: this.queue.length + this.running.length + this.completed.length + this.failed.length

    };

  }

  

  getResults() {

    return {

      completed: this.completed.map(t => t.getInfo()),

      failed: this.failed.map(t => t.getInfo())

    };

  }

}



// Usage

const queue = new TaskQueue(2); // Process 2 tasks concurrently



// Add tasks

queue.add(new Task('Download File 1', async () => {

  await new Promise(resolve => setTimeout(resolve, 1000));

  return 'file1.jpg downloaded';

}));



queue.add(new Task('Download File 2', async () => {

  await new Promise(resolve => setTimeout(resolve, 1500));

  return 'file2.jpg downloaded';

}));



queue.add(new Task('Process Image', async () => {

  await new Promise(resolve => setTimeout(resolve, 800));

  return 'image processed';

}));



queue.add(new Task('Upload to Server', async () => {

  await new Promise(resolve => setTimeout(resolve, 1200));

  return 'uploaded successfully';

}));



queue.add(new Task('Failing Task', async () => {

  await new Promise(resolve => setTimeout(resolve, 500));

  throw new Error('Simulated failure');

}));



// Wait a bit then check status

setTimeout(() => {

  console.log('\n[STATUS]', queue.getStatus());

}, 2000);



setTimeout(() => {

  console.log('\n[FINAL STATUS]', queue.getStatus());

  console.log('\n[RESULTS]', queue.getResults());

}, 5000);

```



---



### **11. Iterator Pattern**



Provides a way to access elements of a collection sequentially without exposing its underlying representation.



```javascript

// Custom Iterator

class ArrayIterator {

  constructor(array) {

    this.array = array;

    this.index = 0;

  }

  

  hasNext() {

    return this.index < this.array.length;

  }

  

  next() {

    if (!this.hasNext()) {

      throw new Error('No more elements');

    }

    

    return this.array[this.index++];

  }

  

  reset() {

    this.index = 0;

  }

  

  current() {

    return this.array[this.index];

  }

}



// Usage

const iterator = new ArrayIterator([1, 2, 3, 4, 5]);



while (iterator.hasNext()) {

  console.log(iterator.next());

}

// Output: 1, 2, 3, 4, 5



iterator.reset();

console.log(iterator.next()); // 1

```



**ES6 Iterator Protocol:**



```javascript

// Custom iterable object

class Range {

  constructor(start, end, step = 1) {

    this.start = start;

    this.end = end;

    this.step = step;

  }

  

  // Make it iterable by implementing [Symbol.iterator]

  [Symbol.iterator]() {

    let current = this.start;

    const end = this.end;

    const step = this.step;

    

    return {

      next() {

        if (current <= end) {

          const value = current;

          current += step;

          return { value, done: false };

        }

        return { done: true };

      }

    };

  }

}



// Usage with for...of

const range = new Range(1, 10, 2);



for (const num of range) {

  console.log(num); // 1, 3, 5, 7, 9

}



// Works with spread operator

console.log([...range]); // [1, 3, 5, 7, 9]



// Works with destructuring

const [first, second, ...rest] = range;

console.log(first, second, rest); // 1, 3, [5, 7, 9]

```



**Advanced Iterator: Tree Traversal:**



```javascript

class TreeNode {

  constructor(value) {

    this.value = value;

    this.children = [];

  }

  

  addChild(node) {

    this.children.push(node);

  }

}



class TreeIterator {

  constructor(root, strategy = 'breadth') {

    this.root = root;

    this.strategy = strategy;

    this.queue = [];

    this.stack = [];

    this.visited = new Set();

    this.initialize();

  }

  

  initialize() {

    if (this.strategy === 'breadth') {

      this.queue.push(this.root);

    } else if (this.strategy === 'depth') {

      this.stack.push(this.root);

    }

  }

  

  hasNext() {

    if (this.strategy === 'breadth') {

      return this.queue.length > 0;

    } else if (this.strategy === 'depth') {

      return this.stack.length > 0;

    }

  }

  

  next() {

    if (!this.hasNext()) {

      throw new Error('No more elements');

    }

    

    let node;

    

    if (this.strategy === 'breadth') {

      // Breadth-first (BFS)

      node = this.queue.shift();

      this.queue.push(...node.children);

    } else if (this.strategy === 'depth') {

      // Depth-first (DFS)

      node = this.stack.pop();

      this.stack.push(...node.children.reverse());

    }

    

    return node;

  }

  

  [Symbol.iterator]() {

    return {

      hasNext: () => this.hasNext(),

      next: () => {

        if (!this.hasNext()) {

          return { done: true };

        }

        return { value: this.next(), done: false };

      }

    };

  }

}



// Build tree

const root = new TreeNode('Root');

const child1 = new TreeNode('Child 1');

const child2 = new TreeNode('Child 2');

const child3 = new TreeNode('Child 3');

const grandchild1 = new TreeNode('Grandchild 1');

const grandchild2 = new TreeNode('Grandchild 2');



root.addChild(child1);

root.addChild(child2);

root.addChild(child3);

child1.addChild(grandchild1);

child1.addChild(grandchild2);



// Breadth-first traversal

console.log('Breadth-first:');

const bfsIterator = new TreeIterator(root, 'breadth');

while (bfsIterator.hasNext()) {

  const node = bfsIterator.next();

  console.log(node.value);

}

// Output: Root, Child 1, Child 2, Child 3, Grandchild 1, Grandchild 2



// Depth-first traversal

console.log('\nDepth-first:');

const dfsIterator = new TreeIterator(root, 'depth');

while (dfsIterator.hasNext()) {

  const node = dfsIterator.next();

  console.log(node.value);

}

// Output: Root, Child 1, Grandchild 1, Grandchild 2, Child 2, Child 3

```



**Generator-based Iterator:**



```javascript

class Playlist {

  constructor() {

    this.songs = [];

    this.currentIndex = 0;

  }

  

  addSong(song) {

    this.songs.push(song);

  }

  

  // Generator for sequential iteration

  *[Symbol.iterator]() {

    for (const song of this.songs) {

      yield song;

    }

  }

  

  // Generator for shuffle mode

  *shuffle() {

    const shuffled = [...this.songs].sort(() => Math.random() - 0.5);

    for (const song of shuffled) {

      yield song;

    }

  }

  

  // Generator for repeat mode

  *repeat(times = Infinity) {

    let count = 0;

    while (count < times) {

      for (const song of this.songs) {

        yield song;

      }

      count++;

    }

  }

  

  // Generator with filtering

  *filterByArtist(artist) {

    for (const song of this.songs) {

      if (song.artist === artist) {

        yield song;

      }

    }

  }

  

  // Async generator for streaming

  async *stream() {

    for (const song of this.songs) {

      // Simulate loading/buffering

      await new Promise(resolve => setTimeout(resolve, 100));

      console.log(`Streaming: ${song.title}`);

      yield song;

    }

  }

}



// Usage

const playlist = new Playlist();

playlist.addSong({ title: 'Song 1', artist: 'Artist A', duration: 180 });

playlist.addSong({ title: 'Song 2', artist: 'Artist B', duration: 200 });

playlist.addSong({ title: 'Song 3', artist: 'Artist A', duration: 220 });

playlist.addSong({ title: 'Song 4', artist: 'Artist C', duration: 190 });



// Normal iteration

console.log('Normal play:');

for (const song of playlist) {

  console.log(song.title);

}



// Shuffle

console.log('\nShuffle mode:');

for (const song of playlist.shuffle()) {

  console.log(song.title);

}



// Repeat 2 times

console.log('\nRepeat 2 times:');

for (const song of playlist.repeat(2)) {

  console.log(song.title);

}



// Filter by artist

console.log('\nArtist A songs:');

for (const song of playlist.filterByArtist('Artist A')) {

  console.log(song.title);

}



// Async streaming

console.log('\nStreaming:');

(async () => {

  for await (const song of playlist.stream()) {

    // Song is being streamed

  }

})();

```



**Real-World Iterator: Paginated API:**



```javascript

class PaginatedAPI {

  constructor(baseUrl, pageSize = 10) {

    this.baseUrl = baseUrl;

    this.pageSize = pageSize;

    this.currentPage = 1;

    this.totalPages = null;

    this.cache = new Map();

  }

  

  async fetchPage(page) {

    // Check cache

    if (this.cache.has(page)) {

      console.log(`Cache hit for page ${page}`);

      return this.cache.get(page);

    }

    

    console.log(`Fetching page ${page}...`);

    

    // Simulated API call

    const response = {

      page,

      pageSize: this.pageSize,

      totalPages: 5,

      totalItems: 47,

      data: Array.from({ length: this.pageSize }, (_, i) => ({

        id: (page - 1) * this.pageSize + i + 1,

        name: `Item ${(page - 1) * this.pageSize + i + 1}`

      }))

    };

    

    // Simulate network delay

    await new Promise(resolve => setTimeout(resolve, 500));

    

    this.totalPages = response.totalPages;

    this.cache.set(page, response.data);

    

    return response.data;

  }

  

  async *[Symbol.asyncIterator]() {

    while (this.totalPages === null || this.currentPage <= this.totalPages) {

      const data = await this.fetchPage(this.currentPage);

      

      for (const item of data) {

        yield item;

      }

      

      this.currentPage++;

      

      if (this.totalPages !== null && this.currentPage > this.totalPages) {

        break;

      }

    }

  }

  

  async *pages() {

    let page = 1;

    

    while (this.totalPages === null || page <= this.totalPages) {

      const data = await this.fetchPage(page);

      yield { page, data };

      

      page++;

      

      if (this.totalPages !== null && page > this.totalPages) {

        break;

      }

    }

  }

  

  reset() {

    this.currentPage = 1;

    this.totalPages = null;

  }

}



// Usage

const api = new PaginatedAPI('/api/items', 10);



// Iterate through all items

console.log('All items:');

(async () => {

  for await (const item of api) {

    console.log(item);

    

    // Early exit if needed

    if (item.id === 25) {

      console.log('Stopping at item 25');

      break;

    }

  }

})();



// Iterate by pages

console.log('\nBy pages:');

(async () => {

  for await (const { page, data } of api.pages()) {

    console.log(`Page ${page}:`, data.length, 'items');

  }

})();

```



---



### **12. Chain of Responsibility Pattern**



Passes requests along a chain of handlers. Each handler decides either to process the request or pass it to the next handler.



```javascript

// Base Handler

class Handler {

  constructor() {

    this.nextHandler = null;

  }

  

  setNext(handler) {

    this.nextHandler = handler;

    return handler; // Allow chaining

  }

  

  handle(request) {

    if (this.nextHandler) {

      return this.nextHandler.handle(request);

    }

    return null;

  }

}



// Concrete Handlers

class AuthenticationHandler extends Handler {

  handle(request) {

    console.log('AuthenticationHandler: Checking authentication...');

    

    if (!request.user) {

      console.log('❌ Authentication failed: No user');

      return { success: false, error: 'Not authenticated' };

    }

    

    console.log('✓ Authentication passed');

    return super.handle(request);

  }

}



class AuthorizationHandler extends Handler {

  handle(request) {

    console.log('AuthorizationHandler: Checking authorization...');

    

    if (!request.user.role || request.user.role !== 'admin') {

      console.log('❌ Authorization failed: Not admin');

      return { success: false, error: 'Not authorized' };

    }

    

    console.log('✓ Authorization passed');

    return super.handle(request);

  }

}



class ValidationHandler extends Handler {

  handle(request) {

    console.log('ValidationHandler: Validating request data...');

    

    if (!request.data || Object.keys(request.data).length === 0) {

      console.log('❌ Validation failed: No data');

      return { success: false, error: 'Invalid data' };

    }

    

    console.log('✓ Validation passed');

    return super.handle(request);

  }

}



class LoggingHandler extends Handler {

  handle(request) {

    console.log('LoggingHandler: Logging request...');

    console.log(`[LOG] ${request.method} ${request.path} by ${request.user?.name || 'anonymous'}`);

    

    return super.handle(request);

  }

}



class ProcessHandler extends Handler {

  handle(request) {

    console.log('ProcessHandler: Processing request...');

    console.log('✓ Request processed successfully');

    

    return {

      success: true,

      data: { message: 'Request processed', request }

    };

  }

}



// Usage

const authHandler = new AuthenticationHandler();

const authzHandler = new AuthorizationHandler();

const validationHandler = new ValidationHandler();

const loggingHandler = new LoggingHandler();

const processHandler = new ProcessHandler();



// Build chain

authHandler

  .setNext(authzHandler)

  .setNext(validationHandler)

  .setNext(loggingHandler)

  .setNext(processHandler);



// Test 1: Valid request

console.log('\n=== Test 1: Valid Request ===');

const request1 = {

  method: 'POST',

  path: '/api/users',

  user: { name: 'John', role: 'admin' },

  data: { name: 'New User' }

};

const result1 = authHandler.handle(request1);

console.log('Result:', result1);



// Test 2: No authentication

console.log('\n=== Test 2: No Authentication ===');

const request2 = {

  method: 'POST',

  path: '/api/users',

  data: { name: 'New User' }

};

const result2 = authHandler.handle(request2);

console.log('Result:', result2);



// Test 3: No authorization

console.log('\n=== Test 3: No Authorization ===');

const request3 = {

  method: 'POST',

  path: '/api/users',

  user: { name: 'Jane', role: 'user' },

  data: { name: 'New User' }

};

const result3 = authHandler.handle(request3);

console.log('Result:', result3);

```



**Advanced Chain: Support Ticket System:**



```javascript

class SupportHandler {

  constructor(name, level) {

    this.name = name;

    this.level = level;

    this.nextHandler = null;

  }

  

  setNext(handler) {

    this.nextHandler = handler;

    return handler;

  }

  

  handle(ticket) {

    if (ticket.priority <= this.level) {

      return this.process(ticket);

    }

    

    if (this.nextHandler) {

      console.log(`${this.name}: Escalating ticket #${ticket.id} to next level`);

      return this.nextHandler.handle(ticket);

    }

    

    console.log(`${this.name}: No one can handle ticket #${ticket.id}`);

    return { handled: false, message: 'No handler available' };

  }

  

  process(ticket) {

    console.log(`${this.name}: Handling ticket #${ticket.id} - ${ticket.issue}`);

    return {

      handled: true,

      handledBy: this.name,

      ticket

    };

  }

}



class Ticket {

  constructor(id, issue, priority) {

    this.id = id;

    this.issue = issue;

    this.priority = priority; // 1 = low, 2 = medium, 3 = high, 4 = critical

    this.createdAt = new Date();

  }

}



// Create support hierarchy

const juniorSupport = new SupportHandler('Junior Support', 1);

const seniorSupport = new SupportHandler('Senior Support', 2);

const teamLead = new SupportHandler('Team Lead', 3);

const manager = new SupportHandler('Manager', 4);



// Build chain

juniorSupport

  .setNext(seniorSupport)

  .setNext(teamLead)

  .setNext(manager);



// Create tickets

const tickets = [

  new Ticket(1, 'Password reset', 1),

  new Ticket(2, 'Account locked', 2),

  new Ticket(3, 'Data corruption', 3),

  new Ticket(4, 'Security breach', 4),

  new Ticket(5, 'General inquiry', 1)

];



// Process tickets

console.log('Processing Support Tickets:\n');

tickets.forEach(ticket => {

  console.log(`\nTicket #${ticket.id} (Priority: ${ticket.priority})`);

  const result = juniorSupport.handle(ticket);

  console.log('Result:', result.handled ? '✓ Handled' : '✗ Not handled');

});

```



**Real-World Chain: Middleware Pipeline:**



```javascript

class Middleware {

  constructor() {

    this.middlewares = [];

  }

  

  use(fn) {

    this.middlewares.push(fn);

    return this;

  }

  

  async execute(context) {

    let index = 0;

    

    const next = async () => {

      if (index >= this.middlewares.length) {

        return;

      }

      

      const middleware = this.middlewares[index++];

      await middleware(context, next);

    };

    

    await next();

  }

}



// Middleware functions

const authMiddleware = async (ctx, next) => {

  console.log('[Auth] Checking authentication...');

  

  if (!ctx.headers.authorization) {

    ctx.status = 401;

    ctx.body = { error: 'Unauthorized' };

    return; // Stop chain

  }

  

  ctx.user = { id: 1, name: 'John Doe' };

  console.log('[Auth] ✓ Authenticated');

  await next();

};



const loggerMiddleware = async (ctx, next) => {

  const start = Date.now();

  console.log(`[Logger] ${ctx.method} ${ctx.path}`);

  

  await next();

  

  const duration = Date.now() - start;

  console.log(`[Logger] Completed in ${duration}ms with status ${ctx.status}`);

};



const rateLimitMiddleware = async (ctx, next) => {

  console.log('[RateLimit] Checking rate limit...');

  

  // Simulated rate limit check

  const isRateLimited = false;

  

  if (isRateLimited) {

    ctx.status = 429;

    ctx.body = { error: 'Too many requests' };

    return;

  }

  

  console.log('[RateLimit] ✓ Within limits');

  await next();

};



const validationMiddleware = async (ctx, next) => {

  console.log('[Validation] Validating request...');

  

  if (ctx.method === 'POST' && !ctx.body) {

    ctx.status = 400;

    ctx.body = { error: 'Body required' };

    return;

  }

  

  console.log('[Validation] ✓ Valid');

  await next();

};



const corsMiddleware = async (ctx, next) => {

  console.log('[CORS] Setting CORS headers...');

  

  ctx.headers = {

    ...ctx.headers,

    'Access-Control-Allow-Origin': '*',

    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE'

  };

  

  await next();

};



const handlerMiddleware = async (ctx, next) => {

  console.log('[Handler] Processing request...');

  

  ctx.status = 200;

  ctx.body = {

    message: 'Success',

    user: ctx.user,

    path: ctx.path

  };

  

  await next();

};



// Usage

const app = new Middleware();



app

  .use(loggerMiddleware)

  .use(corsMiddleware)

  .use(authMiddleware)

  .use(rateLimitMiddleware)

  .use(validationMiddleware)

  .use(handlerMiddleware);



// Test request 1: Valid

console.log('\n=== Request 1: Valid ===');

const context1 = {

  method: 'GET',

  path: '/api/users',

  headers: { authorization: 'Bearer token123' },

  status: null,

  body: null

};

await app.execute(context1);

console.log('Response:', context1.body);



// Test request 2: No auth

console.log('\n=== Request 2: No Auth ===');

const context2 = {

  method: 'GET',

  path: '/api/users',

  headers: {},

  status: null,

  body: null

};

await app.execute(context2);

console.log('Response:', context2.body);

```



---



### **13. Mediator Pattern**



Reduces coupling between components by making them communicate through a mediator object instead of directly with each other.



```javascript

// Mediator

class ChatRoom {

  constructor() {

    this.users = new Map();

  }

  

  register(user) {

    this.users.set(user.name, user);

    user.chatRoom = this;

    console.log(`${user.name} joined the chat room`);

  }

  

  sendMessage(message, from, to) {

    if (to) {

      // Private message

      const recipient = this.users.get(to);

      if (recipient) {

        recipient.receive(message, from);

      } else {

        console.log(`User ${to} not found`);

      }

    } else {

      // Broadcast to all

      this.users.forEach((user, name) => {

        if (name !== from) {

          user.receive(message, from);

        }

      });

    }

  }

  

  getUsers() {

    return Array.from(this.users.keys());

  }

}



// Colleague

class User {

  constructor(name) {

    this.name = name;

    this.chatRoom = null;

  }

  

  send(message, to = null) {

    console.log(`${this.name} sends: "${message}"${to ? ` to ${to}` : ' (broadcast)'}`);

    this.chatRoom.sendMessage(message, this.name, to);

  }

  

  receive(message, from) {

    console.log(`${this.name} received from ${from}: "${message}"`);

  }

}



// Usage

const chatRoom = new ChatRoom();



const john = new User('John');

const jane = new User('Jane');

const bob = new User('Bob');



chatRoom.register(john);

chatRoom.register(jane);

chatRoom.register(bob);



// Broadcast message

john.send('Hello everyone!');



// Private message

jane.send('Hi John!', 'John');



console.log('\nUsers in chat:', chatRoom.getUsers());

```



**Advanced Mediator: Air Traffic Control:**



```javascript

class AirTrafficControl {

  constructor() {

    this.aircrafts = new Map();

    this.runways = new Set(['Runway 1', 'Runway 2', 'Runway 3']);

    this.occupiedRunways = new Map();

  }

  

  registerAircraft(aircraft) {

    this.aircrafts.set(aircraft.id, aircraft);

    aircraft.setMediator(this);

    console.log(`✈️  ${aircraft.id} registered with ATC`);

  }

  

  requestLanding(aircraftId) {

    const aircraft = this.aircrafts.get(aircraftId);

    

    if (!aircraft) {

      console.log(`❌ Aircraft ${aircraftId} not registered`);

      return false;

    }

    

    // Find available runway

    for (const runway of this.runways) {

      if (!this.occupiedRunways.has(runway)) {

        this.occupiedRunways.set(runway, aircraftId);

        aircraft.grantLanding(runway);

        

        // Auto-release runway after landing

        setTimeout(() => {

          this.releaseRunway(runway, aircraftId);

        }, 3000);

        

        return true;

      }

    }

    

    console.log(`⏳ ${aircraftId} is holding - no runways available`);

    aircraft.hold();

    return false;

  }

  

  requestTakeoff(aircraftId) {

    const aircraft = this.aircrafts.get(aircraftId);

    

    if (!aircraft) {

      console.log(`❌ Aircraft ${aircraftId} not registered`);

      return false;

    }

    

    // Find available runway

    for (const runway of this.runways) {

      if (!this.occupiedRunways.has(runway)) {

        this.occupiedRunways.set(runway, aircraftId);

        aircraft.grantTakeoff(runway);

        

        // Auto-release runway after takeoff

        setTimeout(() => {

          this.releaseRunway(runway, aircraftId);

        }, 2000);

        

        return true;

      }

    }

    

    console.log(`⏳ ${aircraftId} is waiting for takeoff`);

    return false;

  }

  

  releaseRunway(runway, aircraftId) {

    if (this.occupiedRunways.get(runway) === aircraftId) {

      this.occupiedRunways.delete(runway);

      console.log(`🟢 ${runway} is now available`);

    }

  }

  

  getStatus() {

    return {

      totalAircrafts: this.aircrafts.size,

      totalRunways: this.runways.size,

      availableRunways: this.runways.size - this.occupiedRunways.size,

      occupiedRunways: Array.from(this.occupiedRunways.entries())

    };

  }

}



class Aircraft {

  constructor(id, type) {

    this.id = id;

    this.type = type;

    this.mediator = null;

    this.status = 'airborne';

  }

  

  setMediator(mediator) {

    this.mediator = mediator;

  }

  

  requestLanding() {

    console.log(`\n${this.id}: Requesting landing clearance`);

    this.mediator.requestLanding(this.id);

  }

  

  grantLanding(runway) {

    console.log(`✓ ${this.id}: Landing cleared on ${runway}`);

    this.status = 'landing';

    

    setTimeout(() => {

      this.status = 'landed';

      console.log(`✓ ${this.id}: Successfully landed on ${runway}`);

    }, 1000);

  }

  

  hold() {

    console.log(`⏳ ${this.id}: Holding pattern - awaiting clearance`);

    this.status = 'holding';

    

    // Retry after delay

    setTimeout(() => {

      if (this.status === 'holding') {

        this.requestLanding();

      }

    }, 2000);

  }

  

  requestTakeoff() {

    console.log(`\n${this.id}: Requesting takeoff clearance`);

    this.mediator.requestTakeoff(this.id);

  }

  

  grantTakeoff(runway) {

    console.log(`✓ ${this.id}: Takeoff cleared from ${runway}`);

    this.status = 'taking-off';

    

    setTimeout(() => {

      this.status = 'airborne';

      console.log(`✓ ${this.id}: Airborne`);

    }, 1000);

  }

}



// Usage

const atc = new AirTrafficControl();



const flight1 = new Aircraft('AA101', 'Boeing 737');

const flight2 = new Aircraft('UA202', 'Airbus A320');

const flight3 = new Aircraft('DL303', 'Boeing 777');

const flight4 = new Aircraft('SW404', 'Boeing 737');



atc.registerAircraft(flight1);

atc.registerAircraft(flight2);

atc.registerAircraft(flight3);

atc.registerAircraft(flight4);



// Simulate landing requests

flight1.requestLanding();

flight2.requestLanding();

flight3.requestLanding();

flight4.requestLanding(); // Will hold



setTimeout(() => {

  console.log('\n=== ATC Status ===');

  console.log(atc.getStatus());

}, 5000);

```



**Real-World Mediator: Form Validation:**



```javascript

class FormMediator {

  constructor() {

    this.fields = new Map();

    this.validators = new Map();

    this.errors = new Map();

  }

  

  registerField(name, field) {

    this.fields.set(name, field);

    field.setMediator(this);

  }

  

  registerValidator(name, validatorFn) {

    this.validators.set(name, validatorFn);

  }

  

  notify(fieldName, value) {

    // Validate field

    const validator = this.validators.get(fieldName);

    

    if (validator) {

      const error = validator(value, this.getAllValues());

      

      if (error) {

        this.errors.set(fieldName, error);

        this.fields.get(fieldName).showError(error);

      } else {

        this.errors.delete(fieldName);

        this.fields.get(fieldName).clearError();

      }

    }

    

    // Cross-field validation

    this.validateDependentFields(fieldName);

  }

  

  validateDependentFields(changedField) {

    // Re-validate related fields

    const dependencies = {

      password: ['confirmPassword'],

      email: ['confirmEmail']

    };

    

    const dependent = dependencies[changedField];

    if (dependent) {

      dependent.forEach(fieldName => {

        const field = this.fields.get(fieldName);

        if (field) {

          this.notify(fieldName, field.value);

        }

      });

    }

  }

  

  getAllValues() {

    const values = {};

    this.fields.forEach((field, name) => {

      values[name] = field.value;

    });

    return values;

  }

  

  isValid() {

    // Validate all fields

    this.fields.forEach((field, name) => {

      this.notify(name, field.value);

    });

    

    return this.errors.size === 0;

  }

  

  getErrors() {

    return Object.fromEntries(this.errors);

  }

}



class FormField {

  constructor(name, value = '') {

    this.name = name;

    this.value = value;

    this.mediator = null;

    this.error = null;

  }

  

  setMediator(mediator) {

    this.mediator = mediator;

  }

  

  setValue(value) {

    this.value = value;

    if (this.mediator) {

      this.mediator.notify(this.name, value);

    }

  }

  

  showError(error) {

    this.error = error;

    console.log(`❌ ${this.name}: ${error}`);

  }

  

  clearError() {

    this.error = null;

    console.log(`✓ ${this.name}: Valid`);

  }

}



// Usage

const formMediator = new FormMediator();



// Create fields

const emailField = new FormField('email');

const passwordField = new FormField('password');

const confirmPasswordField = new FormField('confirmPassword');

const usernameField = new FormField('username');



// Register fields

formMediator.registerField('email', emailField);

formMediator.registerField('password', passwordField);

formMediator.registerField('confirmPassword', confirmPasswordField);

formMediator.registerField('username', usernameField);



// Register validators

formMediator.registerValidator('email', (value) => {

  if (!value) return 'Email is required';

  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) return 'Invalid email format';

  return null;

});



formMediator.registerValidator('password', (value) => {

  if (!value) return 'Password is required';

  if (value.length < 8) return 'Password must be at least 8 characters';

  return null;

});



formMediator.registerValidator('confirmPassword', (value, allValues) => {

  if (!value) return 'Please confirm password';

  if (value !== allValues.password) return 'Passwords do not match';

  return null;

});



formMediator.registerValidator('username', (value) => {

  if (!value) return 'Username is required';

  if (value.length < 3) return 'Username must be at least 3 characters';

  if (!/^[a-zA-Z0-9_]+$/.test(value)) return 'Username can only contain letters, numbers, and underscores';

  return null;

});



// Simulate user input

console.log('\n=== Form Validation ===\n');



emailField.setValue('invalid-email'); // Invalid

emailField.setValue('user@example.com'); // Valid



passwordField.setValue('123'); // Too short

passwordField.setValue('password123'); // Valid



confirmPasswordField.setValue('password'); // Doesn't match

confirmPasswordField.setValue('password123'); // Matches



usernameField.setValue('ab'); // Too short

usernameField.setValue('john_doe'); // Valid



// Validate entire form

console.log('\n=== Final Validation ===');

const isValid = formMediator.isValid();

console.log('Form valid:', isValid);



if (!isValid) {

  console.log('Errors:', formMediator.getErrors());

}

```



---



### **14. Adapter Pattern**



Converts the interface of a class into another interface that clients expect. Allows incompatible interfaces to work together.



```javascript

// Old API (incompatible interface)

class OldPaymentAPI {

  processPayment(cardNumber, amount) {

    console.log(`Old API: Processing $${amount} with card ${cardNumber}`);

    return {

      statusCode: 200,

      message: 'Success',

      transactionId: `OLD-${Date.now()}`

    };

  }

}



// New API (different interface)

class NewPaymentAPI {

  charge(paymentInfo) {

    console.log(`New API: Charging $${paymentInfo.amount}`);

    return {

      success: true,

      id: `NEW-${Date.now()}`,

      details: paymentInfo

    };

  }

}



// Adapter - makes NewPaymentAPI compatible with OldPaymentAPI interface

class PaymentAdapter {

  constructor(newApi) {

    this.newApi = newApi;

  }

  

  processPayment(cardNumber, amount) {

    // Convert old interface to new interface

    const paymentInfo = {

      card: cardNumber,

      amount: amount,

      currency: 'USD',

      timestamp: new Date().toISOString()

    };

    

    const result = this.newApi.charge(paymentInfo);

    

    // Convert new response to old response format

    return {

      statusCode: result.success ? 200 : 400,

      message: result.success ? 'Success' : 'Failed',

      transactionId: result.id

    };

  }

}



// Usage

const oldApi = new OldPaymentAPI();

const newApi = new NewPaymentAPI();

const adapter = new PaymentAdapter(newApi);



// Client code expects old interface

function processTransaction(api, cardNumber, amount) {

  const result = api.processPayment(cardNumber, amount);

  console.log('Transaction result:', result);

}



// Works with old API

processTransaction(oldApi, '1234-5678-9012-3456', 100);



// Also works with new API through adapter

processTransaction(adapter, '1234-5678-9012-3456', 100);

```



**Advanced Adapter: Data Format Converter:**



```javascript

// XML Data Source

class XMLDataSource {

  getData() {

    return `

      <users>

        <user>

          <id>1</id>

          <name>John Doe</name>

          <email>john@example.com</email>

        </user>

        <user>

          <id>2</id>

          <name>Jane Smith</name>

          <email>jane@example.com</email>

        </user>

      </users>

    `;

  }

}



// CSV Data Source

class CSVDataSource {

  getData() {

    return `id,name,email

1,John Doe,john@example.com

2,Jane Smith,jane@example.com`;

  }

}



// Application expects JSON format

class DataConsumer {

  processData(jsonData) {

    const users = JSON.parse(jsonData);

    console.log('Processing users:');

    users.forEach(user => {

      console.log(`- ${user.name} (${user.email})`);

    });

  }

}



// Adapter for XML

class XMLToJSONAdapter {

  constructor(xmlSource) {

    this.xmlSource = xmlSource;

  }

  

  getData() {

    const xmlString = this.xmlSource.getData();

    

    // Simple XML parsing (in production, use DOMParser or library)

    const users = [];

    const userMatches = xmlString.matchAll(/<user>[\s\S]*?<\/user>/g);

    

    for (const match of userMatches) {

      const userXml = match[0];

      const id = userXml.match(/<id>(\d+)<\/id>/)[1];

      const name = userXml.match(/<name>(.+?)<\/name>/)[1];

      const email = userXml.match(/<email>(.+?)<\/email>/)[1];

      

      users.push({

        id: parseInt(id),

        name,

        email

      });

    }

    

    return JSON.stringify(users);

  }

}



// Adapter for CSV

class CSVToJSONAdapter {

  constructor(csvSource) {

    this.csvSource = csvSource;

  }

  

  getData() {

    const csvString = this.csvSource.getData();

    const lines = csvString.trim().split('\n');

    const headers = lines[0].split(',');

    

    const users = lines.slice(1).map(line => {

      const values = line.split(',');

      const user = {};

      

      headers.forEach((header, index) => {

        user[header] = header === 'id' ? parseInt(values[index]) : values[index];

      });

      

      return user;

    });

    

    return JSON.stringify(users);

  }

}



// Usage

const consumer = new DataConsumer();



// XML data source

const xmlSource = new XMLDataSource();

const xmlAdapter = new XMLToJSONAdapter(xmlSource);

console.log('XML Data:');

consumer.processData(xmlAdapter.getData());



// CSV data source

console.log('\nCSV Data:');

const csvSource = new CSVDataSource();

const csvAdapter = new CSVToJSONAdapter(csvSource);

consumer.processData(csvAdapter.getData());

```



**Real-World Adapter: Third-Party API Integration:**



```javascript

// Third-party weather API (incompatible interface)

class WeatherAPIv1 {

  async fetchWeather(city) {

    console.log(`WeatherAPIv1: Fetching for ${city}`);

    

    // Simulated API response

    return {

      location: city,

      temp_celsius: 25,

      conditions: 'sunny',

      wind_speed_kmh: 15,

      humidity_percent: 60

    };

  }

}



class WeatherAPIv2 {

  async getTemperature(location) {

    console.log(`WeatherAPIv2: Fetching for ${location}`);

    

    // Different response format

    return {

      place: location,

      temperature: { value: 77, unit: 'F' },

      weather: 'clear',

      wind: { speed: 9.3, unit: 'mph' },

      humidity: 0.6

    };

  }

}



// Application interface

class WeatherService {

  constructor(adapter) {

    this.adapter = adapter;

  }

  

  async displayWeather(city) {

    const weather = await this.adapter.getWeather(city);

    

    console.log('\n=== Weather Report ===');

    console.log(`Location: ${weather.location}`);

    console.log(`Temperature: ${weather.temperature}°C`);

    console.log(`Conditions: ${weather.conditions}`);

    console.log(`Wind Speed: ${weather.windSpeed} km/h`);

    console.log(`Humidity: ${weather.humidity}%`);

  }

}



// Adapter for APIv1

class WeatherAPIv1Adapter {

  constructor(api) {

    this.api = api;

  }

  

  async getWeather(city) {

    const data = await this.api.fetchWeather(city);

    

    // Normalize to standard format

    return {

      location: data.location,

      temperature: data.temp_celsius,

      conditions: data.conditions,

      windSpeed: data.wind_speed_kmh,

      humidity: data.humidity_percent

    };

  }

}



// Adapter for APIv2

class WeatherAPIv2Adapter {

  constructor(api) {

    this.api = api;

  }

  

  async getWeather(city) {

    const data = await this.api.getTemperature(city);

    

    // Convert Fahrenheit to Celsius

    const tempCelsius = ((data.temperature.value - 32) * 5) / 9;

    

    // Convert mph to km/h

    const windKmh = data.wind.speed * 1.60934;

    

    // Normalize to standard format

    return {

      location: data.place,

      temperature: Math.round(tempCelsius),

      conditions: data.weather,

      windSpeed: Math.round(windKmh),

      humidity: Math.round(data.humidity * 100)

    };

  }

}



// Usage

(async () => {

  // Using APIv1

  const apiv1 = new WeatherAPIv1();

  const adapterv1 = new WeatherAPIv1Adapter(apiv1);

  const servicev1 = new WeatherService(adapterv1);

  await servicev1.displayWeather('London');

  

  // Using APIv2 (different API, same interface through adapter)

  const apiv2 = new WeatherAPIv2();

  const adapterv2 = new WeatherAPIv2Adapter(apiv2);

  const servicev2 = new WeatherService(adapterv2);

  await servicev2.displayWeather('New York');

})();

```



---



### **15. Composite Pattern**



Composes objects into tree structures to represent part-whole hierarchies. Allows clients to treat individual objects and compositions uniformly.



```javascript

// Component interface

class FileSystemItem {

  constructor(name) {

    this.name = name;

  }

  

  getSize() {

    throw new Error('getSize() must be implemented');

  }

  

  print(indent = '') {

    throw new Error('print() must be implemented');

  }

}



// Leaf - File

class File extends FileSystemItem {

  constructor(name, size) {

    super(name);

    this.size = size;

  }

  

  getSize() {

    return this.size;

  }

  

  print(indent = '') {

    console.log(`${indent}📄 ${this.name} (${this.size} KB)`);

  }

}



// Composite - Directory

class Directory extends FileSystemItem {

  constructor(name) {

    super(name);

    this.children = [];

  }

  

  add(item) {

    this.children.push(item);

    return this;

  }

  

  remove(item) {

    const index = this.children.indexOf(item);

    if (index > -1) {

      this.children.splice(index, 1);

    }

    return this;

  }

  

  getSize() {

    return this.children.reduce((total, child) => total + child.getSize(), 0);

  }

  

  print(indent = '') {

    console.log(`${indent}📁 ${this.name} (${this.getSize()} KB)`);

    this.children.forEach(child => child.print(indent + '  '));

  }

  

  find(name) {

    if (this.name === name) return this;

    

    for (const child of this.children) {

      if (child.name === name) return child;

      if (child instanceof Directory) {

        const found = child.find(name);

        if (found) return found;

      }

    }

    

    return null;

  }

}



// Usage

const root = new Directory('root');



const documents = new Directory('documents');

documents.add(new File('resume.pdf', 150));

documents.add(new File('cover-letter.docx', 50));



const photos = new Directory('photos');

photos.add(new File('vacation.jpg', 2000));

photos.add(new File('family.jpg', 1500));



const work = new Directory('work');

work.add(new File('project.pptx', 500));

work.add(new File('budget.xlsx', 100));

documents.add(work);



root.add(documents);

root.add(photos);

root.add(new File('readme.txt', 5));



// Print entire structure

root.print();



// Get total size

console.log(`\nTotal size: ${root.getSize()} KB`);



// Find specific directory

const workDir = root.find('work');

if (workDir) {

  console.log(`\nWork directory size: ${workDir.getSize()} KB`);

}

```



**Advanced Composite: UI Component Tree:**



```javascript

// Component base

class UIComponent {

  constructor(name) {

    this.name = name;

    this.visible = true;

  }

  

  render() {

    throw new Error('render() must be implemented');

  }

  

  show() {

    this.visible = true;

  }

  

  hide() {

    this.visible = false;

  }

  

  onClick(handler) {

    this.clickHandler = handler;

  }

}



// Leaf components

class Button extends UIComponent {

  constructor(name, label) {

    super(name);

    this.label = label;

  }

  

  render(indent = '') {

    if (!this.visible) return;

    console.log(`${indent}<button>${this.label}</button>`);

  }

  

  click() {

    console.log(`Button "${this.label}" clicked`);

    if (this.clickHandler) {

      this.clickHandler();

    }

  }

}



class TextInput extends UIComponent {

  constructor(name, placeholder) {

    super(name);

    this.placeholder = placeholder;

    this.value = '';

  }

  

  render(indent = '') {

    if (!this.visible) return;

    console.log(`${indent}<input type="text" placeholder="${this.placeholder}" />`);

  }

  

  setValue(value) {

    this.value = value;

    console.log(`Input "${this.name}" value set to: ${value}`);

  }

}



class Label extends UIComponent {

  constructor(name, text) {

    super(name);

    this.text = text;

  }

  

  render(indent = '') {

    if (!this.visible) return;

    console.log(`${indent}<label>${this.text}</label>`);

  }

}



// Composite components

class Panel extends UIComponent {

  constructor(name) {

    super(name);

    this.children = [];

  }

  

  add(component) {

    this.children.push(component);

    return this;

  }

  

  remove(component) {

    const index = this.children.indexOf(component);

    if (index > -1) {

      this.children.splice(index, 1);

    }

    return this;

  }

  

  render(indent = '') {

    if (!this.visible) return;

    console.log(`${indent}<div class="panel">`);

    this.children.forEach(child => child.render(indent + '  '));

    console.log(`${indent}</div>`);

  }

  

  find(name) {

    if (this.name === name) return this;

    

    for (const child of this.children) {

      if (child.name === name) return child;

      if (child instanceof Panel) {

        const found = child.find(name);

        if (found) return found;

      }

    }

    

    return null;

  }

}



class Form extends Panel {

  constructor(name) {

    super(name);

    this.data = {};

  }

  

  render(indent = '') {

    if (!this.visible) return;

    console.log(`${indent}<form>`);

    this.children.forEach(child => child.render(indent + '  '));

    console.log(`${indent}</form>`);

  }

  

  submit() {

    console.log('Form submitted with data:', this.data);

  }

}



// Usage

const loginForm = new Form('loginForm');



const usernamePanel = new Panel('usernamePanel');

usernamePanel.add(new Label('usernameLabel', 'Username:'));

usernamePanel.add(new TextInput('usernameInput', 'Enter username'));



const passwordPanel = new Panel('passwordPanel');

passwordPanel.add(new Label('passwordLabel', 'Password:'));

passwordPanel.add(new TextInput('passwordInput', 'Enter password'));



const buttonPanel = new Panel('buttonPanel');

const loginButton = new Button('loginButton', 'Login');

const cancelButton = new Button('cancelButton', 'Cancel');



loginButton.onClick(() => {

  console.log('Logging in...');

  loginForm.submit();

});



cancelButton.onClick(() => {

  console.log('Login cancelled');

});



buttonPanel.add(loginButton);

buttonPanel.add(cancelButton);



loginForm.add(usernamePanel);

loginForm.add(passwordPanel);

loginForm.add(buttonPanel);



// Render entire form

console.log('=== Login Form ===');

loginForm.render();



// Interact with components

console.log('\n=== Interactions ===');

const usernameInput = loginForm.find('usernameInput');

usernameInput.setValue('john_doe');



loginButton.click();



// Hide password panel

console.log('\n=== After hiding password ===');

passwordPanel.hide();

loginForm.render();

```



**Real-World Composite: Organization Structure:**



```javascript

class OrganizationUnit {

  constructor(name) {

    this.name = name;

  }

  

  getSalaryTotal() {

    throw new Error('getSalaryTotal() must be implemented');

  }

  

  getEmployeeCount() {

    throw new Error('getEmployeeCount() must be implemented');

  }

  

  print(indent = '') {

    throw new Error('print() must be implemented');

  }

}



// Leaf - Individual Employee

class Employee extends OrganizationUnit {

  constructor(name, position, salary) {

    super(name);

    this.position = position;

    this.salary = salary;

  }

  

  getSalaryTotal() {

    return this.salary;

  }

  

  getEmployeeCount() {

    return 1;

  }

  

  print(indent = '') {

    console.log(`${indent}👤 ${this.name} - ${this.position} ($${this.salary.toLocaleString()})`);

  }

}



// Composite - Department

class Department extends OrganizationUnit {

  constructor(name, manager) {

    super(name);

    this.manager = manager;

    this.members = [];

  }

  

  add(unit) {

    this.members.push(unit);

    return this;

  }

  

  remove(unit) {

    const index = this.members.indexOf(unit);

    if (index > -1) {

      this.members.splice(index, 1);

    }

    return this;

  }

  

  getSalaryTotal() {

    const managerSalary = this.manager.getSalaryTotal();

    const membersSalary = this.members.reduce(

      (total, member) => total + member.getSalaryTotal(),

      0

    );

    return managerSalary + membersSalary;

  }

  

  getEmployeeCount() {

    const managerCount = this.manager.getEmployeeCount();

    const membersCount = this.members.reduce(

      (total, member) => total + member.getEmployeeCount(),

      0

    );

    return managerCount + membersCount;

  }

  

  print(indent = '') {

    console.log(`${indent}🏢 ${this.name} Department`);

    console.log(`${indent}  Manager:`);

    this.manager.print(indent + '    ');

    

    if (this.members.length > 0) {

      console.log(`${indent}  Team Members:`);

      this.members.forEach(member => member.print(indent + '    '));

    }

    

    console.log(`${indent}  Total: ${this.getEmployeeCount()} employees, $${this.getSalaryTotal().toLocaleString()} salary`);

  }

}



// Usage

const ceo = new Employee('Alice Johnson', 'CEO', 250000);



const engineeringManager = new Employee('Bob Smith', 'Engineering Manager', 150000);

const engineeringDept = new Department('Engineering', engineeringManager);

engineeringDept.add(new Employee('Charlie Brown', 'Senior Engineer', 120000));

engineeringDept.add(new Employee('Diana Prince', 'Senior Engineer', 120000));

engineeringDept.add(new Employee('Eve Wilson', 'Junior Engineer', 80000));



const frontendTeamLead = new Employee('Frank Miller', 'Team Lead', 110000);

const frontendTeam = new Department('Frontend', frontendTeamLead);

frontendTeam.add(new Employee('Grace Lee', 'Developer', 90000));

frontendTeam.add(new Employee('Henry Ford', 'Developer', 90000));



engineeringDept.add(frontendTeam);



const salesManager = new Employee('Ivy Chen', 'Sales Manager', 130000);

const salesDept = new Department('Sales', salesManager);

salesDept.add(new Employee('Jack Black', 'Sales Rep', 70000));

salesDept.add(new Employee('Kate White', 'Sales Rep', 70000));



const company = new Department('TechCorp', ceo);

company.add(engineeringDept);

company.add(salesDept);



// Print organization structure

console.log('=== Organization Structure ===\n');

company.print();



console.log(`\n=== Company Summary ===`);

console.log(`Total Employees: ${company.getEmployeeCount()}`);

console.log(`Total Payroll: $${company.getSalaryTotal().toLocaleString()}`);

console.log(`Average Salary: $${Math.round(company.getSalaryTotal() / company.getEmployeeCount()).toLocaleString()}`);

```



---



### **16. Builder Pattern**



Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.



```javascript

// Product

class Computer {

  constructor() {

    this.cpu = null;

    this.ram = null;

    this.storage = null;

    this.gpu = null;

    this.monitor = null;

    this.keyboard = null;

    this.mouse = null;

  }

  

  getSpecs() {

    return {

      cpu: this.cpu,

      ram: this.ram,

      storage: this.storage,

      gpu: this.gpu,

      monitor: this.monitor,

      keyboard: this.keyboard,

      mouse: this.mouse

    };

  }

  

  displaySpecs() {

    console.log('=== Computer Specifications ===');

    console.log(`CPU: ${this.cpu || 'Not specified'}`);

    console.log(`RAM: ${this.ram || 'Not specified'}`);

    console.log(`Storage: ${this.storage || 'Not specified'}`);

    console.log(`GPU: ${this.gpu || 'Not specified'}`);

    console.log(`Monitor: ${this.monitor || 'Not specified'}`);

    console.log(`Keyboard: ${this.keyboard || 'Not specified'}`);

    console.log(`Mouse: ${this.mouse || 'Not specified'}`);

  }

}



// Builder

class ComputerBuilder {

  constructor() {

    this.computer = new Computer();

  }

  

  setCPU(cpu) {

    this.computer.cpu = cpu;

    return this; // Enable method chaining

  }

  

  setRAM(ram) {

    this.computer.ram = ram;

    return this;

  }

  

  setStorage(storage) {

    this.computer.storage = storage;

    return this;

  }

  

  setGPU(gpu) {

    this.computer.gpu = gpu;

    return this;

  }

  

  setMonitor(monitor) {

    this.computer.monitor = monitor;

    return this;

  }

  

  setKeyboard(keyboard) {

    this.computer.keyboard = keyboard;

    return this;

  }

  

  setMouse(mouse) {

    this.computer.mouse = mouse;

    return this;

  }

  

  build() {

    return this.computer;

  }

}



// Director - knows how to build specific configurations

class ComputerDirector {

  static buildGamingPC() {

    return new ComputerBuilder()

      .setCPU('Intel Core i9-13900K')

      .setRAM('32GB DDR5')

      .setStorage('2TB NVMe SSD')

      .setGPU('NVIDIA RTX 4090')

      .setMonitor('34" 4K 144Hz')

      .setKeyboard('Mechanical RGB')

      .setMouse('Gaming Mouse 16000 DPI')

      .build();

  }

  

  static buildOfficePC() {

    return new ComputerBuilder()

      .setCPU('Intel Core i5-13400')

      .setRAM('16GB DDR4')

      .setStorage('512GB SSD')

      .setMonitor('24" 1080p')

      .setKeyboard('Standard Keyboard')

      .setMouse('Standard Mouse')

      .build();

  }

  

  static buildWorkstation() {

    return new ComputerBuilder()

      .setCPU('AMD Ryzen 9 7950X')

      .setRAM('64GB DDR5')

      .setStorage('4TB NVMe SSD')

      .setGPU('NVIDIA RTX 4080')

      .setMonitor('32" 4K IPS')

      .setKeyboard('Mechanical Keyboard')

      .setMouse('Precision Mouse')

      .build();

  }

}



// Usage

const gamingPC = ComputerDirector.buildGamingPC();

gamingPC.displaySpecs();



console.log('\n');



const officePC = ComputerDirector.buildOfficePC();

officePC.displaySpecs();



console.log('\n');



// Custom build

const customPC = new ComputerBuilder()

  .setCPU('AMD Ryzen 7 5800X')

  .setRAM('32GB DDR4')

  .setStorage('1TB SSD')

  .setGPU('AMD RX 6800 XT')

  .build();

customPC.displaySpecs();

```



**Advanced Builder: Query Builder:**



```javascript

class SQLQuery {

  constructor() {

    this.selectFields = [];

    this.fromTable = '';

    this.joins = [];

    this.whereClauses = [];

    this.orderByFields = [];

    this.limitValue = null;

    this.offsetValue = null;

  }

  

  toString() {

    let query = '';

    

    // SELECT

    if (this.selectFields.length > 0) {

      query += `SELECT ${this.selectFields.join(', ')}`;

    } else {

      query += 'SELECT *';

    }

    

    // FROM

    if (this.fromTable) {

      query += `\nFROM ${this.fromTable}`;

    }

    

    // JOINS

    if (this.joins.length > 0) {

      query += '\n' + this.joins.join('\n');

    }

    

    // WHERE

    if (this.whereClauses.length > 0) {

      query += `\nWHERE ${this.whereClauses.join(' AND ')}`;

    }

    

    // ORDER BY

    if (this.orderByFields.length > 0) {

      query += `\nORDER BY ${this.orderByFields.join(', ')}`;

    }

    

    // LIMIT

    if (this.limitValue !== null) {

      query += `\nLIMIT ${this.limitValue}`;

    }

    

    // OFFSET

    if (this.offsetValue !== null) {

      query += `\nOFFSET ${this.offsetValue}`;

    }

    

    return query + ';';

  }

}



class QueryBuilder {

  constructor() {

    this.query = new SQLQuery();

  }

  

  select(...fields) {

    this.query.selectFields = fields;

    return this;

  }

  

  from(table) {

    this.query.fromTable = table;

    return this;

  }

  

  join(table, condition, type = 'INNER') {

    this.query.joins.push(`${type} JOIN ${table} ON ${condition}`);

    return this;

  }

  

  leftJoin(table, condition) {

    return this.join(table, condition, 'LEFT');

  }

  

  rightJoin(table, condition) {

    return this.join(table, condition, 'RIGHT');

  }

  

  where(condition) {

    this.query.whereClauses.push(condition);

    return this;

  }

  

  whereEquals(field, value) {

    const formattedValue = typeof value === 'string' ? `'${value}'` : value;

    this.query.whereClauses.push(`${field} = ${formattedValue}`);

    return this;

  }

  

  whereIn(field, values) {

    const formattedValues = values

      .map(v => typeof v === 'string' ? `'${v}'` : v)

      .join(', ');

    this.query.whereClauses.push(`${field} IN (${formattedValues})`);

    return this;

  }

  

  orderBy(field, direction = 'ASC') {

    this.query.orderByFields.push(`${field} ${direction}`);

    return this;

  }

  

  limit(value) {

    this.query.limitValue = value;

    return this;

  }

  

  offset(value) {

    this.query.offsetValue = value;

    return this;

  }

  

  build() {

    return this.query.toString();

  }

  

  // Convenience method

  toString() {

    return this.build();

  }

}



// Usage

console.log('=== Simple Query ===');

const query1 = new QueryBuilder()

  .select('id', 'name', 'email')

  .from('users')

  .whereEquals('status', 'active')

  .orderBy('name', 'ASC')

  .limit(10)

  .build();

console.log(query1);



console.log('\n=== Complex Query with Joins ===');

const query2 = new QueryBuilder()

  .select('u.id', 'u.name', 'o.order_date', 'o.total')

  .from('users u')

  .leftJoin('orders o', 'u.id = o.user_id')

  .leftJoin('order_items oi', 'o.id = oi.order_id')

  .whereEquals('u.status', 'active')

  .whereIn('o.status', ['completed', 'shipped'])

  .orderBy('o.order_date', 'DESC')

  .limit(20)

  .offset(10)

  .build();

console.log(query2);



console.log('\n=== Filter Query ===');

const query3 = new QueryBuilder()

  .select('*')

  .from('products')

  .where('price > 100')

  .where('stock > 0')

  .whereIn('category', ['electronics', 'computers'])

  .orderBy('price', 'DESC')

  .build();

console.log(query3);

```



**Real-World Builder: HTTP Request Builder:**



```javascript

class HTTPRequest {

  constructor() {

    this.method = 'GET';

    this.url = '';

    this.headers = {};

    this.queryParams = {};

    this.body = null;

    this.timeout = 30000;

    this.retries = 0;

  }

  

  async execute() {

    const url = new URL(this.url);

    

    // Add query parameters

    Object.keys(this.queryParams).forEach(key => {

      url.searchParams.append(key, this.queryParams[key]);

    });

    

    const options = {

      method: this.method,

      headers: this.headers

    };

    

    if (this.body) {

      options.body = typeof this.body === 'string' 

        ? this.body 

        : JSON.stringify(this.body);

    }

    

    console.log(`\n[HTTP] ${this.method} ${url}`);

    console.log('[Headers]', this.headers);

    if (this.body) console.log('[Body]', this.body);

    

    // Simulated response

    return {

      status: 200,

      data: { success: true, message: 'Request successful' }

    };

  }

}



class HTTPRequestBuilder {

  constructor() {

    this.request = new HTTPRequest();

  }

  

  setMethod(method) {

    this.request.method = method.toUpperCase();

    return this;

  }

  

  get(url) {

    this.request.method = 'GET';

    this.request.url = url;

    return this;

  }

  

  post(url) {

    this.request.method = 'POST';

    this.request.url = url;

    return this;

  }

  

  put(url) {

    this.request.method = 'PUT';

    this.request.url = url;

    return this;

  }

  

  delete(url) {

    this.request.method = 'DELETE';

    this.request.url = url;

    return this;

  }

  

  setHeader(key, value) {

    this.request.headers[key] = value;

    return this;

  }

  

  setHeaders(headers) {

    this.request.headers = { ...this.request.headers, ...headers };

    return this;

  }

  

  setAuth(token, type = 'Bearer') {

    this.request.headers['Authorization'] = `${type} ${token}`;

    return this;

  }

  

  setContentType(contentType) {

    this.request.headers['Content-Type'] = contentType;

    return this;

  }

  

  json() {

    this.setContentType('application/json');

    return this;

  }

  

  setQueryParam(key, value) {

    this.request.queryParams[key] = value;

    return this;

  }

  

  setQueryParams(params) {

    this.request.queryParams = { ...this.request.queryParams, ...params };

    return this;

  }

  

  setBody(body) {

    this.request.body = body;

    return this;

  }

  

  setTimeout(timeout) {

    this.request.timeout = timeout;

    return this;

  }

  

  setRetries(retries) {

    this.request.retries = retries;

    return this;

  }

  

  build() {

    return this.request;

  }

  

  async send() {

    return this.request.execute();

  }

}



// Usage

console.log('=== GET Request ===');

const getRequest = new HTTPRequestBuilder()

  .get('https://api.example.com/users')

  .setAuth('my-token-123')

  .setQueryParams({

    page: 1,

    limit: 10,

    sort: 'name'

  })

  .send();



console.log('\n=== POST Request ===');

const postRequest = new HTTPRequestBuilder()

  .post('https://api.example.com/users')

  .json()

  .setAuth('my-token-123')

  .setBody({

    name: 'John Doe',

    email: 'john@example.com',

    role: 'admin'

  })

  .setTimeout(5000)

  .send();



console.log('\n=== PUT Request with Custom Headers ===');

const putRequest = new HTTPRequestBuilder()

  .put('https://api.example.com/users/123')

  .setHeaders({

    'Content-Type': 'application/json',

    'Authorization': 'Bearer token-xyz',

    'X-Custom-Header': 'custom-value'

  })

  .setBody({

    name: 'Jane Doe',

    email: 'jane@example.com'

  })

  .setRetries(3)

  .send();

```



---



### **17. Prototype Pattern**



Creates objects based on a template of an existing object through cloning. Avoids expensive initialization by copying existing instances.



```javascript

// Prototype with Object.create()

const carPrototype = {

  drive() {

    console.log(`${this.make} ${this.model} is driving`);

  },

  

  brake() {

    console.log(`${this.make} ${this.model} is braking`);

  },

  

  getInfo() {

    return `${this.year} ${this.make} ${this.model} - ${this.color}`;

  }

};



function createCar(make, model, year, color) {

  const car = Object.create(carPrototype);

  car.make = make;

  car.model = model;

  car.year = year;

  car.color = color;

  return car;

}



// Usage

const car1 = createCar('Toyota', 'Camry', 2024, 'Silver');

const car2 = createCar('Honda', 'Accord', 2024, 'Blue');



console.log(car1.getInfo()); // 2024 Toyota Camry - Silver

car1.drive(); // Toyota Camry is driving



console.log(car2.getInfo()); // 2024 Honda Accord - Blue

car2.drive(); // Honda Accord is driving

```



**Advanced Prototype with Cloning:**



```javascript

class Character {

  constructor(name, health, strength, skills = []) {

    this.name = name;

    this.health = health;

    this.strength = strength;

    this.skills = skills;

    this.inventory = [];

    this.position = { x: 0, y: 0 };

  }

  

  // Deep clone method

  clone() {

    const cloned = Object.create(Object.getPrototypeOf(this));

    

    // Deep copy properties

    cloned.name = this.name + ' (Clone)';

    cloned.health = this.health;

    cloned.strength = this.strength;

    cloned.skills = [...this.skills]; // Copy array

    cloned.inventory = this.inventory.map(item => ({ ...item })); // Deep copy

    cloned.position = { ...this.position }; // Copy object

    

    return cloned;

  }

  

  attack() {

    console.log(`${this.name} attacks with ${this.strength} strength!`);

  }

  

  useSkill(skillIndex) {

    if (this.skills[skillIndex]) {

      console.log(`${this.name} uses ${this.skills[skillIndex]}!`);

    }

  }

  

  addItem(item) {

    this.inventory.push(item);

  }

  

  move(x, y) {

    this.position = { x, y };

    console.log(`${this.name} moved to (${x}, ${y})`);

  }

  

  getInfo() {

    return {

      name: this.name,

      health: this.health,

      strength: this.strength,

      skills: this.skills.length,

      inventory: this.inventory.length,

      position: this.position

    };

  }

}



// Create prototype characters

const warriorPrototype = new Character('Warrior', 100, 20, ['Slash', 'Shield Block', 'Power Strike']);

const magePrototype = new Character('Mage', 70, 10, ['Fireball', 'Ice Bolt', 'Teleport']);



// Clone characters

const player1 = warriorPrototype.clone();

player1.name = 'Player 1 Warrior';

player1.addItem({ name: 'Sword', damage: 15 });

player1.addItem({ name: 'Shield', defense: 10 });

player1.move(10, 20);



const player2 = warriorPrototype.clone();

player2.name = 'Player 2 Warrior';

player2.addItem({ name: 'Axe', damage: 18 });

player2.move(15, 25);



const player3 = magePrototype.clone();

player3.name = 'Player 1 Mage';

player3.addItem({ name: 'Staff', magic: 20 });

player3.move(5, 10);



// Use cloned characters

console.log('\n=== Character Info ===');

console.log('Player 1:', player1.getInfo());

console.log('Player 2:', player2.getInfo());

console.log('Player 3:', player3.getInfo());



console.log('\n=== Actions ===');

player1.attack();

player1.useSkill(0);



player3.attack();

player3.useSkill(2);



// Verify independence

console.log('\n=== Verifying Independence ===');

console.log('Player 1 inventory:', player1.inventory);

console.log('Player 2 inventory:', player2.inventory);

console.log('Prototypes unchanged:', warriorPrototype.inventory.length === 0);

```



**Real-World Prototype: Document Templates:**



```javascript

class DocumentPrototype {

  constructor() {

    this.title = '';

    this.content = '';

    this.metadata = {};

    this.sections = [];

    this.formatting = {};

  }

  

  clone() {

    const cloned = Object.create(Object.getPrototypeOf(this));

    

    // Deep copy all properties

    cloned.title = this.title;

    cloned.content = this.content;

    cloned.metadata = JSON.parse(JSON.stringify(this.metadata));

    cloned.sections = JSON.parse(JSON.stringify(this.sections));

    cloned.formatting = JSON.parse(JSON.stringify(this.formatting));

    

    return cloned;

  }

  

  setTitle(title) {

    this.title = title;

    return this;

  }

  

  setContent(content) {

    this.content = content;

    return this;

  }

  

  addSection(section) {

    this.sections.push(section);

    return this;

  }

  

  setMetadata(key, value) {

    this.metadata[key] = value;

    return this;

  }

  

  setFormatting(formatting) {

    this.formatting = { ...this.formatting, ...formatting };

    return this;

  }

  

  render() {

    console.log('='.repeat(50));

    console.log(`TITLE: ${this.title}`);

    console.log(`Author: ${this.metadata.author || 'Unknown'}`);

    console.log(`Date: ${this.metadata.date || 'N/A'}`);

    console.log('='.repeat(50));

    

    if (this.content) {

      console.log(`\n${this.content}\n`);

    }

    

    this.sections.forEach((section, index) => {

      console.log(`\n${index + 1}. ${section.title}`);

      console.log(section.content);

    });

    

    console.log('\n' + '='.repeat(50));

  }

}



// Create template documents

const reportTemplate = new DocumentPrototype()

  .setMetadata('type', 'report')

  .setMetadata('author', 'System')

  .setFormatting({

    font: 'Arial',

    fontSize: 12,

    margins: { top: 1, bottom: 1, left: 1, right: 1 }

  })

  .addSection({

    title: 'Executive Summary',

    content: '[Summary content goes here]'

  })

  .addSection({

    title: 'Findings',

    content: '[Findings content goes here]'

  })

  .addSection({

    title: 'Recommendations',

    content: '[Recommendations content goes here]'

  });



const letterTemplate = new DocumentPrototype()

  .setMetadata('type', 'letter')

  .setFormatting({

    font: 'Times New Roman',

    fontSize: 11,

    margins: { top: 1.5, bottom: 1.5, left: 1, right: 1 }

  })

  .addSection({

    title: 'Opening',

    content: 'Dear [Recipient],'

  })

  .addSection({

    title: 'Body',

    content: '[Letter content goes here]'

  })

  .addSection({

    title: 'Closing',

    content: 'Sincerely,\n[Your Name]'

  });



// Clone and customize documents

console.log('=== Monthly Report ===');

const monthlyReport = reportTemplate.clone()

  .setTitle('Monthly Sales Report - December 2024')

  .setMetadata('author', 'John Doe')

  .setMetadata('date', '2024-12-20')

  .setContent('This report summarizes sales performance for December 2024.');



monthlyReport.render();



console.log('\n=== Welcome Letter ===');

const welcomeLetter = letterTemplate.clone()

  .setTitle('Welcome Letter')

  .setMetadata('author', 'HR Department')

  .setMetadata('date', '2024-12-20');



welcomeLetter.sections[0].content = 'Dear New Employee,';

welcomeLetter.sections[1].content = 'Welcome to our company! We are excited to have you join our team.';

welcomeLetter.sections[2].content = 'Best regards,\nHR Team';



welcomeLetter.render();

```



---



### **18. State Pattern**



Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.



```javascript

// State interface

class State {

  handle(context) {

    throw new Error('handle() must be implemented');

  }

}



// Concrete States

class RedLight extends State {

  handle(context) {

    console.log('🔴 RED - Stop');

    setTimeout(() => {

      context.setState(new GreenLight());

    }, 3000);

  }

}



class YellowLight extends State {

  handle(context) {

    console.log('🟡 YELLOW - Slow down');

    setTimeout(() => {

      context.setState(new RedLight());

    }, 1000);

  }

}



class GreenLight extends State {

  handle(context) {

    console.log('🟢 GREEN - Go');

    setTimeout(() => {

      context.setState(new YellowLight());

    }, 5000);

  }

}



// Context

class TrafficLight {

  constructor() {

    this.state = new RedLight();

  }

  

  setState(state) {

    this.state = state;

    this.state.handle(this);

  }

  

  start() {

    this.state.handle(this);

  }

}



// Usage

const trafficLight = new TrafficLight();

trafficLight.start();

```



**Advanced State: Order Processing:**



```javascript

class OrderState {

  constructor(name) {

    this.name = name;

  }

  

  process(order) {

    throw new Error('process() must be implemented');

  }

  

  cancel(order) {

    throw new Error('cancel() must be implemented');

  }

  

  ship(order) {

    throw new Error('ship() must be implemented');

  }

  

  deliver(order) {

    throw new Error('deliver() must be implemented');

  }

}



class PendingState extends OrderState {

  constructor() {

    super('Pending');

  }

  

  process(order) {

    console.log(`✓ Order #${order.id}: Pending → Processing`);

    order.setState(new ProcessingState());

    return true;

  }

  

  cancel(order) {

    console.log(`✓ Order #${order.id}: Pending → Cancelled`);

    order.setState(new CancelledState());

    return true;

  }

  

  ship(order) {

    console.log(`✗ Cannot ship order #${order.id} - must be processed first`);

    return false;

  }

  

  deliver(order) {

    console.log(`✗ Cannot deliver order #${order.id} - must be shipped first`);

    return false;

  }

}



class ProcessingState extends OrderState {

  constructor() {

    super('Processing');

  }

  

  process(order) {

    console.log(`✗ Order #${order.id} is already being processed`);

    return false;

  }

  

  cancel(order) {

    console.log(`✓ Order #${order.id}: Processing → Cancelled`);

    order.setState(new CancelledState());

    return true;

  }

  

  ship(order) {

    console.log(`✓ Order #${order.id}: Processing → Shipped`);

    order.setState(new ShippedState());

    return true;

  }

  

  deliver(order) {

    console.log(`✗ Cannot deliver order #${order.id} - must be shipped first`);

    return false;

  }

}



class ShippedState extends OrderState {

  constructor() {

    super('Shipped');

  }

  

  process(order) {

    console.log(`✗ Order #${order.id} has already been shipped`);

    return false;

  }

  

  cancel(order) {

    console.log(`✗ Cannot cancel order #${order.id} - already shipped`);

    return false;

  }

  

  ship(order) {

    console.log(`✗ Order #${order.id} has already been shipped`);

    return false;

  }

  

  deliver(order) {

    console.log(`✓ Order #${order.id}: Shipped → Delivered`);

    order.setState(new DeliveredState());

    return true;

  }

}



class DeliveredState extends OrderState {

  constructor() {

    super('Delivered');

  }

  

  process(order) {

    console.log(`✗ Order #${order.id} has already been delivered`);

    return false;

  }

  

  cancel(order) {

    console.log(`✗ Cannot cancel order #${order.id} - already delivered`);

    return false;

  }

  

  ship(order) {

    console.log(`✗ Order #${order.id} has already been delivered`);

    return false;

  }

  

  deliver(order) {

    console.log(`✗ Order #${order.id} has already been delivered`);

    return false;

  }

}



class CancelledState extends OrderState {

  constructor() {

    super('Cancelled');

  }

  

  process(order) {

    console.log(`✗ Cannot process cancelled order #${order.id}`);

    return false;

  }

  

  cancel(order) {

    console.log(`✗ Order #${order.id} is already cancelled`);

    return false;

  }

  

  ship(order) {

    console.log(`✗ Cannot ship cancelled order #${order.id}`);

    return false;

  }

  

  deliver(order) {

    console.log(`✗ Cannot deliver cancelled order #${order.id}`);

    return false;

  }

}



class Order {

  constructor(id, items) {

    this.id = id;

    this.items = items;

    this.state = new PendingState();

    this.history = [{ state: 'Pending', timestamp: new Date() }];

  }

  

  setState(state) {

    this.state = state;

    this.history.push({

      state: state.name,

      timestamp: new Date()

    });

  }

  

  getState() {

    return this.state.name;

  }

  

  process() {

    return this.state.process(this);

  }

  

  cancel() {

    return this.state.cancel(this);

  }

  

  ship() {

    return this.state.ship(this);

  }

  

  deliver() {

    return this.state.deliver(this);

  }

  

  getHistory() {

    return this.history.map(h => 

      `${h.state} at ${h.timestamp.toLocaleString()}`

    ).join('\n');

  }

}



// Usage

console.log('=== Order State Management ===\n');



const order1 = new Order(1001, ['Laptop', 'Mouse']);

console.log(`Order #${order1.id} - Current state: ${order1.getState()}\n`);



order1.process();  // Pending → Processing

order1.ship();     // Processing → Shipped

order1.deliver();  // Shipped → Delivered



console.log(`\nOrder #${order1.id} - Final state: ${order1.getState()}`);

console.log('\nOrder History:');

console.log(order1.getHistory());



// Test invalid transitions

console.log('\n=== Testing Invalid Transitions ===\n');

const order2 = new Order(1002, ['Phone']);

order2.ship();     // ✗ Cannot ship - not processed

order2.cancel();   // ✓ Pending → Cancelled

order2.process();  // ✗ Cannot process - cancelled

```



**Real-World State: Media Player:**



```javascript

class PlayerState {

  play(player) {

    console.log('Not implemented');

  }

  

  pause(player) {

    console.log('Not implemented');

  }

  

  stop(player) {

    console.log('Not implemented');

  }

  

  next(player) {

    console.log('Not implemented');

  }

  

  previous(player) {

    console.log('Not implemented');

  }

}



class StoppedState extends PlayerState {

  play(player) {

    console.log('▶️  Starting playback...');

    player.currentTime = 0;

    player.setState(new PlayingState());

  }

  

  pause(player) {

    console.log('⏸️  Already stopped');

  }

  

  stop(player) {

    console.log('⏹️  Already stopped');

  }

  

  next(player) {

    console.log('⏭️  Skipping to next track...');

    player.nextTrack();

    player.setState(new PlayingState());

  }

  

  previous(player) {

    console.log('⏮️  Going to previous track...');

    player.previousTrack();

    player.setState(new PlayingState());

  }

}



class PlayingState extends PlayerState {

  play(player) {

    console.log('▶️  Already playing');

  }

  

  pause(player) {

    console.log('⏸️  Pausing playback...');

    player.setState(new PausedState());

  }

  

  stop(player) {

    console.log('⏹️  Stopping playback...');

    player.currentTime = 0;

    player.setState(new StoppedState());

  }

  

  next(player) {

    console.log('⏭️  Skipping to next track...');

    player.nextTrack();

  }

  

  previous(player) {

    console.log('⏮️  Going to previous track...');

    player.previousTrack();

  }

}



class PausedState extends PlayerState {

  play(player) {

    console.log('▶️  Resuming playback...');

    player.setState(new PlayingState());

  }

  

  pause(player) {

    console.log('⏸️  Already paused');

  }

  

  stop(player) {

    console.log('⏹️  Stopping playback...');

    player.currentTime = 0;

    player.setState(new StoppedState());

  }

  

  next(player) {

    console.log('⏭️  Skipping to next track...');

    player.nextTrack();

    player.setState(new PlayingState());

  }

  

  previous(player) {

    console.log('⏮️  Going to previous track...');

    player.previousTrack();

    player.setState(new PlayingState());

  }

}



class MediaPlayer {

  constructor(playlist) {

    this.playlist = playlist;

    this.currentTrackIndex = 0;

    this.currentTime = 0;

    this.state = new StoppedState();

  }

  

  setState(state) {

    this.state = state;

  }

  

  play() {

    console.log(`\n[${this.getCurrentTrack()}]`);

    this.state.play(this);

  }

  

  pause() {

    console.log(`\n[${this.getCurrentTrack()}]`);

    this.state.pause(this);

  }

  

  stop() {

    console.log(`\n[${this.getCurrentTrack()}]`);

    this.state.stop(this);

  }

  

  next() {

    console.log(`\n[${this.getCurrentTrack()}]`);

    this.state.next(this);

  }

  

  previous() {

    console.log(`\n[${this.getCurrentTrack()}]`);

    this.state.previous(this);

  }

  

  nextTrack() {

    this.currentTrackIndex = (this.currentTrackIndex + 1) % this.playlist.length;

    this.currentTime = 0;

  }

  

  previousTrack() {

    this.currentTrackIndex = this.currentTrackIndex === 0 

      ? this.playlist.length - 1 

      : this.currentTrackIndex - 1;

    this.currentTime = 0;

  }

  

  getCurrentTrack() {

    return this.playlist[this.currentTrackIndex];

  }

  

  getStatus() {

    return {

      track: this.getCurrentTrack(),

      state: this.state.constructor.name.replace('State', ''),

      time: this.currentTime

    };

  }

}



// Usage

const player = new MediaPlayer([

  'Song 1.mp3',

  'Song 2.mp3',

  'Song 3.mp3'

]);



console.log('=== Media Player State Management ===');



player.play();      // Stopped → Playing

player.pause();     // Playing → Paused

player.play();      // Paused → Playing

player.next();      // Skip to next track

player.previous();  // Go back

player.stop();      // Playing → Stopped

player.pause();     // Already stopped



console.log('\n=== Current Status ===');

console.log(player.getStatus());

```



---



### **19. Template Method Pattern**



Defines the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's structure.



```javascript

// Abstract class

class DataProcessor {

  // Template method - defines algorithm structure

  process(data) {

    console.log('=== Starting Data Processing ===\n');

    

    const validated = this.validate(data);

    if (!validated) {

      console.log('❌ Validation failed');

      return null;

    }

    

    const extracted = this.extract(validated);

    const transformed = this.transform(extracted);

    const loaded = this.load(transformed);

    

    this.cleanup();

    

    console.log('\n=== Processing Complete ===');

    return loaded;

  }

  

  // Abstract methods - must be implemented by subclasses

  validate(data) {

    throw new Error('validate() must be implemented');

  }

  

  extract(data) {

    throw new Error('extract() must be implemented');

  }

  

  transform(data) {

    throw new Error('transform() must be implemented');

  }

  

  load(data) {

    throw new Error('load() must be implemented');

  }

  

  // Hook method - optional override

  cleanup() {

    console.log('\n🧹 Cleanup completed');

  }

}



// Concrete implementation 1

class CSVProcessor extends DataProcessor {

  validate(data) {

    console.log('✓ Validating CSV format...');

    return typeof data === 'string' && data.includes(',');

  }

  

  extract(data) {

    console.log('✓ Extracting CSV data...');

    const lines = data.split('\n');

    const headers = lines[0].split(',');

    const rows = lines.slice(1).map(line => line.split(','));

    return { headers, rows };

  }

  

  transform(data) {

    console.log('✓ Transforming CSV to objects...');

    return data.rows.map(row => {

      const obj = {};

      data.headers.forEach((header, index) => {

        obj[header.trim()] = row[index]?.trim();

      });

      return obj;

    });

  }

  

  load(data) {

    console.log(`✓ Loading ${data.length} records...`);

    return data;

  }

  

  cleanup() {

    console.log('\n🧹 CSV processor cleanup: Closing file handles');

  }

}



// Concrete implementation 2

class JSONProcessor extends DataProcessor {

  validate(data) {

    console.log('✓ Validating JSON format...');

    try {

      JSON.parse(data);

      return true;

    } catch {

      return false;

    }

  }

  

  extract(data) {

    console.log('✓ Extracting JSON data...');

    return JSON.parse(data);

  }

  

  transform(data) {

    console.log('✓ Transforming JSON data...');

    // Normalize field names to lowercase

    if (Array.isArray(data)) {

      return data.map(item => {

        const normalized = {};

        Object.keys(item).forEach(key => {

          normalized[key.toLowerCase()] = item[key];

        });

        return normalized;

      });

    }

    return data;

  }

  

  load(data) {

    console.log(`✓ Loading ${Array.isArray(data) ? data.length : 1} record(s)...`);

    return data;

  }

  

  cleanup() {

    console.log('\n🧹 JSON processor cleanup: Clearing cache');

  }

}



// Concrete implementation 3

class XMLProcessor extends DataProcessor {

  validate(data) {

    console.log('✓ Validating XML format...');

    return typeof data === 'string' && data.includes('<') && data.includes('>');

  }

  

  extract(data) {

    console.log('✓ Extracting XML data...');

    // Simplified XML parsing

    const items = [];

    const itemMatches = data.matchAll(/<item>([\s\S]*?)<\/item>/g);

    

    for (const match of itemMatches) {

      items.push(match[1]);

    }

    

    return items;

  }

  

  transform(data) {

    console.log('✓ Transforming XML to objects...');

    return data.map(item => {

      const obj = {};

      const fieldMatches = item.matchAll(/<(\w+)>(.*?)<\/\1>/g);

      

      for (const match of fieldMatches) {

        obj[match[1]] = match[2];

      }

      

      return obj;

    });

  }

  

  load(data) {

    console.log(`✓ Loading ${data.length} records...`);

    return data;

  }

}



// Usage

const csvData = `name,age,city

John Doe,30,New York

Jane Smith,25,Los Angeles`;



const jsonData = `[

  {"Name": "John Doe", "Age": 30, "City": "New York"},

  {"Name": "Jane Smith", "Age": 25, "City": "Los Angeles"}

]`;



const xmlData = `

<items>

  <item><name>John Doe</name><age>30</age><city>New York</city></item>

  <item><name>Jane Smith</name><age>25</age><city>Los Angeles</city></item>

</items>`;



console.log('CSV Processing:');

const csvProcessor = new CSVProcessor();

const csvResult = csvProcessor.process(csvData);

console.log('Result:', csvResult);



console.log('\n' + '='.repeat(50) + '\n');



console.log('JSON Processing:');

const jsonProcessor = new JSONProcessor();

const jsonResult = jsonProcessor.process(jsonData);

console.log('Result:', jsonResult);



console.log('\n' + '='.repeat(50) + '\n');



console.log('XML Processing:');

const xmlProcessor = new XMLProcessor();

const xmlResult = xmlProcessor.process(xmlData);

console.log('Result:', xmlResult);

```



**Real-World Template: Report Generator:**



```javascript

class ReportGenerator {

  // Template method

  generate(data, options = {}) {

    console.log(`\n=== Generating ${this.getReportType()} Report ===\n`);

    

    this.initialize(options);

    

    const processedData = this.processData(data);

    

    this.renderHeader(options);

    this.renderBody(processedData);

    this.renderFooter(options);

    

    const output = this.finalize();

    

    console.log('\n✓ Report generation complete\n');

    return output;

  }

  

  // Abstract methods

  getReportType() {

    throw new Error('getReportType() must be implemented');

  }

  

  renderHeader(options) {

    throw new Error('renderHeader() must be implemented');

  }

  

  renderBody(data) {

    throw new Error('renderBody() must be implemented');

  }

  

  renderFooter(options) {

    throw new Error('renderFooter() must be implemented');

  }

  

  // Concrete methods with default implementation

  initialize(options) {

    this.output = [];

    this.options = options;

  }

  

  processData(data) {

    return data;

  }

  

  finalize() {

    return this.output.join('\n');

  }

}



class PDFReport extends ReportGenerator {

  getReportType() {

    return 'PDF';

  }

  

  renderHeader(options) {

    this.output.push('PDF HEADER');

    this.output.push('='.repeat(50));

    this.output.push(`Title: ${options.title || 'Untitled Report'}`);

    this.output.push(`Date: ${new Date().toLocaleDateString()}`);

    this.output.push(`Author: ${options.author || 'Unknown'}`);

    this.output.push('='.repeat(50));

  }

  

  renderBody(data) {

    this.output.push('\nCONTENT:');

    data.forEach((item, index) => {

      this.output.push(`\n${index + 1}. ${item.title}`);

      this.output.push(`   ${item.description}`);

      this.output.push(`   Value: ${item.value}`);

    });

  }

  

  renderFooter(options) {

    this.output.push('\n' + '='.repeat(50));

    this.output.push('PDF FOOTER');

    this.output.push(`Page 1 of 1`);

    this.output.push(`© ${options.company || 'Company'} ${new Date().getFullYear()}`);

  }

}



class HTMLReport extends ReportGenerator {

  getReportType() {

    return 'HTML';

  }

  

  renderHeader(options) {

    this.output.push('<!DOCTYPE html>');

    this.output.push('<html>');

    this.output.push('<head>');

    this.output.push(`  <title>${options.title || 'Report'}</title>`);

    this.output.push('  <style>');

    this.output.push('    body { font-family: Arial, sans-serif; margin: 20px; }');

    this.output.push('    h1 { color: #333; }');

    this.output.push('    .item { margin: 10px 0; padding: 10px; border: 1px solid #ddd; }');

    this.output.push('  </style>');

    this.output.push('</head>');

    this.output.push('<body>');

    this.output.push(`  <h1>${options.title || 'Report'}</h1>`);

    this.output.push(`  <p>Date: ${new Date().toLocaleDateString()}</p>`);

  }

  

  renderBody(data) {

    this.output.push('  <div class="content">');

    data.forEach(item => {

      this.output.push('    <div class="item">');

      this.output.push(`      <h3>${item.title}</h3>`);

      this.output.push(`      <p>${item.description}</p>`);

      this.output.push(`      <strong>Value: ${item.value}</strong>`);

      this.output.push('    </div>');

    });

    this.output.push('  </div>');

  }

  

  renderFooter(options) {

    this.output.push('  <footer>');

    this.output.push(`    <p>© ${options.company || 'Company'} ${new Date().getFullYear()}</p>`);

    this.output.push('  </footer>');

    this.output.push('</body>');

    this.output.push('</html>');

  }

}



class MarkdownReport extends ReportGenerator {

  getReportType() {

    return 'Markdown';

  }

  

  renderHeader(options) {

    this.output.push(`# ${options.title || 'Report'}`);

    this.output.push('');

    this.output.push(`**Date:** ${new Date().toLocaleDateString()}`);

    this.output.push(`**Author:** ${options.author || 'Unknown'}`);

    this.output.push('');

    this.output.push('---');

  }

  

  renderBody(data) {

    this.output.push('');

    this.output.push('## Content');

    this.output.push('');

    data.forEach((item, index) => {

      this.output.push(`### ${index + 1}. ${item.title}`);

      this.output.push('');

      this.output.push(item.description);

      this.output.push('');

      this.output.push(`**Value:** ${item.value}`);

      this.output.push('');

    });

  }

  

  renderFooter(options) {

    this.output.push('---');

    this.output.push('');

    this.output.push(`*© ${options.company || 'Company'} ${new Date().getFullYear()}*`);

  }

}



// Usage

const reportData = [

  {

    title: 'Q4 Revenue',

    description: 'Total revenue for Q4 2024',

    value: '$1,250,000'

  },

  {

    title: 'Customer Growth',

    description: 'New customers acquired',

    value: '450 customers'

  },

  {

    title: 'Product Sales',

    description: 'Top-selling products',

    value: 'Product A, Product B'

  }

];



const options = {

  title: 'Q4 2024 Business Report',

  author: 'John Doe',

  company: 'TechCorp'

};



// Generate PDF report

const pdfGenerator = new PDFReport();

const pdfOutput = pdfGenerator.generate(reportData, options);

console.log(pdfOutput);



// Generate HTML report

const htmlGenerator = new HTMLReport();

const htmlOutput = htmlGenerator.generate(reportData, options);

console.log(htmlOutput);



// Generate Markdown report

const mdGenerator = new MarkdownReport();

const mdOutput = mdGenerator.generate(reportData, options);

console.log(mdOutput);

```



---



## **Pattern Comparison & Selection Guide**



### **When to Use Each Pattern**



| Pattern | Use When | Don't Use When | Complexity |

|---------|----------|----------------|------------|

| **Module** | Need encapsulation, private state | ES6 modules available | Low |

| **Singleton** | Need exactly one instance (DB, config) | Testing is priority, need multiple instances | Low |

| **Factory** | Object creation is complex, many types | Simple object creation | Medium |

| **Observer** | Need event-driven architecture, pub/sub | Simple one-to-one communication | Medium |

| **Strategy** | Multiple algorithms, runtime selection | Only one algorithm needed | Low |

| **Decorator** | Add behavior without subclassing | Core functionality changes | Medium |

| **Proxy** | Control access, lazy loading, caching | Direct access is sufficient | Medium |

| **Facade** | Simplify complex subsystems | System is already simple | Low |

| **Command** | Need undo/redo, queuing operations | Simple direct method calls | Medium |

| **Iterator** | Custom traversal logic needed | Built-in iteration sufficient | Low |

| **Chain of Responsibility** | Multiple handlers, request processing | Single handler sufficient | Medium |

| **Mediator** | Complex object communication | Simple direct communication | High |

| **Adapter** | Integrate incompatible interfaces | Interfaces already compatible | Low |

| **Composite** | Tree structures, part-whole hierarchies | Flat structures | Medium |

| **Builder** | Complex object construction, many options | Simple object creation | Medium |

| **Prototype** | Object cloning, avoid expensive creation | Objects are cheap to create | Low |

| **State** | Behavior changes based on state | Simple if-else sufficient | Medium |

| **Template Method** | Algorithm skeleton, variable steps | No common algorithm structure | Low |



### **Pattern Categories & Relationships**



**Creational Patterns** (Object Creation):

```

Singleton ──────► One instance globally

Factory ─────────► Create objects by type

Builder ─────────► Step-by-step construction

Prototype ───────► Clone existing objects

```



**Structural Patterns** (Object Composition):

```

Adapter ─────────► Make interfaces compatible

Decorator ───────► Add behavior dynamically

Facade ──────────► Simplify complex systems

Composite ───────► Tree structures

Proxy ───────────► Control access

```



**Behavioral Patterns** (Object Interaction):

```

Observer ────────► Event notification

Strategy ────────► Algorithm selection

Command ─────────► Encapsulate requests

State ───────────► Behavior by state

Chain ───────────► Pass requests along chain

Iterator ────────► Sequential access

Mediator ────────► Centralized communication

Template Method ─► Algorithm skeleton

```



### **Pattern Combinations**



Patterns often work together:



```javascript

// Singleton + Factory

class DatabaseFactory {

  static instance = null;

  

  static getInstance() {

    if (!DatabaseFactory.instance) {

      DatabaseFactory.instance = new DatabaseFactory();

    }

    return DatabaseFactory.instance;

  }

  

  createConnection(type) {

    switch (type) {

      case 'mysql':

        return new MySQLConnection();

      case 'postgres':

        return new PostgresConnection();

      default:

        throw new Error('Unknown database type');

    }

  }

}



// Strategy + Factory

class CompressionFactory {

  static create(type) {

    const strategies = {

      'zip': new ZipCompressionStrategy(),

      'gzip': new GzipCompressionStrategy(),

      'bzip2': new Bzip2CompressionStrategy()

    };

    return strategies[type] || strategies['zip'];

  }

}



// Observer + Mediator

class ChatMediator {

  constructor() {

    this.users = [];

    this.observers = []; // Log observers, analytics observers, etc.

  }

  

  subscribe(observer) {

    this.observers.push(observer);

  }

  

  notify(message) {

    this.observers.forEach(observer => observer.update(message));

  }

  

  sendMessage(message, from, to) {

    this.notify({ type: 'message', message, from, to });

    to.receive(message, from);

  }

}



// Decorator + Proxy

class CachedAPIProxy {

  constructor(api) {

    this.api = api;

    this.cache = new Map();

  }

  

  async get(endpoint) {

    if (this.cache.has(endpoint)) {

      return this.cache.get(endpoint);

    }

    

    // Decorated API with logging

    const result = await this.api.get(endpoint);

    this.cache.set(endpoint, result);

    return result;

  }

}

```



---



## **Anti-Patterns to Avoid**



### **1. God Object / Monster Class**



**Problem:** One class that does everything.



```javascript

// ❌ BAD - God Object

class Application {

  constructor() {

    this.users = [];

    this.products = [];

    this.orders = [];

    this.database = null;

    this.server = null;

  }

  

  // User management

  createUser(data) { /* ... */ }

  updateUser(id, data) { /* ... */ }

  deleteUser(id) { /* ... */ }

  

  // Product management

  createProduct(data) { /* ... */ }

  updateProduct(id, data) { /* ... */ }

  deleteProduct(id) { /* ... */ }

  

  // Order management

  createOrder(data) { /* ... */ }

  processOrder(id) { /* ... */ }

  shipOrder(id) { /* ... */ }

  

  // Database operations

  connectDB() { /* ... */ }

  queryDB() { /* ... */ }

  

  // Server operations

  startServer() { /* ... */ }

  handleRequest() { /* ... */ }

  

  // ... hundreds more methods

}



// ✅ GOOD - Separation of Concerns

class UserService {

  constructor(repository) {

    this.repository = repository;

  }

  

  create(data) { return this.repository.create(data); }

  update(id, data) { return this.repository.update(id, data); }

  delete(id) { return this.repository.delete(id); }

}



class ProductService {

  constructor(repository) {

    this.repository = repository;

  }

  

  create(data) { return this.repository.create(data); }

  update(id, data) { return this.repository.update(id, data); }

  delete(id) { return this.repository.delete(id); }

}



class OrderService {

  constructor(repository, userService, productService) {

    this.repository = repository;

    this.userService = userService;

    this.productService = productService;

  }

  

  create(orderData) { /* ... */ }

  process(orderId) { /* ... */ }

  ship(orderId) { /* ... */ }

}

```



### **2. Spaghetti Code**



**Problem:** Tangled, unstructured code with no clear flow.



```javascript

// ❌ BAD - Spaghetti Code

let total = 0;

for (let i = 0; i < items.length; i++) {

  if (items[i].price) {

    if (items[i].discount) {

      if (items[i].discount > 0) {

        total += items[i].price - (items[i].price * items[i].discount / 100);

      } else {

        total += items[i].price;

      }

    } else {

      total += items[i].price;

    }

  }

}

if (total > 100) {

  total = total - 10;

}



// ✅ GOOD - Clean Structure

class ShoppingCart {

  calculateTotal(items) {

    const subtotal = items.reduce((sum, item) => 

      sum + this.calculateItemPrice(item), 0

    );

    

    return this.applyCartDiscount(subtotal);

  }

  

  calculateItemPrice(item) {

    if (!item.price) return 0;

    

    const discount = item.discount || 0;

    return item.price * (1 - discount / 100);

  }

  

  applyCartDiscount(subtotal) {

    const DISCOUNT_THRESHOLD = 100;

    const DISCOUNT_AMOUNT = 10;

    

    return subtotal > DISCOUNT_THRESHOLD 

      ? subtotal - DISCOUNT_AMOUNT 

      : subtotal;

  }

}

```



### **3. Premature Optimization**



**Problem:** Optimizing before measuring or understanding bottlenecks.



```javascript

// ❌ BAD - Premature Optimization

class DataCache {

  constructor() {

    // Complex caching with LRU, compression, serialization

    this.cache = new Map();

    this.lruList = [];

    this.compressionAlgo = new ComplexCompressor();

    this.serializer = new CustomSerializer();

  }

  

  set(key, value) {

    const compressed = this.compressionAlgo.compress(value);

    const serialized = this.serializer.serialize(compressed);

    this.cache.set(key, serialized);

    this.updateLRU(key);

  }

  

  // ... complex implementation for 10 items

}



// ✅ GOOD - Simple First, Optimize Later

class DataCache {

  constructor() {

    this.cache = new Map();

  }

  

  set(key, value) {

    this.cache.set(key, value);

  }

  

  get(key) {

    return this.cache.get(key);

  }

  

  // Measure performance first, then optimize if needed

}

```



### **4. Overusing Patterns**



**Problem:** Using patterns where simple code suffices.



```javascript

// ❌ BAD - Pattern Overkill

class AdditionStrategy {

  execute(a, b) { return a + b; }

}



class SubtractionStrategy {

  execute(a, b) { return a - b; }

}



class CalculatorContext {

  setStrategy(strategy) {

    this.strategy = strategy;

  }

  

  calculate(a, b) {

    return this.strategy.execute(a, b);

  }

}



const calc = new CalculatorContext();

calc.setStrategy(new AdditionStrategy());

const result = calc.calculate(2, 3);



// ✅ GOOD - Simple Solution

function add(a, b) { return a + b; }

function subtract(a, b) { return a - b; }



const result = add(2, 3);

```



### **5. Singleton Abuse**



**Problem:** Using Singleton when not needed, making testing difficult.



```javascript

// ❌ BAD - Singleton Abuse

class Logger {

  static instance = null;

  

  static getInstance() {

    if (!Logger.instance) {

      Logger.instance = new Logger();

    }

    return Logger.instance;

  }

  

  log(message) {

    console.log(message);

  }

}



// Hard to test, can't mock easily

class UserService {

  createUser(data) {

    Logger.getInstance().log('Creating user');

    // ... create user

  }

}



// ✅ GOOD - Dependency Injection

class Logger {

  log(message) {

    console.log(message);

  }

}



class UserService {

  constructor(logger) {

    this.logger = logger;

  }

  

  createUser(data) {

    this.logger.log('Creating user');

    // ... create user

  }

}



// Easy to test with mock logger

const mockLogger = { log: jest.fn() };

const service = new UserService(mockLogger);

```



---



## **Modern JavaScript Patterns**



### **1. React Component Patterns**



```javascript

// Higher-Order Component (HOC)

function withLoading(Component) {

  return function WithLoadingComponent({ isLoading, ...props }) {

    if (isLoading) {

      return <div>Loading...</div>;

    }

    return <Component {...props} />;

  };

}



const UserListWithLoading = withLoading(UserList);



// Render Props

class DataProvider extends React.Component {

  state = { data: null, loading: true };

  

  componentDidMount() {

    fetch(this.props.url)

      .then(res => res.json())

      .then(data => this.setState({ data, loading: false }));

  }

  

  render() {

    return this.props.render(this.state);

  }

}



// Usage

<DataProvider

  url="/api/users"

  render={({ data, loading }) => (

    loading ? <Spinner /> : <UserList users={data} />

  )}

/>



// Custom Hooks (Modern React)

function useData(url) {

  const [data, setData] = useState(null);

  const [loading, setLoading] = useState(true);

  const [error, setError] = useState(null);

  

  useEffect(() => {

    fetch(url)

      .then(res => res.json())

      .then(data => {

        setData(data);

        setLoading(false);

      })

      .catch(err => {

        setError(err);

        setLoading(false);

      });

  }, [url]);

  

  return { data, loading, error };

}



// Usage

function UserList() {

  const { data, loading, error } = useData('/api/users');

  

  if (loading) return <Spinner />;

  if (error) return <Error message={error.message} />;

  return <List items={data} />;

}



// Compound Components

function Tabs({ children }) {

  const [activeIndex, setActiveIndex] = useState(0);

  

  return (

    <TabsContext.Provider value={{ activeIndex, setActiveIndex }}>

      {children}

    </TabsContext.Provider>

  );

}



Tabs.List = function TabsList({ children }) {

  return <div className="tabs-list">{children}</div>;

};



Tabs.Tab = function Tab({ index, children }) {

  const { activeIndex, setActiveIndex } = useContext(TabsContext);

  return (

    <button

      className={activeIndex === index ? 'active' : ''}

      onClick={() => setActiveIndex(index)}

    >

      {children}

    </button>

  );

};



Tabs.Panel = function TabsPanel({ index, children }) {

  const { activeIndex } = useContext(TabsContext);

  return activeIndex === index ? <div>{children}</div> : null;

};



// Usage

<Tabs>

  <Tabs.List>

    <Tabs.Tab index={0}>Tab 1</Tabs.Tab>

    <Tabs.Tab index={1}>Tab 2</Tabs.Tab>

  </Tabs.List>

  <Tabs.Panel index={0}>Content 1</Tabs.Panel>

  <Tabs.Panel index={1}>Content 2</Tabs.Panel>

</Tabs>

```



### **2. Async Patterns**



```javascript

// Async Iterator Pattern

async function* fetchPages(url, totalPages) {

  for (let page = 1; page <= totalPages; page++) {

    const response = await fetch(`${url}?page=${page}`);

    const data = await response.json();

    yield data;

  }

}



// Usage

for await (const pageData of fetchPages('/api/items', 5)) {

  console.log('Processing page:', pageData);

}



// Promise Pool (Concurrency Control)

class PromisePool {

  constructor(concurrency) {

    this.concurrency = concurrency;

    this.running = 0;

    this.queue = [];

  }

  

  async add(promiseFactory) {

    while (this.running >= this.concurrency) {

      await Promise.race(this.queue);

    }

    

    this.running++;

    const promise = promiseFactory()

      .then(result => {

        this.running--;

        this.queue.splice(this.queue.indexOf(promise), 1);

        return result;

      })

      .catch(error => {

        this.running--;

        this.queue.splice(this.queue.indexOf(promise), 1);

        throw error;

      });

    

    this.queue.push(promise);

    return promise;

  }

  

  async all(promiseFactories) {

    return Promise.all(

      promiseFactories.map(factory => this.add(factory))

    );

  }

}



// Usage

const pool = new PromisePool(3); // Max 3 concurrent requests



const urls = Array.from({ length: 10 }, (_, i) => `/api/item/${i}`);

const results = await pool.all(

  urls.map(url => () => fetch(url).then(r => r.json()))

);



// Retry Pattern with Exponential Backoff

async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {

  for (let attempt = 0; attempt < maxRetries; attempt++) {

    try {

      return await fn();

    } catch (error) {

      if (attempt === maxRetries - 1) {

        throw error;

      }

      

      const delay = baseDelay * Math.pow(2, attempt);

      console.log(`Retry attempt ${attempt + 1} after ${delay}ms`);

      await new Promise(resolve => setTimeout(resolve, delay));

    }

  }

}



// Usage

const data = await retryWithBackoff(

  () => fetch('/api/unstable-endpoint').then(r => r.json()),

  5,

  1000

);



// Circuit Breaker Pattern

class CircuitBreaker {

  constructor(threshold = 5, timeout = 60000) {

    this.threshold = threshold;

    this.timeout = timeout;

    this.failures = 0;

    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN

    this.nextAttempt = Date.now();

  }

  

  async execute(fn) {

    if (this.state === 'OPEN') {

      if (Date.now() < this.nextAttempt) {

        throw new Error('Circuit breaker is OPEN');

      }

      this.state = 'HALF_OPEN';

    }

    

    try {

      const result = await fn();

      this.onSuccess();

      return result;

    } catch (error) {

      this.onFailure();

      throw error;

    }

  }

  

  onSuccess() {

    this.failures = 0;

    this.state = 'CLOSED';

  }

  

  onFailure() {

    this.failures++;

    if (this.failures >= this.threshold) {

      this.state = 'OPEN';

      this.nextAttempt = Date.now() + this.timeout;

      console.log(`Circuit breaker opened. Retry after ${this.timeout}ms`);

    }

  }

}



// Usage

const breaker = new CircuitBreaker(3, 30000);



async function fetchData() {

  return breaker.execute(() =>

    fetch('/api/data').then(r => r.json())

  );

}

```



### **3. Module Patterns (ES6+)**



```javascript

// Named Exports

// math.js

export const PI = 3.14159;

export function add(a, b) { return a + b; }

export function multiply(a, b) { return a * b; }



// app.js

import { PI, add, multiply } from './math.js';



// Default Export

// logger.js

export default class Logger {

  log(message) {

    console.log(`[${new Date().toISOString()}] ${message}`);

  }

}



// app.js

import Logger from './logger.js';



// Re-exports (Barrel Pattern)

// components/index.js

export { Button } from './Button.js';

export { Input } from './Input.js';

export { Card } from './Card.js';



// app.js

import { Button, Input, Card } from './components';



// Dynamic Imports

async function loadModule(moduleName) {

  if (moduleName === 'heavy-module') {

    const module = await import('./heavy-module.js');

    return module.default;

  }

}



// Namespace Pattern

const App = {

  config: {

    apiUrl: 'https://api.example.com',

    timeout: 5000

  },

  

  utils: {

    formatDate(date) { /* ... */ },

    parseJSON(str) { /* ... */ }

  },

  

  services: {

    api: {

      get(endpoint) { /* ... */ },

      post(endpoint, data) { /* ... */ }

    },

    

    auth: {

      login(credentials) { /* ... */ },

      logout() { /* ... */ }

    }

  }

};

```



---



## **Best Practices**



### **1. SOLID Principles Applied to Patterns**



- **Single Responsibility**: Each pattern solves one specific problem

- **Open/Closed**: Patterns allow extension without modification

- **Liskov Substitution**: Strategy and State patterns ensure interchangeable components

- **Interface Segregation**: Use small, focused interfaces

- **Dependency Inversion**: Depend on abstractions, not concretions



### **2. When to Use Patterns**



✅ **DO use patterns when:**

- Code is becoming complex and hard to maintain

- You recognize a recurring problem

- You need flexibility for future changes

- Multiple team members need to understand the code

- You're building a framework or library



❌ **DON'T use patterns when:**

- A simple solution exists

- The problem is unlikely to change

- It's a one-time script

- The pattern adds unnecessary complexity

- You're just learning patterns



### **3. Pattern Selection Checklist**




1. **Identify the problem**: What exactly are you trying to solve?



2. **Check simpler solutions**: Can vanilla JS solve it?



3. **Consider maintenance**: Will others understand this?



4. **Think about testing**: Does the pattern make testing easier or harder?



5. **Evaluate performance**: Does the abstraction add significant overhead?




### **4. Code Quality Guidelines**



```javascript

// ✅ Good Pattern Implementation

class PaymentProcessor {

  constructor(strategy) {

    this.strategy = strategy; // Dependency injection

  }

  

  // Clear, single purpose

  process(amount) {

    this.validateAmount(amount);

    return this.strategy.execute(amount);

  }

  

  // Easy to test

  validateAmount(amount) {

    if (amount <= 0) {

      throw new Error('Amount must be positive');

    }

  }

  

  // Allows strategy changes

  setStrategy(strategy) {

    this.strategy = strategy;

  }

}



// ✅ Good usage - Clear and testable

const processor = new PaymentProcessor(new CreditCardStrategy());

processor.process(100);



// Testing is straightforward

const mockStrategy = { execute: jest.fn() };

const testProcessor = new PaymentProcessor(mockStrategy);

```



---



## **Comprehensive Key Takeaways**



### **Pattern Categories Summary**



**Creational Patterns** - Focus on object creation:

- **Module**: Encapsulation and privacy

- **Singleton**: Single instance control

- **Factory**: Flexible object creation

- **Builder**: Step-by-step construction

- **Prototype**: Clone existing objects



**Structural Patterns** - Focus on object composition:

- **Adapter**: Interface compatibility

- **Decorator**: Add behavior dynamically

- **Facade**: Simplify complex systems

- **Composite**: Tree structures

- **Proxy**: Access control and lazy loading



**Behavioral Patterns** - Focus on object interaction:

- **Observer**: Event-driven architecture

- **Strategy**: Algorithm selection

- **Command**: Encapsulate operations

- **State**: Behavior based on state

- **Chain of Responsibility**: Request processing pipeline

- **Iterator**: Sequential access

- **Mediator**: Centralized communication

- **Template Method**: Algorithm skeleton



### **Essential Principles**




1. **Favor Composition Over Inheritance**


   - Use patterns like Decorator, Strategy, and Composite

   - More flexible and maintainable




2. **Program to Interfaces, Not Implementations**


   - Patterns like Strategy and Factory promote this

   - Easier to swap implementations




3. **Encapsulate What Varies**


   - Identify aspects that change and separate them

   - Strategy, State, and Builder patterns excel here




4. **Depend on Abstractions**


   - High-level modules shouldn't depend on low-level modules

   - Use Factory, Adapter, and Proxy patterns




5. **Keep It Simple**


   - Don't use patterns just because you know them

   - Choose simplicity over cleverness



### **Pattern Selection Quick Reference**



**Need to create objects?** → Creational Patterns

- One instance? → **Singleton**

- Many types? → **Factory**

- Complex setup? → **Builder**

- Copy existing? → **Prototype**



**Need to structure objects?** → Structural Patterns

- Incompatible interfaces? → **Adapter**

- Add features? → **Decorator**

- Simplify complexity? → **Facade**

- Tree structures? → **Composite**

- Control access? → **Proxy**



**Need objects to interact?** → Behavioral Patterns

- Event system? → **Observer**

- Multiple algorithms? → **Strategy**

- Undo/redo? → **Command**

- State-dependent behavior? → **State**

- Request pipeline? → **Chain of Responsibility**

- Custom iteration? → **Iterator**

- Complex communication? → **Mediator**

- Algorithm steps? → **Template Method**



### **Modern JavaScript Context**



- ES6+ provides native solutions: classes, modules, promises, async/await

- React promotes: HOCs, Render Props, Custom Hooks, Compound Components

- Node.js favors: Middleware pattern, Event Emitters, Streams

- Always consider framework-specific patterns before reinventing



### **Final Wisdom**



> "Design patterns are not a silver bullet. They are tools in your toolbox. Use them when they solve a real problem, not because they look elegant." 



**Remember:**

- Patterns make code more maintainable, not more clever

- Simple code is better than pattern-heavy code

- Understand the problem before applying a solution

- Patterns should emerge from needs, not be forced into designs

- Testing and clarity always trump cleverness



---












</details>
