# JavaScript Coding Interview Questions

A comprehensive collection of frequently asked JavaScript and frontend coding questions in technical interviews, organized by difficulty level.

---

## **EASY LEVEL (1-30)**

### **Arrays & Strings**

1. Reverse a string without using built-in reverse method

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using a Loop (Brute Force)**
```javascript
/**
 * Reverse a string using traditional for loop
 * Time Complexity: O(n) - iterate through entire string
 * Space Complexity: O(n) - create new string
 * 
 * @param {string} str - Input string to reverse
 * @returns {string} - Reversed string
 */
function reverseString(str) {
  // Handle edge cases
  if (!str || str.length === 0) return str;
  
  let reversed = '';
  
  // Iterate from end to beginning
  for (let i = str.length - 1; i >= 0; i--) {
    reversed += str[i];
  }
  
  return reversed;
}

// Test cases
console.log(reverseString('hello'));        // 'olleh'
console.log(reverseString('JavaScript'));   // 'tpircSavaJ'
console.log(reverseString(''));             // ''
console.log(reverseString('a'));            // 'a'
```

### **Approach 2: Using Array Methods (Optimized)**
```javascript
/**
 * Reverse string using array conversion
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Most readable and commonly used in production
 */
function reverseString(str) {
  if (!str) return str;
  
  // Split to array, reverse, join back
  return str.split('').reverse().join('');
}

// Test cases
console.log(reverseString('hello'));        // 'olleh'
console.log(reverseString('JavaScript'));   // 'tpircSavaJ'
```

### **Approach 3: Using Recursion**
```javascript
/**
 * Reverse string using recursion
 * Time Complexity: O(n)
 * Space Complexity: O(n) - due to call stack
 * 
 * Good for demonstrating recursion understanding
 */
function reverseString(str) {
  // Base case: empty or single character
  if (str.length <= 1) return str;
  
  // Recursive case: last char + reverse of remaining string
  return str[str.length - 1] + reverseString(str.slice(0, -1));
}

// Test cases
console.log(reverseString('hello'));        // 'olleh'
console.log(reverseString('JavaScript'));   // 'tpircSavaJ'
```

### **Approach 4: Two-Pointer In-Place (Most Efficient for Arrays)**
```javascript
/**
 * Reverse string in-place using two pointers
 * Time Complexity: O(n)
 * Space Complexity: O(1) - if working with array
 * 
 * Most efficient for character arrays
 */
function reverseString(str) {
  if (!str) return str;
  
  // Convert to array for in-place modification
  const arr = str.split('');
  let left = 0;
  let right = arr.length - 1;
  
  // Swap characters from both ends moving towards center
  while (left < right) {
    // Swap using destructuring
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
  
  return arr.join('');
}

// Test cases
console.log(reverseString('hello'));        // 'olleh'
console.log(reverseString('JavaScript'));   // 'tpircSavaJ'
```

### **Production-Grade Solution with Validation**
```javascript
/**
 * Production-ready string reversal with comprehensive error handling
 * 
 * @param {string} str - Input string to reverse
 * @returns {string} - Reversed string
 * @throws {TypeError} - If input is not a string
 */
function reverseString(str) {
  // Type validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  // Handle empty string
  if (str.length === 0) return str;
  
  // Handle single character (optimization)
  if (str.length === 1) return str;
  
  // Use built-in methods for best performance and readability
  return str.split('').reverse().join('');
}

// Comprehensive test suite
try {
  console.log(reverseString('hello'));           // 'olleh'
  console.log(reverseString('JavaScript'));      // 'tpircSavaJ'
  console.log(reverseString(''));                // ''
  console.log(reverseString('a'));               // 'a'
  console.log(reverseString('A man a plan'));    // 'nalp a nam A'
  console.log(reverseString(123));               // TypeError
} catch (error) {
  console.error(error.message);
}
```

**Interview Tips:**
- Start with brute force approach, then optimize
- Mention that strings are immutable in JavaScript
- Discuss trade-offs: readability vs performance
- For production, use `split().reverse().join()` for clarity
- For interviews, two-pointer approach shows algorithm knowledge

</details>

2. Check if a string is a palindrome

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Reverse and Compare (Simple)**
```javascript
/**
 * Check palindrome by reversing string
 * Time Complexity: O(n)
 * Space Complexity: O(n) - creates reversed copy
 * 
 * @param {string} str - Input string
 * @returns {boolean} - True if palindrome
 */
function isPalindrome(str) {
  // Normalize: lowercase and remove non-alphanumeric
  const normalized = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  
  // Compare with reversed version
  const reversed = normalized.split('').reverse().join('');
  
  return normalized === reversed;
}

// Test cases
console.log(isPalindrome('racecar'));              // true
console.log(isPalindrome('hello'));                // false
console.log(isPalindrome('A man a plan a canal Panama')); // true
console.log(isPalindrome('Was it a car or a cat I saw')); // true
console.log(isPalindrome(''));                     // true
```

### **Approach 2: Two-Pointer (Optimized)**
```javascript
/**
 * Check palindrome using two pointers
 * Time Complexity: O(n)
 * Space Complexity: O(1) - only uses pointers
 * 
 * Most efficient approach - stops at first mismatch
 */
function isPalindrome(str) {
  // Normalize string
  const normalized = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  
  let left = 0;
  let right = normalized.length - 1;
  
  // Compare characters from both ends
  while (left < right) {
    if (normalized[left] !== normalized[right]) {
      return false; // Early exit on mismatch
    }
    left++;
    right--;
  }
  
  return true;
}

// Test cases
console.log(isPalindrome('racecar'));              // true
console.log(isPalindrome('hello'));                // false
console.log(isPalindrome('A man a plan a canal Panama')); // true
```

### **Approach 3: Recursive Solution**
```javascript
/**
 * Check palindrome using recursion
 * Time Complexity: O(n)
 * Space Complexity: O(n) - call stack
 */
function isPalindrome(str, left = 0, right = str.length - 1) {
  // Normalize on first call
  if (left === 0 && right === str.length - 1) {
    str = str.toLowerCase().replace(/[^a-z0-9]/g, '');
    right = str.length - 1;
  }
  
  // Base case: pointers met or crossed
  if (left >= right) return true;
  
  // Recursive case: check current chars and recurse
  if (str[left] !== str[right]) return false;
  
  return isPalindrome(str, left + 1, right - 1);
}

// Test cases
console.log(isPalindrome('racecar'));              // true
console.log(isPalindrome('hello'));                // false
```

### **Approach 4: Using Every Method (Functional)**
```javascript
/**
 * Functional approach using array methods
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function isPalindrome(str) {
  const normalized = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  const arr = normalized.split('');
  
  return arr.every((char, index) => {
    return char === arr[arr.length - 1 - index];
  });
}

// Test cases
console.log(isPalindrome('racecar'));              // true
console.log(isPalindrome('hello'));                // false
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready palindrome checker with options
 * 
 * @param {string} str - Input string to check
 * @param {Object} options - Configuration options
 * @param {boolean} options.caseSensitive - Whether to consider case (default: false)
 * @param {boolean} options.ignoreSpaces - Whether to ignore spaces (default: true)
 * @param {boolean} options.alphanumericOnly - Only consider alphanumeric chars (default: true)
 * @returns {boolean} - True if string is palindrome
 */
function isPalindrome(str, options = {}) {
  const {
    caseSensitive = false,
    ignoreSpaces = true,
    alphanumericOnly = true
  } = options;
  
  // Type validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  // Normalize based on options
  let normalized = str;
  
  if (!caseSensitive) {
    normalized = normalized.toLowerCase();
  }
  
  if (alphanumericOnly) {
    normalized = normalized.replace(/[^a-z0-9]/gi, '');
  } else if (ignoreSpaces) {
    normalized = normalized.replace(/\s/g, '');
  }
  
  // Two-pointer check
  let left = 0;
  let right = normalized.length - 1;
  
  while (left < right) {
    if (normalized[left] !== normalized[right]) {
      return false;
    }
    left++;
    right--;
  }
  
  return true;
}

// Comprehensive test suite
console.log(isPalindrome('racecar'));                           // true
console.log(isPalindrome('RaceCar'));                           // true
console.log(isPalindrome('A man a plan a canal Panama'));       // true
console.log(isPalindrome('hello'));                             // false
console.log(isPalindrome('Was it a car or a cat I saw'));       // true
console.log(isPalindrome('Madam'));                             // true
console.log(isPalindrome('12321'));                             // true
console.log(isPalindrome('12345'));                             // false

// With options
console.log(isPalindrome('RaceCar', { caseSensitive: true }));  // false
console.log(isPalindrome('race car', { ignoreSpaces: false })); // false
```

**Interview Tips:**
- Two-pointer is the most efficient (O(1) space)
- Always clarify requirements: case sensitivity, special characters
- Mention early exit optimization
- Show understanding of string normalization
- Discuss Unicode considerations for international characters

</details>

3. Find the largest number in an array

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Loop (Brute Force)**
```javascript
/**
 * Find largest number using traditional loop
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {number[]} arr - Array of numbers
 * @returns {number} - Largest number in array
 */
function findLargest(arr) {
  // Handle edge cases
  if (!arr || arr.length === 0) {
    throw new Error('Array is empty or undefined');
  }
  
  // Initialize with first element
  let largest = arr[0];
  
  // Iterate through array starting from second element
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > largest) {
      largest = arr[i];
    }
  }
  
  return largest;
}

// Test cases
console.log(findLargest([3, 7, 2, 9, 1]));           // 9
console.log(findLargest([1]));                       // 1
console.log(findLargest([-5, -2, -10, -1]));         // -1
console.log(findLargest([100, 50, 200, 75]));        // 200
```

### **Approach 2: Using Math.max with Spread (Clean)**
```javascript
/**
 * Find largest using Math.max
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Most concise approach
 */
function findLargest(arr) {
  if (!arr || arr.length === 0) {
    throw new Error('Array is empty or undefined');
  }
  
  // Spread array into Math.max
  return Math.max(...arr);
}

// Test cases
console.log(findLargest([3, 7, 2, 9, 1]));           // 9
console.log(findLargest([-5, -2, -10, -1]));         // -1
```

### **Approach 3: Using Reduce (Functional)**
```javascript
/**
 * Find largest using array reduce
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Functional programming approach
 */
function findLargest(arr) {
  if (!arr || arr.length === 0) {
    throw new Error('Array is empty or undefined');
  }
  
  return arr.reduce((max, current) => {
    return current > max ? current : max;
  });
}

// Alternative: with initial value
function findLargest(arr) {
  if (!arr || arr.length === 0) {
    throw new Error('Array is empty or undefined');
  }
  
  return arr.reduce((max, current) => Math.max(max, current), arr[0]);
}

// Test cases
console.log(findLargest([3, 7, 2, 9, 1]));           // 9
console.log(findLargest([-5, -2, -10, -1]));         // -1
```

### **Approach 4: Using Sort (Less Efficient)**
```javascript
/**
 * Find largest by sorting
 * Time Complexity: O(n log n) - due to sorting
 * Space Complexity: O(1) or O(n) depending on sort implementation
 * 
 * NOT recommended for just finding max, but useful if sorted array is needed
 */
function findLargest(arr) {
  if (!arr || arr.length === 0) {
    throw new Error('Array is empty or undefined');
  }
  
  // Create copy to avoid mutating original
  const sorted = [...arr].sort((a, b) => b - a);
  
  return sorted[0];
}

// Test cases
console.log(findLargest([3, 7, 2, 9, 1]));           // 9
console.log(findLargest([-5, -2, -10, -1]));         // -1
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready function to find largest number with comprehensive error handling
 * 
 * @param {number[]} arr - Array of numbers
 * @param {Object} options - Configuration options
 * @param {boolean} options.ignoreNaN - Whether to ignore NaN values (default: true)
 * @param {boolean} options.ignoreInfinity - Whether to ignore Infinity (default: false)
 * @returns {number} - Largest number in array
 * @throws {TypeError} - If input is not an array
 * @throws {Error} - If array is empty or has no valid numbers
 */
function findLargest(arr, options = {}) {
  const { ignoreNaN = true, ignoreInfinity = false } = options;
  
  // Type validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  if (arr.length === 0) {
    throw new Error('Array cannot be empty');
  }
  
  // Filter based on options
  let validNumbers = arr.filter(num => {
    if (typeof num !== 'number') return false;
    if (ignoreNaN && Number.isNaN(num)) return false;
    if (ignoreInfinity && !Number.isFinite(num)) return false;
    return true;
  });
  
  if (validNumbers.length === 0) {
    throw new Error('Array contains no valid numbers');
  }
  
  // Use Math.max for best performance and clarity
  return Math.max(...validNumbers);
}

// Comprehensive test suite
console.log(findLargest([3, 7, 2, 9, 1]));                    // 9
console.log(findLargest([-5, -2, -10, -1]));                  // -1
console.log(findLargest([100, 50, 200, 75]));                 // 200
console.log(findLargest([0, -0, 0.1, -0.1]));                 // 0.1
console.log(findLargest([1, NaN, 3], { ignoreNaN: true }));   // 3
console.log(findLargest([1, Infinity], { ignoreInfinity: true })); // 1

// Edge cases
try {
  console.log(findLargest([]));                               // Error
} catch (e) {
  console.error(e.message);
}

try {
  console.log(findLargest([NaN, NaN]));                       // Error
} catch (e) {
  console.error(e.message);
}
```

### **Bonus: Find N Largest Numbers**
```javascript
/**
 * Find N largest numbers in array
 * Time Complexity: O(n log n) for sorting approach
 * Space Complexity: O(n)
 */
function findNLargest(arr, n) {
  if (!Array.isArray(arr) || arr.length === 0) {
    throw new Error('Invalid array');
  }
  
  if (n <= 0) return [];
  if (n >= arr.length) return [...arr].sort((a, b) => b - a);
  
  // Sort in descending order and take first n elements
  return [...arr].sort((a, b) => b - a).slice(0, n);
}

// Test cases
console.log(findNLargest([3, 7, 2, 9, 1, 8, 5], 3));  // [9, 8, 7]
console.log(findNLargest([10, 5, 15, 20], 2));        // [20, 15]
```

**Interview Tips:**
- Math.max with spread is most concise for production
- Mention O(n) vs O(n log n) complexity
- Discuss handling of NaN, Infinity, and mixed types
- For large arrays, discuss memory limitations of spread operator
- Mention that sort mutates array (show array copy technique)

</details>

4. Remove duplicates from an array

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Set (Modern & Efficient)**
```javascript
/**
 * Remove duplicates using ES6 Set
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Best approach for most cases
 * 
 * @param {Array} arr - Input array with potential duplicates
 * @returns {Array} - Array with unique values
 */
function removeDuplicates(arr) {
  // Set automatically removes duplicates
  return [...new Set(arr)];
}

// Alternative using Array.from
function removeDuplicates(arr) {
  return Array.from(new Set(arr));
}

// Test cases
console.log(removeDuplicates([1, 2, 2, 3, 4, 4, 5]));           // [1, 2, 3, 4, 5]
console.log(removeDuplicates(['a', 'b', 'a', 'c']));            // ['a', 'b', 'c']
console.log(removeDuplicates([1, '1', 2, '2']));                // [1, '1', 2, '2'] - maintains types
console.log(removeDuplicates([]));                              // []
```

### **Approach 2: Using Filter with indexOf**
```javascript
/**
 * Remove duplicates using filter
 * Time Complexity: O(n²) - indexOf is O(n) inside filter
 * Space Complexity: O(n)
 * 
 * Works in older browsers without Set support
 */
function removeDuplicates(arr) {
  return arr.filter((item, index) => {
    // Keep item if it's the first occurrence
    return arr.indexOf(item) === index;
  });
}

// Test cases
console.log(removeDuplicates([1, 2, 2, 3, 4, 4, 5]));           // [1, 2, 3, 4, 5]
console.log(removeDuplicates(['a', 'b', 'a', 'c']));            // ['a', 'b', 'c']
```

### **Approach 3: Using Reduce with Object**
```javascript
/**
 * Remove duplicates using reduce with accumulator object
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Good for showing understanding of reduce
 */
function removeDuplicates(arr) {
  return arr.reduce((unique, item) => {
    // Add item if not already in unique array
    return unique.includes(item) ? unique : [...unique, item];
  }, []);
}

// More efficient with object lookup
function removeDuplicates(arr) {
  const seen = {};
  return arr.reduce((unique, item) => {
    if (!seen[item]) {
      seen[item] = true;
      unique.push(item);
    }
    return unique;
  }, []);
}

// Test cases
console.log(removeDuplicates([1, 2, 2, 3, 4, 4, 5]));           // [1, 2, 3, 4, 5]
console.log(removeDuplicates(['a', 'b', 'a', 'c']));            // ['a', 'b', 'c']
```

### **Approach 4: Using Loop with Hash Map (Most Control)**
```javascript
/**
 * Remove duplicates using traditional loop
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Most control over the process
 */
function removeDuplicates(arr) {
  const seen = new Map();
  const result = [];
  
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    
    // Check if we've seen this item before
    if (!seen.has(item)) {
      seen.set(item, true);
      result.push(item);
    }
  }
  
  return result;
}

// Test cases
console.log(removeDuplicates([1, 2, 2, 3, 4, 4, 5]));           // [1, 2, 3, 4, 5]
console.log(removeDuplicates(['a', 'b', 'a', 'c']));            // ['a', 'b', 'c']
```

### **Approach 5: In-Place Removal for Sorted Array**
```javascript
/**
 * Remove duplicates in-place from SORTED array
 * Time Complexity: O(n)
 * Space Complexity: O(1) - modifies array in place
 * 
 * LeetCode-style problem (modify array in place)
 * Returns length of unique portion
 */
function removeDuplicatesInPlace(arr) {
  if (arr.length === 0) return 0;
  
  let writeIndex = 1; // Position to write next unique element
  
  for (let readIndex = 1; readIndex < arr.length; readIndex++) {
    // If current element is different from previous
    if (arr[readIndex] !== arr[readIndex - 1]) {
      arr[writeIndex] = arr[readIndex];
      writeIndex++;
    }
  }
  
  // Truncate array to unique length
  arr.length = writeIndex;
  
  return writeIndex;
}

// Test cases
const arr1 = [1, 1, 2, 2, 3, 4, 4, 5];
const length1 = removeDuplicatesInPlace(arr1);
console.log(arr1, length1);  // [1, 2, 3, 4, 5], 5

const arr2 = [1, 1, 1, 1];
const length2 = removeDuplicatesInPlace(arr2);
console.log(arr2, length2);  // [1], 1
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready duplicate removal with options
 * 
 * @param {Array} arr - Input array
 * @param {Object} options - Configuration options
 * @param {boolean} options.preserveOrder - Maintain original order (default: true)
 * @param {Function} options.comparator - Custom comparison function
 * @param {boolean} options.caseInsensitive - For strings, ignore case (default: false)
 * @returns {Array} - Array with duplicates removed
 */
function removeDuplicates(arr, options = {}) {
  const {
    preserveOrder = true,
    comparator = null,
    caseInsensitive = false
  } = options;
  
  // Type validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  if (arr.length === 0) return [];
  
  // Custom comparator logic
  if (comparator) {
    const result = [];
    for (const item of arr) {
      const isDuplicate = result.some(existing => comparator(existing, item));
      if (!isDuplicate) {
        result.push(item);
      }
    }
    return result;
  }
  
  // Case-insensitive string handling
  if (caseInsensitive && arr.every(item => typeof item === 'string')) {
    const seen = new Set();
    const result = [];
    
    for (const item of arr) {
      const normalized = item.toLowerCase();
      if (!seen.has(normalized)) {
        seen.add(normalized);
        result.push(item); // Keep original case
      }
    }
    return result;
  }
  
  // Default: use Set (fastest and most reliable)
  return [...new Set(arr)];
}

// Comprehensive test suite
console.log(removeDuplicates([1, 2, 2, 3, 4, 4, 5]));
// [1, 2, 3, 4, 5]

console.log(removeDuplicates(['a', 'b', 'A', 'c'], { caseInsensitive: true }));
// ['a', 'b', 'c']

console.log(removeDuplicates(
  [{ id: 1 }, { id: 2 }, { id: 1 }],
  { comparator: (a, b) => a.id === b.id }
));
// [{ id: 1 }, { id: 2 }]

console.log(removeDuplicates([NaN, NaN, 1, 2, 1]));
// [NaN, 1, 2] - Set handles NaN correctly

console.log(removeDuplicates([1, '1', true, 1, 'true']));
// [1, '1', true, 'true'] - maintains types
```

### **Bonus: Remove Duplicates from Array of Objects**
```javascript
/**
 * Remove duplicate objects based on a property
 */
function removeDuplicatesByProperty(arr, property) {
  const seen = new Set();
  return arr.filter(item => {
    const value = item[property];
    if (seen.has(value)) {
      return false;
    }
    seen.add(value);
    return true;
  });
}

// Test
const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
  { id: 1, name: 'John Doe' },
  { id: 3, name: 'Bob' }
];

console.log(removeDuplicatesByProperty(users, 'id'));
// [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }, { id: 3, name: 'Bob' }]
```

**Interview Tips:**
- Set is the modern, preferred approach (O(n) time)
- Mention that Set uses SameValueZero comparison (NaN === NaN)
- Discuss trade-offs: readability vs browser support
- For objects, need custom comparison logic
- In-place solution demonstrates algorithmic thinking
- Mention that order is preserved with Set

</details>

5. Check if two strings are anagrams

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Sort and Compare (Simple)**
```javascript
/**
 * Check anagram by sorting both strings
 * Time Complexity: O(n log n) - dominated by sorting
 * Space Complexity: O(n) - for sorted strings
 * 
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {boolean} - True if strings are anagrams
 */
function isAnagram(str1, str2) {
  // Quick check: different lengths can't be anagrams
  if (str1.length !== str2.length) return false;
  
  // Normalize: lowercase and remove spaces
  const normalize = (str) => 
    str.toLowerCase().replace(/\s/g, '').split('').sort().join('');
  
  return normalize(str1) === normalize(str2);
}

// Test cases
console.log(isAnagram('listen', 'silent'));          // true
console.log(isAnagram('hello', 'world'));            // false
console.log(isAnagram('Dormitory', 'Dirty room'));   // true
console.log(isAnagram('The eyes', 'They see'));      // true
console.log(isAnagram('abc', 'def'));                // false
```

### **Approach 2: Character Frequency Map (Optimized)**
```javascript
/**
 * Check anagram using character frequency counting
 * Time Complexity: O(n)
 * Space Complexity: O(k) where k is unique characters (max 26 for English)
 * 
 * Most efficient approach
 */
function isAnagram(str1, str2) {
  // Early exit: different lengths
  if (str1.length !== str2.length) return false;
  
  // Normalize strings
  str1 = str1.toLowerCase().replace(/\s/g, '');
  str2 = str2.toLowerCase().replace(/\s/g, '');
  
  // Build frequency map for first string
  const charCount = {};
  
  for (const char of str1) {
    charCount[char] = (charCount[char] || 0) + 1;
  }
  
  // Verify second string matches frequencies
  for (const char of str2) {
    if (!charCount[char]) {
      return false; // Character not in first string or count exhausted
    }
    charCount[char]--;
  }
  
  // All counts should be zero
  return Object.values(charCount).every(count => count === 0);
}

// Test cases
console.log(isAnagram('listen', 'silent'));          // true
console.log(isAnagram('hello', 'world'));            // false
console.log(isAnagram('anagram', 'nagaram'));        // true
```

### **Approach 3: Using Map (ES6)**
```javascript
/**
 * Check anagram using ES6 Map
 * Time Complexity: O(n)
 * Space Complexity: O(k)
 * 
 * Modern JavaScript approach
 */
function isAnagram(str1, str2) {
  if (str1.length !== str2.length) return false;
  
  // Normalize
  str1 = str1.toLowerCase().replace(/\s/g, '');
  str2 = str2.toLowerCase().replace(/\s/g, '');
  
  const charMap = new Map();
  
  // Count characters in first string
  for (const char of str1) {
    charMap.set(char, (charMap.get(char) || 0) + 1);
  }
  
  // Decrement counts with second string
  for (const char of str2) {
    if (!charMap.has(char)) return false;
    
    const count = charMap.get(char) - 1;
    if (count === 0) {
      charMap.delete(char);
    } else {
      charMap.set(char, count);
    }
  }
  
  // Map should be empty if anagram
  return charMap.size === 0;
}

// Test cases
console.log(isAnagram('listen', 'silent'));          // true
console.log(isAnagram('hello', 'world'));            // false
```

### **Approach 4: Single Pass with Array (For Lowercase Letters Only)**
```javascript
/**
 * Optimized for lowercase English letters only
 * Time Complexity: O(n)
 * Space Complexity: O(1) - fixed size array of 26
 * 
 * Best performance for English alphabet
 */
function isAnagram(str1, str2) {
  if (str1.length !== str2.length) return false;
  
  // Array to count character frequencies (a-z)
  const counts = new Array(26).fill(0);
  
  str1 = str1.toLowerCase().replace(/\s/g, '');
  str2 = str2.toLowerCase().replace(/\s/g, '');
  
  // Increment for str1, decrement for str2
  for (let i = 0; i < str1.length; i++) {
    counts[str1.charCodeAt(i) - 97]++; // 'a' is 97
    counts[str2.charCodeAt(i) - 97]--;
  }
  
  // All counts should be zero
  return counts.every(count => count === 0);
}

// Test cases
console.log(isAnagram('listen', 'silent'));          // true
console.log(isAnagram('hello', 'world'));            // false
console.log(isAnagram('anagram', 'nagaram'));        // true
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready anagram checker with comprehensive options
 * 
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @param {Object} options - Configuration options
 * @param {boolean} options.caseSensitive - Consider case (default: false)
 * @param {boolean} options.ignoreSpaces - Ignore spaces (default: true)
 * @param {boolean} options.ignoreSpecialChars - Ignore non-alphanumeric (default: true)
 * @returns {boolean} - True if strings are anagrams
 */
function isAnagram(str1, str2, options = {}) {
  const {
    caseSensitive = false,
    ignoreSpaces = true,
    ignoreSpecialChars = true
  } = options;
  
  // Type validation
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both inputs must be strings');
  }
  
  // Normalize strings based on options
  const normalize = (str) => {
    let normalized = str;
    
    if (!caseSensitive) {
      normalized = normalized.toLowerCase();
    }
    
    if (ignoreSpaces) {
      normalized = normalized.replace(/\s/g, '');
    }
    
    if (ignoreSpecialChars) {
      normalized = normalized.replace(/[^a-z0-9]/gi, '');
    }
    
    return normalized;
  };
  
  const normalized1 = normalize(str1);
  const normalized2 = normalize(str2);
  
  // Quick check: different lengths
  if (normalized1.length !== normalized2.length) {
    return false;
  }
  
  // Use frequency map for optimal performance
  const charCount = new Map();
  
  // Count characters in first string
  for (const char of normalized1) {
    charCount.set(char, (charCount.get(char) || 0) + 1);
  }
  
  // Verify with second string
  for (const char of normalized2) {
    const count = charCount.get(char);
    
    if (!count) {
      return false; // Character missing or count exhausted
    }
    
    if (count === 1) {
      charCount.delete(char);
    } else {
      charCount.set(char, count - 1);
    }
  }
  
  return charCount.size === 0;
}

// Comprehensive test suite
console.log(isAnagram('listen', 'silent'));                    // true
console.log(isAnagram('hello', 'world'));                      // false
console.log(isAnagram('Dormitory', 'Dirty room'));             // true
console.log(isAnagram('The eyes', 'They see'));                // true
console.log(isAnagram('astronomer', 'moon starer'));           // true
console.log(isAnagram('abc', 'def'));                          // false

// With options
console.log(isAnagram('Listen', 'Silent', { caseSensitive: true }));  // false
console.log(isAnagram('hello!', 'olleh', { ignoreSpecialChars: false })); // false

// Edge cases
console.log(isAnagram('', ''));                                // true
console.log(isAnagram('a', 'a'));                              // true
console.log(isAnagram('ab', 'ba'));                            // true
```

### **Bonus: Find All Anagrams in String**
```javascript
/**
 * Find all starting indices of anagrams of pattern in string
 * (Sliding Window approach)
 * Time Complexity: O(n) where n is length of string
 */
function findAnagrams(str, pattern) {
  const result = [];
  const patternMap = new Map();
  const windowMap = new Map();
  
  // Build pattern frequency map
  for (const char of pattern) {
    patternMap.set(char, (patternMap.get(char) || 0) + 1);
  }
  
  let left = 0;
  let right = 0;
  let count = patternMap.size; // Unique characters to match
  
  while (right < str.length) {
    // Expand window
    const rightChar = str[right];
    if (patternMap.has(rightChar)) {
      windowMap.set(rightChar, (windowMap.get(rightChar) || 0) + 1);
      if (windowMap.get(rightChar) === patternMap.get(rightChar)) {
        count--;
      }
    }
    right++;
    
    // When all characters matched
    while (count === 0) {
      // Found an anagram
      if (right - left === pattern.length) {
        result.push(left);
      }
      
      // Shrink window
      const leftChar = str[left];
      if (patternMap.has(leftChar)) {
        if (windowMap.get(leftChar) === patternMap.get(leftChar)) {
          count++;
        }
        windowMap.set(leftChar, windowMap.get(leftChar) - 1);
      }
      left++;
    }
  }
  
  return result;
}

// Test
console.log(findAnagrams('cbaebabacd', 'abc'));  // [0, 6] - "cba" and "bac"
console.log(findAnagrams('abab', 'ab'));         // [0, 1, 2] - "ab", "ba", "ab"
```

**Interview Tips:**
- Sorting approach is O(n log n), frequency map is O(n)
- Frequency map is optimal for performance
- Always clarify: case sensitivity, spaces, special characters
- For English alphabet only, can use fixed-size array (26)
- Mention early exit optimization (length check)
- Discuss Unicode considerations for international strings

</details>
6. Find the first non-repeating character in a string

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Two-Pass with Object (Straightforward)**
```javascript
/**
 * Find first non-repeating character using frequency map
 * Time Complexity: O(n) - two passes through string
 * Space Complexity: O(k) - k is unique characters
 * 
 * @param {string} str - Input string
 * @returns {string|null} - First non-repeating character or null
 */
function firstNonRepeating(str) {
  if (!str) return null;
  
  // First pass: count character frequencies
  const charCount = {};
  for (const char of str) {
    charCount[char] = (charCount[char] || 0) + 1;
  }
  
  // Second pass: find first character with count 1
  for (const char of str) {
    if (charCount[char] === 1) {
      return char;
    }
  }
  
  return null; // All characters repeat
}

// Test cases
console.log(firstNonRepeating('leetcode'));      // 'l'
console.log(firstNonRepeating('loveleetcode'));  // 'v'
console.log(firstNonRepeating('aabb'));          // null
console.log(firstNonRepeating(''));              // null
console.log(firstNonRepeating('a'));             // 'a'
```

### **Approach 2: Using Map (ES6)**
```javascript
/**
 * Find first non-repeating character using ES6 Map
 * Time Complexity: O(n)
 * Space Complexity: O(k)
 * 
 * Maintains insertion order naturally
 */
function firstNonRepeating(str) {
  if (!str) return null;
  
  const charMap = new Map();
  
  // Count frequencies
  for (const char of str) {
    charMap.set(char, (charMap.get(char) || 0) + 1);
  }
  
  // Find first with count 1 (Map maintains insertion order)
  for (const [char, count] of charMap) {
    if (count === 1) {
      return char;
    }
  }
  
  return null;
}

// Test cases
console.log(firstNonRepeating('leetcode'));      // 'l'
console.log(firstNonRepeating('loveleetcode'));  // 'v'
console.log(firstNonRepeating('aabb'));          // null
```

### **Approach 3: Using indexOf and lastIndexOf**
```javascript
/**
 * Simple approach using built-in string methods
 * Time Complexity: O(n²) - indexOf/lastIndexOf are O(n)
 * Space Complexity: O(1)
 * 
 * Less efficient but very concise
 */
function firstNonRepeating(str) {
  if (!str) return null;
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    // If first and last occurrence are same, it's unique
    if (str.indexOf(char) === str.lastIndexOf(char)) {
      return char;
    }
  }
  
  return null;
}

// Test cases
console.log(firstNonRepeating('leetcode'));      // 'l'
console.log(firstNonRepeating('loveleetcode'));  // 'v'
console.log(firstNonRepeating('aabb'));          // null
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready first non-repeating character finder
 * 
 * @param {string} str - Input string
 * @param {Object} options - Configuration options
 * @param {boolean} options.caseSensitive - Consider case (default: false)
 * @param {boolean} options.ignoreSpaces - Ignore spaces (default: true)
 * @param {boolean} options.returnIndex - Return index instead of char (default: false)
 * @returns {string|number|null} - First non-repeating character, its index, or null
 */
function firstNonRepeating(str, options = {}) {
  const {
    caseSensitive = false,
    ignoreSpaces = true,
    returnIndex = false
  } = options;
  
  // Type validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  if (str.length === 0) return null;
  
  // Normalize if needed
  let processedStr = str;
  if (!caseSensitive) {
    processedStr = str.toLowerCase();
  }
  
  // Build frequency map with original indices
  const charMap = new Map();
  
  for (let i = 0; i < processedStr.length; i++) {
    const char = processedStr[i];
    
    // Skip spaces if ignoreSpaces is true
    if (ignoreSpaces && char === ' ') continue;
    
    if (charMap.has(char)) {
      charMap.get(char).count++;
    } else {
      charMap.set(char, {
        count: 1,
        originalIndex: i,
        originalChar: str[i] // Keep original case
      });
    }
  }
  
  // Find first non-repeating character
  let result = null;
  let minIndex = Infinity;
  
  for (const [char, data] of charMap) {
    if (data.count === 1 && data.originalIndex < minIndex) {
      minIndex = data.originalIndex;
      result = returnIndex ? data.originalIndex : data.originalChar;
    }
  }
  
  return result;
}

// Comprehensive test suite
console.log(firstNonRepeating('leetcode'));                    // 'l'
console.log(firstNonRepeating('loveleetcode'));                // 'v'
console.log(firstNonRepeating('aabb'));                        // null
console.log(firstNonRepeating(''));                            // null
console.log(firstNonRepeating('AaBbCc', { caseSensitive: true })); // 'A'
console.log(firstNonRepeating('AaBbCc', { caseSensitive: false })); // null
console.log(firstNonRepeating('a b c b a', { ignoreSpaces: true })); // 'c'
console.log(firstNonRepeating('leetcode', { returnIndex: true })); // 0
```

**Interview Tips:**
- Two-pass solution is most straightforward and efficient O(n)
- indexOf/lastIndexOf is simple but O(n²)
- Map maintains insertion order (ES6+)
- Clarify if case matters and how to handle spaces
- Mention that returning null vs empty string vs -1 (index) should be clarified

</details>

7. Merge two sorted arrays

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Two-Pointer Merge (Optimal)**
```javascript
/**
 * Merge two sorted arrays using two-pointer technique
 * Time Complexity: O(n + m) where n, m are array lengths
 * Space Complexity: O(n + m) for result array
 * 
 * Classic merge sort merge step
 * 
 * @param {number[]} arr1 - First sorted array
 * @param {number[]} arr2 - Second sorted array
 * @returns {number[]} - Merged sorted array
 */
function mergeSortedArrays(arr1, arr2) {
  const result = [];
  let i = 0; // Pointer for arr1
  let j = 0; // Pointer for arr2
  
  // Compare elements from both arrays
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] <= arr2[j]) {
      result.push(arr1[i]);
      i++;
    } else {
      result.push(arr2[j]);
      j++;
    }
  }
  
  // Add remaining elements from arr1 (if any)
  while (i < arr1.length) {
    result.push(arr1[i]);
    i++;
  }
  
  // Add remaining elements from arr2 (if any)
  while (j < arr2.length) {
    result.push(arr2[j]);
    j++;
  }
  
  return result;
}

// Test cases
console.log(mergeSortedArrays([1, 3, 5], [2, 4, 6]));
// [1, 2, 3, 4, 5, 6]
```

### **Approach 2: Using Spread and Sort (Simple but Less Efficient)**
```javascript
/**
 * Merge by concatenating and sorting
 * Time Complexity: O((n + m) log(n + m)) - due to sorting
 * Space Complexity: O(n + m)
 */
function mergeSortedArrays(arr1, arr2) {
  return [...arr1, ...arr2].sort((a, b) => a - b);
}
```

**Interview Tips:**
- Two-pointer is optimal: O(n + m) time
- Always handle edge cases: empty arrays
- This is the "merge" step in merge sort

</details>

8. Find the second largest number in an array

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Single Pass (Most Efficient)**
```javascript
/**
 * Find second largest using single pass
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {number[]} arr - Array of numbers
 * @returns {number|null} - Second largest number or null
 */
function findSecondLargest(arr) {
  if (!arr || arr.length < 2) {
    return null;
  }
  
  let largest = -Infinity;
  let secondLargest = -Infinity;
  
  for (const num of arr) {
    if (num > largest) {
      secondLargest = largest;
      largest = num;
    } else if (num > secondLargest && num < largest) {
      secondLargest = num;
    }
  }
  
  return secondLargest === -Infinity ? null : secondLargest;
}

// Test cases
console.log(findSecondLargest([3, 7, 2, 9, 1]));        // 7
console.log(findSecondLargest([5, 5, 5, 5]));           // null
```

### **Approach 2: Using Set to Remove Duplicates**
```javascript
/**
 * Remove duplicates then find second max
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function findSecondLargest(arr) {
  if (!arr || arr.length < 2) return null;
  
  const unique = [...new Set(arr)];
  if (unique.length < 2) return null;
  
  let largest = Math.max(unique[0], unique[1]);
  let secondLargest = Math.min(unique[0], unique[1]);
  
  for (let i = 2; i < unique.length; i++) {
    if (unique[i] > largest) {
      secondLargest = largest;
      largest = unique[i];
    } else if (unique[i] > secondLargest) {
      secondLargest = unique[i];
    }
  }
  
  return secondLargest;
}
```

**Interview Tips:**
- Single-pass solution is optimal: O(n) time, O(1) space
- Clarify if duplicates count (e.g., [5,5,3] - is second largest 5 or 3?)
- Be careful with initialization: use -Infinity

</details>

9. Count the occurrence of each character in a string

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Object (Classic)**
```javascript
/**
 * Count character occurrences using plain object
 * Time Complexity: O(n)
 * Space Complexity: O(k) where k is unique characters
 * 
 * @param {string} str - Input string
 * @returns {Object} - Character frequency map
 */
function countCharacters(str) {
  const charCount = {};
  
  for (const char of str) {
    charCount[char] = (charCount[char] || 0) + 1;
  }
  
  return charCount;
}

// Test cases
console.log(countCharacters('hello'));
// { h: 1, e: 1, l: 2, o: 1 }

console.log(countCharacters('mississippi'));
// { m: 1, i: 4, s: 4, p: 2 }
```

### **Approach 2: Using Map (ES6)**
```javascript
/**
 * Count characters using ES6 Map
 * Time Complexity: O(n)
 * Space Complexity: O(k)
 */
function countCharacters(str) {
  const charMap = new Map();
  
  for (const char of str) {
    charMap.set(char, (charMap.get(char) || 0) + 1);
  }
  
  return charMap;
}

// Test
const result = countCharacters('hello');
console.log(result);
// Map(4) { 'h' => 1, 'e' => 1, 'l' => 2, 'o' => 1 }
```

### **Approach 3: Using Reduce (Functional)**
```javascript
/**
 * Count characters using reduce
 * Time Complexity: O(n)
 * Space Complexity: O(k)
 */
function countCharacters(str) {
  return str.split('').reduce((acc, char) => {
    acc[char] = (acc[char] || 0) + 1;
    return acc;
  }, {});
}
```

**Interview Tips:**
- Object/Map approach is standard: O(n) time, O(k) space
- Map is better for non-string keys and maintains insertion order
- Clarify requirements: case sensitivity, special characters, spaces

</details>

10. Flatten a nested array by one level

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using flat() Method (Modern)**
```javascript
/**
 * Flatten array by one level using built-in flat()
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * ES2019+ feature - simplest approach
 * 
 * @param {Array} arr - Nested array
 * @returns {Array} - Flattened array
 */
function flattenOneLevel(arr) {
  return arr.flat(1); // 1 is default depth
}

// Test cases
console.log(flattenOneLevel([1, [2, 3], 4, [5, 6]]));
// [1, 2, 3, 4, 5, 6]

console.log(flattenOneLevel([1, [2, [3, 4]], 5]));
// [1, 2, [3, 4], 5] - only one level flattened
```

### **Approach 2: Using concat() with Spread**
```javascript
/**
 * Flatten using concat and spread operator
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Works in ES6+
 */
function flattenOneLevel(arr) {
  return [].concat(...arr);
}

// Test cases
console.log(flattenOneLevel([1, [2, 3], 4, [5, 6]]));
// [1, 2, 3, 4, 5, 6]
```

### **Approach 3: Using reduce() (Functional)**
```javascript
/**
 * Flatten using reduce
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function flattenOneLevel(arr) {
  return arr.reduce((flattened, item) => {
    return Array.isArray(item)
      ? [...flattened, ...item]
      : [...flattened, item];
  }, []);
}

// More efficient: using concat
function flattenOneLevel(arr) {
  return arr.reduce((flattened, item) => {
    return flattened.concat(item);
  }, []);
}
```

### **Approach 4: Manual Loop**
```javascript
/**
 * Flatten using traditional loop
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function flattenOneLevel(arr) {
  const result = [];
  
  for (const item of arr) {
    if (Array.isArray(item)) {
      for (const subItem of item) {
        result.push(subItem);
      }
    } else {
      result.push(item);
    }
  }
  
  return result;
}
```

### **Bonus: Flatten Completely (Any Depth)**
```javascript
/**
 * Flatten array to any depth recursively
 */
function flattenDeep(arr) {
  return arr.reduce((flattened, item) => {
    return Array.isArray(item)
      ? [...flattened, ...flattenDeep(item)]
      : [...flattened, item];
  }, []);
}

// Using flat with Infinity
function flattenDeep(arr) {
  return arr.flat(Infinity);
}

// Test
console.log(flattenDeep([1, [2, [3, [4, [5]]]]]));
// [1, 2, 3, 4, 5]
```

**Interview Tips:**
- `arr.flat()` is the modern, simplest approach (ES2019+)
- `[].concat(...arr)` works in ES6+ for one level
- For multiple levels, can use `arr.flat(depth)` or recursion
- Manual loop gives most control and works everywhere

</details>

### **Basic Algorithms**

11. Implement FizzBuzz (print numbers 1-100, "Fizz" for multiples of 3, "Buzz" for multiples of 5, "FizzBuzz" for both)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Classic If-Else Chain**
```javascript
/**
 * FizzBuzz using if-else statements
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {number} n - Upper limit (default: 100)
 * @returns {void} - Prints results to console
 */
function fizzBuzz(n = 100) {
  for (let i = 1; i <= n; i++) {
    if (i % 15 === 0) {
      console.log('FizzBuzz');
    } else if (i % 3 === 0) {
      console.log('Fizz');
    } else if (i % 5 === 0) {
      console.log('Buzz');
    } else {
      console.log(i);
    }
  }
}

// Test
fizzBuzz(15);
// 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz
```

### **Approach 2: String Concatenation (Cleaner)**
```javascript
/**
 * FizzBuzz using string building
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * More maintainable for additional rules
 */
function fizzBuzz(n = 100) {
  for (let i = 1; i <= n; i++) {
    let output = '';
    
    if (i % 3 === 0) output += 'Fizz';
    if (i % 5 === 0) output += 'Buzz';
    
    console.log(output || i);
  }
}

// Test
fizzBuzz(15);
```

### **Approach 3: Array Map (Functional)**
```javascript
/**
 * FizzBuzz using functional approach
 * Time Complexity: O(n)
 * Space Complexity: O(n) - stores results
 */
function fizzBuzz(n = 100) {
  return Array.from({ length: n }, (_, i) => {
    const num = i + 1;
    let result = '';
    
    if (num % 3 === 0) result += 'Fizz';
    if (num % 5 === 0) result += 'Buzz';
    
    return result || num;
  });
}

// Test
console.log(fizzBuzz(15));
// [1, 2, 'Fizz', 4, 'Buzz', 'Fizz', 7, 8, 'Fizz', 'Buzz', 11, 'Fizz', 13, 14, 'FizzBuzz']
```

### **Approach 4: Lookup Object (Scalable)**
```javascript
/**
 * FizzBuzz using object lookup
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Easy to extend with more rules
 */
function fizzBuzz(n = 100, rules = { 3: 'Fizz', 5: 'Buzz' }) {
  for (let i = 1; i <= n; i++) {
    let output = '';
    
    for (const [divisor, word] of Object.entries(rules)) {
      if (i % divisor === 0) output += word;
    }
    
    console.log(output || i);
  }
}

// Test with custom rules
fizzBuzz(20, { 3: 'Fizz', 5: 'Buzz', 7: 'Bang' });
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready FizzBuzz with validation and options
 * 
 * @param {number} start - Starting number (default: 1)
 * @param {number} end - Ending number (default: 100)
 * @param {Object} rules - Custom rules { divisor: word }
 * @param {boolean} returnArray - Return array instead of printing
 * @returns {Array|void}
 */
function fizzBuzz(start = 1, end = 100, options = {}) {
  const {
    rules = { 3: 'Fizz', 5: 'Buzz' },
    returnArray = false
  } = options;
  
  // Validation
  if (typeof start !== 'number' || typeof end !== 'number') {
    throw new TypeError('Start and end must be numbers');
  }
  
  if (start > end) {
    throw new RangeError('Start must be less than or equal to end');
  }
  
  // Convert rules to sorted array for consistent order
  const sortedRules = Object.entries(rules)
    .map(([divisor, word]) => [Number(divisor), word])
    .sort((a, b) => a[0] - b[0]);
  
  const results = [];
  
  for (let i = start; i <= end; i++) {
    let output = '';
    
    for (const [divisor, word] of sortedRules) {
      if (i % divisor === 0) {
        output += word;
      }
    }
    
    const result = output || i;
    
    if (returnArray) {
      results.push(result);
    } else {
      console.log(result);
    }
  }
  
  return returnArray ? results : undefined;
}

// Comprehensive test suite
console.log('=== Standard FizzBuzz ===');
fizzBuzz(1, 15);

console.log('\n=== Custom Range ===');
fizzBuzz(10, 20);

console.log('\n=== Custom Rules ===');
fizzBuzz(1, 20, { rules: { 2: 'Even', 3: 'Three', 7: 'Lucky' } });

console.log('\n=== Return Array ===');
const result = fizzBuzz(1, 15, { returnArray: true });
console.log(result);

// Edge cases
console.log('\n=== Single Number ===');
fizzBuzz(15, 15);

console.log('\n=== Large Numbers ===');
fizzBuzz(1000, 1015);
```

### **Bonus: FizzBuzz Variations**
```javascript
/**
 * FizzBuzzBazz with three rules
 */
function fizzBuzzBazz(n) {
  for (let i = 1; i <= n; i++) {
    let output = '';
    if (i % 3 === 0) output += 'Fizz';
    if (i % 5 === 0) output += 'Buzz';
    if (i % 7 === 0) output += 'Bazz';
    console.log(output || i);
  }
}

/**
 * Reverse FizzBuzz (countdown)
 */
function reverseFizzBuzz(n = 100) {
  for (let i = n; i >= 1; i--) {
    let output = '';
    if (i % 3 === 0) output += 'Fizz';
    if (i % 5 === 0) output += 'Buzz';
    console.log(output || i);
  }
}

/**
 * FizzBuzz as a generator
 */
function* fizzBuzzGenerator(start = 1, end = 100) {
  for (let i = start; i <= end; i++) {
    let output = '';
    if (i % 3 === 0) output += 'Fizz';
    if (i % 5 === 0) output += 'Buzz';
    yield output || i;
  }
}

// Use generator
for (const value of fizzBuzzGenerator(1, 15)) {
  console.log(value);
}
```

**Interview Tips:**
- Check divisibility by 15 first (or build string) to avoid wrong "Fizz" or "Buzz" only
- String concatenation approach is more maintainable
- Mention that % operator checks divisibility
- Discuss how to extend with more rules (object lookup)
- Can optimize by checking smaller divisor first

</details>

12. Check if a number is prime

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Trial Division**
```javascript
/**
 * Check if number is prime using basic trial division
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {number} num - Number to check
 * @returns {boolean} - True if prime
 */
function isPrime(num) {
  // Handle edge cases
  if (num <= 1) return false;
  if (num <= 3) return true;
  
  // Check divisibility from 2 to num-1
  for (let i = 2; i < num; i++) {
    if (num % i === 0) {
      return false;
    }
  }
  
  return true;
}

// Test cases
console.log(isPrime(2));    // true
console.log(isPrime(17));   // true
console.log(isPrime(4));    // false
console.log(isPrime(1));    // false
console.log(isPrime(0));    // false
```

### **Approach 2: Optimized to √n (Efficient)**
```javascript
/**
 * Check prime by testing up to square root
 * Time Complexity: O(√n)
 * Space Complexity: O(1)
 * 
 * Most efficient basic approach
 */
function isPrime(num) {
  if (num <= 1) return false;
  if (num <= 3) return true;
  
  // Eliminate even numbers and multiples of 3
  if (num % 2 === 0 || num % 3 === 0) return false;
  
  // Check odd divisors up to √n
  for (let i = 2; i * i <= num; i++) {
    if (num % i === 0) {
      return false;
    }
  }
  
  return true;
}

// Test cases
console.log(isPrime(29));   // true
console.log(isPrime(100));  // false
console.log(isPrime(97));   // true
```

### **Approach 3: 6k ± 1 Optimization**
```javascript
/**
 * Optimized prime check using 6k ± 1 pattern
 * Time Complexity: O(√n)
 * Space Complexity: O(1)
 * 
 * All primes > 3 are of form 6k ± 1
 */
function isPrime(num) {
  if (num <= 1) return false;
  if (num <= 3) return true;
  if (num % 2 === 0 || num % 3 === 0) return false;
  
  // Check numbers of form 6k ± 1 up to √n
  let i = 5;
  while (i * i <= num) {
    if (num % i === 0 || num % (i + 2) === 0) {
      return false;
    }
    i += 6;
  }
  
  return true;
}

// Test cases
console.log(isPrime(101));  // true
console.log(isPrime(103));  // true
console.log(isPrime(104));  // false
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready prime checker with validation
 * 
 * @param {number} num - Number to check
 * @returns {boolean} - True if prime
 * @throws {TypeError} - If input is not a number
 */
function isPrime(num) {
  // Validation
  if (typeof num !== 'number' || !Number.isFinite(num)) {
    throw new TypeError('Input must be a finite number');
  }
  
  // Handle non-integers
  if (!Number.isInteger(num)) {
    return false;
  }
  
  // Handle negative numbers and 0, 1
  if (num <= 1) return false;
  if (num === 2) return true;
  if (num === 3) return true;
  
  // Eliminate even numbers
  if (num % 2 === 0) return false;
  
  // Eliminate multiples of 3
  if (num % 3 === 0) return false;
  
  // Check using 6k ± 1 optimization
  let i = 5;
  while (i * i <= num) {
    if (num % i === 0 || num % (i + 2) === 0) {
      return false;
    }
    i += 6;
  }
  
  return true;
}

// Comprehensive test suite
console.log(isPrime(2));      // true - smallest prime
console.log(isPrime(3));      // true
console.log(isPrime(17));     // true
console.log(isPrime(29));     // true
console.log(isPrime(97));     // true
console.log(isPrime(4));      // false
console.log(isPrime(1));      // false
console.log(isPrime(0));      // false
console.log(isPrime(-5));     // false
console.log(isPrime(100));    // false
console.log(isPrime(1009));   // true - large prime

// Edge cases
console.log(isPrime(2.5));    // false - not integer
console.log(isPrime(Infinity)); // TypeError
```

### **Bonus: Find All Primes Up to N (Sieve of Eratosthenes)**
```javascript
/**
 * Find all prime numbers up to n
 * Time Complexity: O(n log log n)
 * Space Complexity: O(n)
 * 
 * Most efficient for finding multiple primes
 */
function sieveOfEratosthenes(n) {
  if (n < 2) return [];
  
  // Create boolean array, initially all true
  const isPrime = new Array(n + 1).fill(true);
  isPrime[0] = isPrime[1] = false;
  
  // Sieve process
  for (let i = 2; i * i <= n; i++) {
    if (isPrime[i]) {
      // Mark all multiples as not prime
      for (let j = i * i; j <= n; j += i) {
        isPrime[j] = false;
      }
    }
  }
  
  // Collect all primes
  const primes = [];
  for (let i = 2; i <= n; i++) {
    if (isPrime[i]) primes.push(i);
  }
  
  return primes;
}

// Test
console.log(sieveOfEratosthenes(30));
// [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

console.log(sieveOfEratosthenes(100).length);
// 25 primes under 100
```

**Interview Tips:**
- Basic approach is O(n), optimized is O(√n)
- Only need to check up to √n because factors come in pairs
- Eliminate even numbers and multiples of 3 first
- 6k ± 1 optimization is fastest for single number check
- For finding many primes, use Sieve of Eratosthenes
- Handle edge cases: 0, 1, negative numbers, non-integers

</details>

13. Calculate factorial of a number (iterative and recursive)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Iterative (Space Efficient)**
```javascript
/**
 * Calculate factorial using iteration
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {number} n - Non-negative integer
 * @returns {number} - Factorial of n
 */
function factorial(n) {
  if (n < 0) {
    throw new Error('Factorial not defined for negative numbers');
  }
  
  if (n === 0 || n === 1) return 1;
  
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  
  return result;
}

// Test cases
console.log(factorial(0));   // 1
console.log(factorial(1));   // 1
console.log(factorial(5));   // 120
console.log(factorial(10));  // 3628800
```

### **Approach 2: Recursive (Classic)**
```javascript
/**
 * Calculate factorial using recursion
 * Time Complexity: O(n)
 * Space Complexity: O(n) - call stack
 * 
 * Classic recursive approach
 */
function factorial(n) {
  // Base cases
  if (n < 0) {
    throw new Error('Factorial not defined for negative numbers');
  }
  
  if (n === 0 || n === 1) return 1;
  
  // Recursive case
  return n * factorial(n - 1);
}

// Test cases
console.log(factorial(5));   // 120
console.log(factorial(6));   // 720
```

### **Approach 3: Tail Recursion (Optimized Recursive)**
```javascript
/**
 * Calculate factorial using tail recursion
 * Time Complexity: O(n)
 * Space Complexity: O(1) in languages with TCO, O(n) in JavaScript
 * 
 * Can be optimized by compilers with tail call optimization
 */
function factorial(n, accumulator = 1) {
  if (n < 0) {
    throw new Error('Factorial not defined for negative numbers');
  }
  
  if (n === 0 || n === 1) return accumulator;
  
  return factorial(n - 1, n * accumulator);
}

// Test cases
console.log(factorial(5));   // 120
console.log(factorial(7));   // 5040
```

### **Approach 4: Using Reduce (Functional)**
```javascript
/**
 * Calculate factorial using reduce
 * Time Complexity: O(n)
 * Space Complexity: O(n) - array creation
 */
function factorial(n) {
  if (n < 0) {
    throw new Error('Factorial not defined for negative numbers');
  }
  
  if (n === 0 || n === 1) return 1;
  
  return Array.from({ length: n }, (_, i) => i + 1)
    .reduce((product, num) => product * num, 1);
}

// Test cases
console.log(factorial(5));   // 120
console.log(factorial(4));   // 24
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready factorial with caching and validation
 * 
 * @param {number} n - Non-negative integer
 * @returns {number|bigint} - Factorial of n
 */
function factorial(n) {
  // Validation
  if (typeof n !== 'number' || !Number.isInteger(n)) {
    throw new TypeError('Input must be an integer');
  }
  
  if (n < 0) {
    throw new RangeError('Factorial not defined for negative numbers');
  }
  
  // Handle base cases
  if (n === 0 || n === 1) return 1;
  
  // For large numbers, use BigInt to avoid overflow
  if (n > 20) {
    return factorialBigInt(n);
  }
  
  // Iterative calculation
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  
  return result;
}

/**
 * Factorial using BigInt for large numbers
 */
function factorialBigInt(n) {
  let result = 1n;
  for (let i = 2n; i <= BigInt(n); i++) {
    result *= i;
  }
  return result;
}

// Comprehensive test suite
console.log(factorial(0));      // 1
console.log(factorial(1));      // 1
console.log(factorial(5));      // 120
console.log(factorial(10));     // 3628800
console.log(factorial(20));     // 2432902008176640000
console.log(factorial(25));     // BigInt (prevents overflow)

// Edge cases
try {
  console.log(factorial(-5));   // Error
} catch (e) {
  console.error(e.message);
}

try {
  console.log(factorial(3.5));  // Error
} catch (e) {
  console.error(e.message);
}
```

### **Bonus: Memoized Factorial (Performance)**
```javascript
/**
 * Factorial with memoization for repeated calls
 */
const factorialMemoized = (() => {
  const cache = { 0: 1, 1: 1 };
  
  return function factorial(n) {
    if (n < 0) {
      throw new Error('Factorial not defined for negative numbers');
    }
    
    if (cache[n] !== undefined) {
      return cache[n];
    }
    
    cache[n] = n * factorial(n - 1);
    return cache[n];
  };
})();

// Test - second call uses cache
console.log(factorialMemoized(10));  // Calculates
console.log(factorialMemoized(10));  // Returns cached
console.log(factorialMemoized(11));  // Only calculates 11, reuses 10!
```

### **Bonus: Calculate nPr and nCr**
```javascript
/**
 * Permutation: nPr = n! / (n-r)!
 */
function permutation(n, r) {
  if (r > n) return 0;
  
  let result = 1;
  for (let i = n; i > n - r; i--) {
    result *= i;
  }
  return result;
}

/**
 * Combination: nCr = n! / (r! * (n-r)!)
 */
function combination(n, r) {
  if (r > n) return 0;
  if (r === 0 || r === n) return 1;
  
  // Optimize by using smaller r
  r = Math.min(r, n - r);
  
  let result = 1;
  for (let i = 0; i < r; i++) {
    result *= (n - i);
    result /= (i + 1);
  }
  
  return Math.round(result);
}

// Test
console.log(permutation(5, 3));  // 60 (5P3)
console.log(combination(5, 3));  // 10 (5C3)
```

**Interview Tips:**
- Iterative is more space-efficient: O(1) vs O(n)
- Recursive is more intuitive but uses call stack
- JavaScript numbers overflow after 20! (use BigInt)
- Tail recursion optimization not guaranteed in JavaScript
- Memoization improves performance for repeated calls
- Always validate input: negative numbers, non-integers

</details>

14. Find the sum of all numbers in an array

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Loop (Basic)**
```javascript
/**
 * Sum array elements using for loop
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {number[]} arr - Array of numbers
 * @returns {number} - Sum of all elements
 */
function sumArray(arr) {
  let sum = 0;
  
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
  }
  
  return sum;
}

// Test cases
console.log(sumArray([1, 2, 3, 4, 5]));        // 15
console.log(sumArray([10, 20, 30]));           // 60
console.log(sumArray([]));                     // 0
console.log(sumArray([-1, -2, -3]));           // -6
```

### **Approach 2: Using reduce() (Functional)**
```javascript
/**
 * Sum array elements using reduce
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Most concise and idiomatic
 */
function sumArray(arr) {
  return arr.reduce((sum, num) => sum + num, 0);
}

// Test cases
console.log(sumArray([1, 2, 3, 4, 5]));        // 15
console.log(sumArray([100, 200, 300]));        // 600
```

### **Approach 3: Using for...of (Modern)**
```javascript
/**
 * Sum array elements using for...of
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Clean and readable
 */
function sumArray(arr) {
  let sum = 0;
  
  for (const num of arr) {
    sum += num;
  }
  
  return sum;
}

// Test cases
console.log(sumArray([1, 2, 3, 4, 5]));        // 15
console.log(sumArray([5, 10, 15]));            // 30
```

### **Approach 4: Recursive**
```javascript
/**
 * Sum array elements recursively
 * Time Complexity: O(n)
 * Space Complexity: O(n) - call stack
 */
function sumArray(arr) {
  // Base case
  if (arr.length === 0) return 0;
  
  // Recursive case
  return arr[0] + sumArray(arr.slice(1));
}

// More efficient with index
function sumArray(arr, index = 0) {
  if (index >= arr.length) return 0;
  return arr[index] + sumArray(arr, index + 1);
}

// Test cases
console.log(sumArray([1, 2, 3, 4, 5]));        // 15
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready sum with validation and options
 * 
 * @param {number[]} arr - Array of numbers
 * @param {Object} options - Configuration options
 * @param {boolean} options.ignoreNaN - Skip NaN values (default: true)
 * @param {boolean} options.absolute - Sum absolute values (default: false)
 * @returns {number} - Sum of array elements
 */
function sumArray(arr, options = {}) {
  const { ignoreNaN = true, absolute = false } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  let sum = 0;
  
  for (const value of arr) {
    // Type check
    if (typeof value !== 'number') {
      continue; // Skip non-numbers
    }
    
    // Handle NaN
    if (Number.isNaN(value)) {
      if (ignoreNaN) continue;
      return NaN;
    }
    
    // Handle Infinity
    if (!Number.isFinite(value)) {
      return value; // Return Infinity/-Infinity
    }
    
    // Add to sum
    sum += absolute ? Math.abs(value) : value;
  }
  
  return sum;
}

// Comprehensive test suite
console.log(sumArray([1, 2, 3, 4, 5]));                    // 15
console.log(sumArray([10, 20, 30, 40]));                   // 100
console.log(sumArray([]));                                 // 0
console.log(sumArray([-1, -2, -3]));                       // -6
console.log(sumArray([-1, -2, -3], { absolute: true }));   // 6
console.log(sumArray([1, NaN, 3]));                        // 4 (ignores NaN)
console.log(sumArray([1, NaN, 3], { ignoreNaN: false }));  // NaN
console.log(sumArray([1, 'a', 3]));                        // 4 (skips non-numbers)
console.log(sumArray([1, 2, Infinity]));                   // Infinity

// Edge cases
console.log(sumArray([0, 0, 0]));                          // 0
console.log(sumArray([1.5, 2.5, 3.5]));                    // 7.5
console.log(sumArray([-10, 10]));                          // 0
```

### **Bonus: Sum with Condition**
```javascript
/**
 * Sum array elements that meet a condition
 */
function sumWhere(arr, predicate) {
  return arr.reduce((sum, num) => {
    return predicate(num) ? sum + num : sum;
  }, 0);
}

// Examples
console.log(sumWhere([1, 2, 3, 4, 5], num => num % 2 === 0));
// 6 (sum of even numbers: 2 + 4)

console.log(sumWhere([1, 2, 3, 4, 5], num => num > 2));
// 12 (sum of numbers > 2: 3 + 4 + 5)

console.log(sumWhere([-5, -2, 0, 3, 7], num => num > 0));
// 10 (sum of positive numbers: 3 + 7)
```

### **Bonus: Cumulative Sum**
```javascript
/**
 * Calculate cumulative sum array
 */
function cumulativeSum(arr) {
  const result = [];
  let sum = 0;
  
  for (const num of arr) {
    sum += num;
    result.push(sum);
  }
  
  return result;
}

// Using reduce
function cumulativeSum(arr) {
  return arr.reduce((acc, num, i) => {
    const sum = i === 0 ? num : acc[i - 1] + num;
    return [...acc, sum];
  }, []);
}

// Test
console.log(cumulativeSum([1, 2, 3, 4, 5]));
// [1, 3, 6, 10, 15]

console.log(cumulativeSum([10, 20, 30]));
// [10, 30, 60]
```

**Interview Tips:**
- reduce() is the most idiomatic JavaScript solution
- Always handle empty array case (return 0)
- Consider edge cases: NaN, Infinity, mixed types
- For large arrays, simple loop is most performant
- Mention floating point precision issues for decimals
- Can optimize with parallel processing for very large arrays

</details>

15. Check if a number is even or odd

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Modulo Operator (Standard)**
```javascript
/**
 * Check if number is even using modulo
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * @param {number} num - Number to check
 * @returns {boolean} - True if even
 */
function isEven(num) {
  return num % 2 === 0;
}

function isOdd(num) {
  return num % 2 !== 0;
}

// Test cases
console.log(isEven(4));     // true
console.log(isEven(5));     // false
console.log(isOdd(7));      // true
console.log(isOdd(10));     // false
```

### **Approach 2: Using Bitwise AND (Performance)**
```javascript
/**
 * Check if even using bitwise operation
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Faster than modulo for integers
 */
function isEven(num) {
  return (num & 1) === 0;
}

function isOdd(num) {
  return (num & 1) === 1;
}

// Test cases
console.log(isEven(8));     // true
console.log(isEven(9));     // false
console.log(isOdd(11));     // true
```

### **Approach 3: Using Math.abs for Negative Numbers**
```javascript
/**
 * Handle negative numbers properly
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 */
function isEven(num) {
  return Math.abs(num) % 2 === 0;
}

function isOdd(num) {
  return Math.abs(num) % 2 === 1;
}

// Test cases
console.log(isEven(-4));    // true
console.log(isEven(-5));    // false
console.log(isOdd(-7));     // true
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready even/odd checker with validation
 * 
 * @param {number} num - Number to check
 * @returns {string} - 'even', 'odd', or 'neither' for non-integers
 */
function checkEvenOdd(num) {
  // Validation
  if (typeof num !== 'number' || !Number.isFinite(num)) {
    throw new TypeError('Input must be a finite number');
  }
  
  // Handle non-integers
  if (!Number.isInteger(num)) {
    return 'neither';
  }
  
  // Check even/odd
  return num % 2 === 0 ? 'even' : 'odd';
}

// Alternative: return boolean
function isEven(num) {
  if (typeof num !== 'number' || !Number.isFinite(num)) {
    throw new TypeError('Input must be a finite number');
  }
  
  if (!Number.isInteger(num)) {
    throw new Error('Input must be an integer');
  }
  
  return num % 2 === 0;
}

// Comprehensive test suite
console.log(checkEvenOdd(4));      // 'even'
console.log(checkEvenOdd(7));      // 'odd'
console.log(checkEvenOdd(-6));     // 'even'
console.log(checkEvenOdd(-3));     // 'odd'
console.log(checkEvenOdd(0));      // 'even'
console.log(checkEvenOdd(3.5));    // 'neither'

// Edge cases
console.log(checkEvenOdd(1000000)); // 'even'
console.log(checkEvenOdd(-999999)); // 'odd'
```

### **Bonus: Filter Even/Odd from Array**
```javascript
/**
 * Filter even or odd numbers from array
 */
function filterEven(arr) {
  return arr.filter(num => num % 2 === 0);
}

function filterOdd(arr) {
  return arr.filter(num => num % 2 !== 0);
}

// Test
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log(filterEven(numbers));  // [2, 4, 6, 8, 10]
console.log(filterOdd(numbers));   // [1, 3, 5, 7, 9]

/**
 * Partition array into even and odd
 */
function partitionEvenOdd(arr) {
  const even = [];
  const odd = [];
  
  for (const num of arr) {
    if (num % 2 === 0) {
      even.push(num);
    } else {
      odd.push(num);
    }
  }
  
  return { even, odd };
}

// Test
console.log(partitionEvenOdd([1, 2, 3, 4, 5, 6]));
// { even: [2, 4, 6], odd: [1, 3, 5] }
```

**Interview Tips:**
- Modulo (%) is standard and most readable
- Bitwise AND (&1) is faster but less clear
- Remember: 0 is even
- Negative numbers: -4 is even, -5 is odd
- For non-integers, clarify requirements
- Mention that % can give negative results with negative numbers

</details>

16. Convert Celsius to Fahrenheit

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Conversion Formula**
```javascript
/**
 * Convert Celsius to Fahrenheit
 * Formula: F = (C × 9/5) + 32
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * @param {number} celsius - Temperature in Celsius
 * @returns {number} - Temperature in Fahrenheit
 */
function celsiusToFahrenheit(celsius) {
  return (celsius * 9/5) + 32;
}

// Test cases
console.log(celsiusToFahrenheit(0));      // 32
console.log(celsiusToFahrenheit(100));    // 212
console.log(celsiusToFahrenheit(-40));    // -40
console.log(celsiusToFahrenheit(37));     // 98.6
```

### **Approach 2: Alternative Formula (1.8 multiplier)**
```javascript
/**
 * Using 1.8 instead of 9/5 for clarity
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 */
function celsiusToFahrenheit(celsius) {
  return (celsius * 1.8) + 32;
}

// Test cases
console.log(celsiusToFahrenheit(25));     // 77
console.log(celsiusToFahrenheit(-10));    // 14
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready temperature converter with validation
 * 
 * @param {number} celsius - Temperature in Celsius
 * @param {Object} options - Configuration options
 * @param {number} options.decimals - Decimal places (default: 2)
 * @returns {number} - Temperature in Fahrenheit
 */
function celsiusToFahrenheit(celsius, options = {}) {
  const { decimals = 2 } = options;
  
  // Validation
  if (typeof celsius !== 'number' || !Number.isFinite(celsius)) {
    throw new TypeError('Input must be a finite number');
  }
  
  // Check absolute zero
  if (celsius < -273.15) {
    throw new RangeError('Temperature cannot be below absolute zero (-273.15°C)');
  }
  
  // Convert
  const fahrenheit = (celsius * 9/5) + 32;
  
  // Round to specified decimal places
  return Number(fahrenheit.toFixed(decimals));
}

// Reverse conversion
function fahrenheitToCelsius(fahrenheit, options = {}) {
  const { decimals = 2 } = options;
  
  if (typeof fahrenheit !== 'number' || !Number.isFinite(fahrenheit)) {
    throw new TypeError('Input must be a finite number');
  }
  
  if (fahrenheit < -459.67) {
    throw new RangeError('Temperature cannot be below absolute zero (-459.67°F)');
  }
  
  const celsius = (fahrenheit - 32) * 5/9;
  return Number(celsius.toFixed(decimals));
}

// Comprehensive test suite
console.log(celsiusToFahrenheit(0));          // 32
console.log(celsiusToFahrenheit(100));        // 212
console.log(celsiusToFahrenheit(-40));        // -40 (same in both)
console.log(celsiusToFahrenheit(37));         // 98.6
console.log(celsiusToFahrenheit(25));         // 77

console.log(fahrenheitToCelsius(32));         // 0
console.log(fahrenheitToCelsius(212));        // 100
console.log(fahrenheitToCelsius(98.6));       // 37

// With custom decimals
console.log(celsiusToFahrenheit(25.5555, { decimals: 4 }));  // 77.9999

// Edge cases
console.log(celsiusToFahrenheit(-273.15));    // -459.67 (absolute zero)
```

### **Bonus: Multi-Unit Temperature Converter**
```javascript
/**
 * Convert between Celsius, Fahrenheit, and Kelvin
 */
class TemperatureConverter {
  static celsiusToFahrenheit(c) {
    return (c * 9/5) + 32;
  }
  
  static celsiusToKelvin(c) {
    return c + 273.15;
  }
  
  static fahrenheitToCelsius(f) {
    return (f - 32) * 5/9;
  }
  
  static fahrenheitToKelvin(f) {
    return this.celsiusToKelvin(this.fahrenheitToCelsius(f));
  }
  
  static kelvinToCelsius(k) {
    return k - 273.15;
  }
  
  static kelvinToFahrenheit(k) {
    return this.celsiusToFahrenheit(this.kelvinToCelsius(k));
  }
  
  static convert(value, from, to) {
    const converters = {
      'C-F': this.celsiusToFahrenheit,
      'C-K': this.celsiusToKelvin,
      'F-C': this.fahrenheitToCelsius,
      'F-K': this.fahrenheitToKelvin,
      'K-C': this.kelvinToCelsius,
      'K-F': this.kelvinToFahrenheit
    };
    
    const key = `${from}-${to}`;
    
    if (from === to) return value;
    
    const converter = converters[key];
    if (!converter) {
      throw new Error(`Invalid conversion: ${from} to ${to}`);
    }
    
    return Number(converter.call(this, value).toFixed(2));
  }
}

// Test
console.log(TemperatureConverter.convert(0, 'C', 'F'));    // 32
console.log(TemperatureConverter.convert(100, 'C', 'K'));  // 373.15
console.log(TemperatureConverter.convert(32, 'F', 'C'));   // 0
console.log(TemperatureConverter.convert(300, 'K', 'C'));  // 26.85
```

**Interview Tips:**
- Formula: F = (C × 9/5) + 32 or F = (C × 1.8) + 32
- Reverse: C = (F - 32) × 5/9
- -40°C = -40°F (same in both scales)
- Absolute zero: -273.15°C = -459.67°F = 0K
- Consider rounding for display purposes

</details>

17. Generate Fibonacci sequence up to n terms

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Iterative (Most Efficient)**
```javascript
/**
 * Generate Fibonacci sequence using iteration
 * Time Complexity: O(n)
 * Space Complexity: O(n) - for result array
 * 
 * @param {number} n - Number of terms
 * @returns {number[]} - Fibonacci sequence
 */
function fibonacci(n) {
  if (n <= 0) return [];
  if (n === 1) return [0];
  if (n === 2) return [0, 1];
  
  const fib = [0, 1];
  
  for (let i = 2; i < n; i++) {
    fib[i] = fib[i - 1] + fib[i - 2];
  }
  
  return fib;
}

// Test cases
console.log(fibonacci(10));
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

console.log(fibonacci(5));
// [0, 1, 1, 2, 3]
```

### **Approach 2: Recursive (Classic but Inefficient)**
```javascript
/**
 * Generate Fibonacci using recursion
 * Time Complexity: O(2^n) - exponential, very slow
 * Space Complexity: O(n) - call stack
 * 
 * Not recommended for production
 */
function fibonacci(n) {
  // Helper function to calculate nth Fibonacci number
  function fib(num) {
    if (num <= 1) return num;
    return fib(num - 1) + fib(num - 2);
  }
  
  const result = [];
  for (let i = 0; i < n; i++) {
    result.push(fib(i));
  }
  
  return result;
}

// Test - slow for large n
console.log(fibonacci(10));
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### **Approach 3: Memoized Recursion (Optimized)**
```javascript
/**
 * Fibonacci with memoization
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function fibonacci(n) {
  const memo = {};
  
  function fib(num) {
    if (num <= 1) return num;
    
    if (memo[num]) return memo[num];
    
    memo[num] = fib(num - 1) + fib(num - 2);
    return memo[num];
  }
  
  const result = [];
  for (let i = 0; i < n; i++) {
    result.push(fib(i));
  }
  
  return result;
}

// Test
console.log(fibonacci(15));
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]
```

### **Approach 4: Using Generator**
```javascript
/**
 * Fibonacci generator for lazy evaluation
 * Time Complexity: O(1) per next()
 * Space Complexity: O(1)
 * 
 * Memory efficient for large sequences
 */
function* fibonacciGenerator() {
  let [prev, curr] = [0, 1];
  
  yield prev;
  yield curr;
  
  while (true) {
    [prev, curr] = [curr, prev + curr];
    yield curr;
  }
}

// Usage
function fibonacci(n) {
  const result = [];
  const gen = fibonacciGenerator();
  
  for (let i = 0; i < n; i++) {
    result.push(gen.next().value);
  }
  
  return result;
}

// Test
console.log(fibonacci(10));
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready Fibonacci generator
 * 
 * @param {number} n - Number of terms
 * @param {Object} options - Configuration options
 * @param {boolean} options.useBigInt - Use BigInt for large numbers (default: false)
 * @returns {Array} - Fibonacci sequence
 */
function fibonacci(n, options = {}) {
  const { useBigInt = false } = options;
  
  // Validation
  if (typeof n !== 'number' || !Number.isInteger(n)) {
    throw new TypeError('Input must be an integer');
  }
  
  if (n < 0) {
    throw new RangeError('Input must be non-negative');
  }
  
  if (n === 0) return [];
  if (n === 1) return useBigInt ? [0n] : [0];
  if (n === 2) return useBigInt ? [0n, 1n] : [0, 1];
  
  if (useBigInt) {
    const fib = [0n, 1n];
    for (let i = 2; i < n; i++) {
      fib[i] = fib[i - 1] + fib[i - 2];
    }
    return fib;
  } else {
    const fib = [0, 1];
    for (let i = 2; i < n; i++) {
      fib[i] = fib[i - 1] + fib[i - 2];
    }
    return fib;
  }
}

// Get nth Fibonacci number
function getNthFibonacci(n, useBigInt = false) {
  if (n < 0) throw new RangeError('Input must be non-negative');
  if (n === 0) return useBigInt ? 0n : 0;
  if (n === 1) return useBigInt ? 1n : 1;
  
  if (useBigInt) {
    let [prev, curr] = [0n, 1n];
    for (let i = 2; i <= n; i++) {
      [prev, curr] = [curr, prev + curr];
    }
    return curr;
  } else {
    let [prev, curr] = [0, 1];
    for (let i = 2; i <= n; i++) {
      [prev, curr] = [curr, prev + curr];
    }
    return curr;
  }
}

// Comprehensive test suite
console.log(fibonacci(10));
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

console.log(fibonacci(0));   // []
console.log(fibonacci(1));   // [0]
console.log(fibonacci(2));   // [0, 1]

// Large numbers with BigInt
console.log(fibonacci(100, { useBigInt: true }));

console.log(getNthFibonacci(10));      // 55
console.log(getNthFibonacci(50, true)); // BigInt for large numbers
```

### **Bonus: Fibonacci Up to Maximum Value**
```javascript
/**
 * Generate Fibonacci numbers up to a maximum value
 */
function fibonacciUpTo(max) {
  if (max < 0) return [];
  
  const fib = [0];
  if (max === 0) return fib;
  
  fib.push(1);
  
  while (true) {
    const next = fib[fib.length - 1] + fib[fib.length - 2];
    if (next > max) break;
    fib.push(next);
  }
  
  return fib;
}

// Test
console.log(fibonacciUpTo(100));
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

console.log(fibonacciUpTo(1000));
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]
```

**Interview Tips:**
- Iterative is most efficient: O(n) time and space
- Recursive without memoization is O(2^n) - exponential
- Memoization reduces recursive to O(n)
- Generator is memory-efficient for large sequences
- For n > 78, use BigInt to avoid overflow
- Sequence starts: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...

</details>

18. Find the missing number in an array of 1 to n

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Sum Formula (Optimal)**
```javascript
/**
 * Find missing number using mathematical formula
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Formula: Sum of 1 to n = n(n+1)/2
 * Missing = Expected Sum - Actual Sum
 * 
 * @param {number[]} arr - Array of numbers from 1 to n with one missing
 * @returns {number} - Missing number
 */
function findMissingNumber(arr) {
  const n = arr.length + 1; // Original length
  const expectedSum = (n * (n + 1)) / 2;
  const actualSum = arr.reduce((sum, num) => sum + num, 0);
  
  return expectedSum - actualSum;
}

// Test cases
console.log(findMissingNumber([1, 2, 3, 5]));        // 4
console.log(findMissingNumber([1, 2, 4, 5, 6]));     // 3
console.log(findMissingNumber([2, 3, 4, 5]));        // 1
```

### **Approach 2: Using XOR (Bit Manipulation)**
```javascript
/**
 * Find missing number using XOR
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * XOR properties: a ^ a = 0, a ^ 0 = a
 * XOR all numbers 1 to n and all array elements
 * Everything cancels except missing number
 */
function findMissingNumber(arr) {
  const n = arr.length + 1;
  let xor = 0;
  
  // XOR with all numbers from 1 to n
  for (let i = 1; i <= n; i++) {
    xor ^= i;
  }
  
  // XOR with all array elements
  for (const num of arr) {
    xor ^= num;
  }
  
  return xor;
}

// Test cases
console.log(findMissingNumber([1, 2, 3, 5]));        // 4
console.log(findMissingNumber([1, 2, 4, 5, 6]));     // 3
```

### **Approach 3: Using Set (Simple)**
```javascript
/**
 * Find missing number using Set
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Create set, check which number is missing
 */
function findMissingNumber(arr) {
  const n = arr.length + 1;
  const numSet = new Set(arr);
  
  for (let i = 1; i <= n; i++) {
    if (!numSet.has(i)) {
      return i;
    }
  }
  
  return -1; // Should never reach here
}

// Test cases
console.log(findMissingNumber([1, 2, 3, 5]));        // 4
console.log(findMissingNumber([3, 4, 5, 6, 7]));     // 1 or 2 (depends on range)
```

### **Approach 4: Sort and Find Gap**
```javascript
/**
 * Find missing by sorting and looking for gap
 * Time Complexity: O(n log n) - due to sorting
 * Space Complexity: O(1) or O(n) depending on sort
 * 
 * Less efficient but intuitive
 */
function findMissingNumber(arr) {
  arr.sort((a, b) => a - b);
  
  for (let i = 0; i < arr.length; i++) {
    // Expected number at position i (assuming starts at 1)
    const expected = arr[0] + i;
    
    if (arr[i] !== expected) {
      return expected;
    }
  }
  
  // Missing is at the end
  return arr[arr.length - 1] + 1;
}

// Test cases
console.log(findMissingNumber([1, 2, 3, 5]));        // 4
console.log(findMissingNumber([2, 3, 4, 5]));        // 1 (if starts at 1)
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready missing number finder
 * 
 * @param {number[]} arr - Array with one missing number
 * @param {Object} options - Configuration options
 * @param {number} options.start - Starting number (default: 1)
 * @returns {number} - Missing number
 */
function findMissingNumber(arr, options = {}) {
  const { start = 1 } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  if (arr.length === 0) {
    return start;
  }
  
  // Calculate range
  const n = arr.length + 1;
  const end = start + n - 1;
  
  // Expected sum: sum of arithmetic sequence
  const expectedSum = (n * (start + end)) / 2;
  
  // Actual sum
  const actualSum = arr.reduce((sum, num) => sum + num, 0);
  
  return expectedSum - actualSum;
}

// Comprehensive test suite
console.log(findMissingNumber([1, 2, 3, 5]));              // 4
console.log(findMissingNumber([1, 2, 4, 5, 6]));           // 3
console.log(findMissingNumber([2, 3, 4, 5]));              // 1 or 6
console.log(findMissingNumber([10, 11, 13, 14], { start: 10 })); // 12

// Edge cases
console.log(findMissingNumber([2]));                       // 1
console.log(findMissingNumber([1]));                       // 2
console.log(findMissingNumber([1, 3]));                    // 2
```

### **Bonus: Find All Missing Numbers**
```javascript
/**
 * Find all missing numbers in array
 */
function findAllMissingNumbers(arr, n) {
  const numSet = new Set(arr);
  const missing = [];
  
  for (let i = 1; i <= n; i++) {
    if (!numSet.has(i)) {
      missing.push(i);
    }
  }
  
  return missing;
}

// Using cyclic sort approach (modify array in place)
function findAllMissingNumbers(arr) {
  const n = arr.length;
  
  // Place each number at its correct index
  let i = 0;
  while (i < n) {
    const correctIndex = arr[i] - 1;
    
    if (arr[i] > 0 && arr[i] <= n && arr[i] !== arr[correctIndex]) {
      // Swap
      [arr[i], arr[correctIndex]] = [arr[correctIndex], arr[i]];
    } else {
      i++;
    }
  }
  
  // Find missing numbers
  const missing = [];
  for (let i = 0; i < n; i++) {
    if (arr[i] !== i + 1) {
      missing.push(i + 1);
    }
  }
  
  return missing;
}

// Test
console.log(findAllMissingNumbers([1, 2, 4, 6], 6));
// [3, 5]

console.log(findAllMissingNumbers([4, 3, 2, 7, 8, 2, 3, 1]));
// [5, 6] - using cyclic sort
```

**Interview Tips:**
- Sum formula is optimal: O(n) time, O(1) space
- XOR is clever and doesn't risk integer overflow
- Set approach is simple but uses O(n) space
- Clarify: does sequence start at 0 or 1?
- Clarify: is only one number missing?
- For large numbers, sum formula might overflow (use XOR or BigInt)
- Cyclic sort is elegant for finding multiple missing numbers

</details>

19. Swap two variables without using a third variable

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Destructuring (Modern & Recommended)**
```javascript
/**
 * Swap variables using ES6 destructuring
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Cleanest and most readable approach
 */
function swap() {
  let a = 5;
  let b = 10;
  
  console.log('Before:', a, b);  // 5, 10
  
  [a, b] = [b, a];
  
  console.log('After:', a, b);   // 10, 5
  
  return [a, b];
}

swap();
```

### **Approach 2: Arithmetic (Addition/Subtraction)**
```javascript
/**
 * Swap using arithmetic operations
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Works for numbers only
 * Risk: potential overflow for very large numbers
 */
function swap(a, b) {
  console.log('Before:', a, b);
  
  a = a + b;  // a now contains sum
  b = a - b;  // b now contains original a
  a = a - b;  // a now contains original b
  
  console.log('After:', a, b);
  return [a, b];
}

swap(5, 10);   // 10, 5
swap(100, 200); // 200, 100
```

### **Approach 3: Arithmetic (Multiplication/Division)**
```javascript
/**
 * Swap using multiplication and division
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Risk: doesn't work if either number is 0
 * Risk: potential overflow/precision loss
 */
function swap(a, b) {
  if (a === 0 || b === 0) {
    throw new Error('Cannot use with zero values');
  }
  
  console.log('Before:', a, b);
  
  a = a * b;  // a now contains product
  b = a / b;  // b now contains original a
  a = a / b;  // a now contains original b
  
  console.log('After:', a, b);
  return [a, b];
}

swap(5, 10);    // 10, 5
swap(3, 7);     // 7, 3
```

### **Approach 4: XOR (Bit Manipulation)**
```javascript
/**
 * Swap using XOR bitwise operation
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Works for integers without overflow risk
 * XOR properties: a ^ a = 0, a ^ 0 = a
 */
function swap(a, b) {
  console.log('Before:', a, b);
  
  a = a ^ b;  // a now contains XOR of both
  b = a ^ b;  // b = (a ^ b) ^ b = a
  a = a ^ b;  // a = (a ^ b) ^ a = b
  
  console.log('After:', a, b);
  return [a, b];
}

swap(5, 10);    // 10, 5
swap(15, 30);   // 30, 15
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready variable swap with multiple methods
 * 
 * @param {*} a - First value
 * @param {*} b - Second value
 * @param {string} method - Swap method ('destructuring', 'arithmetic', 'xor')
 * @returns {Array} - [b, a]
 */
function swap(a, b, method = 'destructuring') {
  switch (method) {
    case 'destructuring':
      // Modern, works with any type
      [a, b] = [b, a];
      break;
      
    case 'arithmetic':
      // Only for numbers
      if (typeof a !== 'number' || typeof b !== 'number') {
        throw new TypeError('Arithmetic method requires numbers');
      }
      a = a + b;
      b = a - b;
      a = a - b;
      break;
      
    case 'xor':
      // Only for integers
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        throw new TypeError('XOR method requires integers');
      }
      a = a ^ b;
      b = a ^ b;
      a = a ^ b;
      break;
      
    default:
      throw new Error(`Unknown method: ${method}`);
  }
  
  return [a, b];
}

// Comprehensive test suite
console.log('=== Destructuring (Default) ===');
console.log(swap(5, 10));                    // [10, 5]
console.log(swap('hello', 'world'));         // ['world', 'hello']
console.log(swap([1, 2], [3, 4]));          // [[3, 4], [1, 2]]

console.log('\n=== Arithmetic ===');
console.log(swap(5, 10, 'arithmetic'));      // [10, 5]
console.log(swap(-5, 15, 'arithmetic'));     // [15, -5]

console.log('\n=== XOR ===');
console.log(swap(5, 10, 'xor'));            // [10, 5]
console.log(swap(100, 200, 'xor'));         // [200, 100]

// Edge cases
console.log(swap(0, 5));                     // [5, 0]
console.log(swap(-10, -20));                 // [-20, -10]
```

### **Bonus: Swap Array Elements**
```javascript
/**
 * Swap two elements in an array
 */
function swapArrayElements(arr, i, j) {
  // Validation
  if (i < 0 || i >= arr.length || j < 0 || j >= arr.length) {
    throw new RangeError('Index out of bounds');
  }
  
  // Using destructuring
  [arr[i], arr[j]] = [arr[j], arr[i]];
  
  return arr;
}

// Test
const numbers = [1, 2, 3, 4, 5];
swapArrayElements(numbers, 0, 4);
console.log(numbers);  // [5, 2, 3, 4, 1]

/**
 * Swap object properties
 */
function swapObjectProps(obj, key1, key2) {
  [obj[key1], obj[key2]] = [obj[key2], obj[key1]];
  return obj;
}

// Test
const person = { name: 'John', age: 30 };
swapObjectProps(person, 'name', 'age');
console.log(person);  // { name: 30, age: 'John' }
```

### **Performance Comparison**
```javascript
/**
 * Compare performance of different swap methods
 */
function benchmarkSwap() {
  const iterations = 1000000;
  
  console.time('Destructuring');
  for (let i = 0; i < iterations; i++) {
    let a = 5, b = 10;
    [a, b] = [b, a];
  }
  console.timeEnd('Destructuring');
  
  console.time('Arithmetic');
  for (let i = 0; i < iterations; i++) {
    let a = 5, b = 10;
    a = a + b;
    b = a - b;
    a = a - b;
  }
  console.timeEnd('Arithmetic');
  
  console.time('XOR');
  for (let i = 0; i < iterations; i++) {
    let a = 5, b = 10;
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
  }
  console.timeEnd('XOR');
}

benchmarkSwap();
```

**Interview Tips:**
- Destructuring is the modern, recommended approach
- Works with any data type
- Arithmetic methods only work with numbers
- XOR is clever but only for integers
- Arithmetic risks overflow with large numbers
- XOR is fastest for integers
- Always prefer readability over cleverness in production

</details>

20. Check if a year is a leap year

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Modulo (Standard Algorithm)**
```javascript
/**
 * Check if year is a leap year
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Rules:
 * 1. Divisible by 4 AND
 * 2. (Not divisible by 100 OR divisible by 400)
 * 
 * @param {number} year - Year to check
 * @returns {boolean} - True if leap year
 */
function isLeapYear(year) {
  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

// Test cases
console.log(isLeapYear(2000));   // true (divisible by 400)
console.log(isLeapYear(2020));   // true (divisible by 4, not by 100)
console.log(isLeapYear(1900));   // false (divisible by 100, not by 400)
console.log(isLeapYear(2021));   // false (not divisible by 4)
```

### **Approach 2: Step-by-Step Logic**
```javascript
/**
 * Leap year check with explicit steps
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * More readable version
 */
function isLeapYear(year) {
  // Step 1: If divisible by 400, it's a leap year
  if (year % 400 === 0) {
    return true;
  }
  
  // Step 2: If divisible by 100 (but not 400), it's not a leap year
  if (year % 100 === 0) {
    return false;
  }
  
  // Step 3: If divisible by 4 (but not 100), it's a leap year
  if (year % 4 === 0) {
    return true;
  }
  
  // Step 4: Otherwise, it's not a leap year
  return false;
}

// Test cases
console.log(isLeapYear(2024));   // true
console.log(isLeapYear(2023));   // false
console.log(isLeapYear(2100));   // false
console.log(isLeapYear(2400));   // true
```

### **Approach 3: Using Date Object**
```javascript
/**
 * Check leap year using JavaScript Date
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Leverages built-in calendar logic
 * February has 29 days in leap years
 */
function isLeapYear(year) {
  // Create date for Feb 29 of given year
  const feb29 = new Date(year, 1, 29);
  
  // If it's still Feb (month 1), then Feb 29 exists
  return feb29.getMonth() === 1;
}

// Alternative: check days in February
function isLeapYear(year) {
  // Last day of February (month 1)
  const lastDayOfFeb = new Date(year, 2, 0);
  return lastDayOfFeb.getDate() === 29;
}

// Test cases
console.log(isLeapYear(2020));   // true
console.log(isLeapYear(2021));   // false
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready leap year checker with validation
 * 
 * @param {number} year - Year to check
 * @returns {boolean} - True if leap year
 * @throws {TypeError} - If year is not a number
 * @throws {RangeError} - If year is out of valid range
 */
function isLeapYear(year) {
  // Validation
  if (typeof year !== 'number' || !Number.isInteger(year)) {
    throw new TypeError('Year must be an integer');
  }
  
  // Reasonable year range (Gregorian calendar started in 1582)
  if (year < 1582) {
    throw new RangeError('Year must be 1582 or later (Gregorian calendar)');
  }
  
  // Leap year algorithm
  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

// Get leap years in a range
function getLeapYears(startYear, endYear) {
  if (startYear > endYear) {
    throw new RangeError('Start year must be <= end year');
  }
  
  const leapYears = [];
  
  for (let year = startYear; year <= endYear; year++) {
    if (isLeapYear(year)) {
      leapYears.push(year);
    }
  }
  
  return leapYears;
}

// Comprehensive test suite
console.log('=== Leap Years ===');
console.log(isLeapYear(2000));   // true
console.log(isLeapYear(2004));   // true
console.log(isLeapYear(2020));   // true
console.log(isLeapYear(2024));   // true

console.log('\n=== Not Leap Years ===');
console.log(isLeapYear(1900));   // false
console.log(isLeapYear(2001));   // false
console.log(isLeapYear(2021));   // false
console.log(isLeapYear(2100));   // false

console.log('\n=== Leap Years 2020-2040 ===');
console.log(getLeapYears(2020, 2040));
// [2020, 2024, 2028, 2032, 2036, 2040]

// Edge cases
console.log('\n=== Edge Cases ===');
console.log(isLeapYear(2400));   // true
console.log(isLeapYear(1600));   // true
```

### **Bonus: Days in Month**
```javascript
/**
 * Get number of days in a month
 */
function daysInMonth(year, month) {
  // month is 1-12
  const daysInMonths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  
  if (month < 1 || month > 12) {
    throw new RangeError('Month must be between 1 and 12');
  }
  
  // Check if February and leap year
  if (month === 2 && isLeapYear(year)) {
    return 29;
  }
  
  return daysInMonths[month - 1];
}

// Using Date object (more reliable)
function daysInMonth(year, month) {
  // Last day of the month
  return new Date(year, month, 0).getDate();
}

// Test
console.log(daysInMonth(2020, 2));   // 29 (Feb in leap year)
console.log(daysInMonth(2021, 2));   // 28 (Feb in non-leap year)
console.log(daysInMonth(2020, 1));   // 31 (January)
console.log(daysInMonth(2020, 4));   // 30 (April)
```

### **Bonus: Next/Previous Leap Year**
```javascript
/**
 * Find next leap year
 */
function nextLeapYear(year) {
  let next = year + 1;
  while (!isLeapYear(next)) {
    next++;
  }
  return next;
}

/**
 * Find previous leap year
 */
function previousLeapYear(year) {
  let prev = year - 1;
  while (!isLeapYear(prev) && prev >= 1582) {
    prev--;
  }
  return prev >= 1582 ? prev : null;
}

// Test
console.log(nextLeapYear(2021));      // 2024
console.log(nextLeapYear(2020));      // 2024
console.log(previousLeapYear(2021));  // 2020
console.log(previousLeapYear(2020));  // 2016
```

**Interview Tips:**
- Standard algorithm: divisible by 4, except centuries unless divisible by 400
- Remember: year 2000 was leap, 1900 was not, 2100 will not be
- Gregorian calendar rule: most simple and correct approach
- Date object method works but less explicit
- Leap year occurs every 4 years, except every 100 years, except every 400 years
- Examples: 2000, 2004, 2008, 2012, 2016, 2020, 2024 are leap years
- 1900, 2100, 2200, 2300 are NOT leap years (divisible by 100 but not 400)

</details>

### **Objects & Basic Operations**

21. Count properties in an object

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Object.keys()**
```javascript
/**
 * Count properties in an object
 * Time Complexity: O(n) where n is number of properties
 * Space Complexity: O(n) for keys array
 * 
 * Only counts own enumerable properties
 * 
 * @param {Object} obj - Object to count
 * @returns {number} - Number of properties
 */
function countProperties(obj) {
  return Object.keys(obj).length;
}

// Test cases
const person = { name: 'John', age: 30, city: 'NYC' };
console.log(countProperties(person));  // 3

const empty = {};
console.log(countProperties(empty));   // 0
```

### **Approach 2: Using for...in Loop**
```javascript
/**
 * Count properties using for...in
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Counts own enumerable properties
 */
function countProperties(obj) {
  let count = 0;
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      count++;
    }
  }
  
  return count;
}

// Test
const car = { brand: 'Toyota', model: 'Camry', year: 2020 };
console.log(countProperties(car));  // 3
```

### **Approach 3: Using Object.getOwnPropertyNames()**
```javascript
/**
 * Count all own properties (including non-enumerable)
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function countAllProperties(obj) {
  return Object.getOwnPropertyNames(obj).length;
}

// Test with non-enumerable property
const obj = { a: 1, b: 2 };
Object.defineProperty(obj, 'c', {
  value: 3,
  enumerable: false
});

console.log(Object.keys(obj).length);              // 2 (enumerable only)
console.log(countAllProperties(obj));              // 3 (includes non-enumerable)
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready property counter with options
 * 
 * @param {Object} obj - Object to count
 * @param {Object} options - Configuration options
 * @param {boolean} options.includeInherited - Include inherited properties (default: false)
 * @param {boolean} options.includeNonEnumerable - Include non-enumerable (default: false)
 * @param {boolean} options.includeSymbols - Include symbol properties (default: false)
 * @returns {number} - Number of properties
 */
function countProperties(obj, options = {}) {
  const {
    includeInherited = false,
    includeNonEnumerable = false,
    includeSymbols = false
  } = options;
  
  // Validation
  if (obj === null || obj === undefined) {
    return 0;
  }
  
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    return 0;
  }
  
  let count = 0;
  
  if (includeNonEnumerable) {
    // Count all own properties
    count = Object.getOwnPropertyNames(obj).length;
  } else {
    // Count only enumerable own properties
    count = Object.keys(obj).length;
  }
  
  // Add symbol properties if requested
  if (includeSymbols) {
    count += Object.getOwnPropertySymbols(obj).length;
  }
  
  // Add inherited properties if requested
  if (includeInherited) {
    let proto = Object.getPrototypeOf(obj);
    
    while (proto && proto !== Object.prototype) {
      if (includeNonEnumerable) {
        count += Object.getOwnPropertyNames(proto).length;
      } else {
        count += Object.keys(proto).length;
      }
      
      if (includeSymbols) {
        count += Object.getOwnPropertySymbols(proto).length;
      }
      
      proto = Object.getPrototypeOf(proto);
    }
  }
  
  return count;
}

// Comprehensive test suite
const person = {
  name: 'John',
  age: 30,
  city: 'NYC'
};

console.log('=== Basic Count ===');
console.log(countProperties(person));  // 3

// With non-enumerable property
Object.defineProperty(person, 'id', {
  value: 123,
  enumerable: false
});

console.log('\n=== With Non-Enumerable ===');
console.log(countProperties(person));  // 3 (default)
console.log(countProperties(person, { includeNonEnumerable: true }));  // 4

// With symbols
const sym = Symbol('secret');
person[sym] = 'hidden';

console.log('\n=== With Symbols ===');
console.log(countProperties(person));  // 3
console.log(countProperties(person, { includeSymbols: true }));  // 4
console.log(countProperties(person, { 
  includeNonEnumerable: true, 
  includeSymbols: true 
}));  // 5

// With inheritance
class Animal {
  constructor() {
    this.type = 'animal';
  }
}

class Dog extends Animal {
  constructor() {
    super();
    this.breed = 'Labrador';
  }
}

const dog = new Dog();

console.log('\n=== With Inheritance ===');
console.log(countProperties(dog));  // 2 (own properties only)
console.log(countProperties(dog, { includeInherited: true }));  // More

// Edge cases
console.log('\n=== Edge Cases ===');
console.log(countProperties(null));       // 0
console.log(countProperties(undefined));  // 0
console.log(countProperties({}));         // 0
console.log(countProperties([]));         // 0
```

### **Bonus: Property Statistics**
```javascript
/**
 * Get detailed property statistics
 */
function getPropertyStats(obj) {
  if (obj === null || obj === undefined) {
    return {
      total: 0,
      enumerable: 0,
      nonEnumerable: 0,
      symbols: 0,
      inherited: 0
    };
  }
  
  const stats = {
    total: 0,
    enumerable: Object.keys(obj).length,
    nonEnumerable: 0,
    symbols: Object.getOwnPropertySymbols(obj).length,
    inherited: 0
  };
  
  stats.nonEnumerable = Object.getOwnPropertyNames(obj).length - stats.enumerable;
  stats.total = stats.enumerable + stats.nonEnumerable + stats.symbols;
  
  // Count inherited
  let proto = Object.getPrototypeOf(obj);
  while (proto && proto !== Object.prototype) {
    stats.inherited += Object.getOwnPropertyNames(proto).length;
    stats.inherited += Object.getOwnPropertySymbols(proto).length;
    proto = Object.getPrototypeOf(proto);
  }
  
  return stats;
}

// Test
const testObj = { a: 1, b: 2 };
Object.defineProperty(testObj, 'c', { value: 3, enumerable: false });
testObj[Symbol('test')] = 'symbol';

console.log(getPropertyStats(testObj));
// { total: 4, enumerable: 2, nonEnumerable: 1, symbols: 1, inherited: ... }
```

**Interview Tips:**
- Object.keys() is the most common and returns enumerable own properties
- Object.getOwnPropertyNames() includes non-enumerable properties
- Object.getOwnPropertySymbols() for symbol properties
- for...in loops through enumerable properties (including inherited)
- Always use hasOwnProperty() when using for...in to check own properties
- Clarify: do you need inherited properties? Non-enumerable? Symbols?

</details>

22. Deep clone an object

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using JSON Methods (Simple)**
```javascript
/**
 * Deep clone using JSON
 * Time Complexity: O(n) where n is number of properties
 * Space Complexity: O(n)
 * 
 * Limitations:
 * - Doesn't handle functions, undefined, symbols, dates
 * - Loses prototypes
 * - Circular references cause error
 * 
 * @param {Object} obj - Object to clone
 * @returns {Object} - Deep cloned object
 */
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// Test cases
const original = {
  name: 'John',
  age: 30,
  address: {
    city: 'NYC',
    country: 'USA'
  },
  hobbies: ['reading', 'coding']
};

const cloned = deepClone(original);
cloned.address.city = 'LA';

console.log(original.address.city);  // 'NYC' (unchanged)
console.log(cloned.address.city);    // 'LA'
```

### **Approach 2: Recursive Deep Clone**
```javascript
/**
 * Recursive deep clone
 * Time Complexity: O(n)
 * Space Complexity: O(d) where d is depth (call stack)
 * 
 * Handles most data types
 */
function deepClone(obj) {
  // Handle null and primitives
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // Handle Date
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // Handle Array
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item));
  }
  
  // Handle Object
  const clonedObj = {};
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      clonedObj[key] = deepClone(obj[key]);
    }
  }
  
  return clonedObj;
}

// Test
const data = {
  name: 'John',
  date: new Date(),
  nested: {
    arr: [1, 2, { deep: 'value' }]
  }
};

const copy = deepClone(data);
copy.nested.arr[2].deep = 'modified';

console.log(data.nested.arr[2].deep);    // 'value'
console.log(copy.nested.arr[2].deep);    // 'modified'
```

### **Approach 3: Using structuredClone() (Modern)**
```javascript
/**
 * Deep clone using built-in structuredClone (Node 17+, modern browsers)
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Handles: Date, RegExp, Map, Set, ArrayBuffer, etc.
 * Handles circular references
 * Cannot clone functions
 */
function deepClone(obj) {
  return structuredClone(obj);
}

// Test
const obj = {
  date: new Date(),
  regex: /test/gi,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3])
};

// Circular reference
obj.self = obj;

const cloned = deepClone(obj);
console.log(cloned.date instanceof Date);    // true
console.log(cloned.regex instanceof RegExp); // true
console.log(cloned.map instanceof Map);      // true
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready deep clone with circular reference handling
 * 
 * @param {*} obj - Value to clone
 * @param {WeakMap} hash - Track circular references
 * @returns {*} - Deep cloned value
 */
function deepClone(obj, hash = new WeakMap()) {
  // Primitives and null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // Check for circular reference
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // Handle Date
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // Handle RegExp
  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags);
  }
  
  // Handle Map
  if (obj instanceof Map) {
    const clonedMap = new Map();
    hash.set(obj, clonedMap);
    
    obj.forEach((value, key) => {
      clonedMap.set(key, deepClone(value, hash));
    });
    
    return clonedMap;
  }
  
  // Handle Set
  if (obj instanceof Set) {
    const clonedSet = new Set();
    hash.set(obj, clonedSet);
    
    obj.forEach(value => {
      clonedSet.add(deepClone(value, hash));
    });
    
    return clonedSet;
  }
  
  // Handle Array
  if (Array.isArray(obj)) {
    const clonedArr = [];
    hash.set(obj, clonedArr);
    
    obj.forEach((item, index) => {
      clonedArr[index] = deepClone(item, hash);
    });
    
    return clonedArr;
  }
  
  // Handle Object
  // Preserve prototype
  const clonedObj = Object.create(Object.getPrototypeOf(obj));
  hash.set(obj, clonedObj);
  
  // Clone all own properties (including non-enumerable)
  Object.getOwnPropertyNames(obj).forEach(key => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, key);
    
    if (descriptor.value !== undefined) {
      descriptor.value = deepClone(descriptor.value, hash);
    }
    
    Object.defineProperty(clonedObj, key, descriptor);
  });
  
  // Clone symbol properties
  Object.getOwnPropertySymbols(obj).forEach(sym => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    
    if (descriptor.value !== undefined) {
      descriptor.value = deepClone(descriptor.value, hash);
    }
    
    Object.defineProperty(clonedObj, sym, descriptor);
  });
  
  return clonedObj;
}

// Comprehensive test suite
console.log('=== Basic Objects ===');
const person = {
  name: 'John',
  age: 30,
  address: {
    city: 'NYC',
    zip: 10001
  }
};

const clonedPerson = deepClone(person);
clonedPerson.address.city = 'LA';

console.log(person.address.city);        // 'NYC'
console.log(clonedPerson.address.city);  // 'LA'

console.log('\n=== Arrays ===');
const arr = [1, [2, 3], { a: 4 }];
const clonedArr = deepClone(arr);
clonedArr[1][0] = 999;
clonedArr[2].a = 888;

console.log(arr[1][0]);      // 2
console.log(arr[2].a);       // 4
console.log(clonedArr[1][0]); // 999
console.log(clonedArr[2].a);  // 888

console.log('\n=== Special Objects ===');
const special = {
  date: new Date('2024-01-01'),
  regex: /test/gi,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3])
};

const clonedSpecial = deepClone(special);
console.log(clonedSpecial.date instanceof Date);    // true
console.log(clonedSpecial.regex instanceof RegExp); // true
console.log(clonedSpecial.map instanceof Map);      // true
console.log(clonedSpecial.set instanceof Set);      // true

console.log('\n=== Circular Reference ===');
const circular = { name: 'test' };
circular.self = circular;

const clonedCircular = deepClone(circular);
console.log(clonedCircular.self === clonedCircular); // true

console.log('\n=== Class Instance ===');
class Person {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    return `Hello, ${this.name}`;
  }
}

const john = new Person('John');
const clonedJohn = deepClone(john);

console.log(clonedJohn instanceof Person);  // true
console.log(clonedJohn.greet());           // 'Hello, John'
```

### **Bonus: Shallow Clone Comparison**
```javascript
/**
 * Shallow clone (only top level)
 */
function shallowClone(obj) {
  // Using spread operator
  return { ...obj };
  
  // Or using Object.assign
  // return Object.assign({}, obj);
}

// Test shallow vs deep
const original = {
  name: 'John',
  address: { city: 'NYC' }
};

const shallow = shallowClone(original);
const deep = deepClone(original);

shallow.name = 'Jane';           // Only affects shallow
shallow.address.city = 'LA';     // Affects BOTH original and shallow

deep.address.city = 'Boston';    // Only affects deep

console.log(original.name);          // 'John'
console.log(original.address.city);  // 'LA' (shallow modified it!)
console.log(shallow.address.city);   // 'LA'
console.log(deep.address.city);      // 'Boston'
```

**Interview Tips:**
- JSON.stringify/parse is simple but has limitations (no functions, dates as strings)
- Recursive approach is most flexible and commonly used
- structuredClone() is the modern standard (Node 17+, recent browsers)
- Always handle circular references in production
- Shallow clone: spread operator, Object.assign()
- Deep clone: nested objects/arrays are fully copied
- Consider lodash.cloneDeep() for production if available

</details>

23. Merge two objects

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Spread Operator (Shallow)**
```javascript
/**
 * Merge objects using spread operator
 * Time Complexity: O(n + m)
 * Space Complexity: O(n + m)
 * 
 * Shallow merge - later values override earlier ones
 * 
 * @param {Object} obj1 - First object
 * @param {Object} obj2 - Second object
 * @returns {Object} - Merged object
 */
function mergeObjects(obj1, obj2) {
  return { ...obj1, ...obj2 };
}

// Test cases
const obj1 = { a: 1, b: 2, c: 3 };
const obj2 = { b: 4, d: 5 };

const merged = mergeObjects(obj1, obj2);
console.log(merged);  // { a: 1, b: 4, c: 3, d: 5 }
```

### **Approach 2: Using Object.assign()**
```javascript
/**
 * Merge using Object.assign()
 * Time Complexity: O(n + m)
 * Space Complexity: O(n + m)
 * 
 * Shallow merge
 */
function mergeObjects(obj1, obj2) {
  return Object.assign({}, obj1, obj2);
}

// Test
const a = { x: 1, y: 2 };
const b = { y: 3, z: 4 };

console.log(mergeObjects(a, b));  // { x: 1, y: 3, z: 4 }
```

### **Approach 3: Deep Merge (Recursive)**
```javascript
/**
 * Deep merge - recursively merge nested objects
 * Time Complexity: O(n * d) where d is depth
 * Space Complexity: O(d) for recursion
 * 
 * Handles nested objects and arrays
 */
function deepMerge(obj1, obj2) {
  // If either is not an object, return obj2 (override)
  if (typeof obj1 !== 'object' || obj1 === null) return obj2;
  if (typeof obj2 !== 'object' || obj2 === null) return obj2;
  
  // Create result starting with obj1
  const result = { ...obj1 };
  
  // Merge each property from obj2
  for (const key in obj2) {
    if (obj2.hasOwnProperty(key)) {
      // If both are objects, merge recursively
      if (
        typeof obj2[key] === 'object' &&
        obj2[key] !== null &&
        !Array.isArray(obj2[key]) &&
        typeof result[key] === 'object' &&
        result[key] !== null &&
        !Array.isArray(result[key])
      ) {
        result[key] = deepMerge(result[key], obj2[key]);
      } else {
        // Otherwise, override
        result[key] = obj2[key];
      }
    }
  }
  
  return result;
}

// Test deep merge
const user1 = {
  name: 'John',
  age: 30,
  address: {
    city: 'NYC',
    zip: 10001
  },
  hobbies: ['reading']
};

const user2 = {
  age: 31,
  address: {
    country: 'USA'
  },
  hobbies: ['coding']
};

const merged = deepMerge(user1, user2);
console.log(merged);
/*
{
  name: 'John',
  age: 31,
  address: {
    city: 'NYC',
    zip: 10001,
    country: 'USA'
  },
  hobbies: ['coding']
}
*/
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready object merger with options
 * 
 * @param {Object} target - Target object
 * @param {Object} source - Source object
 * @param {Object} options - Merge options
 * @param {boolean} options.deep - Deep merge (default: true)
 * @param {boolean} options.arrayMerge - Merge arrays instead of replace (default: false)
 * @param {boolean} options.clone - Clone instead of mutate target (default: true)
 * @returns {Object} - Merged object
 */
function mergeObjects(target, source, options = {}) {
  const {
    deep = true,
    arrayMerge = false,
    clone = true
  } = options;
  
  // Validation
  if (typeof target !== 'object' || target === null) {
    throw new TypeError('Target must be an object');
  }
  
  if (typeof source !== 'object' || source === null) {
    return clone ? { ...target } : target;
  }
  
  // Start with target (clone if requested)
  const result = clone ? { ...target } : target;
  
  // Helper for deep merge
  function merge(tgt, src) {
    for (const key in src) {
      if (src.hasOwnProperty(key)) {
        const sourceValue = src[key];
        const targetValue = tgt[key];
        
        // Handle arrays
        if (Array.isArray(sourceValue)) {
          if (arrayMerge && Array.isArray(targetValue)) {
            tgt[key] = [...targetValue, ...sourceValue];
          } else {
            tgt[key] = [...sourceValue]; // Clone array
          }
        }
        // Handle nested objects
        else if (
          deep &&
          sourceValue !== null &&
          typeof sourceValue === 'object' &&
          targetValue !== null &&
          typeof targetValue === 'object' &&
          !Array.isArray(targetValue)
        ) {
          tgt[key] = merge({ ...targetValue }, sourceValue);
        }
        // Override primitive or null values
        else {
          tgt[key] = sourceValue;
        }
      }
    }
    
    return tgt;
  }
  
  return merge(result, source);
}

// Merge multiple objects
function mergeMultiple(...objects) {
  return objects.reduce((acc, obj) => mergeObjects(acc, obj), {});
}

// Comprehensive test suite
console.log('=== Shallow Merge ===');
const obj1 = { a: 1, b: { x: 10 } };
const obj2 = { b: { y: 20 }, c: 3 };

const shallow = mergeObjects(obj1, obj2, { deep: false });
console.log(shallow);
// { a: 1, b: { y: 20 }, c: 3 } - b is replaced, not merged

console.log('\n=== Deep Merge ===');
const deep = mergeObjects(obj1, obj2, { deep: true });
console.log(deep);
// { a: 1, b: { x: 10, y: 20 }, c: 3 } - b is merged

console.log('\n=== Array Merge ===');
const arr1 = { items: [1, 2], name: 'test' };
const arr2 = { items: [3, 4], age: 30 };

const arrMerged = mergeObjects(arr1, arr2, { arrayMerge: true });
console.log(arrMerged);
// { items: [1, 2, 3, 4], name: 'test', age: 30 }

const arrReplaced = mergeObjects(arr1, arr2, { arrayMerge: false });
console.log(arrReplaced);
// { items: [3, 4], name: 'test', age: 30 }

console.log('\n=== Multiple Objects ===');
const result = mergeMultiple(
  { a: 1, b: 2 },
  { b: 3, c: 4 },
  { c: 5, d: 6 }
);
console.log(result);  // { a: 1, b: 3, c: 5, d: 6 }

console.log('\n=== Mutation Test ===');
const original = { x: 1, nested: { y: 2 } };
const addition = { nested: { z: 3 } };

const mutated = mergeObjects(original, addition, { clone: false });
console.log(original === mutated);  // true (mutated in place)

const cloned = mergeObjects(original, addition, { clone: true });
console.log(original === cloned);   // false (new object)
```

### **Bonus: Smart Merge Strategies**
```javascript
/**
 * Custom merge with conflict resolution
 */
function mergeWithStrategy(obj1, obj2, strategy = 'override') {
  const result = { ...obj1 };
  
  for (const key in obj2) {
    if (obj2.hasOwnProperty(key)) {
      // If key exists in both
      if (key in result) {
        switch (strategy) {
          case 'override':
            result[key] = obj2[key];
            break;
            
          case 'keep':
            // Keep obj1 value
            break;
            
          case 'concat': // For arrays/strings
            if (Array.isArray(result[key]) && Array.isArray(obj2[key])) {
              result[key] = [...result[key], ...obj2[key]];
            } else if (typeof result[key] === 'string' && typeof obj2[key] === 'string') {
              result[key] = result[key] + obj2[key];
            } else {
              result[key] = obj2[key];
            }
            break;
            
          case 'sum': // For numbers
            if (typeof result[key] === 'number' && typeof obj2[key] === 'number') {
              result[key] = result[key] + obj2[key];
            } else {
              result[key] = obj2[key];
            }
            break;
        }
      } else {
        result[key] = obj2[key];
      }
    }
  }
  
  return result;
}

// Test strategies
console.log(mergeWithStrategy(
  { a: 1, b: [1, 2] },
  { a: 2, b: [3, 4] },
  'concat'
));  // { a: 2, b: [1, 2, 3, 4] }

console.log(mergeWithStrategy(
  { a: 10, b: 20 },
  { a: 5, b: 15 },
  'sum'
));  // { a: 15, b: 35 }
```

**Interview Tips:**
- Spread operator is simplest for shallow merge
- Object.assign() modifies first argument (use empty object as target)
- Deep merge requires recursion for nested objects
- Clarify: should arrays be merged or replaced?
- Clarify: should it mutate original or return new object?
- Consider using lodash.merge() for production
- Order matters: later objects override earlier ones

</details>

24. Check if an object is empty

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Object.keys()**
```javascript
/**
 * Check if object is empty using Object.keys()
 * Time Complexity: O(1) - only checks if keys exist
 * Space Complexity: O(1)
 * 
 * Checks enumerable own properties only
 * 
 * @param {Object} obj - Object to check
 * @returns {boolean} - True if empty
 */
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}

// Test cases
console.log(isEmpty({}));                    // true
console.log(isEmpty({ name: 'John' }));      // false
console.log(isEmpty({ a: undefined }));      // false (has property)
```

### **Approach 2: Using for...in Loop**
```javascript
/**
 * Check if empty using for...in
 * Time Complexity: O(1) - returns on first property
 * Space Complexity: O(1)
 * 
 * Also checks enumerable properties
 */
function isEmpty(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}

// Test
console.log(isEmpty({}));                    // true
console.log(isEmpty({ x: 1 }));              // false
```

### **Approach 3: Using JSON.stringify()**
```javascript
/**
 * Check if empty using JSON
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Simple but less efficient
 */
function isEmpty(obj) {
  return JSON.stringify(obj) === '{}';
}

// Test
console.log(isEmpty({}));                    // true
console.log(isEmpty({ a: 1 }));              // false
```

### **Approach 4: Using Object.getOwnPropertyNames()**
```javascript
/**
 * Check including non-enumerable properties
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 */
function isEmpty(obj) {
  return Object.getOwnPropertyNames(obj).length === 0 &&
         Object.getOwnPropertySymbols(obj).length === 0;
}

// Test with non-enumerable
const obj = {};
Object.defineProperty(obj, 'hidden', {
  value: 'secret',
  enumerable: false
});

console.log(Object.keys(obj).length === 0);  // true (enumerable only)
console.log(isEmpty(obj));                    // false (includes non-enumerable)
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready empty check with validation
 * 
 * @param {*} value - Value to check
 * @param {Object} options - Check options
 * @param {boolean} options.includeNonEnumerable - Check non-enumerable (default: false)
 * @param {boolean} options.includeSymbols - Check symbol properties (default: false)
 * @param {boolean} options.includeInherited - Check inherited properties (default: false)
 * @returns {boolean} - True if empty
 */
function isEmpty(value, options = {}) {
  const {
    includeNonEnumerable = false,
    includeSymbols = false,
    includeInherited = false
  } = options;
  
  // Handle null and undefined
  if (value === null || value === undefined) {
    return true;
  }
  
  // Handle primitives
  if (typeof value !== 'object' && typeof value !== 'function') {
    return false; // Primitives are not "empty"
  }
  
  // Handle arrays
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  
  // Handle Map
  if (value instanceof Map) {
    return value.size === 0;
  }
  
  // Handle Set
  if (value instanceof Set) {
    return value.size === 0;
  }
  
  // Check own properties
  if (includeNonEnumerable) {
    if (Object.getOwnPropertyNames(value).length > 0) {
      return false;
    }
  } else {
    if (Object.keys(value).length > 0) {
      return false;
    }
  }
  
  // Check symbols
  if (includeSymbols) {
    if (Object.getOwnPropertySymbols(value).length > 0) {
      return false;
    }
  }
  
  // Check inherited properties
  if (includeInherited) {
    for (const key in value) {
      return false; // Has at least one inherited property
    }
  }
  
  return true;
}

// Comprehensive test suite
console.log('=== Basic Objects ===');
console.log(isEmpty({}));                          // true
console.log(isEmpty({ a: 1 }));                    // false
console.log(isEmpty({ a: undefined }));            // false (has property)

console.log('\n=== Arrays ===');
console.log(isEmpty([]));                          // true
console.log(isEmpty([1, 2, 3]));                   // false
console.log(isEmpty(['']));                        // false (has element)

console.log('\n=== Map and Set ===');
console.log(isEmpty(new Map()));                   // true
console.log(isEmpty(new Map([['key', 'value']]))); // false
console.log(isEmpty(new Set()));                   // true
console.log(isEmpty(new Set([1, 2])));             // false

console.log('\n=== Primitives ===');
console.log(isEmpty(null));                        // true
console.log(isEmpty(undefined));                   // true
console.log(isEmpty(''));                          // false
console.log(isEmpty(0));                           // false

console.log('\n=== Non-Enumerable ===');
const obj = {};
Object.defineProperty(obj, 'hidden', {
  value: 'secret',
  enumerable: false
});

console.log(isEmpty(obj));                         // true (default)
console.log(isEmpty(obj, { includeNonEnumerable: true })); // false

console.log('\n=== Symbols ===');
const symObj = {};
symObj[Symbol('test')] = 'value';

console.log(isEmpty(symObj));                      // true (default)
console.log(isEmpty(symObj, { includeSymbols: true })); // false

console.log('\n=== Inherited Properties ===');
const parent = { inherited: 'value' };
const child = Object.create(parent);

console.log(isEmpty(child));                       // true (own properties)
console.log(isEmpty(child, { includeInherited: true })); // false
```

### **Bonus: Type-Specific Empty Checks**
```javascript
/**
 * Comprehensive emptiness checker for different types
 */
function isEmptyValue(value) {
  // null or undefined
  if (value === null || value === undefined) return true;
  
  // Boolean
  if (typeof value === 'boolean') return false;
  
  // Number
  if (typeof value === 'number') return value === 0 || isNaN(value);
  
  // String
  if (typeof value === 'string') return value.trim().length === 0;
  
  // Array
  if (Array.isArray(value)) return value.length === 0;
  
  // Map or Set
  if (value instanceof Map || value instanceof Set) return value.size === 0;
  
  // Object
  if (typeof value === 'object') return Object.keys(value).length === 0;
  
  return false;
}

// Test
console.log(isEmptyValue(null));         // true
console.log(isEmptyValue(undefined));    // true
console.log(isEmptyValue(''));           // true
console.log(isEmptyValue('  '));         // true (whitespace)
console.log(isEmptyValue(0));            // true
console.log(isEmptyValue([]));           // true
console.log(isEmptyValue({}));           // true
console.log(isEmptyValue(false));        // false (boolean is valid)
console.log(isEmptyValue('test'));       // false
console.log(isEmptyValue([1]));          // false
```

**Interview Tips:**
- Object.keys() is most common and efficient for objects
- Returns array of enumerable own property names
- Empty object: {} has length 0
- Object with undefined values is NOT empty: { a: undefined }
- Consider different "empty" meanings: no properties vs no enumerable properties
- for...in is more efficient (stops at first property)
- JSON.stringify is simple but inefficient (serializes entire object)
- Clarify: should check inherited properties? Non-enumerable? Symbols?

</details>

25. Convert object to array of key-value pairs

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Object.entries()**
```javascript
/**
 * Convert object to array of [key, value] pairs
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Returns enumerable own properties
 * 
 * @param {Object} obj - Object to convert
 * @returns {Array} - Array of [key, value] pairs
 */
function objectToArray(obj) {
  return Object.entries(obj);
}

// Test cases
const person = { name: 'John', age: 30, city: 'NYC' };
console.log(objectToArray(person));
// [['name', 'John'], ['age', 30], ['city', 'NYC']]
```

### **Approach 2: Using Object.keys() and map()**
```javascript
/**
 * Convert using Object.keys() and map
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function objectToArray(obj) {
  return Object.keys(obj).map(key => [key, obj[key]]);
}

// Test
const data = { a: 1, b: 2, c: 3 };
console.log(objectToArray(data));
// [['a', 1], ['b', 2], ['c', 3]]
```

### **Approach 3: Using for...in Loop**
```javascript
/**
 * Convert using for...in
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function objectToArray(obj) {
  const result = [];
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result.push([key, obj[key]]);
    }
  }
  
  return result;
}

// Test
const obj = { x: 10, y: 20, z: 30 };
console.log(objectToArray(obj));
// [['x', 10], ['y', 20], ['z', 30]]
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready object to array converter
 * 
 * @param {Object} obj - Object to convert
 * @param {Object} options - Conversion options
 * @param {string} options.format - Output format: 'entries', 'keys', 'values', 'objects'
 * @param {boolean} options.includeNonEnumerable - Include non-enumerable (default: false)
 * @param {boolean} options.includeSymbols - Include symbol properties (default: false)
 * @returns {Array} - Converted array
 */
function objectToArray(obj, options = {}) {
  const {
    format = 'entries',
    includeNonEnumerable = false,
    includeSymbols = false
  } = options;
  
  // Validation
  if (obj === null || obj === undefined) {
    return [];
  }
  
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('Input must be an object');
  }
  
  // Get property keys
  let keys;
  
  if (includeNonEnumerable) {
    keys = Object.getOwnPropertyNames(obj);
  } else {
    keys = Object.keys(obj);
  }
  
  // Add symbol properties if requested
  if (includeSymbols) {
    keys = [...keys, ...Object.getOwnPropertySymbols(obj)];
  }
  
  // Convert based on format
  switch (format) {
    case 'entries':
      // [[key, value], ...]
      return keys.map(key => [key, obj[key]]);
      
    case 'keys':
      // [key1, key2, ...]
      return keys;
      
    case 'values':
      // [value1, value2, ...]
      return keys.map(key => obj[key]);
      
    case 'objects':
      // [{key: 'key1', value: 'value1'}, ...]
      return keys.map(key => ({ key, value: obj[key] }));
      
    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

// Reverse: array to object
function arrayToObject(arr, format = 'entries') {
  const obj = {};
  
  switch (format) {
    case 'entries':
      // [[key, value], ...] => object
      arr.forEach(([key, value]) => {
        obj[key] = value;
      });
      break;
      
    case 'objects':
      // [{key: 'k', value: 'v'}, ...] => object
      arr.forEach(item => {
        obj[item.key] = item.value;
      });
      break;
      
    default:
      throw new Error(`Unknown format: ${format}`);
  }
  
  return obj;
}

// Comprehensive test suite
const person = {
  name: 'John',
  age: 30,
  city: 'NYC',
  country: 'USA'
};

console.log('=== Entries Format (Default) ===');
console.log(objectToArray(person));
// [['name', 'John'], ['age', 30], ['city', 'NYC'], ['country', 'USA']]

console.log('\n=== Keys Format ===');
console.log(objectToArray(person, { format: 'keys' }));
// ['name', 'age', 'city', 'country']

console.log('\n=== Values Format ===');
console.log(objectToArray(person, { format: 'values' }));
// ['John', 30, 'NYC', 'USA']

console.log('\n=== Objects Format ===');
console.log(objectToArray(person, { format: 'objects' }));
/*
[
  { key: 'name', value: 'John' },
  { key: 'age', value: 30 },
  { key: 'city', value: 'NYC' },
  { key: 'country', value: 'USA' }
]
*/

console.log('\n=== With Non-Enumerable ===');
const obj = { a: 1, b: 2 };
Object.defineProperty(obj, 'hidden', {
  value: 'secret',
  enumerable: false
});

console.log(objectToArray(obj));  // [['a', 1], ['b', 2]]
console.log(objectToArray(obj, { includeNonEnumerable: true }));
// [['a', 1], ['b', 2], ['hidden', 'secret']]

console.log('\n=== With Symbols ===');
const symObj = { x: 1 };
const sym = Symbol('test');
symObj[sym] = 'symbol value';

console.log(objectToArray(symObj));  // [['x', 1]]
console.log(objectToArray(symObj, { includeSymbols: true }));
// [['x', 1], [Symbol(test), 'symbol value']]

console.log('\n=== Array to Object ===');
const entries = [['name', 'Jane'], ['age', 25]];
console.log(arrayToObject(entries));  // { name: 'Jane', age: 25 }

const objects = [
  { key: 'x', value: 10 },
  { key: 'y', value: 20 }
];
console.log(arrayToObject(objects, 'objects'));  // { x: 10, y: 20 }
```

### **Bonus: Advanced Conversions**
```javascript
/**
 * Convert nested object to flat array
 */
function objectToFlatArray(obj, prefix = '') {
  const result = [];
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      const value = obj[key];
      
      if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
        // Recursively flatten nested objects
        result.push(...objectToFlatArray(value, fullKey));
      } else {
        result.push([fullKey, value]);
      }
    }
  }
  
  return result;
}

// Convert object to Map
function objectToMap(obj) {
  return new Map(Object.entries(obj));
}

// Convert Map to object
function mapToObject(map) {
  return Object.fromEntries(map);
}

// Test
const nested = {
  user: {
    name: 'John',
    address: {
      city: 'NYC',
      zip: 10001
    }
  },
  active: true
};

console.log(objectToFlatArray(nested));
/*
[
  ['user.name', 'John'],
  ['user.address.city', 'NYC'],
  ['user.address.zip', 10001],
  ['active', true]
]
*/

const data = { a: 1, b: 2, c: 3 };
const map = objectToMap(data);
console.log(map);  // Map(3) { 'a' => 1, 'b' => 2, 'c' => 3 }

const objFromMap = mapToObject(map);
console.log(objFromMap);  // { a: 1, b: 2, c: 3 }
```

**Interview Tips:**
- Object.entries() is the modern, recommended approach
- Returns array of [key, value] tuples
- Only includes enumerable own properties
- Object.keys() returns just keys, Object.values() returns just values
- Object.fromEntries() is the reverse (array to object)
- Can convert to Map using new Map(Object.entries(obj))
- For nested objects, consider flattening or recursive conversion

</details>

26. Group array of objects by a property

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using reduce()**
```javascript
/**
 * Group array of objects by a property
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {Array} arr - Array of objects
 * @param {string} key - Property to group by
 * @returns {Object} - Grouped object
 */
function groupBy(arr, key) {
  return arr.reduce((result, item) => {
    const groupKey = item[key];
    
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    
    result[groupKey].push(item);
    return result;
  }, {});
}

// Test cases
const users = [
  { name: 'John', age: 30, city: 'NYC' },
  { name: 'Jane', age: 25, city: 'LA' },
  { name: 'Bob', age: 30, city: 'NYC' },
  { name: 'Alice', age: 25, city: 'Chicago' }
];

console.log(groupBy(users, 'age'));
/*
{
  '25': [
    { name: 'Jane', age: 25, city: 'LA' },
    { name: 'Alice', age: 25, city: 'Chicago' }
  ],
  '30': [
    { name: 'John', age: 30, city: 'NYC' },
    { name: 'Bob', age: 30, city: 'NYC' }
  ]
}
*/

console.log(groupBy(users, 'city'));
/*
{
  'NYC': [
    { name: 'John', age: 30, city: 'NYC' },
    { name: 'Bob', age: 30, city: 'NYC' }
  ],
  'LA': [{ name: 'Jane', age: 25, city: 'LA' }],
  'Chicago': [{ name: 'Alice', age: 25, city: 'Chicago' }]
}
*/
```

### **Approach 2: Using forEach()**
```javascript
/**
 * Group using forEach
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function groupBy(arr, key) {
  const result = {};
  
  arr.forEach(item => {
    const groupKey = item[key];
    
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    
    result[groupKey].push(item);
  });
  
  return result;
}

// Test
const products = [
  { name: 'Laptop', category: 'Electronics', price: 1000 },
  { name: 'Phone', category: 'Electronics', price: 500 },
  { name: 'Shirt', category: 'Clothing', price: 50 }
];

console.log(groupBy(products, 'category'));
/*
{
  'Electronics': [
    { name: 'Laptop', category: 'Electronics', price: 1000 },
    { name: 'Phone', category: 'Electronics', price: 500 }
  ],
  'Clothing': [
    { name: 'Shirt', category: 'Clothing', price: 50 }
  ]
}
*/
```

### **Approach 3: Using Map for Complex Keys**
```javascript
/**
 * Group using Map (better for non-string keys)
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function groupBy(arr, key) {
  const map = new Map();
  
  arr.forEach(item => {
    const groupKey = item[key];
    
    if (!map.has(groupKey)) {
      map.set(groupKey, []);
    }
    
    map.get(groupKey).push(item);
  });
  
  return map;
}

// Test with complex keys
const data = [
  { id: 1, tags: ['A', 'B'] },
  { id: 2, tags: ['A', 'B'] },
  { id: 3, tags: ['C'] }
];

// Group by array reference (Note: arrays are compared by reference)
const grouped = groupBy(data, 'tags');
console.log(grouped);
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready groupBy with advanced features
 * 
 * @param {Array} arr - Array of objects
 * @param {string|Function} key - Property name or function to extract key
 * @param {Object} options - Grouping options
 * @param {Function} options.transform - Transform each group's items
 * @param {Function} options.aggregate - Aggregate each group (instead of array)
 * @returns {Object|Map} - Grouped data
 */
function groupBy(arr, key, options = {}) {
  const { transform, aggregate } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('First argument must be an array');
  }
  
  const result = {};
  
  // Helper to get key from item
  const getKey = typeof key === 'function' 
    ? key 
    : (item) => item[key];
  
  arr.forEach(item => {
    const groupKey = getKey(item);
    
    // Skip undefined/null keys
    if (groupKey === undefined || groupKey === null) {
      return;
    }
    
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    
    result[groupKey].push(item);
  });
  
  // Apply transformations if provided
  if (transform) {
    Object.keys(result).forEach(key => {
      result[key] = transform(result[key]);
    });
  }
  
  // Apply aggregation if provided
  if (aggregate) {
    Object.keys(result).forEach(key => {
      result[key] = aggregate(result[key]);
    });
  }
  
  return result;
}

// Group by multiple properties
function groupByMultiple(arr, keys) {
  return arr.reduce((result, item) => {
    // Create composite key
    const compositeKey = keys.map(k => item[k]).join('|');
    
    if (!result[compositeKey]) {
      result[compositeKey] = [];
    }
    
    result[compositeKey].push(item);
    return result;
  }, {});
}

// Comprehensive test suite
const employees = [
  { name: 'John', department: 'IT', salary: 80000, level: 'Senior' },
  { name: 'Jane', department: 'IT', salary: 70000, level: 'Mid' },
  { name: 'Bob', department: 'HR', salary: 60000, level: 'Senior' },
  { name: 'Alice', department: 'IT', salary: 90000, level: 'Senior' },
  { name: 'Charlie', department: 'HR', salary: 55000, level: 'Junior' }
];

console.log('=== Basic Grouping ===');
console.log(groupBy(employees, 'department'));

console.log('\n=== Group by Function ===');
const byRange = groupBy(employees, emp => {
  if (emp.salary < 60000) return 'Low';
  if (emp.salary < 80000) return 'Medium';
  return 'High';
});
console.log(byRange);

console.log('\n=== Group with Transform (count) ===');
const counts = groupBy(employees, 'department', {
  transform: group => group.length
});
console.log(counts);  // { IT: 3, HR: 2 }

console.log('\n=== Group with Aggregation (average salary) ===');
const avgSalary = groupBy(employees, 'department', {
  aggregate: group => {
    const total = group.reduce((sum, emp) => sum + emp.salary, 0);
    return total / group.length;
  }
});
console.log(avgSalary);  // { IT: 80000, HR: 57500 }

console.log('\n=== Group by Multiple Properties ===');
const multiGroup = groupByMultiple(employees, ['department', 'level']);
console.log(multiGroup);
/*
{
  'IT|Senior': [...],
  'IT|Mid': [...],
  'HR|Senior': [...],
  'HR|Junior': [...]
}
*/

console.log('\n=== Nested Grouping ===');
function nestedGroupBy(arr, keys) {
  if (keys.length === 0) return arr;
  
  const [firstKey, ...remainingKeys] = keys;
  const grouped = groupBy(arr, firstKey);
  
  if (remainingKeys.length > 0) {
    Object.keys(grouped).forEach(key => {
      grouped[key] = nestedGroupBy(grouped[key], remainingKeys);
    });
  }
  
  return grouped;
}

const nested = nestedGroupBy(employees, ['department', 'level']);
console.log(nested);
/*
{
  IT: {
    Senior: [...],
    Mid: [...]
  },
  HR: {
    Senior: [...],
    Junior: [...]
  }
}
*/
```

### **Bonus: Using Object.groupBy() (ES2024)**
```javascript
/**
 * Modern groupBy using built-in method (ES2024)
 * Available in Node 21+ and modern browsers
 */
function groupByModern(arr, key) {
  return Object.groupBy(arr, item => item[key]);
}

// Or with Map
function groupByMap(arr, key) {
  return Map.groupBy(arr, item => item[key]);
}

// Test
const items = [
  { type: 'fruit', name: 'apple' },
  { type: 'fruit', name: 'banana' },
  { type: 'veggie', name: 'carrot' }
];

// Note: Object.groupBy might not be available in all environments yet
// console.log(Object.groupBy(items, item => item.type));
```

**Interview Tips:**
- reduce() is the most common and flexible approach
- forEach() is more readable for simple cases
- Use Map instead of Object for non-string keys
- Function as key parameter allows computed grouping (e.g., by ranges)
- Consider lodash.groupBy() for production use
- ES2024 introduces Object.groupBy() natively
- For multiple properties, can use composite keys or nested grouping
- Common use cases: analytics, data visualization, reporting

</details>

27. Remove falsy values from an array

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using filter() with Boolean**
```javascript
/**
 * Remove falsy values using filter
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Falsy values: false, 0, '', null, undefined, NaN
 * 
 * @param {Array} arr - Array with potential falsy values
 * @returns {Array} - Array with only truthy values
 */
function removeFalsy(arr) {
  return arr.filter(Boolean);
}

// Test cases
console.log(removeFalsy([0, 1, false, 2, '', 3, null, 'hello', undefined, NaN]));
// [1, 2, 3, 'hello']

console.log(removeFalsy([false, 0, '', null, undefined, NaN]));
// []

console.log(removeFalsy([1, 2, 3, 'test', true]));
// [1, 2, 3, 'test', true] (all truthy)
```

### **Approach 2: Using filter() with Explicit Check**
```javascript
/**
 * Remove falsy with explicit condition
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function removeFalsy(arr) {
  return arr.filter(item => item);
}

// Or more explicit
function removeFalsy(arr) {
  return arr.filter(item => !!item);
}

// Test
const mixed = [1, 0, 'text', false, null, 2, undefined, '', 3];
console.log(removeFalsy(mixed));  // [1, 'text', 2, 3]
```

### **Approach 3: Using reduce()**
```javascript
/**
 * Remove falsy using reduce
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function removeFalsy(arr) {
  return arr.reduce((result, item) => {
    if (item) {
      result.push(item);
    }
    return result;
  }, []);
}

// Test
console.log(removeFalsy([0, 1, false, 2, '', 3]));  // [1, 2, 3]
```

### **Approach 4: In-Place Removal (Modify Original)**
```javascript
/**
 * Remove falsy in-place (mutates array)
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
function removeFalsy(arr) {
  let writeIndex = 0;
  
  for (let i = 0; i < arr.length; i++) {
    if (arr[i]) {
      arr[writeIndex] = arr[i];
      writeIndex++;
    }
  }
  
  arr.length = writeIndex;
  return arr;
}

// Test
const data = [1, 0, 2, false, 3, null, 4];
removeFalsy(data);
console.log(data);  // [1, 2, 3, 4] (original array modified)
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready falsy remover with options
 * 
 * @param {Array} arr - Input array
 * @param {Object} options - Filter options
 * @param {boolean} options.keepZero - Keep 0 as valid (default: false)
 * @param {boolean} options.keepEmptyString - Keep '' as valid (default: false)
 * @param {boolean} options.keepFalse - Keep false as valid (default: false)
 * @param {boolean} options.inPlace - Modify array in place (default: false)
 * @returns {Array} - Filtered array
 */
function removeFalsy(arr, options = {}) {
  const {
    keepZero = false,
    keepEmptyString = false,
    keepFalse = false,
    inPlace = false
  } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  // Filter function
  const shouldKeep = (item) => {
    // null and undefined are always removed
    if (item === null || item === undefined) {
      return false;
    }
    
    // NaN is always removed
    if (typeof item === 'number' && isNaN(item)) {
      return false;
    }
    
    // Handle special cases
    if (item === 0 && keepZero) return true;
    if (item === '' && keepEmptyString) return true;
    if (item === false && keepFalse) return true;
    
    // General truthy check
    return !!item;
  };
  
  if (inPlace) {
    let writeIndex = 0;
    
    for (let i = 0; i < arr.length; i++) {
      if (shouldKeep(arr[i])) {
        arr[writeIndex] = arr[i];
        writeIndex++;
      }
    }
    
    arr.length = writeIndex;
    return arr;
  } else {
    return arr.filter(shouldKeep);
  }
}

// Remove specific falsy values
function removeValues(arr, values) {
  return arr.filter(item => !values.includes(item));
}

// Keep only specific types
function keepTypes(arr, types) {
  return arr.filter(item => {
    const itemType = Array.isArray(item) ? 'array' : typeof item;
    return types.includes(itemType);
  });
}

// Comprehensive test suite
const testArray = [
  0, 1, false, 2, '', 3, null, 'hello', undefined, NaN, true, [], {}
];

console.log('=== Default (Remove All Falsy) ===');
console.log(removeFalsy(testArray));
// [1, 2, 3, 'hello', true, [], {}]

console.log('\n=== Keep Zero ===');
console.log(removeFalsy(testArray, { keepZero: true }));
// [0, 1, 2, 3, 'hello', true, [], {}]

console.log('\n=== Keep Empty String ===');
console.log(removeFalsy(testArray, { keepEmptyString: true }));
// [1, 2, '', 3, 'hello', true, [], {}]

console.log('\n=== Keep False ===');
console.log(removeFalsy(testArray, { keepFalse: true }));
// [1, false, 2, 3, 'hello', true, [], {}]

console.log('\n=== Keep All Special Falsy ===');
console.log(removeFalsy(testArray, {
  keepZero: true,
  keepEmptyString: true,
  keepFalse: true
}));
// [0, 1, false, 2, '', 3, 'hello', true, [], {}]
// Only null, undefined, NaN removed

console.log('\n=== Remove Specific Values ===');
console.log(removeValues([1, 2, null, 3, null, 4], [null]));
// [1, 2, 3, 4]

console.log(removeValues([1, 2, 0, 3, 0, 4], [0]));
// [1, 2, 3, 4]

console.log('\n=== Keep Only Numbers ===');
console.log(keepTypes(testArray, ['number']));
// [0, 1, 2, 3] (NaN is excluded)

console.log('\n=== Keep Only Strings and Numbers ===');
console.log(keepTypes(testArray, ['string', 'number']));
// [0, 1, 2, '', 3, 'hello']

console.log('\n=== In-Place Modification ===');
const mutableArray = [0, 1, false, 2, null, 3];
removeFalsy(mutableArray, { inPlace: true });
console.log(mutableArray);  // [1, 2, 3]
```

### **Bonus: Remove Empty Values (More Strict)**
```javascript
/**
 * Remove empty/null/undefined values (stricter than falsy)
 */
function removeEmpty(arr) {
  return arr.filter(item => {
    // Remove null and undefined
    if (item === null || item === undefined) return false;
    
    // Remove NaN
    if (typeof item === 'number' && isNaN(item)) return false;
    
    // Remove empty strings
    if (typeof item === 'string' && item.trim() === '') return false;
    
    // Remove empty arrays
    if (Array.isArray(item) && item.length === 0) return false;
    
    // Remove empty objects
    if (
      typeof item === 'object' &&
      !Array.isArray(item) &&
      Object.keys(item).length === 0
    ) return false;
    
    return true;
  });
}

// Test
const data = [
  0,           // kept (valid number)
  '',          // removed (empty string)
  '  ',        // removed (whitespace only)
  false,       // kept (valid boolean)
  null,        // removed
  undefined,   // removed
  [],          // removed (empty array)
  [1],         // kept
  {},          // removed (empty object)
  { a: 1 },    // kept
  NaN          // removed
];

console.log(removeEmpty(data));
// [0, false, [1], { a: 1 }]
```

**Interview Tips:**
- filter(Boolean) is the simplest and most common
- Falsy values in JavaScript: false, 0, '', null, undefined, NaN
- filter() creates new array; original unchanged unless inPlace option
- Consider if 0 should be kept (e.g., valid count/index)
- Consider if empty string should be kept (e.g., optional field)
- For more control, use explicit filter conditions
- Array.prototype.filter() is O(n) time, O(n) space

</details>

28. Find the intersection of two arrays

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using filter() and includes()**
```javascript
/**
 * Find intersection of two arrays
 * Time Complexity: O(n * m) - includes is O(m) for each element
 * Space Complexity: O(k) where k is intersection size
 * 
 * @param {Array} arr1 - First array
 * @param {Array} arr2 - Second array
 * @returns {Array} - Common elements
 */
function intersection(arr1, arr2) {
  return arr1.filter(item => arr2.includes(item));
}

// Test cases
console.log(intersection([1, 2, 3, 4], [3, 4, 5, 6]));
// [3, 4]

console.log(intersection(['a', 'b', 'c'], ['b', 'c', 'd']));
// ['b', 'c']

console.log(intersection([1, 2, 3], [4, 5, 6]));
// []
```

### **Approach 2: Using Set (Optimal)**
```javascript
/**
 * Find intersection using Set
 * Time Complexity: O(n + m)
 * Space Complexity: O(min(n, m))
 * 
 * Much faster for large arrays
 */
function intersection(arr1, arr2) {
  const set2 = new Set(arr2);
  return arr1.filter(item => set2.has(item));
}

// Or create Set from smaller array for optimization
function intersection(arr1, arr2) {
  // Use smaller array for Set to save space
  if (arr2.length < arr1.length) {
    [arr1, arr2] = [arr2, arr1];
  }
  
  const set = new Set(arr2);
  return arr1.filter(item => set.has(item));
}

// Test
console.log(intersection([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]));
// [3, 4, 5]
```

### **Approach 3: Remove Duplicates from Result**
```javascript
/**
 * Intersection with unique values only
 * Time Complexity: O(n + m)
 * Space Complexity: O(k)
 */
function intersection(arr1, arr2) {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  
  return [...set1].filter(item => set2.has(item));
}

// Test with duplicates
console.log(intersection([1, 1, 2, 2, 3], [2, 2, 3, 3, 4]));
// [2, 3] (no duplicates in result)
```

### **Approach 4: Using reduce()**
```javascript
/**
 * Intersection using reduce
 * Time Complexity: O(n + m)
 * Space Complexity: O(m + k)
 */
function intersection(arr1, arr2) {
  const set2 = new Set(arr2);
  
  return arr1.reduce((result, item) => {
    if (set2.has(item) && !result.includes(item)) {
      result.push(item);
    }
    return result;
  }, []);
}

// Test
console.log(intersection([1, 2, 3, 4], [2, 3, 5, 6]));
// [2, 3]
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready array intersection
 * 
 * @param {Array} arr1 - First array
 * @param {Array} arr2 - Second array
 * @param {Object} options - Intersection options
 * @param {boolean} options.unique - Return unique values only (default: true)
 * @param {Function} options.comparator - Custom comparison function
 * @returns {Array} - Intersection result
 */
function intersection(arr1, arr2, options = {}) {
  const { unique = true, comparator } = options;
  
  // Validation
  if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
    throw new TypeError('Both arguments must be arrays');
  }
  
  if (arr1.length === 0 || arr2.length === 0) {
    return [];
  }
  
  // Use custom comparator if provided
  if (comparator) {
    return arr1.filter(item1 =>
      arr2.some(item2 => comparator(item1, item2))
    );
  }
  
  // Standard intersection
  const set2 = new Set(arr2);
  const result = arr1.filter(item => set2.has(item));
  
  // Return unique values if requested
  return unique ? [...new Set(result)] : result;
}

// Intersection of multiple arrays
function intersectionMultiple(...arrays) {
  if (arrays.length === 0) return [];
  if (arrays.length === 1) return arrays[0];
  
  return arrays.reduce((acc, arr) => intersection(acc, arr));
}

// Intersection of arrays of objects
function intersectionBy(arr1, arr2, key) {
  const map = new Map(arr2.map(item => [item[key], item]));
  
  return arr1.filter(item => map.has(item[key]));
}

// Comprehensive test suite
console.log('=== Basic Intersection ===');
console.log(intersection([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]));
// [3, 4, 5]

console.log('\n=== With Duplicates (Unique: true) ===');
console.log(intersection([1, 1, 2, 2, 3], [2, 2, 3, 3, 4], { unique: true }));
// [2, 3]

console.log('\n=== With Duplicates (Unique: false) ===');
console.log(intersection([1, 1, 2, 2, 3], [2, 2, 3, 3, 4], { unique: false }));
// [2, 2, 3] (duplicates preserved from arr1)

console.log('\n=== With Custom Comparator ===');
const arr1 = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];
const arr2 = [{ id: 2, name: 'B' }, { id: 3, name: 'C' }];

const result = intersection(arr1, arr2, {
  comparator: (a, b) => a.id === b.id
});
console.log(result);  // [{ id: 2, name: 'B' }]

console.log('\n=== Multiple Arrays ===');
console.log(intersectionMultiple(
  [1, 2, 3, 4, 5],
  [2, 3, 4, 5, 6],
  [3, 4, 5, 6, 7]
));  // [3, 4, 5]

console.log('\n=== Arrays of Objects (By Key) ===');
const users1 = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
  { id: 3, name: 'Bob' }
];

const users2 = [
  { id: 2, name: 'Jane' },
  { id: 3, name: 'Bob' },
  { id: 4, name: 'Alice' }
];

console.log(intersectionBy(users1, users2, 'id'));
// [{ id: 2, name: 'Jane' }, { id: 3, name: 'Bob' }]

console.log('\n=== Empty Arrays ===');
console.log(intersection([], [1, 2, 3]));        // []
console.log(intersection([1, 2, 3], []));        // []
console.log(intersection([], []));               // []

console.log('\n=== No Common Elements ===');
console.log(intersection([1, 2, 3], [4, 5, 6])); // []
```

### **Bonus: Symmetric Difference (XOR)**
```javascript
/**
 * Get elements that are in either array but not in both
 */
function symmetricDifference(arr1, arr2) {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  
  const onlyInArr1 = arr1.filter(item => !set2.has(item));
  const onlyInArr2 = arr2.filter(item => !set1.has(item));
  
  return [...new Set([...onlyInArr1, ...onlyInArr2])];
}

// Or using filter on both arrays
function symmetricDifference(arr1, arr2) {
  return [
    ...arr1.filter(item => !arr2.includes(item)),
    ...arr2.filter(item => !arr1.includes(item))
  ];
}

// Test
console.log(symmetricDifference([1, 2, 3, 4], [3, 4, 5, 6]));
// [1, 2, 5, 6] (elements unique to each array)
```

**Interview Tips:**
- Set.has() is O(1) vs array.includes() is O(n)
- For large arrays, always use Set for better performance
- Clarify: should result contain duplicates?
- Clarify: should maintain order from first array?
- Consider lodash.intersection() for production
- Can extend to multiple arrays by reducing pairwise
- For objects, need custom comparator or key-based comparison

</details>

29. Check if an array contains a specific value

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using includes() (Modern)**
```javascript
/**
 * Check if array contains value
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Best for primitives
 * 
 * @param {Array} arr - Array to search
 * @param {*} value - Value to find
 * @returns {boolean} - True if found
 */
function contains(arr, value) {
  return arr.includes(value);
}

// Test cases
console.log(contains([1, 2, 3, 4, 5], 3));        // true
console.log(contains([1, 2, 3, 4, 5], 6));        // false
console.log(contains(['a', 'b', 'c'], 'b'));      // true
console.log(contains([1, 2, NaN, 4], NaN));       // true (includes handles NaN)
```

### **Approach 2: Using indexOf()**
```javascript
/**
 * Check using indexOf
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Returns -1 if not found
 */
function contains(arr, value) {
  return arr.indexOf(value) !== -1;
}

// Or using findIndex for objects
function contains(arr, predicate) {
  return arr.findIndex(predicate) !== -1;
}

// Test
console.log(contains([10, 20, 30], 20));          // true
console.log(contains([10, 20, 30], 25));          // false
console.log(contains([1, 2, NaN, 4], NaN));       // false (indexOf can't find NaN)
```

### **Approach 3: Using some()**
```javascript
/**
 * Check using some() with predicate
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * More flexible for complex conditions
 */
function contains(arr, value) {
  return arr.some(item => item === value);
}

// Or with custom predicate
function containsWhere(arr, predicate) {
  return arr.some(predicate);
}

// Test
console.log(contains([1, 2, 3], 2));              // true

const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' }
];

console.log(containsWhere(users, user => user.id === 2));     // true
console.log(containsWhere(users, user => user.name === 'Bob')); // false
```

### **Approach 4: Using Set**
```javascript
/**
 * Check using Set (efficient for multiple lookups)
 * Time Complexity: O(1) per lookup after O(n) construction
 * Space Complexity: O(n)
 */
function createContainsChecker(arr) {
  const set = new Set(arr);
  return (value) => set.has(value);
}

// Test
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const containsNumber = createContainsChecker(numbers);

console.log(containsNumber(5));    // true
console.log(containsNumber(15));   // false
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready contains check
 * 
 * @param {Array} arr - Array to search
 * @param {*} value - Value to find
 * @param {Object} options - Search options
 * @param {Function} options.comparator - Custom comparison function
 * @param {number} options.fromIndex - Start search from index
 * @param {boolean} options.strict - Use strict equality (default: true)
 * @returns {boolean} - True if found
 */
function contains(arr, value, options = {}) {
  const { comparator, fromIndex = 0, strict = true } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('First argument must be an array');
  }
  
  // Handle custom comparator
  if (comparator) {
    return arr.some(comparator);
  }
  
  // Handle fromIndex
  if (fromIndex !== 0) {
    return arr.slice(fromIndex).includes(value);
  }
  
  // Standard check
  if (strict) {
    return arr.includes(value);
  } else {
    // Loose equality
    return arr.some(item => item == value);
  }
}

// Check if array contains any of the values
function containsAny(arr, values) {
  return values.some(value => arr.includes(value));
}

// Check if array contains all of the values
function containsAll(arr, values) {
  return values.every(value => arr.includes(value));
}

// Check if array contains object with property
function containsObjectWith(arr, key, value) {
  return arr.some(item => item && item[key] === value);
}

// Comprehensive test suite
console.log('=== Basic Contains ===');
const numbers = [1, 2, 3, 4, 5];
console.log(contains(numbers, 3));               // true
console.log(contains(numbers, 6));               // false

console.log('\n=== With Custom Comparator ===');
const users = [
  { id: 1, name: 'John', age: 30 },
  { id: 2, name: 'Jane', age: 25 }
];

console.log(contains(users, null, {
  comparator: user => user.name === 'Jane'
}));  // true

console.log('\n=== From Index ===');
console.log(contains([1, 2, 3, 4, 5], 2, { fromIndex: 0 }));  // true
console.log(contains([1, 2, 3, 4, 5], 2, { fromIndex: 2 }));  // false

console.log('\n=== Strict vs Loose ===');
console.log(contains([1, 2, 3], '2', { strict: true }));   // false
console.log(contains([1, 2, 3], '2', { strict: false }));  // true

console.log('\n=== Contains Any ===');
console.log(containsAny([1, 2, 3, 4], [5, 6, 7]));        // false
console.log(containsAny([1, 2, 3, 4], [3, 5, 7]));        // true

console.log('\n=== Contains All ===');
console.log(containsAll([1, 2, 3, 4, 5], [2, 4]));        // true
console.log(containsAll([1, 2, 3, 4, 5], [2, 6]));        // false

console.log('\n=== Contains Object With Property ===');
const products = [
  { id: 1, name: 'Laptop', price: 1000 },
  { id: 2, name: 'Phone', price: 500 }
];

console.log(containsObjectWith(products, 'name', 'Laptop'));  // true
console.log(containsObjectWith(products, 'name', 'Tablet'));  // false
console.log(containsObjectWith(products, 'price', 500));      // true

console.log('\n=== Special Values ===');
console.log(contains([1, 2, NaN, 4], NaN));           // true (includes handles NaN)
console.log(contains([1, 2, undefined, 4], undefined)); // true
console.log(contains([1, 2, null, 4], null));         // true
```

### **Bonus: Deep Contains for Objects**
```javascript
/**
 * Check if array contains object with deep equality
 */
function deepContains(arr, obj) {
  return arr.some(item => JSON.stringify(item) === JSON.stringify(obj));
}

// Or using lodash-style deep equal
function deepEqual(a, b) {
  if (a === b) return true;
  
  if (typeof a !== 'object' || typeof b !== 'object') return false;
  if (a === null || b === null) return false;
  
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  return keysA.every(key => deepEqual(a[key], b[key]));
}

function deepContains(arr, obj) {
  return arr.some(item => deepEqual(item, obj));
}

// Test
const objects = [
  { a: 1, b: { c: 2 } },
  { a: 2, b: { c: 3 } }
];

console.log(deepContains(objects, { a: 1, b: { c: 2 } }));  // true
console.log(deepContains(objects, { a: 1, b: { c: 3 } }));  // false
```

**Interview Tips:**
- includes() is modern and recommended (ES2016+)
- indexOf() is older but widely supported
- includes() handles NaN correctly, indexOf() doesn't
- some() is more flexible for complex conditions
- For objects, need custom comparison (can't use === by reference)
- Set.has() is O(1) but requires O(n) setup - good for multiple lookups
- Consider using find() if you need the actual element
- includes() supports fromIndex parameter: arr.includes(value, fromIndex)

</details>

30. Capitalize the first letter of each word in a string

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using split(), map(), and join()**
```javascript
/**
 * Capitalize first letter of each word
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {string} str - Input string
 * @returns {string} - Title cased string
 */
function capitalizeWords(str) {
  return str
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

// Test cases
console.log(capitalizeWords('hello world'));
// 'Hello World'

console.log(capitalizeWords('javascript is awesome'));
// 'Javascript Is Awesome'

console.log(capitalizeWords('the quick brown fox'));
// 'The Quick Brown Fox'
```

### **Approach 2: Using Regular Expression**
```javascript
/**
 * Capitalize using regex
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * More concise
 */
function capitalizeWords(str) {
  return str.replace(/\b\w/g, char => char.toUpperCase());
}

// Or lowercase the rest
function capitalizeWords(str) {
  return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
}

// Test
console.log(capitalizeWords('hello world'));              // 'Hello World'
console.log(capitalizeWords('HELLO WORLD'));              // 'Hello World'
console.log(capitalizeWords('this is a test'));           // 'This Is A Test'
```

### **Approach 3: Using Loop (Manual)**
```javascript
/**
 * Capitalize using manual loop
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function capitalizeWords(str) {
  let result = '';
  let capitalizeNext = true;
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    
    if (char === ' ') {
      result += char;
      capitalizeNext = true;
    } else {
      if (capitalizeNext) {
        result += char.toUpperCase();
        capitalizeNext = false;
      } else {
        result += char.toLowerCase();
      }
    }
  }
  
  return result;
}

// Test
console.log(capitalizeWords('hello world'));  // 'Hello World'
console.log(capitalizeWords('a b c d'));      // 'A B C D'
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready title case converter
 * 
 * @param {string} str - Input string
 * @param {Object} options - Capitalization options
 * @param {Array} options.exceptions - Words to keep lowercase
 * @param {boolean} options.allWords - Capitalize all words including exceptions (default: false)
 * @param {boolean} options.firstWordAlways - Always capitalize first word (default: true)
 * @returns {string} - Title cased string
 */
function capitalizeWords(str, options = {}) {
  const {
    exceptions = ['a', 'an', 'the', 'and', 'but', 'or', 'for', 'nor', 'on', 'at', 'to', 'by', 'in', 'of'],
    allWords = false,
    firstWordAlways = true
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  if (str.trim() === '') {
    return str;
  }
  
  const words = str.trim().split(/\s+/);
  
  return words
    .map((word, index) => {
      const lowerWord = word.toLowerCase();
      
      // Always capitalize first word if option is set
      if (index === 0 && firstWordAlways) {
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      }
      
      // Check if word is in exceptions list
      if (!allWords && exceptions.includes(lowerWord)) {
        return lowerWord;
      }
      
      // Capitalize first letter
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
}

// Capitalize only first letter of entire string
function capitalizeFirst(str) {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Capitalize using proper title case rules
function toTitleCase(str) {
  // Articles, conjunctions, and prepositions to keep lowercase (unless first/last)
  const minorWords = new Set([
    'a', 'an', 'the', 'and', 'but', 'or', 'for', 'nor', 'as', 'at',
    'by', 'for', 'from', 'in', 'into', 'near', 'of', 'on', 'onto',
    'to', 'with'
  ]);
  
  const words = str.toLowerCase().split(/\s+/);
  
  return words
    .map((word, index) => {
      // Always capitalize first and last word
      if (index === 0 || index === words.length - 1) {
        return word.charAt(0).toUpperCase() + word.slice(1);
      }
      
      // Keep minor words lowercase
      if (minorWords.has(word)) {
        return word;
      }
      
      // Capitalize everything else
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join(' ');
}

// Comprehensive test suite
console.log('=== Basic Capitalization ===');
console.log(capitalizeWords('hello world'));
// 'Hello World'

console.log(capitalizeWords('the quick brown fox jumps over the lazy dog'));
// 'The Quick Brown Fox Jumps Over The Lazy Dog'

console.log('\n=== With Exceptions (Title Case) ===');
console.log(capitalizeWords('the lord of the rings', { allWords: false }));
// 'The Lord of the Rings'

console.log(capitalizeWords('a tale of two cities', { allWords: false }));
// 'A Tale of Two Cities'

console.log('\n=== All Words (No Exceptions) ===');
console.log(capitalizeWords('the lord of the rings', { allWords: true }));
// 'The Lord Of The Rings'

console.log('\n=== Proper Title Case ===');
console.log(toTitleCase('the lord of the rings'));
// 'The Lord of the Rings'

console.log(toTitleCase('gone with the wind'));
// 'Gone with the Wind'

console.log(toTitleCase('harry potter and the chamber of secrets'));
// 'Harry Potter and the Chamber of Secrets'

console.log('\n=== Capitalize First Only ===');
console.log(capitalizeFirst('hello world'));
// 'Hello world'

console.log(capitalizeFirst('the quick brown fox'));
// 'The quick brown fox'

console.log('\n=== Edge Cases ===');
console.log(capitalizeWords(''));                    // ''
console.log(capitalizeWords('a'));                   // 'A'
console.log(capitalizeWords('   hello   world   '));  // 'Hello World'
console.log(capitalizeWords('HELLO WORLD'));         // 'Hello World'
console.log(capitalizeWords('hello-world'));         // 'Hello-world' (hyphen not handled)
```

### **Bonus: Advanced Capitalization**
```javascript
/**
 * Capitalize with punctuation handling
 */
function capitalizeWithPunctuation(str) {
  return str.replace(/(?:^|\s|[.!?])\w/g, match => match.toUpperCase());
}

/**
 * Capitalize hyphenated words
 */
function capitalizeHyphenated(str) {
  return str
    .split(/(\s+|-)/)
    .map(part => {
      if (part === ' ' || part === '-') return part;
      return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
    })
    .join('');
}

/**
 * Convert to camelCase
 */
function toCamelCase(str) {
  return str
    .toLowerCase()
    .replace(/[^a-zA-Z0-9]+(.)/g, (match, char) => char.toUpperCase());
}

/**
 * Convert to PascalCase
 */
function toPascalCase(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

// Test advanced
console.log(capitalizeWithPunctuation('hello. how are you? i am fine!'));
// 'Hello. How Are You? I Am Fine!'

console.log(capitalizeHyphenated('hello-world-example'));
// 'Hello-World-Example'

console.log(toCamelCase('hello world test'));
// 'helloWorldTest'

console.log(toPascalCase('hello world test'));
// 'HelloWorldTest'
```

**Interview Tips:**
- split/map/join is most common and readable
- Regex /\b\w/g matches word boundaries and first character
- \b is word boundary, \w is word character (alphanumeric + underscore)
- Title case rules: lowercase articles, conjunctions, prepositions
- Always capitalize first and last word in title case
- Consider handling hyphens, apostrophes, punctuation
- CSS text-transform: capitalize does similar in styling
- Different style guides (APA, Chicago, MLA) have different rules

</details>

---

## **MEDIUM LEVEL (31-65)**

### **Array Manipulations**

31. Implement array.map() from scratch

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Implementation**
```javascript
/**
 * Implement Array.prototype.map()
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {Function} callback - Function to execute on each element
 * @param {*} thisArg - Value to use as 'this' when executing callback
 * @returns {Array} - New array with results
 */
Array.prototype.myMap = function(callback, thisArg) {
  const result = [];
  
  for (let i = 0; i < this.length; i++) {
    // Check if index exists (handle sparse arrays)
    if (i in this) {
      result[i] = callback.call(thisArg, this[i], i, this);
    }
  }
  
  return result;
};

// Test cases
const numbers = [1, 2, 3, 4, 5];
console.log(numbers.myMap(x => x * 2));
// [2, 4, 6, 8, 10]

console.log(numbers.myMap((x, index) => x + index));
// [1, 3, 5, 7, 9]

const words = ['hello', 'world'];
console.log(words.myMap(word => word.toUpperCase()));
// ['HELLO', 'WORLD']
```

### **Approach 2: With Validation**
```javascript
/**
 * Enhanced map with validation
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
Array.prototype.myMap = function(callback, thisArg) {
  // Validation
  if (this == null) {
    throw new TypeError('Array.prototype.myMap called on null or undefined');
  }
  
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  const O = Object(this);
  const len = O.length >>> 0; // Convert to unsigned 32-bit integer
  const result = new Array(len);
  
  for (let i = 0; i < len; i++) {
    if (i in O) {
      result[i] = callback.call(thisArg, O[i], i, O);
    }
  }
  
  return result;
};

// Test
const arr = [1, 2, 3];
console.log(arr.myMap(x => x * 3));  // [3, 6, 9]
```

### **Approach 3: Handle Sparse Arrays**
```javascript
/**
 * Map that properly handles sparse arrays
 * Sparse arrays have "holes" - indices without values
 */
Array.prototype.myMap = function(callback, thisArg) {
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  const result = [];
  
  for (let i = 0; i < this.length; i++) {
    // Only process indices that exist
    if (i in this) {
      result[i] = callback.call(thisArg, this[i], i, this);
    }
  }
  
  // Preserve array length (including holes)
  result.length = this.length;
  
  return result;
};

// Test with sparse array
const sparse = [1, , 3, , 5]; // Has holes at index 1 and 3
console.log(sparse.myMap(x => x * 2));
// [2, empty, 6, empty, 10]
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready map implementation following ES specification
 * 
 * @param {Function} callback - Function that produces element of new array
 * @param {*} thisArg - Value to use as this when executing callback
 * @returns {Array} - New array with each element being the result of callback
 */
Array.prototype.myMap = function(callback, thisArg) {
  // 1. Let O be ? ToObject(this value)
  if (this == null) {
    throw new TypeError('Array.prototype.myMap called on null or undefined');
  }
  
  const O = Object(this);
  
  // 2. Let len be ? LengthOfArrayLike(O)
  const len = O.length >>> 0;
  
  // 3. If IsCallable(callback) is false, throw a TypeError
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  // 4. Let A be ? ArraySpeciesCreate(O, len)
  const A = new Array(len);
  
  // 5. Let k be 0
  let k = 0;
  
  // 6. Repeat, while k < len
  while (k < len) {
    // a. Let Pk be ! ToString(k)
    const Pk = String(k);
    
    // b. Let kPresent be ? HasProperty(O, Pk)
    const kPresent = Pk in O;
    
    // c. If kPresent is true, then
    if (kPresent) {
      // i. Let kValue be ? Get(O, Pk)
      const kValue = O[Pk];
      
      // ii. Let mappedValue be ? Call(callback, thisArg, « kValue, k, O »)
      const mappedValue = callback.call(thisArg, kValue, k, O);
      
      // iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue)
      A[Pk] = mappedValue;
    }
    
    // d. Set k to k + 1
    k++;
  }
  
  // 7. Return A
  return A;
};

// Alternative: Standalone function (not modifying prototype)
function map(array, callback, thisArg) {
  if (!Array.isArray(array)) {
    throw new TypeError('First argument must be an array');
  }
  
  if (typeof callback !== 'function') {
    throw new TypeError('Second argument must be a function');
  }
  
  const result = new Array(array.length);
  
  for (let i = 0; i < array.length; i++) {
    if (i in array) {
      result[i] = callback.call(thisArg, array[i], i, array);
    }
  }
  
  return result;
}

// Comprehensive test suite
console.log('=== Basic Mapping ===');
const nums = [1, 2, 3, 4, 5];
console.log(nums.myMap(x => x * 2));
// [2, 4, 6, 8, 10]

console.log('\n=== With Index ===');
console.log(nums.myMap((x, i) => x + i));
// [1, 3, 5, 7, 9]

console.log('\n=== With Array Context ===');
console.log(nums.myMap((x, i, arr) => x + arr.length));
// [6, 7, 8, 9, 10]

console.log('\n=== With thisArg ===');
const multiplier = { factor: 10 };
console.log(nums.myMap(function(x) {
  return x * this.factor;
}, multiplier));
// [10, 20, 30, 40, 50]

console.log('\n=== Sparse Arrays ===');
const sparse = [1, , 3, , 5];
console.log(sparse.myMap(x => x * 2));
// [2, empty, 6, empty, 10]

console.log('\n=== Empty Array ===');
console.log([].myMap(x => x * 2));
// []

console.log('\n=== Type Conversion ===');
const strings = ['1', '2', '3'];
console.log(strings.myMap(Number));
// [1, 2, 3]

console.log('\n=== Object Properties ===');
const users = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 }
];
console.log(users.myMap(user => user.name));
// ['John', 'Jane']

console.log('\n=== Standalone Function ===');
console.log(map([1, 2, 3], x => x * 3));
// [3, 6, 9]

// Error cases
console.log('\n=== Error Handling ===');
try {
  [1, 2, 3].myMap('not a function');
} catch (e) {
  console.log(e.message);  // "not a function is not a function"
}

try {
  Array.prototype.myMap.call(null, x => x);
} catch (e) {
  console.log(e.message);  // "Array.prototype.myMap called on null or undefined"
}
```

### **Bonus: Performance Comparison**
```javascript
/**
 * Compare native map vs custom implementation
 */
function benchmarkMap() {
  const largeArray = Array.from({ length: 100000 }, (_, i) => i);
  
  console.time('Native map');
  const native = largeArray.map(x => x * 2);
  console.timeEnd('Native map');
  
  console.time('Custom myMap');
  const custom = largeArray.myMap(x => x * 2);
  console.timeEnd('Custom myMap');
  
  console.log('Results match:', JSON.stringify(native) === JSON.stringify(custom));
}

benchmarkMap();
```

**Interview Tips:**
- map() creates a new array; doesn't modify original
- Callback receives three arguments: element, index, array
- Always returns array of same length as original
- Handles sparse arrays (skips holes)
- thisArg parameter sets 'this' context in callback
- Return value: new array with transformed elements
- Doesn't execute callback for missing indices in sparse arrays
- Common use: transform each element, extract properties

</details>

32. Implement array.filter() from scratch

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Implementation**
```javascript
/**
 * Implement Array.prototype.filter()
 * Time Complexity: O(n)
 * Space Complexity: O(n) worst case
 * 
 * @param {Function} callback - Function to test each element
 * @param {*} thisArg - Value to use as 'this' when executing callback
 * @returns {Array} - New array with elements that pass the test
 */
Array.prototype.myFilter = function(callback, thisArg) {
  const result = [];
  
  for (let i = 0; i < this.length; i++) {
    if (i in this) {
      if (callback.call(thisArg, this[i], i, this)) {
        result.push(this[i]);
      }
    }
  }
  
  return result;
};

// Test cases
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log(numbers.myFilter(x => x % 2 === 0));
// [2, 4, 6, 8, 10]

console.log(numbers.myFilter(x => x > 5));
// [6, 7, 8, 9, 10]

const words = ['hello', 'hi', 'hey', 'greetings'];
console.log(words.myFilter(word => word.length > 3));
// ['hello', 'greetings']
```

### **Approach 2: With Validation**
```javascript
/**
 * Enhanced filter with validation
 * Time Complexity: O(n)
 * Space Complexity: O(k) where k is number of passing elements
 */
Array.prototype.myFilter = function(callback, thisArg) {
  // Validation
  if (this == null) {
    throw new TypeError('Array.prototype.myFilter called on null or undefined');
  }
  
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  const O = Object(this);
  const len = O.length >>> 0;
  const result = [];
  
  for (let i = 0; i < len; i++) {
    if (i in O) {
      const value = O[i];
      if (callback.call(thisArg, value, i, O)) {
        result.push(value);
      }
    }
  }
  
  return result;
};

// Test
const arr = [1, 2, 3, 4, 5];
console.log(arr.myFilter(x => x >= 3));  // [3, 4, 5]
```

### **Approach 3: Handle Edge Cases**
```javascript
/**
 * Filter with comprehensive edge case handling
 */
Array.prototype.myFilter = function(callback, thisArg) {
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  const result = [];
  
  for (let i = 0; i < this.length; i++) {
    // Skip holes in sparse arrays
    if (!(i in this)) continue;
    
    const element = this[i];
    
    // Only add if callback returns truthy value
    if (callback.call(thisArg, element, i, this)) {
      result.push(element);
    }
  }
  
  return result;
};

// Test with sparse array
const sparse = [1, , 3, , 5, , 7];
console.log(sparse.myFilter(x => x > 2));
// [3, 5, 7]
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready filter implementation following ES specification
 * 
 * @param {Function} callback - Predicate function to test each element
 * @param {*} thisArg - Value to use as this when executing callback
 * @returns {Array} - New array with elements that pass the test
 */
Array.prototype.myFilter = function(callback, thisArg) {
  // 1. Let O be ? ToObject(this value)
  if (this == null) {
    throw new TypeError('Array.prototype.myFilter called on null or undefined');
  }
  
  const O = Object(this);
  
  // 2. Let len be ? LengthOfArrayLike(O)
  const len = O.length >>> 0;
  
  // 3. If IsCallable(callback) is false, throw a TypeError
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  // 4. Let A be a new empty List
  const A = [];
  
  // 5. Let k be 0
  let k = 0;
  
  // 6. Repeat, while k < len
  while (k < len) {
    // a. Let Pk be ! ToString(k)
    const Pk = String(k);
    
    // b. Let kPresent be ? HasProperty(O, Pk)
    const kPresent = Pk in O;
    
    // c. If kPresent is true, then
    if (kPresent) {
      // i. Let kValue be ? Get(O, Pk)
      const kValue = O[Pk];
      
      // ii. Let selected be ToBoolean(? Call(callback, thisArg, « kValue, k, O »))
      const selected = callback.call(thisArg, kValue, k, O);
      
      // iii. If selected is true, then
      if (selected) {
        // 1. Append kValue to A
        A.push(kValue);
      }
    }
    
    // d. Set k to k + 1
    k++;
  }
  
  // 7. Return A
  return A;
};

// Alternative: Standalone function (not modifying prototype)
function filter(array, callback, thisArg) {
  if (!Array.isArray(array)) {
    throw new TypeError('First argument must be an array');
  }
  
  if (typeof callback !== 'function') {
    throw new TypeError('Second argument must be a function');
  }
  
  const result = [];
  
  for (let i = 0; i < array.length; i++) {
    if (i in array) {
      const value = array[i];
      if (callback.call(thisArg, value, i, array)) {
        result.push(value);
      }
    }
  }
  
  return result;
}

// Comprehensive test suite
console.log('=== Basic Filtering ===');
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log(nums.myFilter(x => x % 2 === 0));
// [2, 4, 6, 8, 10]

console.log('\n=== With Index ===');
console.log(nums.myFilter((x, i) => i % 2 === 0));
// [1, 3, 5, 7, 9] (elements at even indices)

console.log('\n=== With Array Context ===');
console.log(nums.myFilter((x, i, arr) => x > arr.length / 2));
// [6, 7, 8, 9, 10]

console.log('\n=== With thisArg ===');
const config = { threshold: 5 };
console.log(nums.myFilter(function(x) {
  return x > this.threshold;
}, config));
// [6, 7, 8, 9, 10]

console.log('\n=== Filter Truthy Values ===');
console.log([0, 1, false, 2, '', 3, null, 4].myFilter(Boolean));
// [1, 2, 3, 4]

console.log('\n=== Filter Objects ===');
const users = [
  { name: 'John', age: 30, active: true },
  { name: 'Jane', age: 25, active: false },
  { name: 'Bob', age: 35, active: true }
];
console.log(users.myFilter(user => user.active));
// [{ name: 'John', age: 30, active: true }, { name: 'Bob', age: 35, active: true }]

console.log('\n=== No Matches ===');
console.log([1, 2, 3].myFilter(x => x > 10));
// []

console.log('\n=== All Match ===');
console.log([1, 2, 3].myFilter(x => x > 0));
// [1, 2, 3]

console.log('\n=== Empty Array ===');
console.log([].myFilter(x => true));
// []

console.log('\n=== Sparse Arrays ===');
const sparse = [1, , 3, , 5];
console.log(sparse.myFilter(x => x >= 3));
// [3, 5] (holes are skipped)

console.log('\n=== Standalone Function ===');
console.log(filter([1, 2, 3, 4, 5], x => x % 2 !== 0));
// [1, 3, 5]

// Error cases
console.log('\n=== Error Handling ===');
try {
  [1, 2, 3].myFilter('not a function');
} catch (e) {
  console.log(e.message);  // "not a function is not a function"
}
```

### **Bonus: Filter Variants**
```javascript
/**
 * Find first element that passes test
 */
Array.prototype.myFind = function(callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    if (i in this) {
      if (callback.call(thisArg, this[i], i, this)) {
        return this[i];
      }
    }
  }
  return undefined;
};

/**
 * Find index of first element that passes test
 */
Array.prototype.myFindIndex = function(callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    if (i in this) {
      if (callback.call(thisArg, this[i], i, this)) {
        return i;
      }
    }
  }
  return -1;
};

// Test
const numbers = [1, 2, 3, 4, 5];
console.log(numbers.myFind(x => x > 3));       // 4
console.log(numbers.myFindIndex(x => x > 3));  // 3
```

**Interview Tips:**
- filter() creates a new array; doesn't modify original
- Only includes elements where callback returns truthy value
- Callback receives three arguments: element, index, array
- Result array can be shorter, same length, or empty
- Skips holes in sparse arrays
- Returns empty array if no elements pass
- Common use: remove unwanted elements, select subset
- filter(Boolean) removes all falsy values

</details>

33. Implement array.reduce() from scratch

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Implementation**
```javascript
/**
 * Implement Array.prototype.reduce()
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {Function} callback - Reducer function
 * @param {*} initialValue - Initial accumulator value (optional)
 * @returns {*} - Final accumulated value
 */
Array.prototype.myReduce = function(callback, initialValue) {
  let accumulator;
  let startIndex = 0;
  
  // If no initial value, use first element
  if (arguments.length < 2) {
    if (this.length === 0) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    accumulator = this[0];
    startIndex = 1;
  } else {
    accumulator = initialValue;
  }
  
  for (let i = startIndex; i < this.length; i++) {
    if (i in this) {
      accumulator = callback(accumulator, this[i], i, this);
    }
  }
  
  return accumulator;
};

// Test cases
const numbers = [1, 2, 3, 4, 5];
console.log(numbers.myReduce((sum, x) => sum + x, 0));
// 15

console.log(numbers.myReduce((product, x) => product * x, 1));
// 120

console.log(numbers.myReduce((max, x) => Math.max(max, x)));
// 5
```

### **Approach 2: With Validation**
```javascript
/**
 * Enhanced reduce with validation
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
Array.prototype.myReduce = function(callback, initialValue) {
  // Validation
  if (this == null) {
    throw new TypeError('Array.prototype.myReduce called on null or undefined');
  }
  
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  const O = Object(this);
  const len = O.length >>> 0;
  
  let k = 0;
  let accumulator;
  
  if (arguments.length >= 2) {
    accumulator = initialValue;
  } else {
    // Find first element in array
    let kPresent = false;
    while (!kPresent && k < len) {
      kPresent = k in O;
      if (kPresent) {
        accumulator = O[k];
      }
      k++;
    }
    
    if (!kPresent) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
  }
  
  while (k < len) {
    if (k in O) {
      accumulator = callback(accumulator, O[k], k, O);
    }
    k++;
  }
  
  return accumulator;
};

// Test
const arr = [1, 2, 3, 4];
console.log(arr.myReduce((sum, x) => sum + x));  // 10
```

### **Approach 3: Handle Sparse Arrays**
```javascript
/**
 * Reduce that properly handles sparse arrays
 */
Array.prototype.myReduce = function(callback, initialValue) {
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  const hasInitialValue = arguments.length >= 2;
  let accumulator = initialValue;
  let foundFirst = hasInitialValue;
  
  for (let i = 0; i < this.length; i++) {
    // Skip holes
    if (!(i in this)) continue;
    
    if (!foundFirst) {
      // First element becomes accumulator
      accumulator = this[i];
      foundFirst = true;
    } else {
      accumulator = callback(accumulator, this[i], i, this);
    }
  }
  
  if (!foundFirst) {
    throw new TypeError('Reduce of empty array with no initial value');
  }
  
  return accumulator;
};

// Test with sparse array
const sparse = [, 1, , 2, , 3];
console.log(sparse.myReduce((sum, x) => sum + x, 0));
// 6 (skips holes)
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready reduce implementation following ES specification
 * 
 * @param {Function} callback - Reducer function (accumulator, currentValue, index, array)
 * @param {*} initialValue - Initial value for accumulator
 * @returns {*} - Final accumulated result
 */
Array.prototype.myReduce = function(callback, initialValue) {
  // 1. Let O be ? ToObject(this value)
  if (this == null) {
    throw new TypeError('Array.prototype.myReduce called on null or undefined');
  }
  
  const O = Object(this);
  
  // 2. Let len be ? LengthOfArrayLike(O)
  const len = O.length >>> 0;
  
  // 3. If IsCallable(callback) is false, throw a TypeError
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  // 4. If len = 0 and initialValue is not present, throw a TypeError
  if (len === 0 && arguments.length < 2) {
    throw new TypeError('Reduce of empty array with no initial value');
  }
  
  // 5. Let k be 0
  let k = 0;
  let accumulator;
  
  // 6. If initialValue is present, then
  if (arguments.length >= 2) {
    // a. Set accumulator to initialValue
    accumulator = initialValue;
  } else {
    // 7. Else,
    // a. Let kPresent be false
    let kPresent = false;
    
    // b. Repeat, while kPresent is false and k < len
    while (!kPresent && k < len) {
      // i. Let Pk be ! ToString(k)
      const Pk = String(k);
      
      // ii. Set kPresent to ? HasProperty(O, Pk)
      kPresent = Pk in O;
      
      // iii. If kPresent is true, then
      if (kPresent) {
        // 1. Set accumulator to ? Get(O, Pk)
        accumulator = O[Pk];
      }
      
      // iv. Set k to k + 1
      k++;
    }
    
    // c. If kPresent is false, throw a TypeError
    if (!kPresent) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
  }
  
  // 8. Repeat, while k < len
  while (k < len) {
    // a. Let Pk be ! ToString(k)
    const Pk = String(k);
    
    // b. Let kPresent be ? HasProperty(O, Pk)
    const kPresent = Pk in O;
    
    // c. If kPresent is true, then
    if (kPresent) {
      // i. Let kValue be ? Get(O, Pk)
      const kValue = O[Pk];
      
      // ii. Set accumulator to ? Call(callback, undefined, « accumulator, kValue, k, O »)
      accumulator = callback(accumulator, kValue, k, O);
    }
    
    // d. Set k to k + 1
    k++;
  }
  
  // 9. Return accumulator
  return accumulator;
};

// Alternative: Standalone function
function reduce(array, callback, initialValue) {
  if (!Array.isArray(array)) {
    throw new TypeError('First argument must be an array');
  }
  
  if (typeof callback !== 'function') {
    throw new TypeError('Second argument must be a function');
  }
  
  const hasInitial = arguments.length >= 3;
  let accumulator = initialValue;
  let startIndex = 0;
  
  if (!hasInitial) {
    if (array.length === 0) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    
    // Find first element
    while (startIndex < array.length && !(startIndex in array)) {
      startIndex++;
    }
    
    if (startIndex >= array.length) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    
    accumulator = array[startIndex];
    startIndex++;
  }
  
  for (let i = startIndex; i < array.length; i++) {
    if (i in array) {
      accumulator = callback(accumulator, array[i], i, array);
    }
  }
  
  return accumulator;
}

// Comprehensive test suite
console.log('=== Sum ===');
const nums = [1, 2, 3, 4, 5];
console.log(nums.myReduce((sum, x) => sum + x, 0));
// 15

console.log('\n=== Product ===');
console.log(nums.myReduce((product, x) => product * x, 1));
// 120

console.log('\n=== Max Value ===');
console.log(nums.myReduce((max, x) => Math.max(max, x)));
// 5

console.log('\n=== Build Object ===');
const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' }
];
const userMap = users.myReduce((acc, user) => {
  acc[user.id] = user.name;
  return acc;
}, {});
console.log(userMap);
// { '1': 'John', '2': 'Jane' }

console.log('\n=== Flatten Array ===');
const nested = [[1, 2], [3, 4], [5, 6]];
console.log(nested.myReduce((flat, arr) => flat.concat(arr), []));
// [1, 2, 3, 4, 5, 6]

console.log('\n=== Count Occurrences ===');
const items = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];
const counts = items.myReduce((acc, item) => {
  acc[item] = (acc[item] || 0) + 1;
  return acc;
}, {});
console.log(counts);
// { apple: 3, banana: 2, orange: 1 }

console.log('\n=== No Initial Value ===');
console.log([1, 2, 3, 4].myReduce((sum, x) => sum + x));
// 10 (starts with 1)

console.log('\n=== Single Element ===');
console.log([5].myReduce((sum, x) => sum + x, 10));
// 15

console.log([5].myReduce((sum, x) => sum + x));
// 5 (no reduction happens)

console.log('\n=== Empty Array with Initial ===');
console.log([].myReduce((sum, x) => sum + x, 0));
// 0

console.log('\n=== Sparse Array ===');
const sparse = [1, , 3, , 5];
console.log(sparse.myReduce((sum, x) => sum + x, 0));
// 9 (skips holes)

console.log('\n=== Standalone Function ===');
console.log(reduce([1, 2, 3, 4], (sum, x) => sum + x, 0));
// 10

// Error cases
console.log('\n=== Error Handling ===');
try {
  [].myReduce((sum, x) => sum + x);
} catch (e) {
  console.log(e.message);  // "Reduce of empty array with no initial value"
}

try {
  [1, 2, 3].myReduce('not a function');
} catch (e) {
  console.log(e.message);  // "not a function is not a function"
}
```

### **Bonus: reduceRight() Implementation**
```javascript
/**
 * Implement reduceRight (right-to-left reduction)
 */
Array.prototype.myReduceRight = function(callback, initialValue) {
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  
  const hasInitial = arguments.length >= 2;
  let accumulator = initialValue;
  let k = this.length - 1;
  
  if (!hasInitial) {
    if (this.length === 0) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    
    // Find last element
    while (k >= 0 && !(k in this)) {
      k--;
    }
    
    if (k < 0) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    
    accumulator = this[k];
    k--;
  }
  
  while (k >= 0) {
    if (k in this) {
      accumulator = callback(accumulator, this[k], k, this);
    }
    k--;
  }
  
  return accumulator;
};

// Test
const arr = [1, 2, 3, 4];
console.log(arr.myReduceRight((result, x) => result + x, ''));
// '4321' (processes right to left)
```

**Interview Tips:**
- reduce() processes array left-to-right, accumulating a single value
- Callback receives four arguments: accumulator, currentValue, index, array
- If no initial value, first element is used as accumulator
- Empty array with no initial value throws TypeError
- Skips holes in sparse arrays
- Versatile: can build objects, arrays, count, sum, etc.
- reduceRight() processes right-to-left
- Common uses: sum, product, flatten, grouping, transforming

</details>

34. Find all pairs in an array that sum to a target value

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Brute Force (Nested Loops)**
```javascript
/**
 * Find all pairs that sum to target using brute force
 * Time Complexity: O(n²)
 * Space Complexity: O(k) where k is number of pairs
 * 
 * @param {number[]} arr - Input array
 * @param {number} target - Target sum
 * @returns {Array} - Array of pairs
 */
function findPairs(arr, target) {
  const pairs = [];
  
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] + arr[j] === target) {
        pairs.push([arr[i], arr[j]]);
      }
    }
  }
  
  return pairs;
}

// Test cases
console.log(findPairs([1, 2, 3, 4, 5], 5));
// [[1, 4], [2, 3]]

console.log(findPairs([1, 5, 7, -1, 5], 6));
// [[1, 5], [1, 5], [7, -1]]

console.log(findPairs([1, 2, 3], 10));
// []
```

### **Approach 2: Using Set (Optimal)**
```javascript
/**
 * Find pairs using Set for O(n) time
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * More efficient for large arrays
 */
function findPairs(arr, target) {
  const pairs = [];
  const seen = new Set();
  
  for (const num of arr) {
    const complement = target - num;
    
    if (seen.has(complement)) {
      pairs.push([complement, num]);
    }
    
    seen.add(num);
  }
  
  return pairs;
}

// Test
console.log(findPairs([1, 2, 3, 4, 5], 5));
// [[1, 4], [2, 3]]

console.log(findPairs([3, 5, 2, -4, 8, 11], 7));
// [[5, 2], [11, -4]]
```

### **Approach 3: Two Pointer (For Sorted Array)**
```javascript
/**
 * Find pairs using two pointers (requires sorted array)
 * Time Complexity: O(n log n) for sorting + O(n) for finding
 * Space Complexity: O(1) excluding output
 */
function findPairs(arr, target) {
  const sorted = [...arr].sort((a, b) => a - b);
  const pairs = [];
  let left = 0;
  let right = sorted.length - 1;
  
  while (left < right) {
    const sum = sorted[left] + sorted[right];
    
    if (sum === target) {
      pairs.push([sorted[left], sorted[right]]);
      left++;
      right--;
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  
  return pairs;
}

// Test
console.log(findPairs([1, 5, 3, 7, 2], 8));
// [[1, 7], [3, 5]]
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready pair finder with options
 * 
 * @param {number[]} arr - Input array
 * @param {number} target - Target sum
 * @param {Object} options - Configuration options
 * @param {boolean} options.unique - Return unique pairs only (default: false)
 * @param {boolean} options.indices - Return indices instead of values (default: false)
 * @param {boolean} options.allowDuplicates - Allow same element twice (default: false)
 * @returns {Array} - Array of pairs
 */
function findPairs(arr, target, options = {}) {
  const {
    unique = false,
    indices = false,
    allowDuplicates = false
  } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('First argument must be an array');
  }
  
  if (typeof target !== 'number') {
    throw new TypeError('Target must be a number');
  }
  
  const pairs = [];
  const seen = new Map(); // value -> array of indices
  const usedPairs = new Set(); // for unique pairs
  
  for (let i = 0; i < arr.length; i++) {
    const num = arr[i];
    const complement = target - num;
    
    if (seen.has(complement)) {
      const complementIndices = seen.get(complement);
      
      for (const j of complementIndices) {
        // Skip if not allowing duplicates and it's the same index
        if (!allowDuplicates && i === j) continue;
        
        // Create pair
        let pair;
        if (indices) {
          pair = j < i ? [j, i] : [i, j];
        } else {
          pair = [complement, num];
        }
        
        // Check uniqueness if needed
        if (unique) {
          const pairKey = indices 
            ? `${pair[0]},${pair[1]}`
            : `${Math.min(pair[0], pair[1])},${Math.max(pair[0], pair[1])}`;
          
          if (usedPairs.has(pairKey)) continue;
          usedPairs.add(pairKey);
        }
        
        pairs.push(pair);
        
        // Only add first complementIndex if not allowing multiple pairs per element
        if (!allowDuplicates) break;
      }
    }
    
    // Add current number to seen map
    if (!seen.has(num)) {
      seen.set(num, []);
    }
    seen.get(num).push(i);
  }
  
  return pairs;
}

// Find count of pairs instead of actual pairs
function countPairs(arr, target) {
  const seen = new Map(); // value -> count
  let count = 0;
  
  for (const num of arr) {
    const complement = target - num;
    
    if (seen.has(complement)) {
      count += seen.get(complement);
    }
    
    seen.set(num, (seen.get(num) || 0) + 1);
  }
  
  return count;
}

// Find unique pairs only
function findUniquePairs(arr, target) {
  const sorted = [...arr].sort((a, b) => a - b);
  const pairs = [];
  let left = 0;
  let right = sorted.length - 1;
  
  while (left < right) {
    const sum = sorted[left] + sorted[right];
    
    if (sum === target) {
      pairs.push([sorted[left], sorted[right]]);
      
      // Skip duplicates
      const leftVal = sorted[left];
      const rightVal = sorted[right];
      
      while (left < right && sorted[left] === leftVal) left++;
      while (left < right && sorted[right] === rightVal) right--;
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  
  return pairs;
}

// Comprehensive test suite
console.log('=== Basic Pairs ===');
const nums = [1, 2, 3, 4, 5, 6];
console.log(findPairs(nums, 7));
// [[1, 6], [2, 5], [3, 4]]

console.log('\n=== With Duplicates ===');
const dups = [1, 5, 7, -1, 5];
console.log(findPairs(dups, 6));
// [[1, 5], [1, 5], [7, -1]]

console.log('\n=== Unique Pairs ===');
console.log(findPairs(dups, 6, { unique: true }));
// [[1, 5], [7, -1]]

console.log('\n=== Return Indices ===');
console.log(findPairs([2, 7, 11, 15], 9, { indices: true }));
// [[0, 1]] (indices of 2 and 7)

console.log('\n=== No Pairs Found ===');
console.log(findPairs([1, 2, 3], 10));
// []

console.log('\n=== Negative Numbers ===');
console.log(findPairs([-5, -2, 0, 3, 5, 8], 3));
// [[-5, 8], [-2, 5], [0, 3]]

console.log('\n=== Count Pairs ===');
console.log(countPairs([1, 5, 3, 3, 3], 6));
// 4 (pairs: [3,3], [3,3], [3,3], [1,5])

console.log('\n=== Unique Pairs (Sorted Method) ===');
console.log(findUniquePairs([1, 1, 2, 3, 3, 4, 5], 5));
// [[1, 4], [2, 3]]

console.log('\n=== Same Number Twice ===');
const arr = [3, 3];
console.log(findPairs(arr, 6));
// [[3, 3]]

console.log(findPairs([3], 6, { allowDuplicates: true }));
// [] (can't pair with itself unless array has duplicate)
```

### **Bonus: K-Sum Problem (Generalized)**
```javascript
/**
 * Find all pairs/triplets/quadruplets that sum to target
 */
function kSum(arr, target, k) {
  const result = [];
  
  function helper(start, k, currentSum, path) {
    if (k === 0) {
      if (currentSum === target) {
        result.push([...path]);
      }
      return;
    }
    
    for (let i = start; i < arr.length; i++) {
      helper(i + 1, k - 1, currentSum + arr[i], [...path, arr[i]]);
    }
  }
  
  helper(0, k, 0, []);
  return result;
}

// Test
console.log(kSum([1, 2, 3, 4, 5], 9, 2));  // 2-sum (pairs)
// [[1, 8], [2, 7], [3, 6], [4, 5]]

console.log(kSum([1, 2, 3, 4], 6, 3));     // 3-sum (triplets)
// [[1, 2, 3]]
```

**Interview Tips:**
- Hash Set approach is optimal: O(n) time, O(n) space
- Brute force is O(n²) but uses O(1) space (excluding output)
- Two pointer works for sorted arrays: O(n log n)
- Clarify: should handle duplicates? Return indices or values?
- Clarify: can use same element twice? (e.g., [3, 3] for target 6)
- For unique pairs, use Set or two-pointer on sorted array
- Can extend to 3-sum, 4-sum with similar approaches
- Common interview variation: return just one pair vs all pairs

</details>

35. Rotate an array by k positions

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using slice() and concat()**
```javascript
/**
 * Rotate array to the right by k positions
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {Array} arr - Input array
 * @param {number} k - Number of positions to rotate
 * @returns {Array} - Rotated array
 */
function rotateArray(arr, k) {
  const n = arr.length;
  if (n === 0) return arr;
  
  // Normalize k (handle k > n)
  k = k % n;
  
  // Split and recombine
  return arr.slice(-k).concat(arr.slice(0, -k));
}

// Test cases
console.log(rotateArray([1, 2, 3, 4, 5], 2));
// [4, 5, 1, 2, 3]

console.log(rotateArray([1, 2, 3, 4, 5, 6, 7], 3));
// [5, 6, 7, 1, 2, 3, 4]

console.log(rotateArray([1, 2], 5));
// [2, 1] (5 % 2 = 1)
```

### **Approach 2: Using Array Destructuring**
```javascript
/**
 * Rotate using spread operator
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function rotateArray(arr, k) {
  const n = arr.length;
  if (n === 0) return arr;
  
  k = k % n;
  
  return [...arr.slice(-k), ...arr.slice(0, -k)];
}

// Test
console.log(rotateArray([1, 2, 3, 4, 5], 2));
// [4, 5, 1, 2, 3]
```

### **Approach 3: In-Place Rotation (Reversal Algorithm)**
```javascript
/**
 * Rotate in-place using reversal algorithm
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Algorithm:
 * 1. Reverse entire array
 * 2. Reverse first k elements
 * 3. Reverse remaining n-k elements
 */
function rotateArray(arr, k) {
  const n = arr.length;
  if (n === 0) return arr;
  
  k = k % n;
  
  // Helper to reverse a portion of array
  function reverse(start, end) {
    while (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]];
      start++;
      end--;
    }
  }
  
  // Reverse entire array
  reverse(0, n - 1);
  
  // Reverse first k elements
  reverse(0, k - 1);
  
  // Reverse remaining elements
  reverse(k, n - 1);
  
  return arr;
}

// Test
const arr = [1, 2, 3, 4, 5, 6, 7];
console.log(rotateArray(arr, 3));
// [5, 6, 7, 1, 2, 3, 4]
```

### **Approach 4: Using unshift() and pop()**
```javascript
/**
 * Rotate by moving elements one at a time
 * Time Complexity: O(n * k)
 * Space Complexity: O(1)
 * 
 * Less efficient but simple
 */
function rotateArray(arr, k) {
  k = k % arr.length;
  
  for (let i = 0; i < k; i++) {
    arr.unshift(arr.pop());
  }
  
  return arr;
}

// Test
console.log(rotateArray([1, 2, 3, 4, 5], 2));
// [4, 5, 1, 2, 3]
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready array rotation with options
 * 
 * @param {Array} arr - Input array
 * @param {number} k - Number of positions to rotate
 * @param {Object} options - Rotation options
 * @param {string} options.direction - 'right' or 'left' (default: 'right')
 * @param {boolean} options.inPlace - Modify array in place (default: false)
 * @returns {Array} - Rotated array
 */
function rotateArray(arr, k, options = {}) {
  const { direction = 'right', inPlace = false } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('First argument must be an array');
  }
  
  if (typeof k !== 'number' || !Number.isInteger(k)) {
    throw new TypeError('k must be an integer');
  }
  
  const n = arr.length;
  
  if (n === 0 || k === 0) {
    return inPlace ? arr : [...arr];
  }
  
  // Normalize k
  k = ((k % n) + n) % n; // Handle negative k
  
  // Adjust for direction
  if (direction === 'left') {
    k = n - k;
  }
  
  if (inPlace) {
    // In-place rotation using reversal
    function reverse(start, end) {
      while (start < end) {
        [arr[start], arr[end]] = [arr[end], arr[start]];
        start++;
        end--;
      }
    }
    
    reverse(0, n - 1);
    reverse(0, k - 1);
    reverse(k, n - 1);
    
    return arr;
  } else {
    // Create new array
    return [...arr.slice(-k), ...arr.slice(0, -k)];
  }
}

// Rotate left
function rotateLeft(arr, k) {
  return rotateArray(arr, k, { direction: 'left' });
}

// Rotate right
function rotateRight(arr, k) {
  return rotateArray(arr, k, { direction: 'right' });
}

// Comprehensive test suite
console.log('=== Rotate Right ===');
console.log(rotateArray([1, 2, 3, 4, 5], 2));
// [4, 5, 1, 2, 3]

console.log('\n=== Rotate Left ===');
console.log(rotateArray([1, 2, 3, 4, 5], 2, { direction: 'left' }));
// [3, 4, 5, 1, 2]

console.log('\n=== In-Place ===');
const arr1 = [1, 2, 3, 4, 5];
rotateArray(arr1, 2, { inPlace: true });
console.log(arr1);
// [4, 5, 1, 2, 3]

console.log('\n=== k > length ===');
console.log(rotateArray([1, 2, 3], 5));
// [2, 3, 1] (5 % 3 = 2)

console.log('\n=== Negative k (Rotate Left) ===');
console.log(rotateArray([1, 2, 3, 4, 5], -2));
// [3, 4, 5, 1, 2]

console.log('\n=== k = 0 ===');
console.log(rotateArray([1, 2, 3], 0));
// [1, 2, 3]

console.log('\n=== Empty Array ===');
console.log(rotateArray([], 5));
// []

console.log('\n=== Single Element ===');
console.log(rotateArray([1], 10));
// [1]

console.log('\n=== Helper Functions ===');
console.log(rotateLeft([1, 2, 3, 4, 5], 2));
// [3, 4, 5, 1, 2]

console.log(rotateRight([1, 2, 3, 4, 5], 2));
// [4, 5, 1, 2, 3]
```

### **Bonus: Rotate 2D Matrix**
```javascript
/**
 * Rotate 2D matrix 90 degrees clockwise
 */
function rotateMatrix(matrix) {
  const n = matrix.length;
  
  // Transpose
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    }
  }
  
  // Reverse each row
  for (let i = 0; i < n; i++) {
    matrix[i].reverse();
  }
  
  return matrix;
}

// Test
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

console.log(rotateMatrix(matrix));
/*
[
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3]
]
*/
```

**Interview Tips:**
- Clarify: rotate right or left? In-place or new array?
- Handle k > array.length by using modulo: k % n
- Reversal algorithm is optimal for in-place: O(n) time, O(1) space
- slice/concat creates new array: O(n) time, O(n) space
- Negative k can mean rotate in opposite direction
- For very large k, always normalize with modulo
- Common variation: rotate 2D matrix 90 degrees

</details>

36. Find the longest consecutive sequence in an array

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Sort First (Simple)**
```javascript
/**
 * Find longest consecutive sequence by sorting
 * Time Complexity: O(n log n) due to sorting
 * Space Complexity: O(1) or O(n) depending on sort
 * 
 * @param {number[]} arr - Input array
 * @returns {number} - Length of longest sequence
 */
function longestConsecutive(arr) {
  if (arr.length === 0) return 0;
  
  // Sort array
  const sorted = [...arr].sort((a, b) => a - b);
  
  let longest = 1;
  let current = 1;
  
  for (let i = 1; i < sorted.length; i++) {
    // Skip duplicates
    if (sorted[i] === sorted[i - 1]) continue;
    
    // Check if consecutive
    if (sorted[i] === sorted[i - 1] + 1) {
      current++;
      longest = Math.max(longest, current);
    } else {
      current = 1;
    }
  }
  
  return longest;
}

// Test cases
console.log(longestConsecutive([100, 4, 200, 1, 3, 2]));
// 4 (sequence: 1, 2, 3, 4)

console.log(longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]));
// 9 (sequence: 0, 1, 2, 3, 4, 5, 6, 7, 8)
```

### **Approach 2: Using Set (Optimal)**
```javascript
/**
 * Find longest consecutive using Set
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Only start counting from numbers that are sequence starts
 */
function longestConsecutive(arr) {
  if (arr.length === 0) return 0;
  
  const numSet = new Set(arr);
  let longest = 0;
  
  for (const num of numSet) {
    // Only start sequence if this is the beginning
    // (if num-1 doesn't exist, this is a sequence start)
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1;
      
      // Count consecutive numbers
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }
      
      longest = Math.max(longest, currentLength);
    }
  }
  
  return longest;
}

// Test
console.log(longestConsecutive([100, 4, 200, 1, 3, 2]));
// 4

console.log(longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]));
// 9
```

### **Approach 3: Using Map (Track Ranges)**
```javascript
/**
 * Find consecutive using Map to track ranges
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function longestConsecutive(arr) {
  if (arr.length === 0) return 0;
  
  const map = new Map(); // number -> length of sequence containing it
  let longest = 0;
  
  for (const num of arr) {
    if (map.has(num)) continue; // Skip duplicates
    
    // Check if num-1 and num+1 exist
    const left = map.get(num - 1) || 0;
    const right = map.get(num + 1) || 0;
    
    // Current sequence length
    const length = left + right + 1;
    longest = Math.max(longest, length);
    
    // Update endpoints of the sequence
    map.set(num, length);
    map.set(num - left, length);
    map.set(num + right, length);
  }
  
  return longest;
}

// Test
console.log(longestConsecutive([100, 4, 200, 1, 3, 2]));
// 4
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready longest consecutive sequence finder
 * 
 * @param {number[]} arr - Input array
 * @param {Object} options - Configuration options
 * @param {boolean} options.returnSequence - Return actual sequence (default: false)
 * @param {boolean} options.allowGaps - Allow gaps of size n (default: 0)
 * @returns {number|Array} - Length or actual sequence
 */
function longestConsecutive(arr, options = {}) {
  const { returnSequence = false, allowGaps = 0 } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  if (arr.length === 0) {
    return returnSequence ? [] : 0;
  }
  
  const numSet = new Set(arr);
  let longest = 0;
  let longestSequence = [];
  
  for (const num of numSet) {
    // Only start from sequence beginnings
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1;
      let sequence = [num];
      
      // Build sequence
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
        sequence.push(currentNum);
      }
      
      if (currentLength > longest) {
        longest = currentLength;
        longestSequence = sequence;
      }
    }
  }
  
  return returnSequence ? longestSequence : longest;
}

// Find all consecutive sequences
function findAllSequences(arr) {
  if (arr.length === 0) return [];
  
  const numSet = new Set(arr);
  const sequences = [];
  
  for (const num of numSet) {
    if (!numSet.has(num - 1)) {
      const sequence = [num];
      let currentNum = num;
      
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        sequence.push(currentNum);
      }
      
      if (sequence.length > 1) {
        sequences.push(sequence);
      }
    }
  }
  
  return sequences.sort((a, b) => b.length - a.length);
}

// Get starting number of longest sequence
function longestConsecutiveStart(arr) {
  if (arr.length === 0) return null;
  
  const numSet = new Set(arr);
  let longest = 0;
  let startNum = null;
  
  for (const num of numSet) {
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1;
      
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }
      
      if (currentLength > longest) {
        longest = currentLength;
        startNum = num;
      }
    }
  }
  
  return startNum;
}

// Comprehensive test suite
console.log('=== Basic Test ===');
console.log(longestConsecutive([100, 4, 200, 1, 3, 2]));
// 4

console.log('\n=== Long Sequence ===');
console.log(longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]));
// 9

console.log('\n=== Return Sequence ===');
console.log(longestConsecutive([100, 4, 200, 1, 3, 2], { returnSequence: true }));
// [1, 2, 3, 4]

console.log('\n=== With Duplicates ===');
console.log(longestConsecutive([1, 2, 0, 1, 1, 2, 3, 4]));
// 5 (0, 1, 2, 3, 4)

console.log('\n=== No Sequence ===');
console.log(longestConsecutive([10, 20, 30]));
// 1

console.log('\n=== All Consecutive ===');
console.log(longestConsecutive([5, 6, 7, 8, 9]));
// 5

console.log('\n=== Negative Numbers ===');
console.log(longestConsecutive([-1, -2, 0, 1, 2, -3]));
// 6 (-3, -2, -1, 0, 1, 2)

console.log('\n=== Empty Array ===');
console.log(longestConsecutive([]));
// 0

console.log('\n=== Find All Sequences ===');
console.log(findAllSequences([100, 4, 200, 1, 3, 2, 201, 202]));
// [[1, 2, 3, 4], [200, 201, 202]]

console.log('\n=== Get Start Number ===');
console.log(longestConsecutiveStart([100, 4, 200, 1, 3, 2]));
// 1
```

### **Bonus: Consecutive Subarray Sum**
```javascript
/**
 * Find longest subarray with consecutive numbers (order doesn't matter)
 */
function longestConsecutiveSubarray(arr) {
  let maxLength = 0;
  
  for (let i = 0; i < arr.length; i++) {
    const seen = new Set();
    let min = arr[i];
    let max = arr[i];
    seen.add(arr[i]);
    
    for (let j = i + 1; j < arr.length; j++) {
      if (seen.has(arr[j])) break; // Duplicate
      
      seen.add(arr[j]);
      min = Math.min(min, arr[j]);
      max = Math.max(max, arr[j]);
      
      // Check if all numbers in range [min, max] are present
      if (max - min === j - i) {
        maxLength = Math.max(maxLength, j - i + 1);
      }
    }
  }
  
  return maxLength;
}

// Test
console.log(longestConsecutiveSubarray([1, 4, 2, 3, 6, 5]));
// 6 (entire array is consecutive: 1, 2, 3, 4, 5, 6)
```

**Interview Tips:**
- Set-based solution is optimal: O(n) time and space
- Key insight: only check sequences starting from their minimum
- Sorting approach is O(n log n) but simpler
- Handle duplicates by using Set
- Can return length, sequence, or starting position
- Similar to "Union Find" problem
- Common follow-up: find all sequences, not just longest

</details>

37. Implement chunk array (split array into chunks of size n)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using slice() in Loop**
```javascript
/**
 * Split array into chunks of size n
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {Array} arr - Input array
 * @param {number} size - Chunk size
 * @returns {Array} - Array of chunks
 */
function chunk(arr, size) {
  const result = [];
  
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  
  return result;
}

// Test cases
console.log(chunk([1, 2, 3, 4, 5, 6, 7, 8], 3));
// [[1, 2, 3], [4, 5, 6], [7, 8]]

console.log(chunk([1, 2, 3, 4, 5], 2));
// [[1, 2], [3, 4], [5]]

console.log(chunk([1, 2, 3], 5));
// [[1, 2, 3]]
```

### **Approach 2: Using Array.from()**
```javascript
/**
 * Chunk using Array.from with mapping function
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function chunk(arr, size) {
  return Array.from(
    { length: Math.ceil(arr.length / size) },
    (_, i) => arr.slice(i * size, i * size + size)
  );
}

// Test
console.log(chunk([1, 2, 3, 4, 5, 6, 7], 2));
// [[1, 2], [3, 4], [5, 6], [7]]
```

### **Approach 3: Using reduce()**
```javascript
/**
 * Chunk using reduce
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function chunk(arr, size) {
  return arr.reduce((chunks, item, index) => {
    const chunkIndex = Math.floor(index / size);
    
    if (!chunks[chunkIndex]) {
      chunks[chunkIndex] = [];
    }
    
    chunks[chunkIndex].push(item);
    return chunks;
  }, []);
}

// Test
console.log(chunk([1, 2, 3, 4, 5, 6], 2));
// [[1, 2], [3, 4], [5, 6]]
```

### **Approach 4: Using splice() (Mutating)**
```javascript
/**
 * Chunk by mutating original array
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * Warning: modifies original array
 */
function chunk(arr, size) {
  const result = [];
  
  while (arr.length > 0) {
    result.push(arr.splice(0, size));
  }
  
  return result;
}

// Test
const data = [1, 2, 3, 4, 5, 6, 7];
console.log(chunk(data, 3));
// [[1, 2, 3], [4, 5, 6], [7]]
console.log(data);  // [] (original is now empty)
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready array chunking with options
 * 
 * @param {Array} arr - Input array
 * @param {number} size - Chunk size
 * @param {Object} options - Chunking options
 * @param {boolean} options.balanced - Balance chunk sizes (default: false)
 * @param {boolean} options.fillLast - Fill last chunk to size (default: false)
 * @param {*} options.fillValue - Value to use for filling (default: undefined)
 * @returns {Array} - Array of chunks
 */
function chunk(arr, size, options = {}) {
  const { balanced = false, fillLast = false, fillValue } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('First argument must be an array');
  }
  
  if (!Number.isInteger(size) || size <= 0) {
    throw new TypeError('Chunk size must be a positive integer');
  }
  
  if (arr.length === 0) {
    return [];
  }
  
  // Balanced chunking (distribute elements evenly)
  if (balanced) {
    const numChunks = Math.ceil(arr.length / size);
    const baseSize = Math.floor(arr.length / numChunks);
    const remainder = arr.length % numChunks;
    
    const result = [];
    let index = 0;
    
    for (let i = 0; i < numChunks; i++) {
      // First 'remainder' chunks get one extra element
      const chunkSize = i < remainder ? baseSize + 1 : baseSize;
      result.push(arr.slice(index, index + chunkSize));
      index += chunkSize;
    }
    
    return result;
  }
  
  // Standard chunking
  const result = [];
  
  for (let i = 0; i < arr.length; i += size) {
    const chunk = arr.slice(i, i + size);
    
    // Fill last chunk if requested
    if (fillLast && i + size > arr.length) {
      while (chunk.length < size) {
        chunk.push(fillValue);
      }
    }
    
    result.push(chunk);
  }
  
  return result;
}

// Chunk with overlap
function chunkWithOverlap(arr, size, overlap) {
  if (overlap >= size) {
    throw new Error('Overlap must be less than chunk size');
  }
  
  const result = [];
  const step = size - overlap;
  
  for (let i = 0; i < arr.length; i += step) {
    const chunk = arr.slice(i, i + size);
    if (chunk.length === size) {
      result.push(chunk);
    }
  }
  
  return result;
}

// Chunk into n groups
function chunkIntoN(arr, n) {
  const result = [];
  const chunkSize = Math.ceil(arr.length / n);
  
  for (let i = 0; i < arr.length; i += chunkSize) {
    result.push(arr.slice(i, i + chunkSize));
  }
  
  return result;
}

// Comprehensive test suite
console.log('=== Basic Chunking ===');
console.log(chunk([1, 2, 3, 4, 5, 6, 7, 8], 3));
// [[1, 2, 3], [4, 5, 6], [7, 8]]

console.log('\n=== Exact Division ===');
console.log(chunk([1, 2, 3, 4, 5, 6], 2));
// [[1, 2], [3, 4], [5, 6]]

console.log('\n=== Size Larger Than Array ===');
console.log(chunk([1, 2, 3], 5));
// [[1, 2, 3]]

console.log('\n=== Empty Array ===');
console.log(chunk([], 3));
// []

console.log('\n=== Balanced Chunking ===');
console.log(chunk([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, { balanced: true }));
// [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
// More balanced than [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

console.log('\n=== Fill Last Chunk ===');
console.log(chunk([1, 2, 3, 4, 5], 2, { fillLast: true, fillValue: null }));
// [[1, 2], [3, 4], [5, null]]

console.log('\n=== With Overlap ===');
console.log(chunkWithOverlap([1, 2, 3, 4, 5, 6, 7], 3, 1));
// [[1, 2, 3], [3, 4, 5], [5, 6, 7]]

console.log('\n=== Chunk Into N Groups ===');
console.log(chunkIntoN([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3));
// [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]

console.log('\n=== Single Element Per Chunk ===');
console.log(chunk([1, 2, 3, 4], 1));
// [[1], [2], [3], [4]]
```

### **Bonus: Chunk String**
```javascript
/**
 * Chunk a string into array of substrings
 */
function chunkString(str, size) {
  const chunks = [];
  
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size));
  }
  
  return chunks;
}

// Or using regex
function chunkString(str, size) {
  const regex = new RegExp(`.{1,${size}}`, 'g');
  return str.match(regex) || [];
}

// Test
console.log(chunkString('abcdefghij', 3));
// ['abc', 'def', 'ghi', 'j']

console.log(chunkString('hello world', 5));
// ['hello', ' worl', 'd']
```

**Interview Tips:**
- slice() is non-mutating and safest approach
- splice() mutates original array - avoid unless needed
- Handle edge cases: empty array, size > length, size = 1
- Balanced chunking distributes elements more evenly
- Can add overlap for sliding window applications
- Common use: pagination, batch processing, parallel processing
- Consider lodash.chunk() for production

</details>

38. Find all subarrays that sum to zero

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Brute Force (Check All Subarrays)**
```javascript
/**
 * Find all subarrays with sum = 0 using brute force
 * Time Complexity: O(n²)
 * Space Complexity: O(k) where k is result size
 * 
 * @param {number[]} arr - Input array
 * @returns {Array} - Array of subarrays that sum to 0
 */
function findZeroSumSubarrays(arr) {
  const result = [];
  
  for (let i = 0; i < arr.length; i++) {
    let sum = 0;
    
    for (let j = i; j < arr.length; j++) {
      sum += arr[j];
      
      if (sum === 0) {
        result.push(arr.slice(i, j + 1));
      }
    }
  }
  
  return result;
}

// Test cases
console.log(findZeroSumSubarrays([4, 2, -3, 1, 6]));
// [[2, -3, 1]]

console.log(findZeroSumSubarrays([3, 4, -7, 3, 1, 3, 1, -4, -2, -2]));
// [[3, 4, -7], [3, 1, -4], [3, 4, -7, 3, 1, 3, 1, -4, -2, -2]]

console.log(findZeroSumSubarrays([0, 1, -1, 0]));
// [[0], [1, -1], [0]]
```

### **Approach 2: Using Prefix Sum with HashMap**
```javascript
/**
 * Find zero-sum subarrays using prefix sums
 * Time Complexity: O(n²) worst case, but more efficient in practice
 * Space Complexity: O(n)
 * 
 * If sum[i] == sum[j], then subarray (i, j] has sum 0
 */
function findZeroSumSubarrays(arr) {
  const result = [];
  const sumMap = new Map();
  sumMap.set(0, [-1]); // Handle subarrays starting from index 0
  
  let sum = 0;
  
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
    
    if (sumMap.has(sum)) {
      // All indices where this sum occurred before
      const indices = sumMap.get(sum);
      
      for (const startIndex of indices) {
        result.push(arr.slice(startIndex + 1, i + 1));
      }
    }
    
    // Store current index for this sum
    if (!sumMap.has(sum)) {
      sumMap.set(sum, []);
    }
    sumMap.get(sum).push(i);
  }
  
  return result;
}

// Test
console.log(findZeroSumSubarrays([4, 2, -3, 1, 6]));
// [[2, -3, 1]]

console.log(findZeroSumSubarrays([1, -1, 2, -2, 3, -3]));
// [[1, -1], [2, -2], [3, -3], [1, -1, 2, -2], [2, -2, 3, -3], [1, -1, 2, -2, 3, -3]]
```

### **Approach 3: Count Zero-Sum Subarrays**
```javascript
/**
 * Just count how many subarrays sum to zero
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function countZeroSumSubarrays(arr) {
  const sumMap = new Map();
  sumMap.set(0, 1); // Empty subarray
  
  let sum = 0;
  let count = 0;
  
  for (const num of arr) {
    sum += num;
    
    if (sumMap.has(sum)) {
      count += sumMap.get(sum);
    }
    
    sumMap.set(sum, (sumMap.get(sum) || 0) + 1);
  }
  
  return count;
}

// Test
console.log(countZeroSumSubarrays([4, 2, -3, 1, 6]));
// 1

console.log(countZeroSumSubarrays([1, -1, 2, -2]));
// 3 ([1, -1], [2, -2], [1, -1, 2, -2])
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready zero-sum subarray finder
 * 
 * @param {number[]} arr - Input array
 * @param {Object} options - Find options
 * @param {number} options.target - Target sum (default: 0)
 * @param {boolean} options.returnIndices - Return indices instead of subarrays
 * @param {boolean} options.countOnly - Return count only
 * @returns {Array|number} - Subarrays, indices, or count
 */
function findZeroSumSubarrays(arr, options = {}) {
  const {
    target = 0,
    returnIndices = false,
    countOnly = false
  } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  if (arr.length === 0) {
    return countOnly ? 0 : [];
  }
  
  const sumMap = new Map();
  sumMap.set(0, [-1]);
  
  let sum = 0;
  let count = 0;
  const result = [];
  
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
    const lookingFor = sum - target;
    
    if (sumMap.has(lookingFor)) {
      const indices = sumMap.get(lookingFor);
      
      for (const startIndex of indices) {
        count++;
        
        if (!countOnly) {
          if (returnIndices) {
            result.push([startIndex + 1, i]);
          } else {
            result.push(arr.slice(startIndex + 1, i + 1));
          }
        }
      }
    }
    
    if (!sumMap.has(sum)) {
      sumMap.set(sum, []);
    }
    sumMap.get(sum).push(i);
  }
  
  return countOnly ? count : result;
}

// Check if array has any zero-sum subarray
function hasZeroSumSubarray(arr) {
  const seen = new Set([0]);
  let sum = 0;
  
  for (const num of arr) {
    sum += num;
    
    if (seen.has(sum)) {
      return true;
    }
    
    seen.add(sum);
  }
  
  return false;
}

// Find longest zero-sum subarray
function longestZeroSumSubarray(arr) {
  const sumMap = new Map();
  sumMap.set(0, -1);
  
  let sum = 0;
  let maxLength = 0;
  let result = [];
  
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
    
    if (sumMap.has(sum)) {
      const length = i - sumMap.get(sum);
      if (length > maxLength) {
        maxLength = length;
        result = arr.slice(sumMap.get(sum) + 1, i + 1);
      }
    } else {
      sumMap.set(sum, i);
    }
  }
  
  return result;
}

// Comprehensive test suite
console.log('=== Find All Subarrays ===');
console.log(findZeroSumSubarrays([4, 2, -3, 1, 6]));
// [[2, -3, 1]]

console.log('\n=== With Single Zeros ===');
console.log(findZeroSumSubarrays([0, 1, -1, 0]));
// [[0], [1, -1], [0, 1, -1, 0], [0]]

console.log('\n=== Count Only ===');
console.log(findZeroSumSubarrays([1, -1, 2, -2], { countOnly: true }));
// 3

console.log('\n=== Return Indices ===');
console.log(findZeroSumSubarrays([4, 2, -3, 1, 6], { returnIndices: true }));
// [[1, 3]] (indices of subarray [2, -3, 1])

console.log('\n=== Target Sum (Not Zero) ===');
console.log(findZeroSumSubarrays([1, 2, 3, 4, 5], { target: 9 }));
// [[2, 3, 4], [4, 5]]

console.log('\n=== Has Zero-Sum Subarray ===');
console.log(hasZeroSumSubarray([4, 2, -3, 1, 6]));
// true

console.log(hasZeroSumSubarray([1, 2, 3, 4]));
// false

console.log('\n=== Longest Zero-Sum Subarray ===');
console.log(longestZeroSumSubarray([3, 4, -7, 3, 1, 3, 1, -4, -2, -2]));
// [3, 4, -7, 3, 1, 3, 1, -4, -2, -2] (length 10)

console.log(longestZeroSumSubarray([1, -1, 3, 2, -2, -3, 3]));
// [1, -1, 3, 2, -2, -3, 3] (length 7, entire array)

console.log('\n=== No Zero-Sum Subarray ===');
console.log(findZeroSumSubarrays([1, 2, 3, 4]));
// []

console.log('\n=== All Negative ===');
console.log(findZeroSumSubarrays([-1, -2, -3]));
// []

console.log('\n=== Complex Case ===');
console.log(findZeroSumSubarrays([1, 2, -3, 4, -4, 5, -5]));
// [[1, 2, -3], [4, -4], [5, -5], [4, -4, 5, -5]]
```

### **Bonus: Maximum Length Subarray with Sum K**
```javascript
/**
 * Find maximum length subarray with sum = k
 */
function maxLengthSumK(arr, k) {
  const sumMap = new Map();
  sumMap.set(0, -1);
  
  let sum = 0;
  let maxLength = 0;
  
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
    
    if (sumMap.has(sum - k)) {
      maxLength = Math.max(maxLength, i - sumMap.get(sum - k));
    }
    
    if (!sumMap.has(sum)) {
      sumMap.set(sum, i);
    }
  }
  
  return maxLength;
}

// Test
console.log(maxLengthSumK([10, 5, 2, 7, 1, 9], 15));
// 4 (subarray [5, 2, 7, 1])
```

**Interview Tips:**
- Prefix sum approach is key insight
- If sum[i] == sum[j], then subarray (i, j] sums to 0
- Use HashMap to store sum -> indices mapping
- O(n) time for counting, O(n²) worst case for finding all
- Can generalize to find subarrays with sum = k
- Single zero counts as zero-sum subarray
- Common follow-ups: longest zero-sum, count, check existence

</details>

39. Sort an array of objects by multiple properties

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using sort() with Multiple Comparisons**
```javascript
/**
 * Sort array of objects by multiple properties
 * Time Complexity: O(n log n)
 * Space Complexity: O(1) or O(log n) depending on sort implementation
 * 
 * @param {Array} arr - Array of objects
 * @param {Array} keys - Array of property names to sort by
 * @returns {Array} - Sorted array
 */
function sortByMultiple(arr, keys) {
  return arr.sort((a, b) => {
    for (const key of keys) {
      if (a[key] < b[key]) return -1;
      if (a[key] > b[key]) return 1;
    }
    return 0;
  });
}

// Test cases
const users = [
  { name: 'John', age: 30, score: 85 },
  { name: 'Jane', age: 25, score: 90 },
  { name: 'Bob', age: 30, score: 75 },
  { name: 'Alice', age: 25, score: 90 }
];

console.log(sortByMultiple(users, ['age', 'score']));
/*
[
  { name: 'Jane', age: 25, score: 90 },
  { name: 'Alice', age: 25, score: 90 },
  { name: 'Bob', age: 30, score: 75 },
  { name: 'John', age: 30, score: 85 }
]
*/
```

### **Approach 2: With Ascending/Descending Order**
```javascript
/**
 * Sort with order specification for each property
 * Time Complexity: O(n log n)
 * Space Complexity: O(1)
 * 
 * @param {Array} arr - Array of objects
 * @param {Array} sortBy - Array of {key, order} objects
 */
function sortByMultiple(arr, sortBy) {
  return arr.sort((a, b) => {
    for (const { key, order = 'asc' } of sortBy) {
      const aVal = a[key];
      const bVal = b[key];
      
      let comparison = 0;
      
      if (aVal < bVal) comparison = -1;
      else if (aVal > bVal) comparison = 1;
      
      if (comparison !== 0) {
        return order === 'asc' ? comparison : -comparison;
      }
    }
    return 0;
  });
}

// Test
const data = [
  { name: 'John', age: 30, score: 85 },
  { name: 'Jane', age: 25, score: 90 },
  { name: 'Bob', age: 30, score: 75 }
];

console.log(sortByMultiple(data, [
  { key: 'age', order: 'asc' },
  { key: 'score', order: 'desc' }
]));
/*
[
  { name: 'Jane', age: 25, score: 90 },
  { name: 'John', age: 30, score: 85 },
  { name: 'Bob', age: 30, score: 75 }
]
*/
```

### **Approach 3: Using localeCompare for Strings**
```javascript
/**
 * Sort with proper string comparison
 * Time Complexity: O(n log n)
 * Space Complexity: O(1)
 */
function sortByMultiple(arr, keys) {
  return arr.sort((a, b) => {
    for (const key of keys) {
      const aVal = a[key];
      const bVal = b[key];
      
      // String comparison
      if (typeof aVal === 'string' && typeof bVal === 'string') {
        const comparison = aVal.localeCompare(bVal);
        if (comparison !== 0) return comparison;
      }
      // Number comparison
      else {
        if (aVal < bVal) return -1;
        if (aVal > bVal) return 1;
      }
    }
    return 0;
  });
}

// Test
const people = [
  { firstName: 'John', lastName: 'Doe', age: 30 },
  { firstName: 'Jane', lastName: 'Doe', age: 25 },
  { firstName: 'Bob', lastName: 'Smith', age: 30 }
];

console.log(sortByMultiple(people, ['lastName', 'firstName']));
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready multi-property sorter
 * 
 * @param {Array} arr - Array of objects to sort
 * @param {Array|Object} criteria - Sort criteria
 * @param {Object} options - Sort options
 * @param {boolean} options.clone - Sort a copy instead of in-place
 * @param {boolean} options.stable - Maintain stable sort (preserve original order for equal elements)
 * @returns {Array} - Sorted array
 */
function sortByMultiple(arr, criteria, options = {}) {
  const { clone = false, stable = false } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('First argument must be an array');
  }
  
  // Normalize criteria to array format
  let sortCriteria;
  if (typeof criteria === 'string') {
    sortCriteria = [{ key: criteria, order: 'asc' }];
  } else if (Array.isArray(criteria)) {
    sortCriteria = criteria.map(item => {
      if (typeof item === 'string') {
        return { key: item, order: 'asc' };
      }
      return { key: item.key, order: item.order || 'asc', type: item.type };
    });
  } else {
    throw new TypeError('Criteria must be a string or array');
  }
  
  // Clone if requested
  const arrayToSort = clone ? [...arr] : arr;
  
  // Add original index for stable sort
  if (stable) {
    arrayToSort.forEach((item, index) => {
      item.__originalIndex = index;
    });
  }
  
  arrayToSort.sort((a, b) => {
    for (const criterion of sortCriteria) {
      const { key, order, type } = criterion;
      
      // Get values (support nested properties like 'user.name')
      const aVal = getNestedValue(a, key);
      const bVal = getNestedValue(b, key);
      
      // Handle null/undefined
      if (aVal == null && bVal == null) continue;
      if (aVal == null) return 1;
      if (bVal == null) return -1;
      
      let comparison = 0;
      
      // Type-specific comparison
      if (type === 'string' || (typeof aVal === 'string' && typeof bVal === 'string')) {
        comparison = aVal.localeCompare(bVal, undefined, { numeric: true, sensitivity: 'base' });
      } else if (type === 'number' || (typeof aVal === 'number' && typeof bVal === 'number')) {
        comparison = aVal - bVal;
      } else if (type === 'date' || (aVal instanceof Date && bVal instanceof Date)) {
        comparison = aVal.getTime() - bVal.getTime();
      } else {
        // Generic comparison
        if (aVal < bVal) comparison = -1;
        else if (aVal > bVal) comparison = 1;
      }
      
      if (comparison !== 0) {
        return order === 'desc' ? -comparison : comparison;
      }
    }
    
    // Stable sort: use original index as tiebreaker
    if (stable) {
      return a.__originalIndex - b.__originalIndex;
    }
    
    return 0;
  });
  
  // Clean up stable sort markers
  if (stable) {
    arrayToSort.forEach(item => {
      delete item.__originalIndex;
    });
  }
  
  return arrayToSort;
}

// Helper to get nested property value
function getNestedValue(obj, path) {
  return path.split('.').reduce((value, key) => value?.[key], obj);
}

// Sort by function instead of property name
function sortByFunction(arr, compareFn) {
  return arr.sort(compareFn);
}

// Create reusable sorter
function createSorter(...criteria) {
  return (arr) => sortByMultiple(arr, criteria, { clone: true });
}

// Comprehensive test suite
console.log('=== Basic Multi-Property Sort ===');
const employees = [
  { name: 'John', department: 'IT', salary: 80000 },
  { name: 'Jane', department: 'HR', salary: 70000 },
  { name: 'Bob', department: 'IT', salary: 90000 },
  { name: 'Alice', department: 'HR', salary: 75000 }
];

console.log(sortByMultiple(employees, ['department', 'salary']));
/*
Sorted by department first, then salary within each department
*/

console.log('\n=== With Descending Order ===');
console.log(sortByMultiple(employees, [
  { key: 'department', order: 'asc' },
  { key: 'salary', order: 'desc' }
], { clone: true }));
/*
HR: Alice (75000), Jane (70000)
IT: Bob (90000), John (80000)
*/

console.log('\n=== Nested Properties ===');
const users = [
  { name: 'John', address: { city: 'NYC', zip: 10001 } },
  { name: 'Jane', address: { city: 'LA', zip: 90001 } },
  { name: 'Bob', address: { city: 'NYC', zip: 10002 } }
];

console.log(sortByMultiple(users, ['address.city', 'address.zip']));

console.log('\n=== Date Sorting ===');
const events = [
  { name: 'Event A', date: new Date('2024-03-15'), priority: 2 },
  { name: 'Event B', date: new Date('2024-03-10'), priority: 1 },
  { name: 'Event C', date: new Date('2024-03-10'), priority: 3 }
];

console.log(sortByMultiple(events, [
  { key: 'date', type: 'date' },
  { key: 'priority', order: 'desc' }
]));

console.log('\n=== String with Numbers (Natural Sort) ===');
const items = [
  { id: 'item10' },
  { id: 'item2' },
  { id: 'item1' },
  { id: 'item20' }
];

console.log(sortByMultiple(items, [{ key: 'id', type: 'string' }]));
// Natural sort: item1, item2, item10, item20

console.log('\n=== Null/Undefined Handling ===');
const data = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: null },
  { name: 'Bob', age: 25 },
  { name: 'Alice', age: undefined }
];

console.log(sortByMultiple(data, ['age', 'name']));
// Nulls/undefined sorted to end

console.log('\n=== Reusable Sorter ===');
const sortByDeptAndSalary = createSorter(
  { key: 'department' },
  { key: 'salary', order: 'desc' }
);

console.log(sortByDeptAndSalary(employees));

console.log('\n=== Clone vs In-Place ===');
const original = [{ id: 3 }, { id: 1 }, { id: 2 }];
const sorted = sortByMultiple(original, ['id'], { clone: true });

console.log('Original:', original.map(x => x.id));  // [3, 1, 2]
console.log('Sorted:', sorted.map(x => x.id));      // [1, 2, 3]
```

### **Bonus: Advanced Sorting Utilities**
```javascript
/**
 * Sort with custom comparator for specific property
 */
function sortWithComparators(arr, comparators) {
  return arr.sort((a, b) => {
    for (const { key, compare } of comparators) {
      const result = compare(a[key], b[key]);
      if (result !== 0) return result;
    }
    return 0;
  });
}

/**
 * Multi-level grouping and sorting
 */
function groupAndSort(arr, groupBy, sortBy) {
  const grouped = {};
  
  // Group
  arr.forEach(item => {
    const key = item[groupBy];
    if (!grouped[key]) grouped[key] = [];
    grouped[key].push(item);
  });
  
  // Sort each group
  Object.keys(grouped).forEach(key => {
    grouped[key] = sortByMultiple(grouped[key], sortBy);
  });
  
  return grouped;
}

/**
 * Sort by multiple properties with priority weights
 */
function sortWithWeights(arr, criteria) {
  return arr.sort((a, b) => {
    let totalScore = 0;
    
    for (const { key, weight = 1, order = 'asc' } of criteria) {
      const aVal = a[key];
      const bVal = b[key];
      
      let comparison = 0;
      if (aVal < bVal) comparison = -1;
      else if (aVal > bVal) comparison = 1;
      
      totalScore += comparison * weight * (order === 'desc' ? -1 : 1);
    }
    
    return totalScore;
  });
}

// Test
const products = [
  { name: 'Laptop', price: 1000, rating: 4.5 },
  { name: 'Mouse', price: 25, rating: 4.8 },
  { name: 'Keyboard', price: 75, rating: 4.7 }
];

console.log(sortWithWeights(products, [
  { key: 'rating', weight: 2, order: 'desc' },
  { key: 'price', weight: 1, order: 'asc' }
]));
// Prioritize rating more than price
```

**Interview Tips:**
- sort() is in-place by default; clone array if needed
- localeCompare() for proper string comparison (handles accents, case)
- Handle null/undefined values explicitly
- Can sort by nested properties using dot notation
- Order matters: primary sort first, then secondary, etc.
- Consider stable vs unstable sort implementations
- Common use: tables, data grids, reports, search results
- lodash.orderBy() and lodash.sortBy() for production use

</details>

40. Find the majority element in an array (appears more than n/2 times)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using HashMap (Count Frequencies)**
```javascript
/**
 * Find majority element using frequency map
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {Array} arr - Input array
 * @returns {*} - Majority element or null
 */
function findMajorityElement(arr) {
  const n = arr.length;
  const countMap = new Map();
  
  for (const num of arr) {
    countMap.set(num, (countMap.get(num) || 0) + 1);
    
    if (countMap.get(num) > n / 2) {
      return num;
    }
  }
  
  return null;
}

// Test cases
console.log(findMajorityElement([3, 2, 3]));
// 3

console.log(findMajorityElement([2, 2, 1, 1, 1, 2, 2]));
// 2

console.log(findMajorityElement([1, 2, 3]));
// null (no majority)
```

### **Approach 2: Boyer-Moore Voting Algorithm (Optimal)**
```javascript
/**
 * Find majority element using Boyer-Moore algorithm
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Works only if majority element is guaranteed to exist
 */
function findMajorityElement(arr) {
  if (arr.length === 0) return null;
  
  // Phase 1: Find candidate
  let candidate = arr[0];
  let count = 1;
  
  for (let i = 1; i < arr.length; i++) {
    if (count === 0) {
      candidate = arr[i];
      count = 1;
    } else if (arr[i] === candidate) {
      count++;
    } else {
      count--;
    }
  }
  
  // Phase 2: Verify candidate (if majority not guaranteed)
  count = 0;
  for (const num of arr) {
    if (num === candidate) {
      count++;
    }
  }
  
  return count > arr.length / 2 ? candidate : null;
}

// Test
console.log(findMajorityElement([3, 2, 3]));
// 3

console.log(findMajorityElement([2, 2, 1, 1, 1, 2, 2]));
// 2
```

### **Approach 3: Using Sorting**
```javascript
/**
 * Find majority element by sorting
 * Time Complexity: O(n log n)
 * Space Complexity: O(1) or O(n) depending on sort
 * 
 * If majority exists, it will be at index n/2 after sorting
 */
function findMajorityElement(arr) {
  if (arr.length === 0) return null;
  
  const sorted = [...arr].sort();
  const candidate = sorted[Math.floor(arr.length / 2)];
  
  // Verify
  let count = 0;
  for (const num of arr) {
    if (num === candidate) count++;
  }
  
  return count > arr.length / 2 ? candidate : null;
}

// Test
console.log(findMajorityElement([2, 2, 1, 1, 1, 2, 2]));
// 2
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready majority element finder
 * 
 * @param {Array} arr - Input array
 * @param {Object} options - Find options
 * @param {number} options.threshold - Threshold fraction (default: 0.5 for >n/2)
 * @param {boolean} options.returnCount - Return {element, count} instead of just element
 * @param {Function} options.comparator - Custom equality comparator
 * @returns {*} - Majority element(s) or null
 */
function findMajorityElement(arr, options = {}) {
  const {
    threshold = 0.5,
    returnCount = false,
    comparator = (a, b) => a === b
  } = options;
  
  // Validation
  if (!Array.isArray(arr)) {
    throw new TypeError('Input must be an array');
  }
  
  if (arr.length === 0) {
    return null;
  }
  
  const n = arr.length;
  const requiredCount = Math.floor(n * threshold) + 1;
  
  // Boyer-Moore for >n/2 majority
  if (threshold === 0.5) {
    // Phase 1: Find candidate
    let candidate = arr[0];
    let count = 1;
    
    for (let i = 1; i < n; i++) {
      if (count === 0) {
        candidate = arr[i];
        count = 1;
      } else if (comparator(arr[i], candidate)) {
        count++;
      } else {
        count--;
      }
    }
    
    // Phase 2: Verify
    count = 0;
    for (const item of arr) {
      if (comparator(item, candidate)) {
        count++;
      }
    }
    
    if (count >= requiredCount) {
      return returnCount ? { element: candidate, count } : candidate;
    }
    
    return null;
  }
  
  // For other thresholds, use frequency map
  const countMap = new Map();
  
  for (const item of arr) {
    let found = false;
    
    // Check if item already in map (using comparator)
    for (const [key, value] of countMap) {
      if (comparator(key, item)) {
        countMap.set(key, value + 1);
        found = true;
        
        if (countMap.get(key) >= requiredCount) {
          return returnCount ? { element: key, count: countMap.get(key) } : key;
        }
        break;
      }
    }
    
    if (!found) {
      countMap.set(item, 1);
    }
  }
  
  return null;
}

// Find all elements appearing more than n/k times
function findMajorityElements(arr, k) {
  const n = arr.length;
  const threshold = Math.floor(n / k);
  const countMap = new Map();
  const result = [];
  
  for (const num of arr) {
    countMap.set(num, (countMap.get(num) || 0) + 1);
  }
  
  for (const [num, count] of countMap) {
    if (count > threshold) {
      result.push(num);
    }
  }
  
  return result;
}

// Get frequency of most common element
function getMostFrequent(arr) {
  if (arr.length === 0) return null;
  
  const countMap = new Map();
  let maxCount = 0;
  let mostFrequent = null;
  
  for (const num of arr) {
    const count = (countMap.get(num) || 0) + 1;
    countMap.set(num, count);
    
    if (count > maxCount) {
      maxCount = count;
      mostFrequent = num;
    }
  }
  
  return { element: mostFrequent, count: maxCount };
}

// Comprehensive test suite
console.log('=== Basic Majority ===');
console.log(findMajorityElement([3, 2, 3]));
// 3

console.log(findMajorityElement([2, 2, 1, 1, 1, 2, 2]));
// 2

console.log('\n=== No Majority ===');
console.log(findMajorityElement([1, 2, 3]));
// null

console.log('\n=== Return with Count ===');
console.log(findMajorityElement([2, 2, 1, 1, 1, 2, 2], { returnCount: true }));
// { element: 2, count: 4 }

console.log('\n=== Custom Threshold (>n/3) ===');
console.log(findMajorityElement([1, 1, 2, 2, 3, 3, 3], { threshold: 1/3 }));
// 3 (appears 3 times > 7/3)

console.log('\n=== Object Comparison ===');
const objects = [
  { id: 1, name: 'A' },
  { id: 1, name: 'A' },
  { id: 2, name: 'B' },
  { id: 1, name: 'A' }
];

console.log(findMajorityElement(objects, {
  comparator: (a, b) => a.id === b.id
}));
// { id: 1, name: 'A' }

console.log('\n=== Find All Elements > n/3 ===');
console.log(findMajorityElements([3, 2, 3, 1, 1, 2, 3], 3));
// [3] (appears 3 times > 7/3)

console.log(findMajorityElements([1, 1, 2, 2, 3], 3));
// [1, 2] (both appear 2 times > 5/3)

console.log('\n=== Most Frequent (Not Necessarily Majority) ===');
console.log(getMostFrequent([1, 2, 2, 3, 3, 3]));
// { element: 3, count: 3 }

console.log('\n=== Single Element ===');
console.log(findMajorityElement([5]));
// 5

console.log('\n=== All Same ===');
console.log(findMajorityElement([7, 7, 7, 7]));
// 7

console.log('\n=== Empty Array ===');
console.log(findMajorityElement([]));
// null
```

### **Bonus: Majority Element in Sliding Window**
```javascript
/**
 * Find majority element in each window of size k
 */
function majorityInWindows(arr, k) {
  const result = [];
  
  for (let i = 0; i <= arr.length - k; i++) {
    const window = arr.slice(i, i + k);
    const majority = findMajorityElement(window);
    result.push(majority);
  }
  
  return result;
}

// Test
console.log(majorityInWindows([1, 2, 2, 2, 3, 3, 3, 3, 4], 3));
// [2, 2, null, 3, 3, 3, 3]
```

**Interview Tips:**
- Boyer-Moore algorithm is optimal: O(n) time, O(1) space
- Works for majority element appearing >n/2 times
- HashMap approach is more general but uses O(n) space
- Always verify candidate in phase 2 if not guaranteed
- Can extend to find elements appearing >n/k times
- Sorting approach is O(n log n) but intuitive
- Common follow-up: find all elements >n/3, >n/k
- Clarify: is majority guaranteed to exist?

</details>

### **String Manipulations**

41. Implement a function to compress a string (e.g., "aaabbc" → "a3b2c1")

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Iterate and Count**
```javascript
/**
 * Compress string using run-length encoding
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {string} str - Input string
 * @returns {string} - Compressed string
 */
function compressString(str) {
  if (str.length === 0) return str;
  
  let compressed = '';
  let count = 1;
  
  for (let i = 1; i <= str.length; i++) {
    // Check if current char is different or end of string
    if (i === str.length || str[i] !== str[i - 1]) {
      compressed += str[i - 1] + count;
      count = 1;
    } else {
      count++;
    }
  }
  
  // Return original if compressed is not shorter
  return compressed.length < str.length ? compressed : str;
}

// Test cases
console.log(compressString('aaabbc'));
// 'a3b2c1'

console.log(compressString('aabcccccaaa'));
// 'a2b1c5a3'

console.log(compressString('abc'));
// 'abc' (compressed would be 'a1b1c1', longer)

console.log(compressString('aaa'));
// 'a3'
```

### **Approach 2: Using Array (More Efficient)**
```javascript
/**
 * Compress using array for better performance
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * String concatenation is slow; array push + join is faster
 */
function compressString(str) {
  if (str.length === 0) return str;
  
  const result = [];
  let count = 1;
  
  for (let i = 1; i <= str.length; i++) {
    if (i === str.length || str[i] !== str[i - 1]) {
      result.push(str[i - 1], count);
      count = 1;
    } else {
      count++;
    }
  }
  
  const compressed = result.join('');
  return compressed.length < str.length ? compressed : str;
}

// Test
console.log(compressString('aabbccc'));
// 'a2b2c3'
```

### **Approach 3: Without Count if 1**
```javascript
/**
 * Compress but omit count if it's 1
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function compressString(str) {
  if (str.length === 0) return str;
  
  let compressed = '';
  let count = 1;
  
  for (let i = 1; i <= str.length; i++) {
    if (i === str.length || str[i] !== str[i - 1]) {
      compressed += str[i - 1];
      if (count > 1) {
        compressed += count;
      }
      count = 1;
    } else {
      count++;
    }
  }
  
  return compressed.length < str.length ? compressed : str;
}

// Test
console.log(compressString('aaabbc'));
// 'a3b2c' (instead of 'a3b2c1')
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready string compression
 * 
 * @param {string} str - Input string
 * @param {Object} options - Compression options
 * @param {boolean} options.omitSingleCounts - Don't show count if 1 (default: false)
 * @param {boolean} options.alwaysCompress - Return compressed even if longer (default: false)
 * @param {boolean} options.caseInsensitive - Treat a and A as same (default: false)
 * @returns {string} - Compressed string
 */
function compressString(str, options = {}) {
  const {
    omitSingleCounts = false,
    alwaysCompress = false,
    caseInsensitive = false
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  if (str.length === 0) {
    return str;
  }
  
  // Normalize case if requested
  const workStr = caseInsensitive ? str.toLowerCase() : str;
  
  const result = [];
  let count = 1;
  let currentChar = workStr[0];
  
  for (let i = 1; i <= workStr.length; i++) {
    if (i === workStr.length || workStr[i] !== currentChar) {
      // Add character
      result.push(currentChar);
      
      // Add count if needed
      if (!omitSingleCounts || count > 1) {
        result.push(count);
      }
      
      if (i < workStr.length) {
        currentChar = workStr[i];
        count = 1;
      }
    } else {
      count++;
    }
  }
  
  const compressed = result.join('');
  
  // Return original if compressed is longer (unless alwaysCompress)
  return alwaysCompress || compressed.length < str.length ? compressed : str;
}

// Decompress a compressed string
function decompressString(str) {
  let result = '';
  let i = 0;
  
  while (i < str.length) {
    const char = str[i];
    i++;
    
    // Get count (may be multiple digits)
    let countStr = '';
    while (i < str.length && /\d/.test(str[i])) {
      countStr += str[i];
      i++;
    }
    
    const count = countStr ? parseInt(countStr) : 1;
    result += char.repeat(count);
  }
  
  return result;
}

// Compress with custom encoding
function compressWithEncoding(str, encoding = 'rle') {
  switch (encoding) {
    case 'rle': // Run-length encoding
      return compressString(str);
      
    case 'count': // Just show unique chars with counts
      const counts = {};
      for (const char of str) {
        counts[char] = (counts[char] || 0) + 1;
      }
      return Object.entries(counts)
        .map(([char, count]) => `${char}${count}`)
        .join('');
      
    default:
      throw new Error(`Unknown encoding: ${encoding}`);
  }
}

// Comprehensive test suite
console.log('=== Basic Compression ===');
console.log(compressString('aaabbc'));
// 'a3b2c1'

console.log(compressString('aabcccccaaa'));
// 'a2b1c5a3'

console.log('\n=== Not Worth Compressing ===');
console.log(compressString('abc'));
// 'abc' (original returned)

console.log(compressString('abcd'));
// 'abcd'

console.log('\n=== Omit Single Counts ===');
console.log(compressString('aaabbc', { omitSingleCounts: true }));
// 'a3b2c' (no '1' after 'c')

console.log('\n=== Always Compress ===');
console.log(compressString('abc', { alwaysCompress: true }));
// 'a1b1c1'

console.log('\n=== Case Insensitive ===');
console.log(compressString('AAAaaaBBB', { caseInsensitive: true }));
// 'a6b3'

console.log('\n=== Empty and Single Character ===');
console.log(compressString(''));
// ''

console.log(compressString('a'));
// 'a'

console.log(compressString('aaaaa'));
// 'a5'

console.log('\n=== Decompression ===');
console.log(decompressString('a3b2c1'));
// 'aaabbc'

console.log(decompressString('a10b2'));
// 'aaaaaaaaaabb'

console.log('\n=== Long Runs ===');
console.log(compressString('a'.repeat(100)));
// 'a100'

console.log('\n=== Mixed Case ===');
console.log(compressString('AAAaaBBBbb'));
// 'A3a2B3b2'

console.log('\n=== Numbers and Special Chars ===');
console.log(compressString('111222!!!'));
// '132231!3'
```

### **Bonus: Advanced Compression**
```javascript
/**
 * Two-pass compression (chars then numbers)
 */
function advancedCompress(str) {
  const charCounts = {};
  
  for (const char of str) {
    charCounts[char] = (charCounts[char] || 0) + 1;
  }
  
  // Sort by frequency (optional optimization)
  const sorted = Object.entries(charCounts)
    .sort((a, b) => b[1] - a[1]);
  
  return sorted.map(([char, count]) => `${char}:${count}`).join(',');
}

// Test
console.log(advancedCompress('aaabbcccccc'));
// 'c:6,a:3,b:2'
```

**Interview Tips:**
- Run-length encoding (RLE) is the standard approach
- Use array.push() + join() instead of string concatenation for performance
- Check if compressed is actually shorter; return original if not
- Handle edge cases: empty string, single char, all unique chars
- Can omit count of 1 for better compression
- Common variation: case-insensitive compression
- Decompression should reverse the process exactly
- Used in: image compression, data transmission, file compression

</details>

42. Find the longest substring without repeating characters

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Sliding Window with Set**
```javascript
/**
 * Find longest substring without repeating characters
 * Time Complexity: O(n)
 * Space Complexity: O(min(n, m)) where m is charset size
 * 
 * @param {string} str - Input string
 * @returns {number} - Length of longest substring
 */
function lengthOfLongestSubstring(str) {
  const seen = new Set();
  let maxLength = 0;
  let left = 0;
  
  for (let right = 0; right < str.length; right++) {
    // Shrink window while we have duplicates
    while (seen.has(str[right])) {
      seen.delete(str[left]);
      left++;
    }
    
    seen.add(str[right]);
    maxLength = Math.max(maxLength, right - left + 1);
  }
  
  return maxLength;
}

// Test cases
console.log(lengthOfLongestSubstring('abcabcbb'));
// 3 ('abc')

console.log(lengthOfLongestSubstring('bbbbb'));
// 1 ('b')

console.log(lengthOfLongestSubstring('pwwkew'));
// 3 ('wke' or 'kew')

console.log(lengthOfLongestSubstring(''));
// 0
```

### **Approach 2: Sliding Window with HashMap (Optimized)**
```javascript
/**
 * Optimized sliding window using HashMap
 * Time Complexity: O(n)
 * Space Complexity: O(min(n, m))
 * 
 * Skip to character position + 1 when duplicate found
 */
function lengthOfLongestSubstring(str) {
  const charIndex = new Map(); // char -> last seen index
  let maxLength = 0;
  let left = 0;
  
  for (let right = 0; right < str.length; right++) {
    const char = str[right];
    
    // If char seen and within current window, move left pointer
    if (charIndex.has(char) && charIndex.get(char) >= left) {
      left = charIndex.get(char) + 1;
    }
    
    charIndex.set(char, right);
    maxLength = Math.max(maxLength, right - left + 1);
  }
  
  return maxLength;
}

// Test
console.log(lengthOfLongestSubstring('abcabcbb'));
// 3

console.log(lengthOfLongestSubstring('tmmzuxt'));
// 5 ('mzuxt')
```

### **Approach 3: Return Actual Substring**
```javascript
/**
 * Return the actual longest substring
 * Time Complexity: O(n)
 * Space Complexity: O(min(n, m))
 */
function longestSubstringWithoutRepeating(str) {
  const charIndex = new Map();
  let maxLength = 0;
  let maxStart = 0;
  let left = 0;
  
  for (let right = 0; right < str.length; right++) {
    const char = str[right];
    
    if (charIndex.has(char) && charIndex.get(char) >= left) {
      left = charIndex.get(char) + 1;
    }
    
    const currentLength = right - left + 1;
    if (currentLength > maxLength) {
      maxLength = currentLength;
      maxStart = left;
    }
    
    charIndex.set(char, right);
  }
  
  return str.substring(maxStart, maxStart + maxLength);
}

// Test
console.log(longestSubstringWithoutRepeating('abcabcbb'));
// 'abc'

console.log(longestSubstringWithoutRepeating('pwwkew'));
// 'wke' or 'kew'
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready longest substring finder
 * 
 * @param {string} str - Input string
 * @param {Object} options - Find options
 * @param {boolean} options.returnString - Return substring instead of length
 * @param {boolean} options.caseInsensitive - Ignore case for duplicates
 * @param {boolean} options.ignoreSpaces - Don't count spaces as characters
 * @param {Array} options.allowedRepeats - Characters that can repeat
 * @returns {number|string} - Length or actual substring
 */
function lengthOfLongestSubstring(str, options = {}) {
  const {
    returnString = false,
    caseInsensitive = false,
    ignoreSpaces = false,
    allowedRepeats = []
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  if (str.length === 0) {
    return returnString ? '' : 0;
  }
  
  // Normalize
  const workStr = caseInsensitive ? str.toLowerCase() : str;
  const allowedSet = new Set(allowedRepeats);
  
  const charIndex = new Map();
  let maxLength = 0;
  let maxStart = 0;
  let left = 0;
  
  for (let right = 0; right < workStr.length; right++) {
    const char = workStr[right];
    
    // Skip spaces if requested
    if (ignoreSpaces && char === ' ') {
      continue;
    }
    
    // Skip if character is allowed to repeat
    if (allowedSet.has(char)) {
      continue;
    }
    
    // Move left pointer if duplicate found
    if (charIndex.has(char) && charIndex.get(char) >= left) {
      left = charIndex.get(char) + 1;
    }
    
    const currentLength = right - left + 1;
    if (currentLength > maxLength) {
      maxLength = currentLength;
      maxStart = left;
    }
    
    charIndex.set(char, right);
  }
  
  if (returnString) {
    return str.substring(maxStart, maxStart + maxLength);
  }
  
  return maxLength;
}

// Find all substrings without repeating characters
function findAllUniqueSubstrings(str) {
  const result = [];
  const seen = new Set();
  
  for (let i = 0; i < str.length; i++) {
    const charSet = new Set();
    
    for (let j = i; j < str.length; j++) {
      if (charSet.has(str[j])) break;
      
      charSet.add(str[j]);
      const substring = str.substring(i, j + 1);
      
      if (!seen.has(substring)) {
        result.push(substring);
        seen.add(substring);
      }
    }
  }
  
  return result.sort((a, b) => b.length - a.length);
}

// Count of substrings with k distinct characters
function countSubstringsWithKDistinct(str, k) {
  function atMostK(k) {
    const count = new Map();
    let result = 0;
    let left = 0;
    
    for (let right = 0; right < str.length; right++) {
      count.set(str[right], (count.get(str[right]) || 0) + 1);
      
      while (count.size > k) {
        count.set(str[left], count.get(str[left]) - 1);
        if (count.get(str[left]) === 0) {
          count.delete(str[left]);
        }
        left++;
      }
      
      result += right - left + 1;
    }
    
    return result;
  }
  
  return atMostK(k) - atMostK(k - 1);
}

// Comprehensive test suite
console.log('=== Basic Tests ===');
console.log(lengthOfLongestSubstring('abcabcbb'));
// 3

console.log(lengthOfLongestSubstring('bbbbb'));
// 1

console.log(lengthOfLongestSubstring('pwwkew'));
// 3

console.log('\n=== Return Substring ===');
console.log(lengthOfLongestSubstring('abcabcbb', { returnString: true }));
// 'abc'

console.log(lengthOfLongestSubstring('dvdf', { returnString: true }));
// 'vdf'

console.log('\n=== Case Insensitive ===');
console.log(lengthOfLongestSubstring('AaBbCc', { caseInsensitive: true }));
// 2 (treats A and a as same)

console.log('\n=== Ignore Spaces ===');
console.log(lengthOfLongestSubstring('ab cd ef', { ignoreSpaces: true }));
// Counts only non-space characters

console.log('\n=== Empty and Single Character ===');
console.log(lengthOfLongestSubstring(''));
// 0

console.log(lengthOfLongestSubstring('a'));
// 1

console.log('\n=== All Unique ===');
console.log(lengthOfLongestSubstring('abcdef'));
// 6

console.log('\n=== Find All Unique Substrings ===');
console.log(findAllUniqueSubstrings('abc').slice(0, 5));
// ['abc', 'ab', 'bc', 'a', 'b']

console.log('\n=== Long String ===');
console.log(lengthOfLongestSubstring('abcdefghijklmnopqrstuvwxyz'));
// 26 (all lowercase letters)

console.log('\n=== With Numbers and Special Chars ===');
console.log(lengthOfLongestSubstring('a1b2c3d4'));
// 8 (all unique)

console.log(lengthOfLongestSubstring('a1b2a3'));
// 4 ('b2a3')
```

### **Bonus: K-Distinct Characters**
```javascript
/**
 * Longest substring with at most K distinct characters
 */
function longestSubstringKDistinct(str, k) {
  const count = new Map();
  let maxLength = 0;
  let left = 0;
  
  for (let right = 0; right < str.length; right++) {
    count.set(str[right], (count.get(str[right]) || 0) + 1);
    
    while (count.size > k) {
      count.set(str[left], count.get(str[left]) - 1);
      if (count.get(str[left]) === 0) {
        count.delete(str[left]);
      }
      left++;
    }
    
    maxLength = Math.max(maxLength, right - left + 1);
  }
  
  return maxLength;
}

// Test
console.log(longestSubstringKDistinct('eceba', 2));
// 3 ('ece')

console.log(longestSubstringKDistinct('aa', 1));
// 2 ('aa')
```

**Interview Tips:**
- Sliding window with Set/Map is optimal: O(n) time
- Two pointers: right expands, left contracts
- Use HashMap to track last seen index for optimization
- Can extend to: k distinct chars, with conditions, return all
- Common follow-ups: return substring, case-insensitive, k-distinct
- Classic sliding window problem pattern
- Alternative: brute force O(n²) checking all substrings

</details>

43. Check if string has balanced parentheses

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Stack**
```javascript
/**
 * Check if parentheses are balanced using stack
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {string} str - Input string
 * @returns {boolean} - True if balanced
 */
function isBalanced(str) {
  const stack = [];
  const pairs = {
    ')': '(',
    '}': '{',
    ']': '['
  };
  
  for (const char of str) {
    // Opening brackets
    if (char === '(' || char === '{' || char === '[') {
      stack.push(char);
    }
    // Closing brackets
    else if (char === ')' || char === '}' || char === ']') {
      if (stack.length === 0 || stack.pop() !== pairs[char]) {
        return false;
      }
    }
    // Ignore other characters
  }
  
  return stack.length === 0;
}

// Test cases
console.log(isBalanced('()'));
// true

console.log(isBalanced('()[]{}'));
// true

console.log(isBalanced('(]'));
// false

console.log(isBalanced('([)]'));
// false

console.log(isBalanced('{[]}'));
// true

console.log(isBalanced('((()))'));
// true

console.log(isBalanced('(()'));
// false
```

### **Approach 2: Counter Method (Single Bracket Type)**
```javascript
/**
 * Check balance for single bracket type using counter
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Only works for one type of bracket
 */
function isBalanced(str) {
  let count = 0;
  
  for (const char of str) {
    if (char === '(') {
      count++;
    } else if (char === ')') {
      count--;
      if (count < 0) return false;
    }
  }
  
  return count === 0;
}

// Test
console.log(isBalanced('(())'));
// true

console.log(isBalanced('(()'));
// false
```

### **Approach 3: Only Check Parentheses in String**
```javascript
/**
 * Check balance ignoring non-bracket characters
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function isBalanced(str) {
  const stack = [];
  const opening = new Set(['(', '{', '[']);
  const closing = new Set([')', '}', ']']);
  const pairs = { ')': '(', '}': '{', ']': '[' };
  
  for (const char of str) {
    if (opening.has(char)) {
      stack.push(char);
    } else if (closing.has(char)) {
      if (stack.length === 0 || stack.pop() !== pairs[char]) {
        return false;
      }
    }
    // Ignore other characters
  }
  
  return stack.length === 0;
}

// Test
console.log(isBalanced('function test() { return [1, 2]; }'));
// true (ignores letters, numbers, etc.)

console.log(isBalanced('let x = (a + b) * [c + d];'));
// true
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready balanced bracket checker
 * 
 * @param {string} str - Input string
 * @param {Object} options - Check options
 * @param {Object} options.brackets - Custom bracket pairs (default: (){}[])
 * @param {boolean} options.strict - Only allow bracket characters (default: false)
 * @param {boolean} options.details - Return detailed error info (default: false)
 * @returns {boolean|Object} - Result or detailed info
 */
function isBalanced(str, options = {}) {
  const {
    brackets = { ')': '(', '}': '{', ']': '[' },
    strict = false,
    details = false
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  const stack = [];
  const opening = new Set(Object.values(brackets));
  const closing = new Set(Object.keys(brackets));
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    
    if (opening.has(char)) {
      stack.push({ char, index: i });
    } else if (closing.has(char)) {
      if (stack.length === 0) {
        if (details) {
          return {
            balanced: false,
            error: 'Unexpected closing bracket',
            char,
            index: i
          };
        }
        return false;
      }
      
      const last = stack.pop();
      if (last.char !== brackets[char]) {
        if (details) {
          return {
            balanced: false,
            error: 'Mismatched brackets',
            expected: brackets[char],
            found: last.char,
            openIndex: last.index,
            closeIndex: i
          };
        }
        return false;
      }
    } else if (strict && char !== ' ') {
      if (details) {
        return {
          balanced: false,
          error: 'Invalid character in strict mode',
          char,
          index: i
        };
      }
      return false;
    }
  }
  
  if (stack.length > 0) {
    if (details) {
      return {
        balanced: false,
        error: 'Unclosed brackets',
        unclosed: stack.map(item => ({ char: item.char, index: item.index }))
      };
    }
    return false;
  }
  
  return details ? { balanced: true } : true;
}

// Check and get matching pairs
function getMatchingPairs(str) {
  const stack = [];
  const pairs = [];
  const bracketPairs = { ')': '(', '}': '{', ']': '[' };
  const opening = new Set(Object.values(bracketPairs));
  const closing = new Set(Object.keys(bracketPairs));
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    
    if (opening.has(char)) {
      stack.push({ char, index: i });
    } else if (closing.has(char)) {
      if (stack.length > 0 && stack[stack.length - 1].char === bracketPairs[char]) {
        const openBracket = stack.pop();
        pairs.push({
          open: openBracket.index,
          close: i,
          type: char
        });
      }
    }
  }
  
  return pairs;
}

// Get all unbalanced brackets
function getUnbalancedBrackets(str) {
  const stack = [];
  const unbalanced = [];
  const bracketPairs = { ')': '(', '}': '{', ']': '[' };
  const opening = new Set(Object.values(bracketPairs));
  const closing = new Set(Object.keys(bracketPairs));
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    
    if (opening.has(char)) {
      stack.push({ char, index: i });
    } else if (closing.has(char)) {
      if (stack.length === 0 || stack[stack.length - 1].char !== bracketPairs[char]) {
        unbalanced.push({ char, index: i, type: 'unmatched-close' });
      } else {
        stack.pop();
      }
    }
  }
  
  // Remaining in stack are unclosed
  stack.forEach(item => {
    unbalanced.push({ char: item.char, index: item.index, type: 'unclosed' });
  });
  
  return unbalanced;
}

// Comprehensive test suite
console.log('=== Basic Tests ===');
console.log(isBalanced('()'));
// true

console.log(isBalanced('()[]{}'));
// true

console.log(isBalanced('(]'));
// false

console.log('\n=== Nested Brackets ===');
console.log(isBalanced('([{}])'));
// true

console.log(isBalanced('({[]})'));
// true

console.log(isBalanced('({[}])'));
// false (mismatched)

console.log('\n=== With Text ===');
console.log(isBalanced('function test() { return [1, 2, 3]; }'));
// true

console.log(isBalanced('let x = (a + b) * {c + d];'));
// false

console.log('\n=== Edge Cases ===');
console.log(isBalanced(''));
// true (empty is balanced)

console.log(isBalanced('abc'));
// true (no brackets)

console.log(isBalanced('('));
// false (unclosed)

console.log(isBalanced(')'));
// false (unexpected closing)

console.log('\n=== Detailed Error Info ===');
console.log(isBalanced('({[}])', { details: true }));
/*
{
  balanced: false,
  error: 'Mismatched brackets',
  expected: '[',
  found: '{',
  openIndex: 1,
  closeIndex: 3
}
*/

console.log(isBalanced('((())', { details: true }));
/*
{
  balanced: false,
  error: 'Unclosed brackets',
  unclosed: [{ char: '(', index: 0 }]
}
*/

console.log('\n=== Custom Brackets ===');
console.log(isBalanced('<html><body></body></html>', {
  brackets: { '>': '<' }
}));
// true

console.log('\n=== Strict Mode ===');
console.log(isBalanced('(())', { strict: true }));
// true

console.log(isBalanced('(a)', { strict: true }));
// false (non-bracket character)

console.log('\n=== Get Matching Pairs ===');
console.log(getMatchingPairs('(a [b] {c})'));
/*
[
  { open: 3, close: 5, type: ']' },
  { open: 7, close: 9, type: '}' },
  { open: 0, close: 10, type: ')' }
]
*/

console.log('\n=== Get Unbalanced Brackets ===');
console.log(getUnbalancedBrackets('((a)[b}'));
/*
[
  { char: '}', index: 6, type: 'unmatched-close' },
  { char: '(', index: 0, type: 'unclosed' }
]
*/

console.log('\n=== Multiple Same Type ===');
console.log(isBalanced('(((())))'));
// true

console.log(isBalanced('(((()))'));
// false

console.log('\n=== Complex Expressions ===');
console.log(isBalanced('if (x > 0) { arr[i] = {a: 1}; }'));
// true

console.log(isBalanced('let obj = { arr: [1, 2, (3 + 4)] };'));
// true
```

### **Bonus: Advanced Validations**
```javascript
/**
 * Validate bracket balance with maximum nesting depth
 */
function isBalancedWithDepth(str, maxDepth = Infinity) {
  const stack = [];
  const pairs = { ')': '(', '}': '{', ']': '[' };
  
  for (const char of str) {
    if (char === '(' || char === '{' || char === '[') {
      stack.push(char);
      if (stack.length > maxDepth) {
        return false;
      }
    } else if (char === ')' || char === '}' || char === ']') {
      if (stack.length === 0 || stack.pop() !== pairs[char]) {
        return false;
      }
    }
  }
  
  return stack.length === 0;
}

// Test
console.log(isBalancedWithDepth('((()))', 3));
// true (max depth is 3)

console.log(isBalancedWithDepth('((()))', 2));
// false (exceeds max depth)

/**
 * Fix unbalanced brackets by adding missing ones
 */
function fixBrackets(str) {
  const stack = [];
  const pairs = { ')': '(', '}': '{', ']': '[' };
  const reverse = { '(': ')', '{': '}', '[': ']' };
  let result = str;
  
  for (const char of str) {
    if (char === '(' || char === '{' || char === '[') {
      stack.push(char);
    } else if (char === ')' || char === '}' || char === ']') {
      if (stack.length > 0 && stack[stack.length - 1] === pairs[char]) {
        stack.pop();
      }
    }
  }
  
  // Add missing closing brackets
  while (stack.length > 0) {
    result += reverse[stack.pop()];
  }
  
  return result;
}

// Test
console.log(fixBrackets('((a)'));
// '((a))'

console.log(fixBrackets('{[}'));
// '{[}]' (partial fix)
```

**Interview Tips:**
- Stack is the canonical solution: O(n) time, O(n) space
- Counter works only for single bracket type
- Remember to check stack is empty at the end (unclosed brackets)
- Handle edge cases: empty string, no brackets, only opening/closing
- Can extend to: custom brackets, maximum depth, error details
- Common follow-ups: return positions, fix unbalanced, check specific types
- Used in: code editors, compilers, expression validators
- Alternative: recursion (less efficient), regex (limited)

</details>

44. Reverse words in a sentence

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Built-in Methods**
```javascript
/**
 * Reverse words in a sentence
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {string} str - Input sentence
 * @returns {string} - Reversed sentence
 */
function reverseWords(str) {
  return str.split(' ').reverse().join(' ');
}

// Test cases
console.log(reverseWords('Hello World'));
// 'World Hello'

console.log(reverseWords('The quick brown fox'));
// 'fox brown quick The'

console.log(reverseWords('JavaScript is awesome'));
// 'awesome is JavaScript'
```

### **Approach 2: Without Built-in Reverse**
```javascript
/**
 * Reverse words manually
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function reverseWords(str) {
  const words = str.split(' ');
  const reversed = [];
  
  for (let i = words.length - 1; i >= 0; i--) {
    reversed.push(words[i]);
  }
  
  return reversed.join(' ');
}

// Test
console.log(reverseWords('Hello World'));
// 'World Hello'
```

### **Approach 3: Handle Multiple Spaces**
```javascript
/**
 * Reverse words handling multiple spaces
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function reverseWords(str) {
  // Filter out empty strings from multiple spaces
  const words = str.split(' ').filter(word => word.length > 0);
  return words.reverse().join(' ');
}

// Test
console.log(reverseWords('  Hello   World  '));
// 'World Hello'

console.log(reverseWords('a  b    c'));
// 'c b a'
```

### **Approach 4: Two-Pointer In-Place (Array of Characters)**
```javascript
/**
 * Reverse words in-place (if using array)
 * Time Complexity: O(n)
 * Space Complexity: O(1) excluding input conversion
 */
function reverseWords(str) {
  const chars = str.split('');
  
  // Helper to reverse a portion of array
  function reverse(arr, start, end) {
    while (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]];
      start++;
      end--;
    }
  }
  
  // Reverse entire string
  reverse(chars, 0, chars.length - 1);
  
  // Reverse each word
  let start = 0;
  for (let i = 0; i <= chars.length; i++) {
    if (i === chars.length || chars[i] === ' ') {
      reverse(chars, start, i - 1);
      start = i + 1;
    }
  }
  
  return chars.join('');
}

// Test
console.log(reverseWords('Hello World'));
// 'World Hello'

console.log(reverseWords('The quick brown fox'));
// 'fox brown quick The'
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready word reverser
 * 
 * @param {string} str - Input string
 * @param {Object} options - Reverse options
 * @param {boolean} options.preserveSpaces - Keep original spacing (default: false)
 * @param {boolean} options.trim - Trim leading/trailing spaces (default: true)
 * @param {RegExp} options.delimiter - Word delimiter pattern (default: /\s+/)
 * @param {boolean} options.reverseChars - Also reverse characters in each word (default: false)
 * @returns {string} - Reversed string
 */
function reverseWords(str, options = {}) {
  const {
    preserveSpaces = false,
    trim = true,
    delimiter = /\s+/,
    reverseChars = false
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  if (str.length === 0) {
    return str;
  }
  
  let workStr = trim ? str.trim() : str;
  
  // Preserve original spacing pattern
  if (preserveSpaces) {
    const words = [];
    const spaces = [];
    let currentWord = '';
    let currentSpace = '';
    
    for (const char of workStr) {
      if (char === ' ') {
        if (currentWord) {
          words.push(currentWord);
          currentWord = '';
        }
        currentSpace += char;
      } else {
        if (currentSpace) {
          spaces.push(currentSpace);
          currentSpace = '';
        }
        currentWord += char;
      }
    }
    
    if (currentWord) words.push(currentWord);
    if (currentSpace) spaces.push(currentSpace);
    
    // Reverse words
    words.reverse();
    
    // Reconstruct with original spacing
    let result = '';
    for (let i = 0; i < words.length; i++) {
      result += words[i];
      if (i < spaces.length) {
        result += spaces[i];
      }
    }
    
    return result;
  }
  
  // Standard word reversal
  const words = workStr.split(delimiter).filter(word => word.length > 0);
  
  if (reverseChars) {
    const reversedWords = words.map(word => 
      word.split('').reverse().join('')
    );
    return reversedWords.reverse().join(' ');
  }
  
  return words.reverse().join(' ');
}

// Reverse only specific parts
function reverseWordsPartial(str, start, end) {
  const words = str.split(' ');
  const startIdx = Math.max(0, start);
  const endIdx = Math.min(words.length, end);
  
  const before = words.slice(0, startIdx);
  const toReverse = words.slice(startIdx, endIdx);
  const after = words.slice(endIdx);
  
  return [...before, ...toReverse.reverse(), ...after].join(' ');
}

// Reverse with punctuation handling
function reverseWordsPreservePunctuation(str) {
  // Extract words (letters only)
  const words = str.match(/\b\w+\b/g) || [];
  
  // Reverse words
  const reversed = words.reverse();
  
  // Replace words in original string
  let index = 0;
  return str.replace(/\b\w+\b/g, () => reversed[index++]);
}

// Comprehensive test suite
console.log('=== Basic Reversal ===');
console.log(reverseWords('Hello World'));
// 'World Hello'

console.log(reverseWords('The quick brown fox'));
// 'fox brown quick The'

console.log('\n=== Multiple Spaces ===');
console.log(reverseWords('  Hello   World  '));
// 'World Hello'

console.log(reverseWords('a  b    c', { trim: false }));
// 'c b a'

console.log('\n=== Preserve Spaces ===');
console.log(reverseWords('a  b    c', { preserveSpaces: true }));
// 'c  b    a' (keeps original spacing pattern)

console.log('\n=== No Trim ===');
console.log(reverseWords('  Hello World  ', { trim: false }));
// '  World Hello  '

console.log('\n=== Custom Delimiter ===');
console.log(reverseWords('apple,banana,cherry', { delimiter: /,/ }));
// 'cherry banana apple'

console.log(reverseWords('one-two-three', { delimiter: /-/ }));
// 'three two one'

console.log('\n=== Reverse Characters Too ===');
console.log(reverseWords('Hello World', { reverseChars: true }));
// 'dlroW olleH'

console.log('\n=== Edge Cases ===');
console.log(reverseWords(''));
// ''

console.log(reverseWords('SingleWord'));
// 'SingleWord'

console.log(reverseWords('   '));
// ''

console.log('\n=== Partial Reversal ===');
console.log(reverseWordsPartial('one two three four five', 1, 4));
// 'one four three two five'

console.log('\n=== With Punctuation ===');
console.log(reverseWordsPreservePunctuation('Hello, World!'));
// 'World, Hello!'

console.log(reverseWordsPreservePunctuation('Hi there, how are you?'));
// 'you are how there, Hi?'

console.log('\n=== Multiple Words Same ===');
console.log(reverseWords('test test test'));
// 'test test test'

console.log('\n=== Numbers ===');
console.log(reverseWords('1 2 3 4 5'));
// '5 4 3 2 1'

console.log('\n=== Mixed Content ===');
console.log(reverseWords('The price is $100.50 today'));
// 'today $100.50 is price The'
```

### **Bonus: Advanced Word Operations**
```javascript
/**
 * Reverse alternate words
 */
function reverseAlternateWords(str) {
  return str.split(' ').map((word, index) => {
    return index % 2 === 1 ? word.split('').reverse().join('') : word;
  }).join(' ');
}

// Test
console.log(reverseAlternateWords('Hello World From JavaScript'));
// 'Hello dlroW From tpircSavaJ'

/**
 * Reverse words maintaining case pattern
 */
function reverseWordsKeepCase(str) {
  const words = str.split(' ');
  const reversed = words.reverse();
  
  return words.map((original, idx) => {
    const reversed_word = reversed[idx];
    return reversed_word.split('').map((char, i) => {
      if (i < original.length) {
        return original[i] === original[i].toUpperCase() 
          ? char.toUpperCase() 
          : char.toLowerCase();
      }
      return char;
    }).join('');
  }).join(' ');
}

// Test
console.log(reverseWordsKeepCase('Hello World'));
// 'Dlrow Olleh' (W->O is capital, h->d is lowercase, etc.)
```

**Interview Tips:**
- split().reverse().join() is simplest: O(n) time
- Handle multiple spaces with filter or regex
- Two-pointer in-place approach for character arrays
- Common variations: preserve spacing, reverse chars too, partial reversal
- Watch for edge cases: empty, single word, all spaces
- Can use regex for complex delimiters
- Follow-up: reverse only alternate words, preserve punctuation
- Used in: text processing, natural language tasks

</details>

45. Implement string search (indexOf) without using built-in methods

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Naive String Matching**
```javascript
/**
 * Implement indexOf without built-in methods
 * Time Complexity: O(n * m) where n = text length, m = pattern length
 * Space Complexity: O(1)
 * 
 * @param {string} text - Text to search in
 * @param {string} pattern - Pattern to search for
 * @returns {number} - Index of first occurrence or -1
 */
function indexOf(text, pattern) {
  if (pattern.length === 0) return 0;
  if (pattern.length > text.length) return -1;
  
  for (let i = 0; i <= text.length - pattern.length; i++) {
    let found = true;
    
    for (let j = 0; j < pattern.length; j++) {
      if (text[i + j] !== pattern[j]) {
        found = false;
        break;
      }
    }
    
    if (found) return i;
  }
  
  return -1;
}

// Test cases
console.log(indexOf('hello world', 'world'));
// 6

console.log(indexOf('hello world', 'hello'));
// 0

console.log(indexOf('hello world', 'xyz'));
// -1

console.log(indexOf('aaaaa', 'aa'));
// 0

console.log(indexOf('', 'test'));
// -1

console.log(indexOf('test', ''));
// 0
```

### **Approach 2: Find All Occurrences**
```javascript
/**
 * Find all occurrences of pattern
 * Time Complexity: O(n * m)
 * Space Complexity: O(k) where k is number of matches
 */
function findAll(text, pattern) {
  const indices = [];
  
  if (pattern.length === 0) return indices;
  
  for (let i = 0; i <= text.length - pattern.length; i++) {
    let match = true;
    
    for (let j = 0; j < pattern.length; j++) {
      if (text[i + j] !== pattern[j]) {
        match = false;
        break;
      }
    }
    
    if (match) {
      indices.push(i);
    }
  }
  
  return indices;
}

// Test
console.log(findAll('ababa', 'aba'));
// [0, 2]

console.log(findAll('aaaa', 'aa'));
// [0, 1, 2]
```

### **Approach 3: KMP Algorithm (Optimal)**
```javascript
/**
 * Knuth-Morris-Pratt algorithm for string matching
 * Time Complexity: O(n + m)
 * Space Complexity: O(m)
 * 
 * More efficient for large texts and patterns
 */
function indexOf(text, pattern) {
  if (pattern.length === 0) return 0;
  if (pattern.length > text.length) return -1;
  
  // Build LPS (Longest Proper Prefix which is also Suffix) array
  const lps = buildLPS(pattern);
  
  let i = 0; // text pointer
  let j = 0; // pattern pointer
  
  while (i < text.length) {
    if (text[i] === pattern[j]) {
      i++;
      j++;
      
      if (j === pattern.length) {
        return i - j; // Found match
      }
    } else {
      if (j > 0) {
        j = lps[j - 1]; // Use LPS to skip characters
      } else {
        i++;
      }
    }
  }
  
  return -1;
}

function buildLPS(pattern) {
  const lps = new Array(pattern.length).fill(0);
  let length = 0;
  let i = 1;
  
  while (i < pattern.length) {
    if (pattern[i] === pattern[length]) {
      length++;
      lps[i] = length;
      i++;
    } else {
      if (length > 0) {
        length = lps[length - 1];
      } else {
        lps[i] = 0;
        i++;
      }
    }
  }
  
  return lps;
}

// Test
console.log(indexOf('abcabcabc', 'abcabc'));
// 0

console.log(indexOf('aaaaaab', 'aaab'));
// 3
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready string search implementation
 * 
 * @param {string} text - Text to search in
 * @param {string} pattern - Pattern to search for
 * @param {Object} options - Search options
 * @param {number} options.startIndex - Start search from this index (default: 0)
 * @param {boolean} options.caseInsensitive - Ignore case (default: false)
 * @param {boolean} options.findAll - Return all occurrences (default: false)
 * @param {boolean} options.useKMP - Use KMP algorithm (default: true for large inputs)
 * @returns {number|Array} - Index or array of indices
 */
function indexOf(text, pattern, options = {}) {
  const {
    startIndex = 0,
    caseInsensitive = false,
    findAll = false,
    useKMP = pattern.length > 10
  } = options;
  
  // Validation
  if (typeof text !== 'string' || typeof pattern !== 'string') {
    throw new TypeError('Both arguments must be strings');
  }
  
  if (pattern.length === 0) {
    return findAll ? [] : startIndex;
  }
  
  if (startIndex < 0 || startIndex >= text.length) {
    return findAll ? [] : -1;
  }
  
  // Normalize case if needed
  const searchText = caseInsensitive ? text.toLowerCase() : text;
  const searchPattern = caseInsensitive ? pattern.toLowerCase() : pattern;
  
  if (findAll) {
    return findAllOccurrences(searchText, searchPattern, startIndex);
  }
  
  if (useKMP) {
    return kmpSearch(searchText, searchPattern, startIndex);
  }
  
  return naiveSearch(searchText, searchPattern, startIndex);
}

function naiveSearch(text, pattern, start) {
  for (let i = start; i <= text.length - pattern.length; i++) {
    let match = true;
    
    for (let j = 0; j < pattern.length; j++) {
      if (text[i + j] !== pattern[j]) {
        match = false;
        break;
      }
    }
    
    if (match) return i;
  }
  
  return -1;
}

function findAllOccurrences(text, pattern, start) {
  const indices = [];
  
  for (let i = start; i <= text.length - pattern.length; i++) {
    let match = true;
    
    for (let j = 0; j < pattern.length; j++) {
      if (text[i + j] !== pattern[j]) {
        match = false;
        break;
      }
    }
    
    if (match) {
      indices.push(i);
    }
  }
  
  return indices;
}

function kmpSearch(text, pattern, start) {
  const lps = buildLPS(pattern);
  let i = start;
  let j = 0;
  
  while (i < text.length) {
    if (text[i] === pattern[j]) {
      i++;
      j++;
      
      if (j === pattern.length) {
        return i - j;
      }
    } else {
      if (j > 0) {
        j = lps[j - 1];
      } else {
        i++;
      }
    }
  }
  
  return -1;
}

function buildLPS(pattern) {
  const lps = new Array(pattern.length).fill(0);
  let length = 0;
  let i = 1;
  
  while (i < pattern.length) {
    if (pattern[i] === pattern[length]) {
      length++;
      lps[i] = length;
      i++;
    } else {
      if (length > 0) {
        length = lps[length - 1];
      } else {
        lps[i] = 0;
        i++;
      }
    }
  }
  
  return lps;
}

// Implement lastIndexOf (search from end)
function lastIndexOf(text, pattern) {
  if (pattern.length === 0) return text.length;
  if (pattern.length > text.length) return -1;
  
  for (let i = text.length - pattern.length; i >= 0; i--) {
    let match = true;
    
    for (let j = 0; j < pattern.length; j++) {
      if (text[i + j] !== pattern[j]) {
        match = false;
        break;
      }
    }
    
    if (match) return i;
  }
  
  return -1;
}

// Count occurrences
function countOccurrences(text, pattern) {
  const indices = indexOf(text, pattern, { findAll: true });
  return indices.length;
}

// Comprehensive test suite
console.log('=== Basic Search ===');
console.log(indexOf('hello world', 'world'));
// 6

console.log(indexOf('hello world', 'hello'));
// 0

console.log(indexOf('hello world', 'xyz'));
// -1

console.log('\n=== Find All ===');
console.log(indexOf('ababa', 'aba', { findAll: true }));
// [0, 2]

console.log(indexOf('aaaa', 'aa', { findAll: true }));
// [0, 1, 2]

console.log('\n=== Case Insensitive ===');
console.log(indexOf('Hello World', 'WORLD', { caseInsensitive: true }));
// 6

console.log(indexOf('JavaScript', 'script', { caseInsensitive: true }));
// 4

console.log('\n=== Start Index ===');
console.log(indexOf('abcabc', 'abc', { startIndex: 1 }));
// 3

console.log(indexOf('hello hello', 'hello', { startIndex: 1 }));
// 6

console.log('\n=== Edge Cases ===');
console.log(indexOf('', 'test'));
// -1

console.log(indexOf('test', ''));
// 0

console.log(indexOf('abc', 'abcd'));
// -1 (pattern longer than text)

console.log('\n=== Last Index Of ===');
console.log(lastIndexOf('hello hello', 'hello'));
// 6

console.log(lastIndexOf('abcabc', 'abc'));
// 3

console.log('\n=== Count Occurrences ===');
console.log(countOccurrences('ababa', 'aba'));
// 2

console.log(countOccurrences('aaaa', 'aa'));
// 3

console.log('\n=== KMP Performance ===');
const longText = 'a'.repeat(10000) + 'b';
const pattern = 'a'.repeat(100) + 'b';
console.log(indexOf(longText, pattern, { useKMP: true }));
// 9900

console.log('\n=== Overlapping Matches ===');
console.log(indexOf('aaa', 'aa', { findAll: true }));
// [0, 1]
```

### **Bonus: Other String Matching Algorithms**
```javascript
/**
 * Rabin-Karp algorithm (rolling hash)
 */
function rabinKarp(text, pattern) {
  const d = 256; // Number of characters in alphabet
  const q = 101; // A prime number
  
  const m = pattern.length;
  const n = text.length;
  let patternHash = 0;
  let textHash = 0;
  let h = 1;
  
  // h = d^(m-1) % q
  for (let i = 0; i < m - 1; i++) {
    h = (h * d) % q;
  }
  
  // Calculate initial hash values
  for (let i = 0; i < m; i++) {
    patternHash = (d * patternHash + pattern.charCodeAt(i)) % q;
    textHash = (d * textHash + text.charCodeAt(i)) % q;
  }
  
  // Slide pattern over text
  for (let i = 0; i <= n - m; i++) {
    if (patternHash === textHash) {
      // Check character by character
      let match = true;
      for (let j = 0; j < m; j++) {
        if (text[i + j] !== pattern[j]) {
          match = false;
          break;
        }
      }
      if (match) return i;
    }
    
    // Calculate hash for next window
    if (i < n - m) {
      textHash = (d * (textHash - text.charCodeAt(i) * h) + text.charCodeAt(i + m)) % q;
      
      if (textHash < 0) {
        textHash += q;
      }
    }
  }
  
  return -1;
}

// Test
console.log(rabinKarp('hello world', 'world'));
// 6
```

**Interview Tips:**
- Naive approach: O(n*m) - check every position
- KMP algorithm: O(n+m) - optimal, uses LPS array
- Rabin-Karp: O(n+m) average - uses rolling hash
- Handle edge cases: empty strings, pattern longer than text
- Common optimizations: early termination, skip obvious mismatches
- Follow-ups: find all, case-insensitive, lastIndexOf, count
- Used in: text editors, search engines, DNA sequencing
- Built-in indexOf uses optimized C++ Boyer-Moore-Horspool variant

</details>

46. Count vowels and consonants in a string

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Simple Loop**
```javascript
/**
 * Count vowels and consonants
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * @param {string} str - Input string
 * @returns {Object} - {vowels, consonants}
 */
function countVowelsConsonants(str) {
  const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
  let vowelCount = 0;
  let consonantCount = 0;
  
  for (const char of str) {
    if (vowels.has(char)) {
      vowelCount++;
    } else if ((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z')) {
      consonantCount++;
    }
  }
  
  return { vowels: vowelCount, consonants: consonantCount };
}

// Test cases
console.log(countVowelsConsonants('Hello World'));
// { vowels: 3, consonants: 7 }

console.log(countVowelsConsonants('JavaScript'));
// { vowels: 3, consonants: 7 }

console.log(countVowelsConsonants('aeiou'));
// { vowels: 5, consonants: 0 }

console.log(countVowelsConsonants('bcdfg'));
// { vowels: 0, consonants: 5 }
```

### **Approach 2: Using Regex**
```javascript
/**
 * Count using regular expressions
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
function countVowelsConsonants(str) {
  const vowels = str.match(/[aeiou]/gi) || [];
  const consonants = str.match(/[bcdfghjklmnpqrstvwxyz]/gi) || [];
  
  return {
    vowels: vowels.length,
    consonants: consonants.length
  };
}

// Test
console.log(countVowelsConsonants('Hello World'));
// { vowels: 3, consonants: 7 }
```

### **Approach 3: Detailed Count (Each Vowel/Consonant)**
```javascript
/**
 * Count frequency of each vowel and consonant
 * Time Complexity: O(n)
 * Space Complexity: O(1) - fixed size map
 */
function countVowelsConsonantsDetailed(str) {
  const vowels = new Set(['a', 'e', 'i', 'o', 'u']);
  const vowelCounts = {};
  const consonantCounts = {};
  
  for (const char of str.toLowerCase()) {
    if (vowels.has(char)) {
      vowelCounts[char] = (vowelCounts[char] || 0) + 1;
    } else if (char >= 'a' && char <= 'z') {
      consonantCounts[char] = (consonantCounts[char] || 0) + 1;
    }
  }
  
  return {
    vowels: vowelCounts,
    consonants: consonantCounts,
    vowelTotal: Object.values(vowelCounts).reduce((a, b) => a + b, 0),
    consonantTotal: Object.values(consonantCounts).reduce((a, b) => a + b, 0)
  };
}

// Test
console.log(countVowelsConsonantsDetailed('Hello World'));
/*
{
  vowels: { e: 1, o: 2 },
  consonants: { h: 1, l: 3, w: 1, r: 1, d: 1 },
  vowelTotal: 3,
  consonantTotal: 7
}
*/
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready vowel and consonant counter
 * 
 * @param {string} str - Input string
 * @param {Object} options - Count options
 * @param {boolean} options.includeY - Treat 'y' as vowel (default: false)
 * @param {boolean} options.detailed - Return frequency of each letter (default: false)
 * @param {boolean} options.includeNumbers - Count numbers separately (default: false)
 * @param {boolean} options.includeSpecial - Count special chars separately (default: false)
 * @returns {Object} - Count results
 */
function countVowelsConsonants(str, options = {}) {
  const {
    includeY = false,
    detailed = false,
    includeNumbers = false,
    includeSpecial = false
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  const vowelSet = includeY 
    ? new Set(['a', 'e', 'i', 'o', 'u', 'y'])
    : new Set(['a', 'e', 'i', 'o', 'u']);
  
  const counts = {
    vowels: 0,
    consonants: 0
  };
  
  if (detailed) {
    counts.vowelFreq = {};
    counts.consonantFreq = {};
  }
  
  if (includeNumbers) {
    counts.numbers = 0;
    if (detailed) counts.numberFreq = {};
  }
  
  if (includeSpecial) {
    counts.special = 0;
    if (detailed) counts.specialFreq = {};
  }
  
  for (const char of str) {
    const lower = char.toLowerCase();
    
    if (vowelSet.has(lower)) {
      counts.vowels++;
      if (detailed) {
        counts.vowelFreq[lower] = (counts.vowelFreq[lower] || 0) + 1;
      }
    } else if (lower >= 'a' && lower <= 'z') {
      counts.consonants++;
      if (detailed) {
        counts.consonantFreq[lower] = (counts.consonantFreq[lower] || 0) + 1;
      }
    } else if (includeNumbers && char >= '0' && char <= '9') {
      counts.numbers++;
      if (detailed) {
        counts.numberFreq[char] = (counts.numberFreq[char] || 0) + 1;
      }
    } else if (includeSpecial && char !== ' ') {
      counts.special++;
      if (detailed) {
        counts.specialFreq[char] = (counts.specialFreq[char] || 0) + 1;
      }
    }
  }
  
  return counts;
}

// Get vowel/consonant ratio
function getVowelConsonantRatio(str) {
  const { vowels, consonants } = countVowelsConsonants(str);
  
  if (consonants === 0) return Infinity;
  
  return (vowels / consonants).toFixed(2);
}

// Check if string is vowel-heavy or consonant-heavy
function classifyString(str) {
  const { vowels, consonants } = countVowelsConsonants(str);
  const ratio = vowels / consonants;
  
  if (ratio > 1) return 'vowel-heavy';
  if (ratio < 0.5) return 'consonant-heavy';
  return 'balanced';
}

// Find longest vowel/consonant sequence
function longestSequence(str, type = 'vowel') {
  const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
  let maxLength = 0;
  let currentLength = 0;
  let maxStart = 0;
  let currentStart = 0;
  
  for (let i = 0; i < str.length; i++) {
    const isVowel = vowels.has(str[i]);
    const isTarget = (type === 'vowel' && isVowel) || (type === 'consonant' && !isVowel && /[a-zA-Z]/.test(str[i]));
    
    if (isTarget) {
      if (currentLength === 0) {
        currentStart = i;
      }
      currentLength++;
      
      if (currentLength > maxLength) {
        maxLength = currentLength;
        maxStart = currentStart;
      }
    } else {
      currentLength = 0;
    }
  }
  
  return {
    length: maxLength,
    sequence: str.substring(maxStart, maxStart + maxLength)
  };
}

// Comprehensive test suite
console.log('=== Basic Count ===');
console.log(countVowelsConsonants('Hello World'));
// { vowels: 3, consonants: 7 }

console.log(countVowelsConsonants('JavaScript'));
// { vowels: 3, consonants: 7 }

console.log('\n=== Include Y as Vowel ===');
console.log(countVowelsConsonants('Happy Birthday', { includeY: true }));
// Y counted as vowel

console.log('\n=== Detailed Frequency ===');
console.log(countVowelsConsonants('Hello', { detailed: true }));
/*
{
  vowels: 2,
  consonants: 3,
  vowelFreq: { e: 1, o: 1 },
  consonantFreq: { h: 1, l: 2 }
}
*/

console.log('\n=== Include Numbers ===');
console.log(countVowelsConsonants('Hello123', { includeNumbers: true }));
// { vowels: 2, consonants: 3, numbers: 3 }

console.log('\n=== Include Special Characters ===');
console.log(countVowelsConsonants('Hello!@#', {
  includeSpecial: true,
  detailed: true
}));

console.log('\n=== Edge Cases ===');
console.log(countVowelsConsonants(''));
// { vowels: 0, consonants: 0 }

console.log(countVowelsConsonants('aeiou'));
// { vowels: 5, consonants: 0 }

console.log(countVowelsConsonants('bcdfg'));
// { vowels: 0, consonants: 5 }

console.log(countVowelsConsonants('123!@#'));
// { vowels: 0, consonants: 0 }

console.log('\n=== Vowel/Consonant Ratio ===');
console.log(getVowelConsonantRatio('Hello World'));
// '0.43'

console.log(getVowelConsonantRatio('aeiou'));
// 'Infinity'

console.log('\n=== Classify String ===');
console.log(classifyString('aeiou bcdfg'));
// 'balanced'

console.log(classifyString('programming'));
// 'consonant-heavy'

console.log(classifyString('beautiful'));
// 'vowel-heavy'

console.log('\n=== Longest Sequence ===');
console.log(longestSequence('programming', 'consonant'));
// { length: 5, sequence: 'prgrmm' }

console.log(longestSequence('beautiful', 'vowel'));
// { length: 3, sequence: 'eau' }

console.log('\n=== Case Insensitive ===');
console.log(countVowelsConsonants('HELLO world'));
// { vowels: 3, consonants: 7 }

console.log('\n=== Mixed Content ===');
console.log(countVowelsConsonants('The price is $100.50', {
  includeNumbers: true,
  includeSpecial: true
}));
```

### **Bonus: Advanced Analysis**
```javascript
/**
 * Calculate readability score based on vowel/consonant distribution
 */
function calculateReadability(str) {
  const { vowels, consonants } = countVowelsConsonants(str);
  const total = vowels + consonants;
  
  if (total === 0) return 0;
  
  const vowelRatio = vowels / total;
  
  // Optimal vowel ratio is around 0.38-0.42 for English
  const deviation = Math.abs(vowelRatio - 0.40);
  const score = Math.max(0, 100 - deviation * 200);
  
  return {
    score: Math.round(score),
    vowelRatio: vowelRatio.toFixed(2),
    rating: score > 80 ? 'excellent' : score > 60 ? 'good' : score > 40 ? 'fair' : 'poor'
  };
}

// Test
console.log(calculateReadability('The quick brown fox jumps over the lazy dog'));
// Analyzes vowel distribution quality
```

**Interview Tips:**
- Simple Set/loop approach is O(n) time, O(1) space
- Regex approach is concise but slightly slower
- Include 'y' as vowel is language-dependent (ask interviewer)
- Can extend to: frequency analysis, longest sequences, ratios
- Handle edge cases: empty string, no vowels/consonants, special chars
- Common follow-ups: most/least common, alternating pattern, balanced
- Used in: linguistics, readability analysis, text classification
- Can optimize with lookup table or bitmask for character classification

</details>

47. Find all permutations of a string

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Recursive Backtracking**
```javascript
/**
 * Find all permutations using recursion
 * Time Complexity: O(n! * n)
 * Space Complexity: O(n! * n) for result + O(n) recursion stack
 * 
 * @param {string} str - Input string
 * @returns {Array} - Array of all permutations
 */
function permutations(str) {
  const result = [];
  
  function backtrack(current, remaining) {
    if (remaining.length === 0) {
      result.push(current);
      return;
    }
    
    for (let i = 0; i < remaining.length; i++) {
      const char = remaining[i];
      const newRemaining = remaining.slice(0, i) + remaining.slice(i + 1);
      backtrack(current + char, newRemaining);
    }
  }
  
  backtrack('', str);
  return result;
}

// Test cases
console.log(permutations('abc'));
// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']

console.log(permutations('ab'));
// ['ab', 'ba']

console.log(permutations('a'));
// ['a']

console.log(permutations(''));
// ['']
```

### **Approach 2: Using Array Swap**
```javascript
/**
 * Generate permutations using in-place swapping
 * Time Complexity: O(n!)
 * Space Complexity: O(n) recursion stack
 */
function permutations(str) {
  const result = [];
  const chars = str.split('');
  
  function backtrack(index) {
    if (index === chars.length) {
      result.push(chars.join(''));
      return;
    }
    
    for (let i = index; i < chars.length; i++) {
      // Swap
      [chars[index], chars[i]] = [chars[i], chars[index]];
      
      // Recurse
      backtrack(index + 1);
      
      // Backtrack (swap back)
      [chars[index], chars[i]] = [chars[i], chars[index]];
    }
  }
  
  backtrack(0);
  return result;
}

// Test
console.log(permutations('abc'));
// ['abc', 'acb', 'bac', 'bca', 'cba', 'cab']
```

### **Approach 3: Handle Duplicate Characters**
```javascript
/**
 * Generate unique permutations (no duplicates)
 * Time Complexity: O(n!)
 * Space Complexity: O(n!)
 */
function uniquePermutations(str) {
  const result = [];
  const chars = str.split('').sort(); // Sort for easier duplicate handling
  const used = new Array(chars.length).fill(false);
  
  function backtrack(current) {
    if (current.length === chars.length) {
      result.push(current);
      return;
    }
    
    for (let i = 0; i < chars.length; i++) {
      // Skip if used or duplicate
      if (used[i]) continue;
      if (i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) continue;
      
      used[i] = true;
      backtrack(current + chars[i]);
      used[i] = false;
    }
  }
  
  backtrack('');
  return result;
}

// Test
console.log(uniquePermutations('aab'));
// ['aab', 'aba', 'baa'] (no duplicates like 'aab' appearing twice)

console.log(uniquePermutations('aaa'));
// ['aaa'] (only one unique permutation)
```

### **Approach 4: Iterative (Heap's Algorithm)**
```javascript
/**
 * Heap's algorithm for generating permutations iteratively
 * Time Complexity: O(n!)
 * Space Complexity: O(n)
 */
function permutations(str) {
  const result = [];
  const arr = str.split('');
  const n = arr.length;
  const c = new Array(n).fill(0);
  
  result.push(arr.join(''));
  
  let i = 0;
  while (i < n) {
    if (c[i] < i) {
      if (i % 2 === 0) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
      } else {
        [arr[c[i]], arr[i]] = [arr[i], arr[c[i]]];
      }
      
      result.push(arr.join(''));
      c[i]++;
      i = 0;
    } else {
      c[i] = 0;
      i++;
    }
  }
  
  return result;
}

// Test
console.log(permutations('abc'));
// All 6 permutations
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready permutation generator
 * 
 * @param {string} str - Input string
 * @param {Object} options - Generation options
 * @param {boolean} options.unique - Remove duplicate permutations (default: true)
 * @param {number} options.length - Generate permutations of specific length (default: str.length)
 * @param {boolean} options.caseInsensitive - Treat a and A as same (default: false)
 * @param {Function} options.filter - Filter function for permutations
 * @returns {Array} - Array of permutations
 */
function permutations(str, options = {}) {
  const {
    unique = true,
    length = str.length,
    caseInsensitive = false,
    filter = null
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  if (str.length === 0) {
    return [''];
  }
  
  const workStr = caseInsensitive ? str.toLowerCase() : str;
  const chars = workStr.split('');
  
  if (unique) {
    chars.sort();
  }
  
  const result = [];
  const used = new Array(chars.length).fill(false);
  
  function backtrack(current) {
    if (current.length === length) {
      if (!filter || filter(current)) {
        result.push(current);
      }
      return;
    }
    
    for (let i = 0; i < chars.length; i++) {
      if (used[i]) continue;
      
      // Skip duplicates if unique mode
      if (unique && i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) {
        continue;
      }
      
      used[i] = true;
      backtrack(current + chars[i]);
      used[i] = false;
    }
  }
  
  backtrack('');
  return result;
}

// Generate k-length permutations (nPk)
function permutationsOfLength(str, k) {
  return permutations(str, { length: k });
}

// Count permutations without generating them
function countPermutations(str, unique = true) {
  if (!unique) {
    return factorial(str.length);
  }
  
  // Count with duplicates: n! / (n1! * n2! * ... * nk!)
  const freq = {};
  for (const char of str) {
    freq[char] = (freq[char] || 0) + 1;
  }
  
  let count = factorial(str.length);
  for (const f of Object.values(freq)) {
    count /= factorial(f);
  }
  
  return count;
}

function factorial(n) {
  if (n <= 1) return 1;
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

// Generator function for memory efficiency
function* permutationGenerator(str) {
  const chars = str.split('');
  const n = chars.length;
  const c = new Array(n).fill(0);
  
  yield chars.join('');
  
  let i = 0;
  while (i < n) {
    if (c[i] < i) {
      if (i % 2 === 0) {
        [chars[0], chars[i]] = [chars[i], chars[0]];
      } else {
        [chars[c[i]], chars[i]] = [chars[i], chars[c[i]]];
      }
      
      yield chars.join('');
      c[i]++;
      i = 0;
    } else {
      c[i] = 0;
      i++;
    }
  }
}

// Get nth permutation without generating all
function nthPermutation(str, n) {
  const chars = str.split('').sort();
  const result = [];
  const available = [...chars];
  const len = chars.length;
  
  // Adjust for 0-based index
  n = n - 1;
  
  for (let i = 0; i < len; i++) {
    const fact = factorial(len - 1 - i);
    const index = Math.floor(n / fact);
    
    result.push(available[index]);
    available.splice(index, 1);
    
    n %= fact;
  }
  
  return result.join('');
}

// Comprehensive test suite
console.log('=== Basic Permutations ===');
console.log(permutations('abc'));
// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']

console.log(permutations('ab'));
// ['ab', 'ba']

console.log('\n=== Unique Permutations (With Duplicates) ===');
console.log(permutations('aab'));
// ['aab', 'aba', 'baa']

console.log(permutations('aaa'));
// ['aaa']

console.log('\n=== Non-Unique Mode ===');
console.log(permutations('aa', { unique: false }));
// ['aa', 'aa'] (duplicates allowed)

console.log('\n=== Specific Length (k-permutations) ===');
console.log(permutations('abc', { length: 2 }));
// ['ab', 'ac', 'ba', 'bc', 'ca', 'cb']

console.log(permutations('abcd', { length: 2 }));
// 12 permutations (4P2 = 12)

console.log('\n=== With Filter ===');
console.log(permutations('abc', {
  filter: perm => perm.startsWith('a')
}));
// ['abc', 'acb'] (only permutations starting with 'a')

console.log('\n=== Case Insensitive ===');
console.log(permutations('Abc', { caseInsensitive: true }));
// All lowercase permutations

console.log('\n=== Edge Cases ===');
console.log(permutations(''));
// ['']

console.log(permutations('a'));
// ['a']

console.log('\n=== Count Permutations ===');
console.log(countPermutations('abc'));
// 6 (3! = 6)

console.log(countPermutations('aab'));
// 3 (3! / 2! = 3)

console.log(countPermutations('aabb'));
// 6 (4! / (2! * 2!) = 6)

console.log('\n=== Nth Permutation ===');
console.log(nthPermutation('abc', 1));
// 'abc' (1st permutation)

console.log(nthPermutation('abc', 3));
// 'bac' (3rd permutation)

console.log(nthPermutation('abc', 6));
// 'cba' (6th/last permutation)

console.log('\n=== Generator (Memory Efficient) ===');
const gen = permutationGenerator('ab');
console.log(gen.next().value); // 'ab'
console.log(gen.next().value); // 'ba'
console.log(gen.next().done);  // true

console.log('\n=== Large String Count ===');
console.log(countPermutations('abcd'));
// 24 (4! = 24)

console.log(countPermutations('aabcd'));
// 60 (5! / 2! = 60)

console.log('\n=== Longer Strings ===');
console.log(permutations('abcd').length);
// 24

console.log(permutations('abc', { length: 1 }));
// ['a', 'b', 'c']
```

### **Bonus: Related Problems**
```javascript
/**
 * Check if one string is a permutation of another
 */
function isPermutation(str1, str2) {
  if (str1.length !== str2.length) return false;
  
  const freq = {};
  
  for (const char of str1) {
    freq[char] = (freq[char] || 0) + 1;
  }
  
  for (const char of str2) {
    if (!freq[char]) return false;
    freq[char]--;
  }
  
  return true;
}

// Test
console.log(isPermutation('abc', 'bca'));
// true

console.log(isPermutation('abc', 'def'));
// false

/**
 * Next lexicographic permutation
 */
function nextPermutation(str) {
  const chars = str.split('');
  let i = chars.length - 2;
  
  // Find first decreasing element from right
  while (i >= 0 && chars[i] >= chars[i + 1]) {
    i--;
  }
  
  if (i < 0) {
    return null; // Already last permutation
  }
  
  // Find smallest element greater than chars[i] to the right
  let j = chars.length - 1;
  while (chars[j] <= chars[i]) {
    j--;
  }
  
  // Swap
  [chars[i], chars[j]] = [chars[j], chars[i]];
  
  // Reverse the suffix
  let left = i + 1;
  let right = chars.length - 1;
  while (left < right) {
    [chars[left], chars[right]] = [chars[right], chars[left]];
    left++;
    right--;
  }
  
  return chars.join('');
}

// Test
console.log(nextPermutation('abc'));
// 'acb'

console.log(nextPermutation('acb'));
// 'bac'

console.log(nextPermutation('cba'));
// null (last permutation)

/**
 * Find all anagrams of a pattern in a string
 */
function findAnagrams(text, pattern) {
  const result = [];
  const patternFreq = {};
  const windowFreq = {};
  
  for (const char of pattern) {
    patternFreq[char] = (patternFreq[char] || 0) + 1;
  }
  
  let left = 0;
  let matched = 0;
  
  for (let right = 0; right < text.length; right++) {
    const char = text[right];
    
    if (char in patternFreq) {
      windowFreq[char] = (windowFreq[char] || 0) + 1;
      if (windowFreq[char] === patternFreq[char]) {
        matched++;
      }
    }
    
    if (right - left + 1 > pattern.length) {
      const leftChar = text[left];
      if (leftChar in patternFreq) {
        if (windowFreq[leftChar] === patternFreq[leftChar]) {
          matched--;
        }
        windowFreq[leftChar]--;
      }
      left++;
    }
    
    if (matched === Object.keys(patternFreq).length) {
      result.push(left);
    }
  }
  
  return result;
}

// Test
console.log(findAnagrams('cbaebabacd', 'abc'));
// [0, 6] (indices where anagrams start)
```

**Interview Tips:**
- Recursive backtracking is most intuitive: O(n!)
- Heap's algorithm is efficient for iterative generation
- For duplicates, sort first and skip identical adjacent elements
- n! grows very fast: 10! = 3.6M, be careful with large strings
- Can optimize with generator functions for memory efficiency
- Common variations: k-length permutations, nth permutation, next permutation
- Follow-ups: count without generating, check if permutation, find anagrams
- Used in: combinatorial problems, cryptography, puzzles

</details>

48. Implement a function to truncate a string with ellipsis

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Simple Truncation**
```javascript
/**
 * Truncate string with ellipsis
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * @param {string} str - Input string
 * @param {number} maxLength - Maximum length including ellipsis
 * @returns {string} - Truncated string
 */
function truncate(str, maxLength) {
  if (str.length <= maxLength) {
    return str;
  }
  
  return str.slice(0, maxLength - 3) + '...';
}

// Test cases
console.log(truncate('Hello World', 8));
// 'Hello...'

console.log(truncate('JavaScript', 20));
// 'JavaScript' (no truncation needed)

console.log(truncate('This is a long string', 10));
// 'This is...'
```

### **Approach 2: Truncate at Word Boundary**
```javascript
/**
 * Truncate at word boundary to avoid cutting words
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
function truncate(str, maxLength) {
  if (str.length <= maxLength) {
    return str;
  }
  
  // Find last space before maxLength
  let truncated = str.slice(0, maxLength - 3);
  const lastSpace = truncated.lastIndexOf(' ');
  
  if (lastSpace > 0) {
    truncated = truncated.slice(0, lastSpace);
  }
  
  return truncated + '...';
}

// Test
console.log(truncate('The quick brown fox', 15));
// 'The quick...' (doesn't cut 'brown')

console.log(truncate('Hello World', 8));
// 'Hello...'
```

### **Approach 3: Custom Ellipsis**
```javascript
/**
 * Truncate with custom ellipsis character(s)
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 */
function truncate(str, maxLength, ellipsis = '...') {
  if (str.length <= maxLength) {
    return str;
  }
  
  return str.slice(0, maxLength - ellipsis.length) + ellipsis;
}

// Test
console.log(truncate('Hello World', 8, '…'));
// 'Hello W…'

console.log(truncate('Hello World', 10, ' [...]'));
// 'Hell [...]'
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready string truncation
 * 
 * @param {string} str - Input string
 * @param {number} maxLength - Maximum length
 * @param {Object} options - Truncation options
 * @param {string} options.ellipsis - Ellipsis string (default: '...')
 * @param {boolean} options.wordBoundary - Break at word boundary (default: true)
 * @param {boolean} options.html - Preserve HTML tags (default: false)
 * @param {string} options.position - Where to truncate: 'end', 'middle', 'start' (default: 'end')
 * @returns {string} - Truncated string
 */
function truncate(str, maxLength, options = {}) {
  const {
    ellipsis = '...',
    wordBoundary = true,
    html = false,
    position = 'end'
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('First argument must be a string');
  }
  
  if (typeof maxLength !== 'number' || maxLength < 0) {
    throw new TypeError('maxLength must be a non-negative number');
  }
  
  // Remove HTML tags if not preserving
  let workStr = str;
  if (html) {
    const textOnly = str.replace(/<[^>]*>/g, '');
    if (textOnly.length <= maxLength) {
      return str;
    }
  } else {
    workStr = str;
  }
  
  if (workStr.length <= maxLength) {
    return str;
  }
  
  // Different truncation positions
  switch (position) {
    case 'start':
      return truncateStart(workStr, maxLength, ellipsis, wordBoundary);
    
    case 'middle':
      return truncateMiddle(workStr, maxLength, ellipsis);
    
    case 'end':
    default:
      return truncateEnd(workStr, maxLength, ellipsis, wordBoundary);
  }
}

function truncateEnd(str, maxLength, ellipsis, wordBoundary) {
  let truncated = str.slice(0, maxLength - ellipsis.length);
  
  if (wordBoundary) {
    const lastSpace = truncated.lastIndexOf(' ');
    if (lastSpace > 0) {
      truncated = truncated.slice(0, lastSpace);
    }
  }
  
  return truncated.trim() + ellipsis;
}

function truncateStart(str, maxLength, ellipsis, wordBoundary) {
  let truncated = str.slice(str.length - (maxLength - ellipsis.length));
  
  if (wordBoundary) {
    const firstSpace = truncated.indexOf(' ');
    if (firstSpace >= 0 && firstSpace < truncated.length - 1) {
      truncated = truncated.slice(firstSpace + 1);
    }
  }
  
  return ellipsis + truncated.trim();
}

function truncateMiddle(str, maxLength, ellipsis) {
  const charsToShow = maxLength - ellipsis.length;
  const frontChars = Math.ceil(charsToShow / 2);
  const backChars = Math.floor(charsToShow / 2);
  
  return str.slice(0, frontChars) + ellipsis + str.slice(str.length - backChars);
}

// Truncate with character count display
function truncateWithCount(str, maxLength, ellipsis = '...') {
  if (str.length <= maxLength) {
    return str;
  }
  
  const remaining = str.length - maxLength;
  return str.slice(0, maxLength - ellipsis.length) + ellipsis + ` (+${remaining})`;
}

// Truncate multiline text
function truncateLines(str, maxLines, ellipsis = '...') {
  const lines = str.split('\n');
  
  if (lines.length <= maxLines) {
    return str;
  }
  
  return lines.slice(0, maxLines).join('\n') + ellipsis;
}

// Smart truncate (tries to keep sentence structure)
function smartTruncate(str, maxLength) {
  if (str.length <= maxLength) {
    return str;
  }
  
  // Try to truncate at sentence boundary
  const truncated = str.slice(0, maxLength - 3);
  const lastPeriod = truncated.lastIndexOf('.');
  const lastQuestion = truncated.lastIndexOf('?');
  const lastExclamation = truncated.lastIndexOf('!');
  
  const sentenceEnd = Math.max(lastPeriod, lastQuestion, lastExclamation);
  
  if (sentenceEnd > maxLength * 0.5) {
    return str.slice(0, sentenceEnd + 1);
  }
  
  // Fall back to word boundary
  const lastSpace = truncated.lastIndexOf(' ');
  if (lastSpace > 0) {
    return truncated.slice(0, lastSpace) + '...';
  }
  
  return truncated + '...';
}

// Comprehensive test suite
console.log('=== Basic Truncation ===');
console.log(truncate('Hello World', 8));
// 'Hello...'

console.log(truncate('JavaScript Programming', 15));
// 'JavaScript...'

console.log('\n=== No Truncation Needed ===');
console.log(truncate('Hello', 10));
// 'Hello'

console.log('\n=== Word Boundary ===');
console.log(truncate('The quick brown fox', 15, { wordBoundary: true }));
// 'The quick...'

console.log(truncate('The quick brown fox', 15, { wordBoundary: false }));
// 'The quick b...'

console.log('\n=== Custom Ellipsis ===');
console.log(truncate('Hello World', 8, { ellipsis: '…' }));
// 'Hello W…'

console.log(truncate('Hello World', 10, { ellipsis: ' [more]' }));
// 'Hel [more]'

console.log('\n=== Start Truncation ===');
console.log(truncate('This is a long file path', 15, { position: 'start' }));
// '...file path'

console.log('\n=== Middle Truncation ===');
console.log(truncate('VeryLongFileName.txt', 15, { position: 'middle' }));
// 'VeryLo...me.txt'

console.log('\n=== With Count ===');
console.log(truncateWithCount('This is a very long string', 10));
// 'This is... (+16)'

console.log('\n=== Multiline Truncation ===');
const multiline = 'Line 1\nLine 2\nLine 3\nLine 4\nLine 5';
console.log(truncateLines(multiline, 3));
// 'Line 1\nLine 2\nLine 3...'

console.log('\n=== Smart Truncation ===');
console.log(smartTruncate('This is sentence one. This is sentence two.', 25));
// 'This is sentence one.'

console.log(smartTruncate('No punctuation here at all', 15));
// 'No punctuation...'

console.log('\n=== Edge Cases ===');
console.log(truncate('', 10));
// ''

console.log(truncate('Hi', 10));
// 'Hi'

console.log(truncate('Test', 3));
// 'Test' (can't truncate to less than ellipsis length)

console.log('\n=== HTML Content ===');
console.log(truncate('<p>Hello World</p>', 10, { html: true }));
// '<p>Hello World</p>' (preserves if text content fits)

console.log('\n=== Long Words ===');
console.log(truncate('Supercalifragilisticexpialidocious', 15));
// 'Supercalif...'

console.log('\n=== Unicode Characters ===');
console.log(truncate('Hello 👋 World 🌍', 10));
// Handles emoji properly
```

### **Bonus: Advanced Truncation**
```javascript
/**
 * Truncate with tooltip showing full text
 */
function truncateWithTooltip(str, maxLength) {
  if (str.length <= maxLength) {
    return str;
  }
  
  const truncated = str.slice(0, maxLength - 3) + '...';
  return {
    display: truncated,
    full: str,
    html: `<span title="${str}">${truncated}</span>`
  };
}

// Test
console.log(truncateWithTooltip('This is a long string', 10));
/*
{
  display: 'This is...',
  full: 'This is a long string',
  html: '<span title="This is a long string">This is...</span>'
}
*/

/**
 * Truncate preserving code formatting
 */
function truncateCode(code, maxLength) {
  if (code.length <= maxLength) {
    return code;
  }
  
  const lines = code.split('\n');
  let truncated = '';
  
  for (const line of lines) {
    if (truncated.length + line.length + 4 <= maxLength) {
      truncated += line + '\n';
    } else {
      truncated += '...';
      break;
    }
  }
  
  return truncated.trim();
}
```

**Interview Tips:**
- Simple slice + '...' is O(1) and usually sufficient
- Word boundary prevents cutting words in half
- Consider position: end (default), middle (file names), start (paths)
- Custom ellipsis for different contexts: '…', ' [more]', ' (more)'
- For HTML, strip tags before measuring or preserve them
- Smart truncation at sentence/paragraph boundaries
- Common use cases: previews, lists, mobile displays, tooltips
- Be careful with Unicode/emoji when counting characters

</details>

49. Check if one string is a rotation of another

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Concatenation Method**
```javascript
/**
 * Check if str2 is rotation of str1
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {boolean} - True if str2 is rotation of str1
 */
function isRotation(str1, str2) {
  // Must be same length and not empty
  if (str1.length !== str2.length || str1.length === 0) {
    return false;
  }
  
  // If str2 is rotation, it will be substring of str1+str1
  return (str1 + str1).includes(str2);
}

// Test cases
console.log(isRotation('waterbottle', 'erbottlewat'));
// true

console.log(isRotation('hello', 'lohel'));
// true

console.log(isRotation('hello', 'world'));
// false

console.log(isRotation('abc', 'cab'));
// true

console.log(isRotation('abc', 'acb'));
// false (permutation, not rotation)
```

### **Approach 2: Find Rotation Point**
```javascript
/**
 * Check rotation by finding the rotation point
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
function isRotation(str1, str2) {
  if (str1.length !== str2.length || str1.length === 0) {
    return false;
  }
  
  if (str1 === str2) {
    return true;
  }
  
  // Try each possible rotation point
  for (let i = 0; i < str1.length; i++) {
    let match = true;
    
    for (let j = 0; j < str1.length; j++) {
      if (str1[j] !== str2[(i + j) % str2.length]) {
        match = false;
        break;
      }
    }
    
    if (match) return true;
  }
  
  return false;
}

// Test
console.log(isRotation('abcde', 'cdeab'));
// true
```

### **Approach 3: Using KMP Pattern Matching**
```javascript
/**
 * Check rotation using KMP algorithm
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function isRotation(str1, str2) {
  if (str1.length !== str2.length || str1.length === 0) {
    return false;
  }
  
  return kmpSearch(str1 + str1, str2) !== -1;
}

function kmpSearch(text, pattern) {
  const lps = buildLPS(pattern);
  let i = 0, j = 0;
  
  while (i < text.length) {
    if (text[i] === pattern[j]) {
      i++;
      j++;
      if (j === pattern.length) {
        return i - j;
      }
    } else {
      if (j > 0) {
        j = lps[j - 1];
      } else {
        i++;
      }
    }
  }
  
  return -1;
}

function buildLPS(pattern) {
  const lps = new Array(pattern.length).fill(0);
  let len = 0;
  let i = 1;
  
  while (i < pattern.length) {
    if (pattern[i] === pattern[len]) {
      len++;
      lps[i] = len;
      i++;
    } else {
      if (len > 0) {
        len = lps[len - 1];
      } else {
        lps[i] = 0;
        i++;
      }
    }
  }
  
  return lps;
}

// Test
console.log(isRotation('abcde', 'cdeab'));
// true
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready rotation checker
 * 
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @param {Object} options - Check options
 * @param {boolean} options.caseInsensitive - Ignore case (default: false)
 * @param {boolean} options.findRotationPoint - Return rotation point if found (default: false)
 * @param {boolean} options.allowEmpty - Allow empty strings (default: false)
 * @returns {boolean|number} - True/false or rotation point index
 */
function isRotation(str1, str2, options = {}) {
  const {
    caseInsensitive = false,
    findRotationPoint = false,
    allowEmpty = false
  } = options;
  
  // Validation
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both arguments must be strings');
  }
  
  if (!allowEmpty && (str1.length === 0 || str2.length === 0)) {
    return findRotationPoint ? -1 : false;
  }
  
  if (str1.length !== str2.length) {
    return findRotationPoint ? -1 : false;
  }
  
  // Normalize case if needed
  const s1 = caseInsensitive ? str1.toLowerCase() : str1;
  const s2 = caseInsensitive ? str2.toLowerCase() : str2;
  
  if (s1 === s2) {
    return findRotationPoint ? 0 : true;
  }
  
  // Find rotation point if requested
  if (findRotationPoint) {
    for (let i = 0; i < s1.length; i++) {
      let match = true;
      
      for (let j = 0; j < s1.length; j++) {
        if (s1[j] !== s2[(i + j) % s2.length]) {
          match = false;
          break;
        }
      }
      
      if (match) return i;
    }
    
    return -1;
  }
  
  // Standard concatenation check
  return (s1 + s1).includes(s2);
}

// Get the rotation point
function getRotationPoint(str1, str2) {
  return isRotation(str1, str2, { findRotationPoint: true });
}

// Get all possible rotations
function getAllRotations(str) {
  const rotations = [];
  
  for (let i = 0; i < str.length; i++) {
    rotations.push(str.slice(i) + str.slice(0, i));
  }
  
  return rotations;
}

// Rotate string by k positions
function rotateString(str, k) {
  if (str.length === 0) return str;
  
  k = k % str.length;
  if (k < 0) k += str.length;
  
  return str.slice(k) + str.slice(0, k);
}

// Find minimum rotation (lexicographically)
function minRotation(str) {
  let min = str;
  
  for (let i = 1; i < str.length; i++) {
    const rotation = str.slice(i) + str.slice(0, i);
    if (rotation < min) {
      min = rotation;
    }
  }
  
  return min;
}

// Comprehensive test suite
console.log('=== Basic Rotation Check ===');
console.log(isRotation('waterbottle', 'erbottlewat'));
// true

console.log(isRotation('hello', 'lohel'));
// true

console.log(isRotation('hello', 'world'));
// false

console.log('\n=== Same String ===');
console.log(isRotation('abc', 'abc'));
// true (0 rotation)

console.log('\n=== Not a Rotation ===');
console.log(isRotation('abc', 'acb'));
// false (this is a permutation, not rotation)

console.log('\n=== Different Lengths ===');
console.log(isRotation('abc', 'abcd'));
// false

console.log('\n=== Empty Strings ===');
console.log(isRotation('', ''));
// false (default behavior)

console.log(isRotation('', '', { allowEmpty: true }));
// true

console.log('\n=== Case Insensitive ===');
console.log(isRotation('Hello', 'LOHel', { caseInsensitive: true }));
// true

console.log('\n=== Find Rotation Point ===');
console.log(getRotationPoint('abcde', 'cdeab'));
// 2 (rotated by 2 positions to the left)

console.log(getRotationPoint('hello', 'lohel'));
// 3

console.log(getRotationPoint('abc', 'xyz'));
// -1 (not a rotation)

console.log('\n=== Get All Rotations ===');
console.log(getAllRotations('abc'));
// ['abc', 'bca', 'cab']

console.log(getAllRotations('abcd'));
// ['abcd', 'bcda', 'cdab', 'dabc']

console.log('\n=== Rotate String ===');
console.log(rotateString('abcde', 2));
// 'cdeab'

console.log(rotateString('abcde', -1));
// 'eabcd' (rotate right by 1)

console.log(rotateString('hello', 7));
// 'lohel' (wraps around: 7 % 5 = 2)

console.log('\n=== Minimum Rotation ===');
console.log(minRotation('cab'));
// 'abc'

console.log(minRotation('dbca'));
// 'acdb'

console.log('\n=== Single Character ===');
console.log(isRotation('a', 'a'));
// true

console.log('\n=== Repeating Characters ===');
console.log(isRotation('aaaa', 'aaaa'));
// true

console.log(isRotation('aabb', 'abba'));
// true

console.log(isRotation('aabb', 'baab'));
// true

console.log('\n=== Long Strings ===');
const long1 = 'a'.repeat(1000) + 'b' + 'a'.repeat(999);
const long2 = 'b' + 'a'.repeat(1999);
console.log(isRotation(long1, long2));
// true
```

### **Bonus: Related Problems**
```javascript
/**
 * Count distinct rotations
 */
function countDistinctRotations(str) {
  const seen = new Set();
  
  for (let i = 0; i < str.length; i++) {
    const rotation = str.slice(i) + str.slice(0, i);
    seen.add(rotation);
  }
  
  return seen.size;
}

// Test
console.log(countDistinctRotations('aaa'));
// 1

console.log(countDistinctRotations('aab'));
// 3

/**
 * Check if array is rotation of another array
 */
function isArrayRotation(arr1, arr2) {
  if (arr1.length !== arr2.length || arr1.length === 0) {
    return false;
  }
  
  const doubled = [...arr1, ...arr1];
  
  // Check if arr2 appears as subarray in doubled
  outer: for (let i = 0; i < arr1.length; i++) {
    for (let j = 0; j < arr2.length; j++) {
      if (doubled[i + j] !== arr2[j]) {
        continue outer;
      }
    }
    return true;
  }
  
  return false;
}

// Test
console.log(isArrayRotation([1, 2, 3, 4], [3, 4, 1, 2]));
// true

console.log(isArrayRotation([1, 2, 3], [2, 1, 3]));
// false
```

**Interview Tips:**
- Concatenation trick (str1+str1).includes(str2) is elegant: O(n)
- Must check: same length, not empty (unless allowed)
- Rotation != permutation (abc -> bca is rotation, abc -> acb is not)
- Works because rotation is just shifting: if rotated, will appear in doubled string
- Can extend to: find rotation point, rotate by k, minimum rotation
- Common follow-ups: arrays, circular lists, rotation count
- Used in: string matching, circular buffers, genome sequencing
- Alternative: manual rotation checking O(n²) but O(1) space

</details>

50. Remove all adjacent duplicates from a string

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Stack**
```javascript
/**
 * Remove adjacent duplicates using stack
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * @param {string} str - Input string
 * @returns {string} - String with adjacent duplicates removed
 */
function removeAdjacentDuplicates(str) {
  const stack = [];
  
  for (const char of str) {
    if (stack.length > 0 && stack[stack.length - 1] === char) {
      stack.pop();
    } else {
      stack.push(char);
    }
  }
  
  return stack.join('');
}

// Test cases
console.log(removeAdjacentDuplicates('abbaca'));
// 'ca' (remove 'bb', then 'aa')

console.log(removeAdjacentDuplicates('azxxzy'));
// 'ay' (remove 'xx', then 'zz')

console.log(removeAdjacentDuplicates('aabbcc'));
// '' (all removed)

console.log(removeAdjacentDuplicates('abc'));
// 'abc' (no duplicates)
```

### **Approach 2: Iterative Removal**
```javascript
/**
 * Remove duplicates iteratively
 * Time Complexity: O(n²) worst case
 * Space Complexity: O(n)
 */
function removeAdjacentDuplicates(str) {
  let prev = '';
  let current = str;
  
  while (prev !== current) {
    prev = current;
    
    for (let i = 0; i < current.length - 1; i++) {
      if (current[i] === current[i + 1]) {
        current = current.slice(0, i) + current.slice(i + 2);
        break;
      }
    }
  }
  
  return current;
}

// Test
console.log(removeAdjacentDuplicates('abbaca'));
// 'ca'
```

### **Approach 3: Remove K Adjacent Duplicates**
```javascript
/**
 * Remove k adjacent duplicate characters
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function removeKAdjacentDuplicates(str, k) {
  const stack = []; // stores [char, count]
  
  for (const char of str) {
    if (stack.length > 0 && stack[stack.length - 1][0] === char) {
      stack[stack.length - 1][1]++;
      
      if (stack[stack.length - 1][1] === k) {
        stack.pop();
      }
    } else {
      stack.push([char, 1]);
    }
  }
  
  return stack.map(([char, count]) => char.repeat(count)).join('');
}

// Test
console.log(removeKAdjacentDuplicates('deeedbbcccbdaa', 3));
// 'aa' (removes 'eee', 'ccc', 'bbb' -> 'ddbdaa' -> 'aa')

console.log(removeKAdjacentDuplicates('pbbcggttciiippooaais', 2));
// 'ps'
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready adjacent duplicate remover
 * 
 * @param {string} str - Input string
 * @param {Object} options - Removal options
 * @param {number} options.k - Number of adjacent duplicates to remove (default: 2)
 * @param {boolean} options.caseInsensitive - Ignore case (default: false)
 * @param {boolean} options.recursive - Keep removing until no more (default: true)
 * @param {Function} options.shouldRemove - Custom function to determine removal
 * @returns {string} - String with duplicates removed
 */
function removeAdjacentDuplicates(str, options = {}) {
  const {
    k = 2,
    caseInsensitive = false,
    recursive = true,
    shouldRemove = null
  } = options;
  
  // Validation
  if (typeof str !== 'string') {
    throw new TypeError('Input must be a string');
  }
  
  if (k < 2) {
    throw new RangeError('k must be at least 2');
  }
  
  const workStr = caseInsensitive ? str.toLowerCase() : str;
  const stack = []; // [char, count, originalChars]
  
  for (let i = 0; i < workStr.length; i++) {
    const char = workStr[i];
    const originalChar = str[i];
    
    if (stack.length > 0 && stack[stack.length - 1][0] === char) {
      const top = stack[stack.length - 1];
      top[1]++;
      top[2].push(originalChar);
      
      // Check if should remove
      const remove = shouldRemove 
        ? shouldRemove(char, top[1])
        : top[1] === k;
      
      if (remove) {
        stack.pop();
      }
    } else {
      stack.push([char, 1, [originalChar]]);
    }
  }
  
  return stack.map(([, , originalChars]) => originalChars.join('')).join('');
}

// Count removed characters
function removeAndCount(str, k = 2) {
  const stack = [];
  let removed = 0;
  
  for (const char of str) {
    if (stack.length > 0 && stack[stack.length - 1][0] === char) {
      stack[stack.length - 1][1]++;
      
      if (stack[stack.length - 1][1] === k) {
        removed += k;
        stack.pop();
      }
    } else {
      stack.push([char, 1]);
    }
  }
  
  return {
    result: stack.map(([char, count]) => char.repeat(count)).join(''),
    removed
  };
}

// Get all removal steps
function getRemovalSteps(str, k = 2) {
  const steps = [str];
  const stack = [];
  
  for (const char of str) {
    if (stack.length > 0 && stack[stack.length - 1][0] === char) {
      stack[stack.length - 1][1]++;
      
      if (stack[stack.length - 1][1] === k) {
        stack.pop();
        const current = stack.map(([c, count]) => c.repeat(count)).join('');
        steps.push(current);
      }
    } else {
      stack.push([char, 1]);
    }
  }
  
  return steps;
}

// Remove all consecutive duplicates (reduce to single)
function reduceAdjacentDuplicates(str) {
  if (str.length === 0) return str;
  
  let result = str[0];
  
  for (let i = 1; i < str.length; i++) {
    if (str[i] !== str[i - 1]) {
      result += str[i];
    }
  }
  
  return result;
}

// Comprehensive test suite
console.log('=== Basic Removal (k=2) ===');
console.log(removeAdjacentDuplicates('abbaca'));
// 'ca'

console.log(removeAdjacentDuplicates('azxxzy'));
// 'ay'

console.log(removeAdjacentDuplicates('aabbcc'));
// ''

console.log('\n=== No Duplicates ===');
console.log(removeAdjacentDuplicates('abcdef'));
// 'abcdef'

console.log('\n=== K=3 Adjacent Duplicates ===');
console.log(removeAdjacentDuplicates('deeedbbcccbdaa', { k: 3 }));
// 'aa'

console.log(removeAdjacentDuplicates('aaabbbaaa', { k: 3 }));
// 'aaa' (removes first 'aaa', 'bbb', leaves last 'aaa')

console.log('\n=== Case Insensitive ===');
console.log(removeAdjacentDuplicates('aAbBcC', { caseInsensitive: true }));
// '' (treats A and a as same)

console.log('\n=== Custom Removal Function ===');
console.log(removeAdjacentDuplicates('aaabbbcc', {
  shouldRemove: (char, count) => count >= 3
}));
// 'cc' (removes runs of 3+)

console.log('\n=== Count Removed ===');
console.log(removeAndCount('abbaca'));
// { result: 'ca', removed: 4 }

console.log(removeAndCount('aabbcc'));
// { result: '', removed: 6 }

console.log('\n=== Removal Steps ===');
console.log(getRemovalSteps('abbaca'));
// ['abbaca', 'aaca', 'ca']

console.log('\n=== Reduce to Single ===');
console.log(reduceAdjacentDuplicates('aaabbbccc'));
// 'abc'

console.log(reduceAdjacentDuplicates('aabbbaac'));
// 'abac'

console.log('\n=== Edge Cases ===');
console.log(removeAdjacentDuplicates(''));
// ''

console.log(removeAdjacentDuplicates('a'));
// 'a'

console.log(removeAdjacentDuplicates('aa'));
// ''

console.log(removeAdjacentDuplicates('aaa'));
// 'a' (removes 'aa', leaves 'a')

console.log('\n=== Complex Cascading ===');
console.log(removeAdjacentDuplicates('abccba'));
// '' (removes 'cc' -> 'abba' -> removes 'bb' -> 'aa' -> removes 'aa' -> '')

console.log(removeAdjacentDuplicates('pbbcggttciiippooaais', { k: 2 }));
// 'ps'

console.log('\n=== Single Character Type ===');
console.log(removeAdjacentDuplicates('aaaa'));
// '' (removes all pairs)

console.log(removeAdjacentDuplicates('aaaaa'));
// 'a' (removes 2 pairs, leaves 1)

console.log('\n=== Long String ===');
console.log(removeAdjacentDuplicates('a'.repeat(100) + 'b'.repeat(100)));
// '' (all removed)
```

### **Bonus: Related Problems**
```javascript
/**
 * Make string palindrome by removing adjacent duplicates
 */
function canMakePalindrome(str) {
  const result = removeAdjacentDuplicates(str);
  return result === result.split('').reverse().join('');
}

// Test
console.log(canMakePalindrome('abccba'));
// true (becomes '')

/**
 * Minimum removals to make string without adjacent duplicates
 */
function minRemovalsToNoAdjacent(str) {
  let removals = 0;
  let prev = '';
  
  for (const char of str) {
    if (char === prev) {
      removals++;
    } else {
      prev = char;
    }
  }
  
  return removals;
}

// Test
console.log(minRemovalsToNoAdjacent('aaabbbccc'));
// 6 (remove 2 'a's, 2 'b's, 2 'c's)
```

**Interview Tips:**
- Stack is optimal solution: O(n) time, O(n) space
- Process character by character, pop if matches top of stack
- Can extend to k adjacent duplicates (store count with character)
- Removal is recursive/cascading: removing one pair may create another
- Common variations: k duplicates, case-insensitive, count removals
- Follow-ups: show steps, reduce to single, minimum removals
- Used in: text processing, game algorithms (candy crush), compression
- Similar to balanced parentheses but removes instead of validating

</details>

### **DOM & Browser**

51. Implement a debounce function

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Debounce**
```javascript
/**
 * Debounce function - delays execution until after wait time
 * Time Complexity: O(1) per call
 * Space Complexity: O(1)
 * 
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} - Debounced function
 */
function debounce(func, wait) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
}

// Test case
const log = debounce((msg) => console.log(msg), 1000);

log('First call');  // Cancelled
log('Second call'); // Cancelled
log('Third call');  // Executed after 1000ms

// Usage example: Search input
const searchInput = document.querySelector('#search');
const debouncedSearch = debounce((value) => {
  console.log('Searching for:', value);
  // API call here
}, 500);

searchInput?.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});
```

### **Approach 2: With Immediate Execution**
```javascript
/**
 * Debounce with leading edge option
 * Execute immediately on first call, then wait
 */
function debounce(func, wait, immediate = false) {
  let timeoutId;
  
  return function(...args) {
    const callNow = immediate && !timeoutId;
    
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      timeoutId = null;
      if (!immediate) {
        func.apply(this, args);
      }
    }, wait);
    
    if (callNow) {
      func.apply(this, args);
    }
  };
}

// Test
const immediateLog = debounce((msg) => console.log(msg), 1000, true);

immediateLog('First');  // Executes immediately
immediateLog('Second'); // Ignored
immediateLog('Third');  // Ignored
// After 1000ms, can execute again
```

### **Approach 3: With Cancel and Flush**
```javascript
/**
 * Advanced debounce with cancel and flush methods
 */
function debounce(func, wait) {
  let timeoutId;
  let lastArgs;
  let lastThis;
  
  const debounced = function(...args) {
    lastArgs = args;
    lastThis = this;
    
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      func.apply(lastThis, lastArgs);
      timeoutId = null;
    }, wait);
  };
  
  // Cancel pending execution
  debounced.cancel = function() {
    clearTimeout(timeoutId);
    timeoutId = null;
  };
  
  // Execute immediately with last arguments
  debounced.flush = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      func.apply(lastThis, lastArgs);
      timeoutId = null;
    }
  };
  
  return debounced;
}

// Test
const saveDraft = debounce((text) => {
  console.log('Saving:', text);
}, 2000);

saveDraft('Hello');
saveDraft('Hello World');
saveDraft.flush(); // Save immediately
saveDraft('New text');
saveDraft.cancel(); // Cancel the save
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready debounce implementation
 * 
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @param {Object} options - Debounce options
 * @param {boolean} options.leading - Execute on leading edge (default: false)
 * @param {boolean} options.trailing - Execute on trailing edge (default: true)
 * @param {number} options.maxWait - Maximum time to wait before execution
 * @returns {Function} - Debounced function with cancel and flush methods
 */
function debounce(func, wait, options = {}) {
  const {
    leading = false,
    trailing = true,
    maxWait = null
  } = options;
  
  // Validation
  if (typeof func !== 'function') {
    throw new TypeError('First argument must be a function');
  }
  
  if (typeof wait !== 'number' || wait < 0) {
    throw new TypeError('Wait time must be a non-negative number');
  }
  
  let timeoutId;
  let maxTimeoutId;
  let lastArgs;
  let lastThis;
  let result;
  let lastCallTime;
  let lastInvokeTime = 0;
  
  function invokeFunc(time) {
    const args = lastArgs;
    const thisArg = lastThis;
    
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  
  function leadingEdge(time) {
    lastInvokeTime = time;
    
    // Start timer for trailing edge
    timeoutId = setTimeout(timerExpired, wait);
    
    // Execute if leading
    return leading ? invokeFunc(time) : result;
  }
  
  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const timeWaiting = wait - timeSinceLastCall;
    
    return maxWait !== null
      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }
  
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    
    return (
      lastCallTime === undefined ||
      timeSinceLastCall >= wait ||
      timeSinceLastCall < 0 ||
      (maxWait !== null && timeSinceLastInvoke >= maxWait)
    );
  }
  
  function timerExpired() {
    const time = Date.now();
    
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    
    // Restart timer
    timeoutId = setTimeout(timerExpired, remainingWait(time));
  }
  
  function trailingEdge(time) {
    timeoutId = undefined;
    
    // Only invoke if we have last args
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    
    lastArgs = lastThis = undefined;
    return result;
  }
  
  function cancel() {
    if (timeoutId !== undefined) {
      clearTimeout(timeoutId);
    }
    if (maxTimeoutId !== undefined) {
      clearTimeout(maxTimeoutId);
    }
    
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timeoutId = maxTimeoutId = undefined;
  }
  
  function flush() {
    return timeoutId === undefined ? result : trailingEdge(Date.now());
  }
  
  function pending() {
    return timeoutId !== undefined;
  }
  
  function debounced(...args) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);
    
    lastArgs = args;
    lastThis = this;
    lastCallTime = time;
    
    if (isInvoking) {
      if (timeoutId === undefined) {
        return leadingEdge(lastCallTime);
      }
      
      if (maxWait !== null) {
        // Handle maxWait
        timeoutId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    
    if (timeoutId === undefined) {
      timeoutId = setTimeout(timerExpired, wait);
    }
    
    return result;
  }
  
  debounced.cancel = cancel;
  debounced.flush = flush;
  debounced.pending = pending;
  
  return debounced;
}

// Real-world usage examples
console.log('=== Window Resize Handler ===');
let resizeCount = 0;
const handleResize = debounce(() => {
  resizeCount++;
  console.log('Window resized!', resizeCount);
}, 500);

// window.addEventListener('resize', handleResize);

console.log('\n=== Search Input ===');
const search = debounce((query) => {
  console.log('Searching for:', query);
  // fetch(`/api/search?q=${query}`)
}, 300);

console.log('\n=== Form Auto-Save ===');
const autoSave = debounce((formData) => {
  console.log('Auto-saving form...', formData);
  // API call to save draft
}, 2000, { maxWait: 5000 });

console.log('\n=== Scroll Handler with Leading Edge ===');
const trackScroll = debounce(() => {
  console.log('Scroll position:', window.scrollY);
}, 100, { leading: true, trailing: false });

console.log('\n=== Button Click Protection ===');
const submitForm = debounce((data) => {
  console.log('Submitting form...', data);
  // Prevent double submissions
}, 1000, { leading: true, trailing: false });

// Test suite
console.log('\n=== Test: Basic Debounce ===');
let callCount = 0;
const debounced = debounce(() => {
  callCount++;
}, 100);

debounced();
debounced();
debounced();
setTimeout(() => {
  console.log('Call count:', callCount); // Should be 1
}, 150);

console.log('\n=== Test: Cancel ===');
const cancellable = debounce(() => {
  console.log('This should not execute');
}, 100);

cancellable();
cancellable.cancel();

console.log('\n=== Test: Flush ===');
const flushable = debounce(() => {
  console.log('Flushed immediately');
}, 1000);

flushable();
flushable.flush(); // Executes immediately

console.log('\n=== Test: MaxWait ===');
const maxWaitTest = debounce(() => {
  console.log('MaxWait triggered');
}, 100, { maxWait: 500 });

// Even if called continuously, will execute at least every 500ms

console.log('\n=== Test: Leading Edge ===');
let leadingCount = 0;
const leadingDebounced = debounce(() => {
  leadingCount++;
  console.log('Leading edge:', leadingCount);
}, 100, { leading: true, trailing: false });

leadingDebounced(); // Executes immediately
leadingDebounced(); // Ignored
leadingDebounced(); // Ignored
```

### **Bonus: Advanced Variations**
```javascript
/**
 * Debounce with Promise support
 */
function debouncePromise(func, wait) {
  let timeoutId;
  let latestResolve;
  let latestReject;
  
  return function(...args) {
    return new Promise((resolve, reject) => {
      clearTimeout(timeoutId);
      
      latestResolve = resolve;
      latestReject = reject;
      
      timeoutId = setTimeout(async () => {
        try {
          const result = await func.apply(this, args);
          latestResolve(result);
        } catch (error) {
          latestReject(error);
        }
      }, wait);
    });
  };
}

// Test
const asyncSearch = debouncePromise(async (query) => {
  // Simulate API call
  return new Promise(resolve => {
    setTimeout(() => resolve(`Results for: ${query}`), 100);
  });
}, 500);

asyncSearch('test').then(console.log);

/**
 * Debounce with grouping by key
 */
function debounceByKey(func, wait) {
  const timeouts = new Map();
  
  return function(key, ...args) {
    if (timeouts.has(key)) {
      clearTimeout(timeouts.get(key));
    }
    
    const timeoutId = setTimeout(() => {
      func.call(this, key, ...args);
      timeouts.delete(key);
    }, wait);
    
    timeouts.set(key, timeoutId);
  };
}

// Test
const updateUser = debounceByKey((userId, data) => {
  console.log(`Updating user ${userId}:`, data);
}, 1000);

updateUser('user1', { name: 'Alice' });
updateUser('user2', { name: 'Bob' });
// Both will execute independently

/**
 * Adaptive debounce (adjusts delay based on call frequency)
 */
function adaptiveDebounce(func, minWait, maxWait) {
  let timeoutId;
  let callCount = 0;
  let lastCallTime;
  
  return function(...args) {
    const now = Date.now();
    
    if (lastCallTime && now - lastCallTime < 100) {
      callCount++;
    } else {
      callCount = 1;
    }
    
    lastCallTime = now;
    
    // Increase wait time based on call frequency
    const wait = Math.min(minWait + callCount * 50, maxWait);
    
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      func.apply(this, args);
      callCount = 0;
    }, wait);
  };
}
```

**Interview Tips:**
- Debounce delays execution until after calls have stopped for wait time
- Use for: search inputs, window resize, scroll events, form validation
- Key features: cancel (clear timeout), flush (execute immediately), pending (check status)
- Leading edge: execute on first call, then ignore until quiet period
- Trailing edge: execute after calls stop (default behavior)
- MaxWait: guarantee execution within maximum time
- Difference from throttle: throttle executes periodically, debounce waits for quiet
- Memory: store timeout IDs, last args, context (this)
- Common pitfall: losing `this` context (use arrow functions or apply)
- lodash.debounce is production standard but good to implement yourself

</details>

52. Implement a throttle function

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Throttle**
```javascript
/**
 * Throttle function - executes at most once per interval
 * Time Complexity: O(1) per call
 * Space Complexity: O(1)
 * 
 * @param {Function} func - Function to throttle
 * @param {number} limit - Time limit in milliseconds
 * @returns {Function} - Throttled function
 */
function throttle(func, limit) {
  let inThrottle;
  
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

// Test case
let scrollCount = 0;
const throttledScroll = throttle(() => {
  scrollCount++;
  console.log('Scroll event:', scrollCount);
}, 1000);

// Simulating rapid calls
for (let i = 0; i < 10; i++) {
  throttledScroll(); // Only first call executes
}
// After 1000ms, can execute again
```

### **Approach 2: With Leading and Trailing Options**
```javascript
/**
 * Throttle with leading and trailing edge control
 */
function throttle(func, limit, options = {}) {
  const { leading = true, trailing = true } = options;
  
  let lastRan;
  let lastFunc;
  
  return function(...args) {
    if (!lastRan) {
      if (leading) {
        func.apply(this, args);
      }
      lastRan = Date.now();
    } else {
      clearTimeout(lastFunc);
      
      lastFunc = setTimeout(() => {
        if (Date.now() - lastRan >= limit) {
          if (trailing) {
            func.apply(this, args);
          }
          lastRan = Date.now();
        }
      }, limit - (Date.now() - lastRan));
    }
  };
}

// Test
const log = throttle((msg) => console.log(msg), 1000, {
  leading: true,
  trailing: true
});
```

### **Approach 3: With Cancel Method**
```javascript
/**
 * Throttle with cancel functionality
 */
function throttle(func, limit) {
  let inThrottle;
  let lastFunc;
  let lastRan;
  
  const throttled = function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      lastRan = Date.now();
      inThrottle = true;
    } else {
      clearTimeout(lastFunc);
      lastFunc = setTimeout(() => {
        if (Date.now() - lastRan >= limit) {
          func.apply(this, args);
          lastRan = Date.now();
        }
      }, limit - (Date.now() - lastRan));
    }
    
    setTimeout(() => {
      inThrottle = false;
    }, limit);
  };
  
  throttled.cancel = function() {
    clearTimeout(lastFunc);
    inThrottle = false;
  };
  
  return throttled;
}

// Test
const save = throttle((data) => {
  console.log('Saving:', data);
}, 2000);

save('data1');
save('data2');
save.cancel(); // Cancel pending execution
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready throttle implementation
 * 
 * @param {Function} func - Function to throttle
 * @param {number} wait - Wait time in milliseconds
 * @param {Object} options - Throttle options
 * @param {boolean} options.leading - Execute on leading edge (default: true)
 * @param {boolean} options.trailing - Execute on trailing edge (default: true)
 * @returns {Function} - Throttled function with cancel method
 */
function throttle(func, wait, options = {}) {
  const { leading = true, trailing = true } = options;
  
  // Validation
  if (typeof func !== 'function') {
    throw new TypeError('First argument must be a function');
  }
  
  if (typeof wait !== 'number' || wait < 0) {
    throw new TypeError('Wait time must be a non-negative number');
  }
  
  let timeoutId;
  let lastArgs;
  let lastThis;
  let result;
  let lastCallTime;
  let lastInvokeTime = 0;
  
  function invokeFunc(time) {
    const args = lastArgs;
    const thisArg = lastThis;
    
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  
  function leadingEdge(time) {
    lastInvokeTime = time;
    timeoutId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  
  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const timeWaiting = wait - timeSinceLastInvoke;
    
    return timeWaiting;
  }
  
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    
    return (
      lastCallTime === undefined ||
      timeSinceLastCall >= wait ||
      timeSinceLastCall < 0 ||
      timeSinceLastInvoke >= wait
    );
  }
  
  function timerExpired() {
    const time = Date.now();
    
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    
    timeoutId = setTimeout(timerExpired, remainingWait(time));
  }
  
  function trailingEdge(time) {
    timeoutId = undefined;
    
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    
    lastArgs = lastThis = undefined;
    return result;
  }
  
  function cancel() {
    if (timeoutId !== undefined) {
      clearTimeout(timeoutId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timeoutId = undefined;
  }
  
  function flush() {
    return timeoutId === undefined ? result : trailingEdge(Date.now());
  }
  
  function throttled(...args) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);
    
    lastArgs = args;
    lastThis = this;
    lastCallTime = time;
    
    if (isInvoking) {
      if (timeoutId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (trailing) {
        timeoutId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    
    if (timeoutId === undefined) {
      timeoutId = setTimeout(timerExpired, wait);
    }
    
    return result;
  }
  
  throttled.cancel = cancel;
  throttled.flush = flush;
  
  return throttled;
}

// Real-world usage examples
console.log('=== Infinite Scroll ===');
const loadMore = throttle(() => {
  console.log('Loading more items...');
  // Fetch next page
}, 1000);

// window.addEventListener('scroll', () => {
//   if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
//     loadMore();
//   }
// });

console.log('\n=== Mouse Move Tracking ===');
const trackMouse = throttle((e) => {
  console.log('Mouse position:', e.clientX, e.clientY);
}, 100);

// document.addEventListener('mousemove', trackMouse);

console.log('\n=== API Rate Limiting ===');
const apiCall = throttle((endpoint) => {
  console.log('Making API call to:', endpoint);
  // fetch(endpoint)
}, 2000);

console.log('\n=== Game Loop Updates ===');
const updateGame = throttle(() => {
  console.log('Updating game state...');
  // Game logic here
}, 16); // ~60 FPS

console.log('\n=== Button Click Protection ===');
const handleSubmit = throttle((formData) => {
  console.log('Submitting form:', formData);
  // Prevent multiple rapid submissions
}, 3000, { leading: true, trailing: false });

// Test suite
console.log('\n=== Test: Basic Throttle ===');
let executeCount = 0;
const throttled = throttle(() => {
  executeCount++;
  console.log('Executed:', executeCount);
}, 100);

// Rapid calls
for (let i = 0; i < 5; i++) {
  throttled();
}
// Only first call executes immediately

console.log('\n=== Test: Leading = false ===');
const noLeading = throttle(() => {
  console.log('Trailing edge only');
}, 100, { leading: false });

noLeading();
noLeading();

console.log('\n=== Test: Trailing = false ===');
const noTrailing = throttle(() => {
  console.log('Leading edge only');
}, 100, { trailing: false });

noTrailing();
noTrailing();

console.log('\n=== Test: Cancel ===');
const cancellable = throttle(() => {
  console.log('This should not execute');
}, 100);

cancellable();
cancellable.cancel();
```

### **Bonus: Advanced Variations**
```javascript
/**
 * Throttle with Promise support
 */
function throttlePromise(func, wait) {
  let lastExecution = 0;
  let pendingPromise = null;
  
  return async function(...args) {
    const now = Date.now();
    const timeSinceLastExecution = now - lastExecution;
    
    if (timeSinceLastExecution >= wait) {
      lastExecution = now;
      return await func.apply(this, args);
    }
    
    if (!pendingPromise) {
      pendingPromise = new Promise((resolve) => {
        setTimeout(async () => {
          lastExecution = Date.now();
          const result = await func.apply(this, args);
          pendingPromise = null;
          resolve(result);
        }, wait - timeSinceLastExecution);
      });
    }
    
    return pendingPromise;
  };
}

/**
 * Throttle with queue (executes all calls, just throttled)
 */
function throttleWithQueue(func, wait) {
  const queue = [];
  let isThrottled = false;
  
  function processQueue() {
    if (queue.length === 0) {
      isThrottled = false;
      return;
    }
    
    const { args, context } = queue.shift();
    func.apply(context, args);
    
    setTimeout(processQueue, wait);
  }
  
  return function(...args) {
    queue.push({ args, context: this });
    
    if (!isThrottled) {
      isThrottled = true;
      processQueue();
    }
  };
}

/**
 * Dynamic throttle (adjusts based on system load)
 */
function dynamicThrottle(func, minWait, maxWait) {
  let lastExecution = 0;
  let performanceScore = 1;
  
  return function(...args) {
    const now = Date.now();
    const startTime = performance.now();
    
    // Calculate dynamic wait based on performance
    const wait = minWait + (maxWait - minWait) * (1 - performanceScore);
    
    if (now - lastExecution >= wait) {
      lastExecution = now;
      
      func.apply(this, args);
      
      // Measure execution time to adjust throttle
      const executionTime = performance.now() - startTime;
      performanceScore = Math.max(0, Math.min(1, 1 - executionTime / 100));
    }
  };
}

/**
 * Compare throttle vs debounce
 */
function compareThrottleDebounce() {
  let throttleCount = 0;
  let debounceCount = 0;
  
  const throttled = throttle(() => {
    throttleCount++;
    console.log('Throttle executed:', throttleCount);
  }, 100);
  
  const debounced = debounce(() => {
    debounceCount++;
    console.log('Debounce executed:', debounceCount);
  }, 100);
  
  // Simulate rapid calls
  const interval = setInterval(() => {
    throttled();
    debounced();
  }, 20);
  
  setTimeout(() => {
    clearInterval(interval);
    console.log('Final counts - Throttle:', throttleCount, 'Debounce:', debounceCount);
    // Throttle: ~5 (every 100ms), Debounce: 1 (after calls stop)
  }, 500);
}

// Helper for debounce comparison
function debounce(func, wait) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), wait);
  };
}
```

**Interview Tips:**
- Throttle executes at most once per time period
- Use for: scroll events, mouse movement, resize, API rate limiting
- Leading edge: execute immediately on first call
- Trailing edge: execute after interval even if still being called
- Difference from debounce: throttle executes periodically during activity, debounce waits for inactivity
- Performance: prevents excessive function calls during continuous events
- Common pattern: leading=true, trailing=true (execute both edges)
- Memory: track last execution time and timeout ID
- Use case examples: infinite scroll (throttle), search input (debounce)
- lodash.throttle is production standard with more features

</details>

53. Create a function to get all elements by class name recursively

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Using Built-in Method**
```javascript
/**
 * Get all elements by class name (simple wrapper)
 * Time Complexity: O(n) where n is DOM nodes
 * Space Complexity: O(k) where k is matching elements
 * 
 * @param {string} className - Class name to search for
 * @param {Element} root - Root element to search from
 * @returns {Array} - Array of matching elements
 */
function getElementsByClassName(className, root = document) {
  return Array.from(root.getElementsByClassName(className));
}

// Test
const buttons = getElementsByClassName('btn');
console.log('Found buttons:', buttons.length);
```

### **Approach 2: Recursive DOM Traversal**
```javascript
/**
 * Recursive implementation without built-in methods
 * Time Complexity: O(n)
 * Space Complexity: O(n) for recursion stack
 */
function getElementsByClassName(className, root = document.body) {
  const result = [];
  
  function traverse(element) {
    // Check if current element has the class
    if (element.classList && element.classList.contains(className)) {
      result.push(element);
    }
    
    // Recurse through children
    for (const child of element.children) {
      traverse(child);
    }
  }
  
  traverse(root);
  return result;
}

// Test
const elements = getElementsByClassName('highlight');
console.log('Found elements:', elements);
```

### **Approach 3: Iterative with Queue (BFS)**
```javascript
/**
 * Iterative breadth-first search implementation
 * Time Complexity: O(n)
 * Space Complexity: O(w) where w is max width of tree
 */
function getElementsByClassName(className, root = document.body) {
  const result = [];
  const queue = [root];
  
  while (queue.length > 0) {
    const element = queue.shift();
    
    if (element.classList && element.classList.contains(className)) {
      result.push(element);
    }
    
    queue.push(...element.children);
  }
  
  return result;
}

// Test
const items = getElementsByClassName('list-item');
console.log('Found items:', items);
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready element finder with multiple selectors
 * 
 * @param {string|Array} selector - Class name(s) or CSS selector
 * @param {Element} root - Root element to search from
 * @param {Object} options - Search options
 * @param {boolean} options.multiple - Match elements with all classes (default: false)
 * @param {boolean} options.exact - Exact class match only (default: false)
 * @param {number} options.maxDepth - Maximum depth to search (default: Infinity)
 * @param {Function} options.filter - Additional filter function
 * @returns {Array} - Array of matching elements
 */
function getElementsByClassName(selector, root = document.body, options = {}) {
  const {
    multiple = false,
    exact = false,
    maxDepth = Infinity,
    filter = null
  } = options;
  
  // Validation
  if (!root || !root.children) {
    throw new TypeError('Root must be a valid DOM element');
  }
  
  // Handle modern querySelector for complex selectors
  if (selector.includes('[') || selector.includes('>') || selector.includes('+')) {
    const elements = Array.from(root.querySelectorAll(selector));
    return filter ? elements.filter(filter) : elements;
  }
  
  // Parse class names
  const classNames = Array.isArray(selector)
    ? selector
    : selector.split(/\s+/).filter(Boolean);
  
  const result = [];
  
  function traverse(element, depth) {
    if (depth > maxDepth) return;
    
    if (element.classList) {
      let matches = false;
      
      if (multiple) {
        // Element must have all classes
        matches = classNames.every(cls => element.classList.contains(cls));
      } else if (exact) {
        // Element must have exactly these classes
        matches = element.classList.length === classNames.length &&
                 classNames.every(cls => element.classList.contains(cls));
      } else {
        // Element must have at least one class
        matches = classNames.some(cls => element.classList.contains(cls));
      }
      
      if (matches && (!filter || filter(element))) {
        result.push(element);
      }
    }
    
    // Recurse through children
    for (const child of element.children) {
      traverse(child, depth + 1);
    }
  }
  
  traverse(root, 0);
  return result;
}

// Get elements by multiple selectors
function getElementsBy(selectors, root = document.body) {
  const results = {};
  
  for (const [key, selector] of Object.entries(selectors)) {
    if (selector.startsWith('.')) {
      results[key] = getElementsByClassName(selector.slice(1), root);
    } else if (selector.startsWith('#')) {
      results[key] = [root.querySelector(selector)].filter(Boolean);
    } else {
      results[key] = Array.from(root.querySelectorAll(selector));
    }
  }
  
  return results;
}

// Get elements with custom attribute
function getElementsByAttribute(attr, value, root = document.body) {
  const result = [];
  
  function traverse(element) {
    if (element.hasAttribute(attr)) {
      if (value === undefined || element.getAttribute(attr) === value) {
        result.push(element);
      }
    }
    
    for (const child of element.children) {
      traverse(child);
    }
  }
  
  traverse(root);
  return result;
}

// Get elements by predicate function
function findElements(predicate, root = document.body) {
  const result = [];
  
  function traverse(element) {
    if (predicate(element)) {
      result.push(element);
    }
    
    for (const child of element.children) {
      traverse(child);
    }
  }
  
  traverse(root);
  return result;
}

// Get parent elements matching selector
function getParentsWithClass(element, className) {
  const parents = [];
  let current = element.parentElement;
  
  while (current) {
    if (current.classList && current.classList.contains(className)) {
      parents.push(current);
    }
    current = current.parentElement;
  }
  
  return parents;
}

// Comprehensive test suite
console.log('=== Basic Class Search ===');
// const buttons = getElementsByClassName('btn');
// console.log('Buttons:', buttons.length);

console.log('\n=== Multiple Classes (Any) ===');
// const elements = getElementsByClassName('btn primary');
// Elements with 'btn' OR 'primary'

console.log('\n=== Multiple Classes (All) ===');
// const elements = getElementsByClassName('btn primary', document.body, {
//   multiple: true
// });
// Elements with both 'btn' AND 'primary'

console.log('\n=== Exact Class Match ===');
// const elements = getElementsByClassName('btn', document.body, {
//   exact: true
// });
// Elements with only 'btn' class, no others

console.log('\n=== Limited Depth ===');
// const elements = getElementsByClassName('item', document.body, {
//   maxDepth: 3
// });
// Search only 3 levels deep

console.log('\n=== With Filter ===');
// const visibleButtons = getElementsByClassName('btn', document.body, {
//   filter: (el) => el.offsetParent !== null
// });
// Only visible buttons

console.log('\n=== By Attribute ===');
// const dataElements = getElementsByAttribute('data-id', '123');
// console.log('Elements with data-id="123":', dataElements.length);

console.log('\n=== By Predicate ===');
// const largeElements = findElements((el) => {
//   return el.offsetWidth > 500;
// });
// console.log('Large elements:', largeElements.length);

console.log('\n=== Multiple Selectors ===');
// const elements = getElementsBy({
//   buttons: '.btn',
//   headers: 'h1, h2, h3',
//   main: '#main'
// });
// console.log('Found:', elements);

console.log('\n=== Parent Search ===');
// const button = document.querySelector('.btn');
// const containers = getParentsWithClass(button, 'container');
// console.log('Parent containers:', containers);

// Example: Practical usage
function highlightElements() {
  const elements = getElementsByClassName('highlight');
  
  elements.forEach(el => {
    el.style.backgroundColor = 'yellow';
  });
}

function toggleClassRecursive(className, root = document.body) {
  const elements = getElementsByClassName(className, root);
  
  elements.forEach(el => {
    el.classList.toggle('active');
  });
}

// Performance comparison
function comparePerformance() {
  const className = 'test-class';
  const root = document.body;
  
  console.time('Native');
  const native = root.getElementsByClassName(className);
  console.timeEnd('Native');
  
  console.time('Recursive');
  const recursive = getElementsByClassName(className, root);
  console.timeEnd('Recursive');
  
  console.time('querySelector');
  const query = root.querySelectorAll(`.${className}`);
  console.timeEnd('querySelector');
}
```

### **Bonus: Advanced DOM Utilities**
```javascript
/**
 * Get elements matching complex criteria
 */
function getElementsAdvanced(criteria, root = document.body) {
  return findElements((el) => {
    // Check all criteria
    for (const [key, value] of Object.entries(criteria)) {
      switch (key) {
        case 'class':
          if (!el.classList.contains(value)) return false;
          break;
        case 'tag':
          if (el.tagName.toLowerCase() !== value.toLowerCase()) return false;
          break;
        case 'attr':
          for (const [attr, attrValue] of Object.entries(value)) {
            if (el.getAttribute(attr) !== attrValue) return false;
          }
          break;
        case 'text':
          if (!el.textContent.includes(value)) return false;
          break;
        case 'visible':
          if (value && el.offsetParent === null) return false;
          break;
      }
    }
    return true;
  }, root);
}

// Test
// const elements = getElementsAdvanced({
//   class: 'btn',
//   tag: 'button',
//   attr: { 'data-action': 'submit' },
//   visible: true
// });

/**
 * Get closest ancestor with class
 */
function closest(element, className) {
  let current = element;
  
  while (current && current !== document.body) {
    if (current.classList && current.classList.contains(className)) {
      return current;
    }
    current = current.parentElement;
  }
  
  return null;
}

/**
 * Get all siblings with class
 */
function getSiblingsWithClass(element, className) {
  const siblings = [];
  const parent = element.parentElement;
  
  if (!parent) return siblings;
  
  for (const child of parent.children) {
    if (child !== element && child.classList && child.classList.contains(className)) {
      siblings.push(child);
    }
  }
  
  return siblings;
}
```

**Interview Tips:**
- Native getElementsByClassName returns HTMLCollection (live), convert to array
- Recursive approach: DFS traversal of DOM tree
- Iterative approach: BFS using queue, avoids stack overflow
- Time complexity: O(n) where n is number of DOM nodes
- classList.contains() is efficient for class checking
- Can extend to: multiple classes, attributes, custom predicates
- querySelectorAll is more powerful but slightly slower for simple class search
- Consider max depth limit for very deep DOM trees
- Use filter option for additional criteria (visibility, size, etc.)
- Modern approach: use querySelectorAll for complex selectors

</details>

54. Implement event delegation for a list

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Event Delegation**
```javascript
/**
 * Basic event delegation for list items
 * Time Complexity: O(1) per event
 * Space Complexity: O(1)
 * 
 * @param {Element} listElement - Parent list element
 * @param {string} itemSelector - Selector for list items
 * @param {Function} handler - Event handler function
 */
function delegateEvent(listElement, itemSelector, handler) {
  listElement.addEventListener('click', (event) => {
    // Find the closest matching element
    const target = event.target.closest(itemSelector);
    
    if (target && listElement.contains(target)) {
      handler.call(target, event);
    }
  });
}

// Test usage
/*
<ul id="myList">
  <li data-id="1">Item 1</li>
  <li data-id="2">Item 2</li>
  <li data-id="3">Item 3</li>
</ul>
*/

// const list = document.getElementById('myList');
// delegateEvent(list, 'li', function(event) {
//   console.log('Clicked item:', this.dataset.id);
//   this.classList.toggle('selected');
// });
```

### **Approach 2: With Event Type Parameter**
```javascript
/**
 * Event delegation with configurable event type
 */
function delegateEvent(parent, selector, eventType, handler) {
  parent.addEventListener(eventType, (event) => {
    const target = event.target.closest(selector);
    
    if (target && parent.contains(target)) {
      handler.call(target, event);
    }
  });
}

// Test
// const list = document.getElementById('list');
// delegateEvent(list, '.item', 'click', function(event) {
//   console.log('Item clicked:', this.textContent);
// });

// delegateEvent(list, '.item', 'mouseenter', function(event) {
//   this.style.backgroundColor = 'lightblue';
// });
```

### **Approach 3: Multiple Event Types**
```javascript
/**
 * Delegate multiple event types at once
 */
function delegateEvents(parent, selector, events) {
  Object.entries(events).forEach(([eventType, handler]) => {
    parent.addEventListener(eventType, (event) => {
      const target = event.target.closest(selector);
      
      if (target && parent.contains(target)) {
        handler.call(target, event);
      }
    });
  });
}

// Test
// delegateEvents(list, '.item', {
//   click: function(event) {
//     console.log('Clicked:', this.textContent);
//   },
//   mouseenter: function(event) {
//     this.classList.add('hover');
//   },
//   mouseleave: function(event) {
//     this.classList.remove('hover');
//   }
// });
```

### **Production-Grade Solution**
```javascript
/**
 * Production-ready event delegation system
 * 
 * @param {Element} parent - Parent element
 * @param {string} selector - Child selector
 * @param {string|Object} eventType - Event type(s)
 * @param {Function} handler - Event handler
 * @param {Object} options - Delegation options
 * @returns {Function} - Cleanup function
 */
function delegate(parent, selector, eventType, handler, options = {}) {
  const {
    capture = false,
    once = false,
    passive = false,
    stopPropagation = false,
    preventDefault = false
  } = options;
  
  // Validation
  if (!parent || !parent.addEventListener) {
    throw new TypeError('Parent must be a valid DOM element');
  }
  
  if (typeof selector !== 'string') {
    throw new TypeError('Selector must be a string');
  }
  
  // Handle multiple event types
  const events = typeof eventType === 'string'
    ? [eventType]
    : eventType;
  
  const listeners = [];
  
  events.forEach(type => {
    const listener = (event) => {
      const target = event.target.closest(selector);
      
      if (target && parent.contains(target)) {
        if (stopPropagation) {
          event.stopPropagation();
        }
        
        if (preventDefault) {
          event.preventDefault();
        }
        
        // Call handler with target as context
        handler.call(target, event, target);
        
        if (once) {
          cleanup();
        }
      }
    };
    
    parent.addEventListener(type, listener, { capture, passive });
    listeners.push({ type, listener });
  });
  
  // Return cleanup function
  function cleanup() {
    listeners.forEach(({ type, listener }) => {
      parent.removeEventListener(type, listener, { capture });
    });
  }
  
  return cleanup;
}

// Advanced event delegation class
class EventDelegator {
  constructor(parent) {
    this.parent = parent;
    this.handlers = new Map();
  }
  
  on(selector, eventType, handler, options = {}) {
    const key = `${selector}:${eventType}`;
    
    if (this.handlers.has(key)) {
      console.warn(`Handler already exists for ${key}`);
      return this;
    }
    
    const cleanup = delegate(
      this.parent,
      selector,
      eventType,
      handler,
      options
    );
    
    this.handlers.set(key, cleanup);
    return this;
  }
  
  off(selector, eventType) {
    const key = `${selector}:${eventType}`;
    const cleanup = this.handlers.get(key);
    
    if (cleanup) {
      cleanup();
      this.handlers.delete(key);
    }
    
    return this;
  }
  
  offAll() {
    this.handlers.forEach(cleanup => cleanup());
    this.handlers.clear();
    return this;
  }
}

// Practical examples
console.log('=== Todo List Example ===');
/*
<ul id="todoList">
  <li>
    <span class="text">Task 1</span>
    <button class="delete">Delete</button>
  </li>
</ul>
*/

function setupTodoList() {
  const todoList = document.getElementById('todoList');
  
  if (!todoList) return;
  
  const delegator = new EventDelegator(todoList);
  
  // Click on list item text to edit
  delegator.on('.text', 'dblclick', function(event) {
    const currentText = this.textContent;
    const input = document.createElement('input');
    input.value = currentText;
    
    input.addEventListener('blur', () => {
      this.textContent = input.value;
      this.style.display = '';
    });
    
    this.style.display = 'none';
    this.parentElement.insertBefore(input, this);
    input.focus();
  });
  
  // Click delete button
  delegator.on('.delete', 'click', function(event) {
    event.stopPropagation();
    this.parentElement.remove();
  });
  
  // Hover effects
  delegator.on('li', 'mouseenter', function() {
    this.classList.add('hover');
  });
  
  delegator.on('li', 'mouseleave', function() {
    this.classList.remove('hover');
  });
  
  return delegator;
}

console.log('\n=== Sortable List Example ===');
function setupSortableList() {
  const list = document.getElementById('sortableList');
  
  if (!list) return;
  
  let draggedElement = null;
  
  delegate(list, '.item', 'dragstart', function(event) {
    draggedElement = this;
    this.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
  });
  
  delegate(list, '.item', 'dragend', function(event) {
    this.classList.remove('dragging');
    draggedElement = null;
  });
  
  delegate(list, '.item', 'dragover', function(event) {
    event.preventDefault();
    
    if (draggedElement && draggedElement !== this) {
      const rect = this.getBoundingClientRect();
      const middle = rect.top + rect.height / 2;
      
      if (event.clientY < middle) {
        this.parentNode.insertBefore(draggedElement, this);
      } else {
        this.parentNode.insertBefore(draggedElement, this.nextSibling);
      }
    }
  });
}

console.log('\n=== Dynamic List Example ===');
function setupDynamicList() {
  const container = document.getElementById('dynamicList');
  
  if (!container) return;
  
  // Add items dynamically
  const addButton = document.getElementById('addItem');
  let itemCount = 0;
  
  addButton?.addEventListener('click', () => {
    const item = document.createElement('li');
    item.className = 'list-item';
    item.dataset.id = ++itemCount;
    item.innerHTML = `
      <span>Item ${itemCount}</span>
      <button class="edit">Edit</button>
      <button class="remove">Remove</button>
    `;
    container.appendChild(item);
  });
  
  // Event delegation handles both existing and future items
  const delegator = new EventDelegator(container);
  
  delegator
    .on('.list-item', 'click', function(event) {
      console.log('Clicked item:', this.dataset.id);
    })
    .on('.edit', 'click', function(event) {
      event.stopPropagation();
      const span = this.parentElement.querySelector('span');
      const newText = prompt('Edit item:', span.textContent);
      if (newText) span.textContent = newText;
    })
    .on('.remove', 'click', function(event) {
      event.stopPropagation();
      this.parentElement.remove();
    });
  
  return delegator;
}

console.log('\n=== Context Menu Example ===');
function setupContextMenu() {
  const list = document.getElementById('list');
  const contextMenu = document.getElementById('contextMenu');
  
  if (!list || !contextMenu) return;
  
  let selectedItem = null;
  
  delegate(list, '.item', 'contextmenu', function(event) {
    event.preventDefault();
    selectedItem = this;
    
    contextMenu.style.display = 'block';
    contextMenu.style.left = event.pageX + 'px';
    contextMenu.style.top = event.pageY + 'px';
  });
  
  delegate(contextMenu, '.menu-item', 'click', function(event) {
    const action = this.dataset.action;
    
    if (selectedItem) {
      switch (action) {
        case 'edit':
          console.log('Edit:', selectedItem.textContent);
          break;
        case 'delete':
          selectedItem.remove();
          break;
        case 'duplicate':
          selectedItem.parentElement.insertBefore(
            selectedItem.cloneNode(true),
            selectedItem.nextSibling
          );
          break;
      }
    }
    
    contextMenu.style.display = 'none';
  });
  
  document.addEventListener('click', () => {
    contextMenu.style.display = 'none';
  });
}

// Test suite
console.log('\n=== Performance Comparison ===');
function comparePerformance() {
  const list = document.createElement('ul');
  
  // Add 1000 items
  for (let i = 0; i < 1000; i++) {
    const li = document.createElement('li');
    li.textContent = `Item ${i}`;
    li.className = 'item';
    list.appendChild(li);
  }
  
  document.body.appendChild(list);
  
  // Method 1: Individual listeners (BAD)
  console.time('Individual Listeners');
  list.querySelectorAll('.item').forEach(item => {
    item.addEventListener('click', () => {
      console.log('Clicked');
    });
  });
  console.timeEnd('Individual Listeners');
  
  // Method 2: Event delegation (GOOD)
  console.time('Event Delegation');
  delegate(list, '.item', 'click', () => {
    console.log('Clicked');
  });
  console.timeEnd('Event Delegation');
  
  document.body.removeChild(list);
}
```

### **Bonus: Advanced Patterns**
```javascript
/**
 * Delegate with data passing
 */
function delegateWithData(parent, selector, eventType, handler) {
  parent.addEventListener(eventType, (event) => {
    const target = event.target.closest(selector);
    
    if (target && parent.contains(target)) {
      const data = Object.assign({}, target.dataset);
      handler.call(target, event, data);
    }
  });
}

// Test
// delegateWithData(list, '.item', 'click', function(event, data) {
//   console.log('Item data:', data); // { id: '1', name: 'Item 1' }
// });

/**
 * Conditional delegation
 */
function delegateIf(parent, selector, eventType, condition, handler) {
  parent.addEventListener(eventType, (event) => {
    const target = event.target.closest(selector);
    
    if (target && parent.contains(target) && condition(target, event)) {
      handler.call(target, event);
    }
  });
}

// Test
// delegateIf(list, '.item', 'click', 
//   (target) => !target.classList.contains('disabled'),
//   function(event) {
//     console.log('Enabled item clicked');
//   }
// );
```

**Interview Tips:**
- Event delegation attaches one listener to parent instead of many to children
- Benefits: better performance, handles dynamic content, less memory
- Use event.target to find clicked element, closest() to match selector
- Works due to event bubbling (events propagate up DOM tree)
- Common use cases: lists, tables, dynamic content, single-page apps
- Always check if target matches selector and is within parent
- Can delegate multiple event types and selectors
- Return cleanup function to remove listeners when done
- Considerations: not all events bubble (focus, blur need focusin, focusout)
- Modern alternative: element.matches(selector) for checking

</details>

55. Create a simple carousel/slider

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Carousel**
```javascript
/**
 * Simple image carousel
 * 
 * HTML Structure:
 * <div class="carousel">
 *   <div class="carousel-track">
 *     <div class="carousel-item"><img src="img1.jpg"></div>
 *     <div class="carousel-item"><img src="img2.jpg"></div>
 *     <div class="carousel-item"><img src="img3.jpg"></div>
 *   </div>
 *   <button class="prev">❮</button>
 *   <button class="next">❯</button>
 * </div>
 */

class Carousel {
  constructor(element) {
    this.carousel = element;
    this.track = element.querySelector('.carousel-track');
    this.items = Array.from(element.querySelectorAll('.carousel-item'));
    this.prevButton = element.querySelector('.prev');
    this.nextButton = element.querySelector('.next');
    
    this.currentIndex = 0;
    this.itemWidth = this.items[0].offsetWidth;
    
    this.init();
  }
  
  init() {
    // Set up event listeners
    this.prevButton.addEventListener('click', () => this.prev());
    this.nextButton.addEventListener('click', () => this.next());
    
    // Update button states
    this.updateButtons();
  }
  
  next() {
    if (this.currentIndex < this.items.length - 1) {
      this.currentIndex++;
      this.updatePosition();
    }
  }
  
  prev() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.updatePosition();
    }
  }
  
  updatePosition() {
    const offset = -this.currentIndex * this.itemWidth;
    this.track.style.transform = `translateX(${offset}px)`;
    this.updateButtons();
  }
  
  updateButtons() {
    this.prevButton.disabled = this.currentIndex === 0;
    this.nextButton.disabled = this.currentIndex === this.items.length - 1;
  }
}

// CSS for basic carousel
const carouselCSS = `
.carousel {
  position: relative;
  overflow: hidden;
  width: 100%;
}

.carousel-track {
  display: flex;
  transition: transform 0.3s ease;
}

.carousel-item {
  flex: 0 0 100%;
  min-width: 100%;
}

.carousel-item img {
  width: 100%;
  display: block;
}

.prev, .next {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.5);
  color: white;
  border: none;
  padding: 10px 15px;
  cursor: pointer;
}

.prev { left: 10px; }
.next { right: 10px; }

.prev:disabled, .next:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}
`;

// Usage
// const carousel = new Carousel(document.querySelector('.carousel'));
```

### **Approach 2: With Auto-Play**
```javascript
/**
 * Carousel with auto-play functionality
 */
class AutoCarousel {
  constructor(element, options = {}) {
    this.carousel = element;
    this.track = element.querySelector('.carousel-track');
    this.items = Array.from(element.querySelectorAll('.carousel-item'));
    this.prevButton = element.querySelector('.prev');
    this.nextButton = element.querySelector('.next');
    
    this.currentIndex = 0;
    this.autoPlayInterval = options.autoPlay ? options.interval || 3000 : null;
    this.loop = options.loop !== false;
    this.intervalId = null;
    
    this.init();
  }
  
  init() {
    this.prevButton.addEventListener('click', () => {
      this.prev();
      this.resetAutoPlay();
    });
    
    this.nextButton.addEventListener('click', () => {
      this.next();
      this.resetAutoPlay();
    });
    
    // Pause on hover
    this.carousel.addEventListener('mouseenter', () => this.pause());
    this.carousel.addEventListener('mouseleave', () => this.resume());
    
    if (this.autoPlayInterval) {
      this.startAutoPlay();
    }
    
    this.updatePosition();
  }
  
  next() {
    if (this.currentIndex < this.items.length - 1) {
      this.currentIndex++;
    } else if (this.loop) {
      this.currentIndex = 0;
    }
    this.updatePosition();
  }
  
  prev() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
    } else if (this.loop) {
      this.currentIndex = this.items.length - 1;
    }
    this.updatePosition();
  }
  
  goTo(index) {
    this.currentIndex = Math.max(0, Math.min(index, this.items.length - 1));
    this.updatePosition();
  }
  
  updatePosition() {
    const offset = -this.currentIndex * 100;
    this.track.style.transform = `translateX(${offset}%)`;
    this.updateButtons();
    this.updateIndicators();
  }
  
  updateButtons() {
    if (this.loop) {
      this.prevButton.disabled = false;
      this.nextButton.disabled = false;
    } else {
      this.prevButton.disabled = this.currentIndex === 0;
      this.nextButton.disabled = this.currentIndex === this.items.length - 1;
    }
  }
  
  updateIndicators() {
    const indicators = this.carousel.querySelectorAll('.indicator');
    indicators.forEach((indicator, index) => {
      indicator.classList.toggle('active', index === this.currentIndex);
    });
  }
  
  startAutoPlay() {
    this.intervalId = setInterval(() => this.next(), this.autoPlayInterval);
  }
  
  pause() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  resume() {
    if (this.autoPlayInterval && !this.intervalId) {
      this.startAutoPlay();
    }
  }
  
  resetAutoPlay() {
    this.pause();
    this.resume();
  }
  
  destroy() {
    this.pause();
    // Remove event listeners
  }
}

// Usage
// const carousel = new AutoCarousel(document.querySelector('.carousel'), {
//   autoPlay: true,
//   interval: 3000,
//   loop: true
// });
```

### **Approach 3: With Indicators and Touch Support**
```javascript
/**
 * Full-featured carousel with touch support
 */
class AdvancedCarousel {
  constructor(element, options = {}) {
    this.carousel = element;
    this.track = element.querySelector('.carousel-track');
    this.items = Array.from(element.querySelectorAll('.carousel-item'));
    this.prevButton = element.querySelector('.prev');
    this.nextButton = element.querySelector('.next');
    
    // Options
    this.currentIndex = 0;
    this.autoPlayInterval = options.autoPlay ? options.interval || 3000 : null;
    this.loop = options.loop !== false;
    this.showIndicators = options.indicators !== false;
    this.swipeEnabled = options.swipe !== false;
    
    // Touch tracking
    this.touchStartX = 0;
    this.touchEndX = 0;
    this.isDragging = false;
    
    this.init();
  }
  
  init() {
    // Navigation buttons
    this.prevButton?.addEventListener('click', () => {
      this.prev();
      this.resetAutoPlay();
    });
    
    this.nextButton?.addEventListener('click', () => {
      this.next();
      this.resetAutoPlay();
    });
    
    // Create indicators
    if (this.showIndicators) {
      this.createIndicators();
    }
    
    // Touch/Swipe support
    if (this.swipeEnabled) {
      this.setupSwipe();
    }
    
    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') this.prev();
      if (e.key === 'ArrowRight') this.next();
    });
    
    // Auto-play
    this.carousel.addEventListener('mouseenter', () => this.pause());
    this.carousel.addEventListener('mouseleave', () => this.resume());
    
    if (this.autoPlayInterval) {
      this.startAutoPlay();
    }
    
    this.updatePosition();
  }
  
  createIndicators() {
    const indicatorContainer = document.createElement('div');
    indicatorContainer.className = 'carousel-indicators';
    
    this.items.forEach((_, index) => {
      const indicator = document.createElement('button');
      indicator.className = 'indicator';
      indicator.setAttribute('aria-label', `Go to slide ${index + 1}`);
      indicator.addEventListener('click', () => {
        this.goTo(index);
        this.resetAutoPlay();
      });
      indicatorContainer.appendChild(indicator);
    });
    
    this.carousel.appendChild(indicatorContainer);
  }
  
  setupSwipe() {
    this.track.addEventListener('touchstart', (e) => {
      this.touchStartX = e.touches[0].clientX;
      this.isDragging = true;
      this.pause();
    }, { passive: true });
    
    this.track.addEventListener('touchmove', (e) => {
      if (!this.isDragging) return;
      this.touchEndX = e.touches[0].clientX;
    }, { passive: true });
    
    this.track.addEventListener('touchend', () => {
      if (!this.isDragging) return;
      
      const diff = this.touchStartX - this.touchEndX;
      const threshold = 50; // Minimum swipe distance
      
      if (Math.abs(diff) > threshold) {
        if (diff > 0) {
          this.next();
        } else {
          this.prev();
        }
      }
      
      this.isDragging = false;
      this.resume();
    });
    
    // Mouse drag support
    let mouseStartX = 0;
    let mouseDown = false;
    
    this.track.addEventListener('mousedown', (e) => {
      mouseStartX = e.clientX;
      mouseDown = true;
      this.track.style.cursor = 'grabbing';
    });
    
    this.track.addEventListener('mousemove', (e) => {
      if (!mouseDown) return;
      e.preventDefault();
    });
    
    this.track.addEventListener('mouseup', (e) => {
      if (!mouseDown) return;
      
      const diff = mouseStartX - e.clientX;
      const threshold = 50;
      
      if (Math.abs(diff) > threshold) {
        if (diff > 0) {
          this.next();
        } else {
          this.prev();
        }
      }
      
      mouseDown = false;
      this.track.style.cursor = 'grab';
    });
  }
  
  next() {
    if (this.currentIndex < this.items.length - 1) {
      this.currentIndex++;
    } else if (this.loop) {
      this.currentIndex = 0;
    }
    this.updatePosition();
  }
  
  prev() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
    } else if (this.loop) {
      this.currentIndex = this.items.length - 1;
    }
    this.updatePosition();
  }
  
  goTo(index) {
    this.currentIndex = Math.max(0, Math.min(index, this.items.length - 1));
    this.updatePosition();
  }
  
  updatePosition() {
    const offset = -this.currentIndex * 100;
    this.track.style.transform = `translateX(${offset}%)`;
    this.updateButtons();
    this.updateIndicators();
  }
  
  updateButtons() {
    if (!this.prevButton || !this.nextButton) return;
    
    if (this.loop) {
      this.prevButton.disabled = false;
      this.nextButton.disabled = false;
    } else {
      this.prevButton.disabled = this.currentIndex === 0;
      this.nextButton.disabled = this.currentIndex === this.items.length - 1;
    }
  }
  
  updateIndicators() {
    const indicators = this.carousel.querySelectorAll('.indicator');
    indicators.forEach((indicator, index) => {
      indicator.classList.toggle('active', index === this.currentIndex);
    });
  }
  
  startAutoPlay() {
    this.intervalId = setInterval(() => this.next(), this.autoPlayInterval);
  }
  
  pause() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  resume() {
    if (this.autoPlayInterval && !this.intervalId) {
      this.startAutoPlay();
    }
  }
  
  resetAutoPlay() {
    this.pause();
    this.resume();
  }
  
  destroy() {
    this.pause();
    // Clean up event listeners
  }
}

// Complete CSS
const advancedCarouselCSS = `
.carousel {
  position: relative;
  overflow: hidden;
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
}

.carousel-track {
  display: flex;
  transition: transform 0.4s ease;
  cursor: grab;
}

.carousel-track:active {
  cursor: grabbing;
}

.carousel-item {
  flex: 0 0 100%;
  min-width: 100%;
}

.carousel-item img {
  width: 100%;
  height: auto;
  display: block;
}

.prev, .next {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.5);
  color: white;
  border: none;
  padding: 12px 18px;
  cursor: pointer;
  font-size: 20px;
  z-index: 10;
  transition: background 0.3s;
}

.prev:hover, .next:hover {
  background: rgba(0, 0, 0, 0.8);
}

.prev:disabled, .next:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.prev { left: 10px; }
.next { right: 10px; }

.carousel-indicators {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  z-index: 10;
}

.indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.5);
  border: none;
  cursor: pointer;
  transition: background 0.3s;
}

.indicator:hover {
  background: rgba(255, 255, 255, 0.8);
}

.indicator.active {
  background: white;
}
`;

// Usage examples
console.log('=== Basic Carousel ===');
// const carousel1 = new Carousel(document.querySelector('#carousel1'));

console.log('\n=== Auto-Play Carousel ===');
// const carousel2 = new AutoCarousel(document.querySelector('#carousel2'), {
//   autoPlay: true,
//   interval: 3000,
//   loop: true
// });

console.log('\n=== Advanced Carousel ===');
// const carousel3 = new AdvancedCarousel(document.querySelector('#carousel3'), {
//   autoPlay: true,
//   interval: 4000,
//   loop: true,
//   indicators: true,
//   swipe: true
// });

// HTML Template
const carouselHTML = `
<div class="carousel" id="myCarousel">
  <div class="carousel-track">
    <div class="carousel-item">
      <img src="image1.jpg" alt="Slide 1">
    </div>
    <div class="carousel-item">
      <img src="image2.jpg" alt="Slide 2">
    </div>
    <div class="carousel-item">
      <img src="image3.jpg" alt="Slide 3">
    </div>
  </div>
  <button class="prev" aria-label="Previous slide">❮</button>
  <button class="next" aria-label="Next slide">❯</button>
</div>
`;
```

### **Bonus: Fade Carousel**
```javascript
/**
 * Carousel with fade transition instead of slide
 */
class FadeCarousel {
  constructor(element, options = {}) {
    this.carousel = element;
    this.items = Array.from(element.querySelectorAll('.carousel-item'));
    this.currentIndex = 0;
    this.autoPlayInterval = options.interval || 3000;
    
    this.init();
  }
  
  init() {
    // Hide all items except first
    this.items.forEach((item, index) => {
      item.style.opacity = index === 0 ? '1' : '0';
      item.style.position = 'absolute';
      item.style.top = '0';
      item.style.left = '0';
      item.style.width = '100%';
      item.style.transition = 'opacity 0.5s ease';
    });
    
    // Start auto-play
    this.startAutoPlay();
    
    // Pause on hover
    this.carousel.addEventListener('mouseenter', () => this.pause());
    this.carousel.addEventListener('mouseleave', () => this.resume());
  }
  
  next() {
    this.items[this.currentIndex].style.opacity = '0';
    this.currentIndex = (this.currentIndex + 1) % this.items.length;
    this.items[this.currentIndex].style.opacity = '1';
  }
  
  startAutoPlay() {
    this.intervalId = setInterval(() => this.next(), this.autoPlayInterval);
  }
  
  pause() {
    clearInterval(this.intervalId);
  }
  
  resume() {
    this.startAutoPlay();
  }
}
```

**Interview Tips:**
- Basic carousel: translate track horizontally based on current index
- Use CSS transform for smooth animations (better than left/right)
- Key features: prev/next buttons, indicators, auto-play, loop
- Touch support: listen to touchstart/touchmove/touchend events
- Auto-play: use setInterval, pause on hover, reset on manual navigation
- Accessibility: ARIA labels, keyboard navigation, focus management
- Performance: use transform instead of margin/left for GPU acceleration
- Common variations: fade, vertical, multiple items visible, infinite loop
- Responsive: use percentages for positioning, handle window resize
- Libraries: Swiper.js, Slick, Glide.js for production

</details>

56. Implement infinite scroll

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Scroll Event Listener**
```javascript
/**
 * Basic infinite scroll using scroll event
 * 
 * @param {Function} loadMore - Function to load more content
 * @param {Object} options - Scroll options
 */
function infiniteScroll(loadMore, options = {}) {
  const {
    threshold = 200, // Distance from bottom to trigger load
    container = window
  } = options;
  
  let loading = false;
  
  const handleScroll = () => {
    if (loading) return;
    
    const scrollTop = container === window 
      ? window.pageYOffset 
      : container.scrollTop;
    
    const scrollHeight = container === window
      ? document.documentElement.scrollHeight
      : container.scrollHeight;
    
    const clientHeight = container === window
      ? window.innerHeight
      : container.clientHeight;
    
    const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);
    
    if (distanceFromBottom < threshold) {
      loading = true;
      
      loadMore()
        .then(() => {
          loading = false;
        })
        .catch(error => {
          console.error('Error loading more:', error);
          loading = false;
        });
    }
  };
  
  container.addEventListener('scroll', handleScroll);
  
  // Return cleanup function
  return () => container.removeEventListener('scroll', handleScroll);
}

// Usage
// const cleanup = infiniteScroll(async () => {
//   const response = await fetch('/api/items?page=' + currentPage);
//   const items = await response.json();
//   renderItems(items);
//   currentPage++;
// }, { threshold: 300 });
```

### **Approach 2: Intersection Observer API**
```javascript
/**
 * Infinite scroll using Intersection Observer (modern approach)
 */
class InfiniteScroll {
  constructor(options = {}) {
    this.container = options.container || document.querySelector('.content');
    this.loadMore = options.loadMore;
    this.threshold = options.threshold || 0.8;
    this.rootMargin = options.rootMargin || '200px';
    
    this.loading = false;
    this.hasMore = true;
    
    this.init();
  }
  
  init() {
    // Create sentinel element at bottom
    this.sentinel = document.createElement('div');
    this.sentinel.className = 'infinite-scroll-sentinel';
    this.container.appendChild(this.sentinel);
    
    // Set up Intersection Observer
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      {
        root: null, // viewport
        rootMargin: this.rootMargin,
        threshold: this.threshold
      }
    );
    
    this.observer.observe(this.sentinel);
  }
  
  async handleIntersection(entries) {
    const entry = entries[0];
    
    if (entry.isIntersecting && !this.loading && this.hasMore) {
      this.loading = true;
      
      try {
        const hasMore = await this.loadMore();
        
        if (hasMore === false) {
          this.hasMore = false;
          this.destroy();
        }
      } catch (error) {
        console.error('Error loading more:', error);
      } finally {
        this.loading = false;
      }
    }
  }
  
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    
    if (this.sentinel && this.sentinel.parentNode) {
      this.sentinel.parentNode.removeChild(this.sentinel);
    }
  }
}

// Usage
// const scroll = new InfiniteScroll({
//   container: document.querySelector('.feed'),
//   loadMore: async () => {
//     const response = await fetch(`/api/posts?page=${currentPage}`);
//     const data = await response.json();
//     
//     if (data.posts.length === 0) {
//       return false; // No more items
//     }
//     
//     renderPosts(data.posts);
//     currentPage++;
//     return true;
//   }
// });
```

### **Approach 3: With Throttle and Loading State**
```javascript
/**
 * Production-ready infinite scroll with throttle
 */
class AdvancedInfiniteScroll {
  constructor(options = {}) {
    this.container = options.container || window;
    this.contentContainer = options.contentContainer || document.querySelector('.content');
    this.loadMore = options.loadMore;
    this.threshold = options.threshold || 200;
    this.throttleDelay = options.throttleDelay || 200;
    
    this.loading = false;
    this.hasMore = true;
    this.currentPage = 1;
    
    this.createLoadingIndicator();
    this.init();
  }
  
  init() {
    // Throttle scroll handler
    this.handleScroll = this.throttle(() => {
      this.checkAndLoad();
    }, this.throttleDelay);
    
    this.container.addEventListener('scroll', this.handleScroll);
    
    // Initial check in case content is too short
    this.checkAndLoad();
  }
  
  throttle(func, delay) {
    let lastCall = 0;
    return function(...args) {
      const now = Date.now();
      if (now - lastCall >= delay) {
        lastCall = now;
        return func.apply(this, args);
      }
    };
  }
  
  checkAndLoad() {
    if (this.loading || !this.hasMore) return;
    
    const scrollTop = this.container === window 
      ? window.pageYOffset 
      : this.container.scrollTop;
    
    const scrollHeight = this.container === window
      ? document.documentElement.scrollHeight
      : this.container.scrollHeight;
    
    const clientHeight = this.container === window
      ? window.innerHeight
      : this.container.clientHeight;
    
    const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);
    
    if (distanceFromBottom < this.threshold) {
      this.load();
    }
  }
  
  async load() {
    if (this.loading) return;
    
    this.loading = true;
    this.showLoading();
    
    try {
      const result = await this.loadMore(this.currentPage);
      
      if (!result || result.length === 0) {
        this.hasMore = false;
        this.showNoMoreContent();
      } else {
        this.currentPage++;
        // Check again in case content is still not enough to scroll
        setTimeout(() => this.checkAndLoad(), 100);
      }
    } catch (error) {
      console.error('Error loading content:', error);
      this.showError(error);
    } finally {
      this.loading = false;
      this.hideLoading();
    }
  }
  
  createLoadingIndicator() {
    this.loadingElement = document.createElement('div');
    this.loadingElement.className = 'infinite-scroll-loading';
    this.loadingElement.innerHTML = '<div class="spinner"></div>';
    this.loadingElement.style.display = 'none';
    
    if (this.contentContainer) {
      this.contentContainer.appendChild(this.loadingElement);
    }
  }
  
  showLoading() {
    if (this.loadingElement) {
      this.loadingElement.style.display = 'block';
    }
  }
  
  hideLoading() {
    if (this.loadingElement) {
      this.loadingElement.style.display = 'none';
    }
  }
  
  showNoMoreContent() {
    const message = document.createElement('div');
    message.className = 'no-more-content';
    message.textContent = 'No more items to load';
    
    if (this.contentContainer) {
      this.contentContainer.appendChild(message);
    }
  }
  
  showError(error) {
    const errorElement = document.createElement('div');
    errorElement.className = 'infinite-scroll-error';
    errorElement.innerHTML = `
      <p>Error loading content</p>
      <button class="retry-button">Retry</button>
    `;
    
    errorElement.querySelector('.retry-button').addEventListener('click', () => {
      errorElement.remove();
      this.load();
    });
    
    if (this.contentContainer) {
      this.contentContainer.appendChild(errorElement);
    }
  }
  
  destroy() {
    this.container.removeEventListener('scroll', this.handleScroll);
    
    if (this.loadingElement && this.loadingElement.parentNode) {
      this.loadingElement.parentNode.removeChild(this.loadingElement);
    }
  }
  
  reset() {
    this.currentPage = 1;
    this.hasMore = true;
    this.loading = false;
  }
}

// Complete example with API integration
class FeedWithInfiniteScroll {
  constructor(containerId) {
    this.container = document.getElementById(containerId);
    this.items = [];
    
    this.infiniteScroll = new AdvancedInfiniteScroll({
      contentContainer: this.container,
      loadMore: (page) => this.loadItems(page),
      threshold: 300
    });
  }
  
  async loadItems(page) {
    // Simulate API call
    const response = await fetch(`/api/items?page=${page}&limit=20`);
    const data = await response.json();
    
    if (data.items.length > 0) {
      this.renderItems(data.items);
      return data.items;
    }
    
    return null;
  }
  
  renderItems(items) {
    items.forEach(item => {
      const element = document.createElement('div');
      element.className = 'item';
      element.innerHTML = `
        <h3>${item.title}</h3>
        <p>${item.description}</p>
      `;
      this.container.appendChild(element);
    });
  }
}

// CSS for loading indicators
const infiniteScrollCSS = `
.infinite-scroll-loading {
  text-align: center;
  padding: 20px;
}

.spinner {
  width: 40px;
  height: 40px;
  margin: 0 auto;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.no-more-content {
  text-align: center;
  padding: 20px;
  color: #666;
}

.infinite-scroll-error {
  text-align: center;
  padding: 20px;
  color: #d32f2f;
}

.retry-button {
  margin-top: 10px;
  padding: 8px 16px;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.retry-button:hover {
  background: #2980b9;
}
`;

// Usage examples
console.log('=== Basic Infinite Scroll ===');
// let currentPage = 1;
// infiniteScroll(async () => {
//   const items = await fetchItems(currentPage);
//   renderItems(items);
//   currentPage++;
// });

console.log('\n=== Intersection Observer ===');
// const scroll = new InfiniteScroll({
//   loadMore: async () => {
//     const items = await fetchItems();
//     return items.length > 0;
//   }
// });

console.log('\n=== Advanced with Features ===');
// const feed = new AdvancedInfiniteScroll({
//   container: window,
//   contentContainer: document.querySelector('.feed'),
//   loadMore: async (page) => {
//     const response = await fetch(`/api/posts?page=${page}`);
//     const data = await response.json();
//     renderPosts(data.posts);
//     return data.posts;
//   },
//   threshold: 300,
//   throttleDelay: 200
// });
```

### **Bonus: Virtual Scrolling**
```javascript
/**
 * Virtual scrolling for massive lists (only render visible items)
 */
class VirtualScroll {
  constructor(container, options = {}) {
    this.container = container;
    this.items = [];
    this.itemHeight = options.itemHeight || 50;
    this.buffer = options.buffer || 5;
    this.renderItem = options.renderItem;
    
    this.visibleStart = 0;
    this.visibleEnd = 0;
    
    this.init();
  }
  
  init() {
    this.viewport = document.createElement('div');
    this.viewport.style.overflow = 'auto';
    this.viewport.style.height = '100%';
    
    this.content = document.createElement('div');
    this.viewport.appendChild(this.content);
    this.container.appendChild(this.viewport);
    
    this.viewport.addEventListener('scroll', () => this.onScroll());
  }
  
  setItems(items) {
    this.items = items;
    this.content.style.height = (items.length * this.itemHeight) + 'px';
    this.onScroll();
  }
  
  onScroll() {
    const scrollTop = this.viewport.scrollTop;
    const viewportHeight = this.viewport.clientHeight;
    
    this.visibleStart = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.buffer);
    this.visibleEnd = Math.min(
      this.items.length,
      Math.ceil((scrollTop + viewportHeight) / this.itemHeight) + this.buffer
    );
    
    this.render();
  }
  
  render() {
    this.content.innerHTML = '';
    
    const offset = this.visibleStart * this.itemHeight;
    this.content.style.paddingTop = offset + 'px';
    
    for (let i = this.visibleStart; i < this.visibleEnd; i++) {
      const element = this.renderItem(this.items[i], i);
      this.content.appendChild(element);
    }
  }
}
```

**Interview Tips:**
- Infinite scroll loads content as user scrolls down
- Use Intersection Observer (modern) or scroll event (traditional)
- Throttle scroll events to improve performance (~200ms)
- Show loading indicator while fetching data
- Handle errors with retry button
- Track loading state to prevent duplicate requests
- Detect "no more content" condition
- Threshold: distance from bottom to trigger load (200-300px typical)
- Accessibility: ensure keyboard navigation works
- Performance: virtual scrolling for massive lists, lazy load images
- Common issues: too short content, API errors, race conditions
- Alternative: pagination for better UX in some cases

</details>

57. Create a star rating component

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Star Rating**
```javascript
/**
 * Basic star rating component
 * 
 * HTML:
 * <div class="star-rating" data-rating="0"></div>
 */
class StarRating {
  constructor(element, options = {}) {
    this.element = element;
    this.maxStars = options.maxStars || 5;
    this.currentRating = options.initialRating || 0;
    this.readonly = options.readonly || false;
    this.onChange = options.onChange || (() => {});
    
    this.init();
  }
  
  init() {
    this.element.innerHTML = '';
    this.stars = [];
    
    for (let i = 1; i <= this.maxStars; i++) {
      const star = document.createElement('span');
      star.className = 'star';
      star.innerHTML = '★';
      star.dataset.value = i;
      
      if (!this.readonly) {
        star.addEventListener('click', () => this.setRating(i));
        star.addEventListener('mouseenter', () => this.highlightStars(i));
      }
      
      this.element.appendChild(star);
      this.stars.push(star);
    }
    
    if (!this.readonly) {
      this.element.addEventListener('mouseleave', () => {
        this.highlightStars(this.currentRating);
      });
    }
    
    this.setRating(this.currentRating);
  }
  
  setRating(rating) {
    this.currentRating = rating;
    this.highlightStars(rating);
    this.onChange(rating);
  }
  
  highlightStars(rating) {
    this.stars.forEach((star, index) => {
      if (index < rating) {
        star.classList.add('active');
      } else {
        star.classList.remove('active');
      }
    });
  }
  
  getRating() {
    return this.currentRating;
  }
  
  reset() {
    this.setRating(0);
  }
}

// CSS
const starRatingCSS = `
.star-rating {
  display: inline-flex;
  gap: 5px;
  cursor: pointer;
}

.star {
  font-size: 30px;
  color: #ddd;
  transition: color 0.2s;
}

.star.active {
  color: #ffd700;
}

.star:hover {
  color: #ffed4e;
}

.star-rating.readonly {
  cursor: default;
}

.star-rating.readonly .star:hover {
  color: inherit;
}
`;

// Usage
// const rating = new StarRating(document.querySelector('.star-rating'), {
//   maxStars: 5,
//   initialRating: 3,
//   onChange: (rating) => {
//     console.log('New rating:', rating);
//   }
// });
```

### **Approach 2: With Half Stars**
```javascript
/**
 * Star rating with half-star support
 */
class HalfStarRating {
  constructor(element, options = {}) {
    this.element = element;
    this.maxStars = options.maxStars || 5;
    this.currentRating = options.initialRating || 0;
    this.allowHalf = options.allowHalf !== false;
    this.readonly = options.readonly || false;
    this.onChange = options.onChange || (() => {});
    
    this.init();
  }
  
  init() {
    this.element.innerHTML = '';
    this.element.className = 'star-rating-half';
    
    if (this.readonly) {
      this.element.classList.add('readonly');
    }
    
    this.stars = [];
    
    for (let i = 1; i <= this.maxStars; i++) {
      const starContainer = document.createElement('span');
      starContainer.className = 'star-container';
      starContainer.dataset.value = i;
      
      const starFull = document.createElement('span');
      starFull.className = 'star star-full';
      starFull.innerHTML = '★';
      
      const starEmpty = document.createElement('span');
      starEmpty.className = 'star star-empty';
      starEmpty.innerHTML = '★';
      
      starContainer.appendChild(starEmpty);
      starContainer.appendChild(starFull);
      
      if (!this.readonly) {
        // Click handlers for full and half stars
        starContainer.addEventListener('click', (e) => {
          const rect = starContainer.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const isHalf = this.allowHalf && x < rect.width / 2;
          this.setRating(i - (isHalf ? 0.5 : 0));
        });
        
        starContainer.addEventListener('mousemove', (e) => {
          const rect = starContainer.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const isHalf = this.allowHalf && x < rect.width / 2;
          this.highlightStars(i - (isHalf ? 0.5 : 0));
        });
      }
      
      this.element.appendChild(starContainer);
      this.stars.push(starContainer);
    }
    
    if (!this.readonly) {
      this.element.addEventListener('mouseleave', () => {
        this.highlightStars(this.currentRating);
      });
    }
    
    this.setRating(this.currentRating);
  }
  
  setRating(rating) {
    this.currentRating = Math.max(0, Math.min(this.maxStars, rating));
    this.highlightStars(this.currentRating);
    this.onChange(this.currentRating);
  }
  
  highlightStars(rating) {
    this.stars.forEach((star, index) => {
      const starValue = index + 1;
      const starFull = star.querySelector('.star-full');
      
      if (rating >= starValue) {
        starFull.style.width = '100%';
      } else if (rating > starValue - 1 && rating < starValue) {
        const percentage = ((rating - (starValue - 1)) * 100) + '%';
        starFull.style.width = percentage;
      } else {
        starFull.style.width = '0%';
      }
    });
  }
  
  getRating() {
    return this.currentRating;
  }
}

// CSS for half stars
const halfStarCSS = `
.star-rating-half {
  display: inline-flex;
  gap: 5px;
}

.star-container {
  position: relative;
  display: inline-block;
  font-size: 30px;
  cursor: pointer;
}

.star {
  transition: color 0.2s;
}

.star-empty {
  color: #ddd;
}

.star-full {
  position: absolute;
  top: 0;
  left: 0;
  color: #ffd700;
  overflow: hidden;
  width: 0%;
  transition: width 0.2s;
}

.star-rating-half.readonly {
  cursor: default;
}
`;
```

### **Approach 3: Production-Grade with Features**
```javascript
/**
 * Full-featured star rating component
 */
class AdvancedStarRating {
  constructor(element, options = {}) {
    this.element = element;
    this.maxStars = options.maxStars || 5;
    this.currentRating = options.initialRating || 0;
    this.allowHalf = options.allowHalf || false;
    this.allowClear = options.allowClear || false;
    this.readonly = options.readonly || false;
    this.showValue = options.showValue || false;
    this.starChar = options.starChar || '★';
    this.emptyStarChar = options.emptyStarChar || '☆';
    this.size = options.size || 'medium'; // small, medium, large
    this.color = options.color || '#ffd700';
    this.onChange = options.onChange || (() => {});
    this.onHover = options.onHover || (() => {});
    
    this.hoverRating = 0;
    this.init();
  }
  
  init() {
    this.element.innerHTML = '';
    this.element.className = `star-rating star-rating-${this.size}`;
    
    if (this.readonly) {
      this.element.classList.add('readonly');
    }
    
    // Create star container
    this.starsContainer = document.createElement('div');
    this.starsContainer.className = 'stars-container';
    this.element.appendChild(this.starsContainer);
    
    this.stars = [];
    this.createStars();
    
    // Create value display
    if (this.showValue) {
      this.valueDisplay = document.createElement('span');
      this.valueDisplay.className = 'rating-value';
      this.element.appendChild(this.valueDisplay);
      this.updateValueDisplay();
    }
    
    // Set initial rating
    this.setRating(this.currentRating, false);
  }
  
  createStars() {
    for (let i = 1; i <= this.maxStars; i++) {
      const starWrapper = document.createElement('span');
      starWrapper.className = 'star-wrapper';
      starWrapper.dataset.value = i;
      
      // Create star elements
      const starEmpty = document.createElement('span');
      starEmpty.className = 'star star-empty';
      starEmpty.innerHTML = this.emptyStarChar;
      
      const starFilled = document.createElement('span');
      starFilled.className = 'star star-filled';
      starFilled.innerHTML = this.starChar;
      starFilled.style.color = this.color;
      
      starWrapper.appendChild(starEmpty);
      starWrapper.appendChild(starFilled);
      
      if (!this.readonly) {
        starWrapper.addEventListener('click', (e) => this.handleClick(e, i));
        starWrapper.addEventListener('mousemove', (e) => this.handleMouseMove(e, i));
        starWrapper.addEventListener('mouseenter', () => {
          this.element.classList.add('hovering');
        });
      }
      
      this.starsContainer.appendChild(starWrapper);
      this.stars.push(starWrapper);
    }
    
    if (!this.readonly) {
      this.element.addEventListener('mouseleave', () => {
        this.element.classList.remove('hovering');
        this.highlightStars(this.currentRating);
        this.onHover(this.currentRating);
      });
    }
  }
  
  handleClick(event, starIndex) {
    if (this.readonly) return;
    
    let rating = starIndex;
    
    if (this.allowHalf) {
      const rect = event.currentTarget.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const isLeftHalf = x < rect.width / 2;
      
      if (isLeftHalf) {
        rating = starIndex - 0.5;
      }
    }
    
    // Allow clearing rating by clicking same star
    if (this.allowClear && this.currentRating === rating) {
      rating = 0;
    }
    
    this.setRating(rating, true);
  }
  
  handleMouseMove(event, starIndex) {
    if (this.readonly) return;
    
    let rating = starIndex;
    
    if (this.allowHalf) {
      const rect = event.currentTarget.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const isLeftHalf = x < rect.width / 2;
      
      if (isLeftHalf) {
        rating = starIndex - 0.5;
      }
    }
    
    this.hoverRating = rating;
    this.highlightStars(rating);
    this.onHover(rating);
  }
  
  setRating(rating, triggerChange = true) {
    this.currentRating = Math.max(0, Math.min(this.maxStars, rating));
    this.highlightStars(this.currentRating);
    this.updateValueDisplay();
    
    if (triggerChange) {
      this.onChange(this.currentRating);
    }
  }
  
  highlightStars(rating) {
    this.stars.forEach((star, index) => {
      const starValue = index + 1;
      const starFilled = star.querySelector('.star-filled');
      
      if (rating >= starValue) {
        starFilled.style.width = '100%';
        starFilled.style.opacity = '1';
      } else if (rating > starValue - 1 && rating < starValue) {
        const percentage = ((rating - (starValue - 1)) * 100);
        starFilled.style.width = percentage + '%';
        starFilled.style.opacity = '1';
      } else {
        starFilled.style.width = '0%';
        starFilled.style.opacity = '0';
      }
    });
  }
  
  updateValueDisplay() {
    if (this.valueDisplay) {
      this.valueDisplay.textContent = this.currentRating.toFixed(1);
    }
  }
  
  getRating() {
    return this.currentRating;
  }
  
  reset() {
    this.setRating(0);
  }
  
  destroy() {
    this.element.innerHTML = '';
  }
}

// Complete CSS
const advancedStarCSS = `
.star-rating {
  display: inline-flex;
  align-items: center;
  gap: 10px;
}

.stars-container {
  display: inline-flex;
  gap: 2px;
}

.star-wrapper {
  position: relative;
  display: inline-block;
  cursor: pointer;
}

.star {
  display: inline-block;
  transition: all 0.2s ease;
}

.star-empty {
  color: #ddd;
}

.star-filled {
  position: absolute;
  top: 0;
  left: 0;
  color: #ffd700;
  overflow: hidden;
  width: 0%;
  white-space: nowrap;
}

.star-rating-small .star {
  font-size: 18px;
}

.star-rating-medium .star {
  font-size: 24px;
}

.star-rating-large .star {
  font-size: 32px;
}

.star-rating.readonly .star-wrapper {
  cursor: default;
}

.star-rating.hovering .star-wrapper:hover .star-filled {
  transform: scale(1.2);
}

.rating-value {
  font-weight: bold;
  font-size: 18px;
  color: #333;
}
`;

// Usage examples
console.log('=== Basic Star Rating ===');
// const rating1 = new StarRating(document.querySelector('#rating1'), {
//   maxStars: 5,
//   initialRating: 3,
//   onChange: (rating) => console.log('Rating:', rating)
// });

console.log('\n=== Half Star Rating ===');
// const rating2 = new HalfStarRating(document.querySelector('#rating2'), {
//   maxStars: 5,
//   initialRating: 3.5,
//   allowHalf: true,
//   onChange: (rating) => console.log('Rating:', rating)
// });

console.log('\n=== Advanced Rating ===');
// const rating3 = new AdvancedStarRating(document.querySelector('#rating3'), {
//   maxStars: 5,
//   initialRating: 4.5,
//   allowHalf: true,
//   allowClear: true,
//   showValue: true,
//   size: 'large',
//   color: '#ff6b6b',
//   onChange: (rating) => console.log('Rating changed:', rating),
//   onHover: (rating) => console.log('Hovering:', rating)
// });

// HTML template
const ratingHTML = `
<div class="rating-container">
  <h3>Rate this product:</h3>
  <div id="product-rating" class="star-rating"></div>
  <p class="rating-text">Click to rate</p>
</div>
`;

// Form integration example
function setupRatingForm() {
  const form = document.querySelector('#review-form');
  const ratingElement = document.querySelector('#rating');
  
  const rating = new AdvancedStarRating(ratingElement, {
    maxStars: 5,
    allowHalf: false,
    showValue: true,
    onChange: (value) => {
      // Update hidden form field
      form.querySelector('input[name="rating"]').value = value;
    }
  });
  
  form.addEventListener('submit', (e) => {
    e.preventDefault();
    
    const ratingValue = rating.getRating();
    
    if (ratingValue === 0) {
      alert('Please select a rating');
      return;
    }
    
    console.log('Submitting rating:', ratingValue);
    // Submit form
  });
}
```

### **Bonus: Animated Stars**
```javascript
/**
 * Star rating with animations
 */
class AnimatedStarRating extends AdvancedStarRating {
  handleClick(event, starIndex) {
    super.handleClick(event, starIndex);
    
    // Add animation effect
    const star = this.stars[starIndex - 1];
    star.classList.add('star-pulse');
    
    setTimeout(() => {
      star.classList.remove('star-pulse');
    }, 600);
  }
}

// Animation CSS
const animationCSS = `
@keyframes star-pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.3);
  }
}

.star-pulse {
  animation: star-pulse 0.6s ease;
}
`;
```

**Interview Tips:**
- Star rating: interactive UI for user ratings (1-5 stars typical)
- Basic approach: click star to set rating, hover to preview
- Half stars: detect click position or separate click handlers
- Features: readonly mode, allow clear, show value, custom colors
- CSS: use absolute positioning for filled stars overlaying empty stars
- Events: click (set rating), hover (preview), change callback
- Accessibility: keyboard navigation, ARIA labels, focus states
- Considerations: mobile touch targets (larger size), form integration
- Common variations: hearts/thumbs, custom icons, animated feedback
- Libraries: react-rating, vue-star-rating for production use

</details>

58. Build an autocomplete/typeahead component

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Autocomplete**
```javascript
/**
 * Simple autocomplete component
 * 
 * HTML:
 * <div class="autocomplete">
 *   <input type="text" id="search" placeholder="Search...">
 *   <ul class="suggestions"></ul>
 * </div>
 */
class Autocomplete {
  constructor(input, options = {}) {
    this.input = input;
    this.suggestions = options.suggestions || [];
    this.onSelect = options.onSelect || (() => {});
    this.minChars = options.minChars || 1;
    
    this.suggestionsList = this.createSuggestionsList();
    this.currentFocus = -1;
    
    this.init();
  }
  
  createSuggestionsList() {
    const ul = document.createElement('ul');
    ul.className = 'autocomplete-suggestions';
    ul.style.display = 'none';
    this.input.parentNode.appendChild(ul);
    return ul;
  }
  
  init() {
    // Input event listener
    this.input.addEventListener('input', (e) => {
      this.handleInput(e.target.value);
    });
    
    // Keyboard navigation
    this.input.addEventListener('keydown', (e) => {
      this.handleKeydown(e);
    });
    
    // Close on click outside
    document.addEventListener('click', (e) => {
      if (!this.input.contains(e.target) && !this.suggestionsList.contains(e.target)) {
        this.closeSuggestions();
      }
    });
  }
  
  handleInput(value) {
    this.currentFocus = -1;
    
    if (value.length < this.minChars) {
      this.closeSuggestions();
      return;
    }
    
    const filtered = this.filterSuggestions(value);
    this.renderSuggestions(filtered, value);
  }
  
  filterSuggestions(value) {
    const lowerValue = value.toLowerCase();
    return this.suggestions.filter(item => 
      item.toLowerCase().includes(lowerValue)
    );
  }
  
  renderSuggestions(items, query) {
    this.suggestionsList.innerHTML = '';
    
    if (items.length === 0) {
      this.closeSuggestions();
      return;
    }
    
    items.forEach(item => {
      const li = document.createElement('li');
      li.textContent = item;
      li.className = 'suggestion-item';
      
      li.addEventListener('click', () => {
        this.selectItem(item);
      });
      
      this.suggestionsList.appendChild(li);
    });
    
    this.suggestionsList.style.display = 'block';
  }
  
  handleKeydown(e) {
    const items = this.suggestionsList.querySelectorAll('.suggestion-item');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      this.currentFocus++;
      this.setActive(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      this.currentFocus--;
      this.setActive(items);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (this.currentFocus > -1 && items[this.currentFocus]) {
        this.selectItem(items[this.currentFocus].textContent);
      }
    } else if (e.key === 'Escape') {
      this.closeSuggestions();
    }
  }
  
  setActive(items) {
    if (!items.length) return;
    
    // Remove active class from all
    items.forEach(item => item.classList.remove('active'));
    
    // Wrap around
    if (this.currentFocus >= items.length) this.currentFocus = 0;
    if (this.currentFocus < 0) this.currentFocus = items.length - 1;
    
    // Add active class
    items[this.currentFocus].classList.add('active');
    items[this.currentFocus].scrollIntoView({ block: 'nearest' });
  }
  
  selectItem(item) {
    this.input.value = item;
    this.closeSuggestions();
    this.onSelect(item);
  }
  
  closeSuggestions() {
    this.suggestionsList.style.display = 'none';
    this.suggestionsList.innerHTML = '';
  }
  
  updateSuggestions(newSuggestions) {
    this.suggestions = newSuggestions;
  }
}

// CSS
const autocompleteCSS = `
.autocomplete {
  position: relative;
  width: 300px;
}

.autocomplete input {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

.autocomplete-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin: 0;
  padding: 0;
  list-style: none;
  background: white;
  border: 1px solid #ddd;
  border-top: none;
  max-height: 300px;
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.suggestion-item {
  padding: 10px;
  cursor: pointer;
  transition: background 0.2s;
}

.suggestion-item:hover,
.suggestion-item.active {
  background: #f0f0f0;
}
`;

// Usage
// const countries = ['USA', 'UK', 'Canada', 'Australia', 'Germany', 'France'];
// const autocomplete = new Autocomplete(document.querySelector('#search'), {
//   suggestions: countries,
//   minChars: 2,
//   onSelect: (item) => console.log('Selected:', item)
// });
```

### **Approach 2: With Debounce and Highlighting**
```javascript
/**
 * Autocomplete with debounce and match highlighting
 */
class AdvancedAutocomplete {
  constructor(input, options = {}) {
    this.input = input;
    this.suggestions = options.suggestions || [];
    this.onSelect = options.onSelect || (() => {});
    this.minChars = options.minChars || 1;
    this.debounceDelay = options.debounceDelay || 300;
    this.maxResults = options.maxResults || 10;
    this.highlightMatches = options.highlightMatches !== false;
    
    this.suggestionsList = this.createSuggestionsList();
    this.currentFocus = -1;
    this.debounceTimer = null;
    
    this.init();
  }
  
  createSuggestionsList() {
    const ul = document.createElement('ul');
    ul.className = 'autocomplete-suggestions';
    ul.style.display = 'none';
    this.input.parentNode.insertBefore(ul, this.input.nextSibling);
    return ul;
  }
  
  init() {
    this.input.addEventListener('input', (e) => {
      this.handleInputDebounced(e.target.value);
    });
    
    this.input.addEventListener('keydown', (e) => {
      this.handleKeydown(e);
    });
    
    document.addEventListener('click', (e) => {
      if (!this.input.parentNode.contains(e.target)) {
        this.closeSuggestions();
      }
    });
    
    this.input.addEventListener('focus', () => {
      if (this.input.value.length >= this.minChars) {
        this.handleInput(this.input.value);
      }
    });
  }
  
  handleInputDebounced(value) {
    clearTimeout(this.debounceTimer);
    
    this.debounceTimer = setTimeout(() => {
      this.handleInput(value);
    }, this.debounceDelay);
  }
  
  handleInput(value) {
    this.currentFocus = -1;
    
    if (value.length < this.minChars) {
      this.closeSuggestions();
      return;
    }
    
    const filtered = this.filterSuggestions(value);
    this.renderSuggestions(filtered, value);
  }
  
  filterSuggestions(value) {
    const lowerValue = value.toLowerCase();
    
    // Filter and rank by match position
    const matches = this.suggestions
      .map(item => {
        const lowerItem = item.toLowerCase();
        const startsWith = lowerItem.startsWith(lowerValue);
        const includes = lowerItem.includes(lowerValue);
        const index = lowerItem.indexOf(lowerValue);
        
        return {
          item,
          startsWith,
          includes,
          index: includes ? index : Infinity
        };
      })
      .filter(match => match.includes)
      .sort((a, b) => {
        // Prioritize starts-with matches
        if (a.startsWith && !b.startsWith) return -1;
        if (!a.startsWith && b.startsWith) return 1;
        // Then by position
        return a.index - b.index;
      })
      .slice(0, this.maxResults)
      .map(match => match.item);
    
    return matches;
  }
  
  highlightMatch(text, query) {
    if (!this.highlightMatches) return text;
    
    const index = text.toLowerCase().indexOf(query.toLowerCase());
    
    if (index === -1) return text;
    
    const before = text.substring(0, index);
    const match = text.substring(index, index + query.length);
    const after = text.substring(index + query.length);
    
    return `${before}<strong>${match}</strong>${after}`;
  }
  
  renderSuggestions(items, query) {
    this.suggestionsList.innerHTML = '';
    
    if (items.length === 0) {
      const li = document.createElement('li');
      li.className = 'no-results';
      li.textContent = 'No results found';
      this.suggestionsList.appendChild(li);
      this.suggestionsList.style.display = 'block';
      return;
    }
    
    items.forEach(item => {
      const li = document.createElement('li');
      li.className = 'suggestion-item';
      li.innerHTML = this.highlightMatch(item, query);
      li.dataset.value = item;
      
      li.addEventListener('click', () => {
        this.selectItem(item);
      });
      
      this.suggestionsList.appendChild(li);
    });
    
    this.suggestionsList.style.display = 'block';
  }
  
  handleKeydown(e) {
    const items = this.suggestionsList.querySelectorAll('.suggestion-item');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      this.currentFocus++;
      this.setActive(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      this.currentFocus--;
      this.setActive(items);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (this.currentFocus > -1 && items[this.currentFocus]) {
        this.selectItem(items[this.currentFocus].dataset.value);
      }
    } else if (e.key === 'Escape') {
      this.closeSuggestions();
    }
  }
  
  setActive(items) {
    if (!items.length) return;
    
    items.forEach(item => item.classList.remove('active'));
    
    if (this.currentFocus >= items.length) this.currentFocus = 0;
    if (this.currentFocus < 0) this.currentFocus = items.length - 1;
    
    items[this.currentFocus].classList.add('active');
    items[this.currentFocus].scrollIntoView({ block: 'nearest' });
  }
  
  selectItem(item) {
    this.input.value = item;
    this.closeSuggestions();
    this.onSelect(item);
  }
  
  closeSuggestions() {
    this.suggestionsList.style.display = 'none';
  }
  
  destroy() {
    clearTimeout(this.debounceTimer);
    this.suggestionsList.remove();
  }
}

// Enhanced CSS
const advancedAutocompleteCSS = `
.autocomplete {
  position: relative;
  width: 100%;
  max-width: 400px;
}

.autocomplete input {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.3s;
}

.autocomplete input:focus {
  outline: none;
  border-color: #4285f4;
}

.autocomplete-suggestions {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  margin: 0;
  padding: 0;
  list-style: none;
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  max-height: 300px;
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.suggestion-item {
  padding: 12px 16px;
  cursor: pointer;
  transition: background 0.2s;
  border-bottom: 1px solid #f0f0f0;
}

.suggestion-item:last-child {
  border-bottom: none;
}

.suggestion-item:hover,
.suggestion-item.active {
  background: #f5f5f5;
}

.suggestion-item strong {
  color: #4285f4;
  font-weight: 600;
}

.no-results {
  padding: 12px 16px;
  color: #999;
  text-align: center;
}
`;
```

### **Approach 3: Async with API Integration**
```javascript
/**
 * Autocomplete with async data fetching
 */
class AsyncAutocomplete {
  constructor(input, options = {}) {
    this.input = input;
    this.fetchSuggestions = options.fetchSuggestions;
    this.onSelect = options.onSelect || (() => {});
    this.minChars = options.minChars || 2;
    this.debounceDelay = options.debounceDelay || 300;
    this.maxResults = options.maxResults || 10;
    this.cache = options.cache !== false;
    this.showLoader = options.showLoader !== false;
    
    this.suggestionsList = this.createSuggestionsList();
    this.loader = this.createLoader();
    this.currentFocus = -1;
    this.debounceTimer = null;
    this.abortController = null;
    this.cacheStore = new Map();
    
    this.init();
  }
  
  createSuggestionsList() {
    const ul = document.createElement('ul');
    ul.className = 'autocomplete-suggestions';
    ul.style.display = 'none';
    this.input.parentNode.appendChild(ul);
    return ul;
  }
  
  createLoader() {
    const loader = document.createElement('div');
    loader.className = 'autocomplete-loader';
    loader.innerHTML = '<div class="spinner"></div>';
    loader.style.display = 'none';
    this.input.parentNode.appendChild(loader);
    return loader;
  }
  
  init() {
    this.input.addEventListener('input', (e) => {
      this.handleInputDebounced(e.target.value);
    });
    
    this.input.addEventListener('keydown', (e) => {
      this.handleKeydown(e);
    });
    
    document.addEventListener('click', (e) => {
      if (!this.input.parentNode.contains(e.target)) {
        this.closeSuggestions();
      }
    });
  }
  
  handleInputDebounced(value) {
    clearTimeout(this.debounceTimer);
    
    // Cancel previous request
    if (this.abortController) {
      this.abortController.abort();
    }
    
    this.debounceTimer = setTimeout(() => {
      this.handleInput(value);
    }, this.debounceDelay);
  }
  
  async handleInput(value) {
    this.currentFocus = -1;
    
    if (value.length < this.minChars) {
      this.closeSuggestions();
      return;
    }
    
    // Check cache
    if (this.cache && this.cacheStore.has(value)) {
      this.renderSuggestions(this.cacheStore.get(value), value);
      return;
    }
    
    // Show loader
    if (this.showLoader) {
      this.loader.style.display = 'block';
    }
    
    try {
      this.abortController = new AbortController();
      
      const results = await this.fetchSuggestions(value, {
        signal: this.abortController.signal,
        maxResults: this.maxResults
      });
      
      // Cache results
      if (this.cache) {
        this.cacheStore.set(value, results);
      }
      
      this.renderSuggestions(results, value);
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Error fetching suggestions:', error);
        this.renderError();
      }
    } finally {
      if (this.showLoader) {
        this.loader.style.display = 'none';
      }
    }
  }
  
  renderSuggestions(items, query) {
    this.suggestionsList.innerHTML = '';
    
    if (!items || items.length === 0) {
      const li = document.createElement('li');
      li.className = 'no-results';
      li.textContent = 'No results found';
      this.suggestionsList.appendChild(li);
      this.suggestionsList.style.display = 'block';
      return;
    }
    
    items.forEach(item => {
      const li = document.createElement('li');
      li.className = 'suggestion-item';
      
      // Handle different item formats
      if (typeof item === 'string') {
        li.textContent = item;
        li.dataset.value = item;
      } else {
        li.innerHTML = this.formatItem(item);
        li.dataset.value = item.value || item.name || item.label;
      }
      
      li.addEventListener('click', () => {
        this.selectItem(li.dataset.value, item);
      });
      
      this.suggestionsList.appendChild(li);
    });
    
    this.suggestionsList.style.display = 'block';
  }
  
  formatItem(item) {
    // Customize based on item structure
    if (item.title && item.subtitle) {
      return `
        <div class="suggestion-main">${item.title}</div>
        <div class="suggestion-sub">${item.subtitle}</div>
      `;
    }
    return item.name || item.label || item.value || String(item);
  }
  
  renderError() {
    this.suggestionsList.innerHTML = `
      <li class="error-message">Failed to load suggestions</li>
    `;
    this.suggestionsList.style.display = 'block';
  }
  
  handleKeydown(e) {
    const items = this.suggestionsList.querySelectorAll('.suggestion-item');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      this.currentFocus++;
      this.setActive(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      this.currentFocus--;
      this.setActive(items);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (this.currentFocus > -1 && items[this.currentFocus]) {
        items[this.currentFocus].click();
      }
    } else if (e.key === 'Escape') {
      this.closeSuggestions();
    }
  }
  
  setActive(items) {
    if (!items.length) return;
    
    items.forEach(item => item.classList.remove('active'));
    
    if (this.currentFocus >= items.length) this.currentFocus = 0;
    if (this.currentFocus < 0) this.currentFocus = items.length - 1;
    
    items[this.currentFocus].classList.add('active');
    items[this.currentFocus].scrollIntoView({ block: 'nearest' });
  }
  
  selectItem(value, originalItem) {
    this.input.value = value;
    this.closeSuggestions();
    this.onSelect(value, originalItem);
  }
  
  closeSuggestions() {
    this.suggestionsList.style.display = 'none';
    if (this.showLoader) {
      this.loader.style.display = 'none';
    }
  }
  
  clearCache() {
    this.cacheStore.clear();
  }
  
  destroy() {
    clearTimeout(this.debounceTimer);
    if (this.abortController) {
      this.abortController.abort();
    }
    this.suggestionsList.remove();
    this.loader.remove();
  }
}

// Complete CSS with loader
const asyncAutocompleteCSS = `
.autocomplete {
  position: relative;
  width: 100%;
  max-width: 500px;
}

.autocomplete input {
  width: 100%;
  padding: 12px 40px 12px 16px;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.3s;
}

.autocomplete input:focus {
  outline: none;
  border-color: #4285f4;
}

.autocomplete-loader {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid #4285f4;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.autocomplete-suggestions {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  margin: 0;
  padding: 0;
  list-style: none;
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  max-height: 400px;
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.suggestion-item {
  padding: 12px 16px;
  cursor: pointer;
  transition: background 0.2s;
  border-bottom: 1px solid #f5f5f5;
}

.suggestion-item:last-child {
  border-bottom: none;
}

.suggestion-item:hover,
.suggestion-item.active {
  background: #f5f5f5;
}

.suggestion-main {
  font-weight: 500;
  color: #333;
}

.suggestion-sub {
  font-size: 12px;
  color: #666;
  margin-top: 4px;
}

.no-results,
.error-message {
  padding: 12px 16px;
  color: #999;
  text-align: center;
}

.error-message {
  color: #d32f2f;
}
`;

// Usage examples
console.log('=== Basic Autocomplete ===');
// const countries = ['USA', 'UK', 'Canada', 'Australia', 'Germany', 'France'];
// const autocomplete1 = new Autocomplete(document.querySelector('#search'), {
//   suggestions: countries,
//   onSelect: (item) => console.log('Selected:', item)
// });

console.log('\n=== Advanced with Highlighting ===');
// const autocomplete2 = new AdvancedAutocomplete(document.querySelector('#search2'), {
//   suggestions: countries,
//   minChars: 2,
//   debounceDelay: 300,
//   highlightMatches: true,
//   onSelect: (item) => console.log('Selected:', item)
// });

console.log('\n=== Async with API ===');
// const autocomplete3 = new AsyncAutocomplete(document.querySelector('#search3'), {
//   minChars: 2,
//   debounceDelay: 300,
//   cache: true,
//   fetchSuggestions: async (query, options) => {
//     const response = await fetch(
//       `https://api.example.com/search?q=${encodeURIComponent(query)}`,
//       { signal: options.signal }
//     );
//     const data = await response.json();
//     return data.results.slice(0, options.maxResults);
//   },
//   onSelect: (value, item) => {
//     console.log('Selected:', value, item);
//   }
// });

// Real-world example: GitHub repository search
async function githubRepoSearch(query, options) {
  const response = await fetch(
    `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&per_page=${options.maxResults}`,
    { signal: options.signal }
  );
  
  const data = await response.json();
  
  return data.items.map(repo => ({
    title: repo.full_name,
    subtitle: repo.description || 'No description',
    value: repo.full_name,
    url: repo.html_url
  }));
}

// const githubAutocomplete = new AsyncAutocomplete(document.querySelector('#github-search'), {
//   fetchSuggestions: githubRepoSearch,
//   onSelect: (value, item) => {
//     window.location.href = item.url;
//   }
// });
```

### **Bonus: Multi-Select Autocomplete**
```javascript
/**
 * Multi-select autocomplete (tags input)
 */
class MultiSelectAutocomplete extends AsyncAutocomplete {
  constructor(input, options = {}) {
    super(input, options);
    this.selectedItems = [];
    this.createTagContainer();
  }
  
  createTagContainer() {
    this.tagContainer = document.createElement('div');
    this.tagContainer.className = 'tag-container';
    this.input.parentNode.insertBefore(this.tagContainer, this.input);
  }
  
  selectItem(value, originalItem) {
    if (!this.selectedItems.find(item => item.value === value)) {
      this.selectedItems.push({ value, originalItem });
      this.addTag(value);
    }
    
    this.input.value = '';
    this.closeSuggestions();
    this.onSelect(this.selectedItems);
  }
  
  addTag(value) {
    const tag = document.createElement('span');
    tag.className = 'tag';
    tag.innerHTML = `
      ${value}
      <button class="tag-remove" aria-label="Remove ${value}">×</button>
    `;
    
    tag.querySelector('.tag-remove').addEventListener('click', () => {
      this.removeTag(value);
    });
    
    this.tagContainer.appendChild(tag);
  }
  
  removeTag(value) {
    this.selectedItems = this.selectedItems.filter(item => item.value !== value);
    
    const tags = this.tagContainer.querySelectorAll('.tag');
    tags.forEach(tag => {
      if (tag.textContent.trim().startsWith(value)) {
        tag.remove();
      }
    });
    
    this.onSelect(this.selectedItems);
  }
  
  getSelectedValues() {
    return this.selectedItems.map(item => item.value);
  }
  
  clear() {
    this.selectedItems = [];
    this.tagContainer.innerHTML = '';
  }
}

const multiSelectCSS = `
.tag-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.tag {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: #e3f2fd;
  border-radius: 16px;
  font-size: 14px;
  color: #1976d2;
}

.tag-remove {
  background: none;
  border: none;
  font-size: 20px;
  line-height: 1;
  cursor: pointer;
  color: #1976d2;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: background 0.2s;
}

.tag-remove:hover {
  background: rgba(25, 118, 210, 0.1);
}
`;
```

**Interview Tips:**
- Autocomplete/typeahead suggests completions as user types
- Key features: debounce input (300ms typical), min characters (2-3)
- Keyboard navigation: arrow keys, Enter to select, Escape to close
- Highlight matching text for better UX
- Async: debounce, abort previous requests, cache results
- Performance: limit max results (10-20), virtual scrolling for large lists
- Ranking: prioritize starts-with matches, then includes
- Accessibility: ARIA attributes, keyboard support, screen reader announcements
- Edge cases: no results, loading state, error handling, click outside
- Common libraries: react-autosuggest, downshift, @reach/combobox
- Real-world: Google search, GitHub search, address autocomplete

</details>

59. Implement a modal/dialog component

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Modal**
```javascript
/**
 * Simple modal/dialog component
 * 
 * HTML:
 * <div id="myModal" class="modal">
 *   <div class="modal-content">
 *     <span class="close">&times;</span>
 *     <h2>Modal Title</h2>
 *     <p>Modal content goes here</p>
 *   </div>
 * </div>
 */
class Modal {
  constructor(element, options = {}) {
    this.modal = element;
    this.closeButton = element.querySelector('.close');
    this.onOpen = options.onOpen || (() => {});
    this.onClose = options.onClose || (() => {});
    this.closeOnOverlay = options.closeOnOverlay !== false;
    this.closeOnEsc = options.closeOnEsc !== false;
    
    this.init();
  }
  
  init() {
    // Close button
    if (this.closeButton) {
      this.closeButton.addEventListener('click', () => this.close());
    }
    
    // Click overlay to close
    if (this.closeOnOverlay) {
      this.modal.addEventListener('click', (e) => {
        if (e.target === this.modal) {
          this.close();
        }
      });
    }
    
    // ESC key to close
    if (this.closeOnEsc) {
      this.handleEsc = (e) => {
        if (e.key === 'Escape' && this.isOpen()) {
          this.close();
        }
      };
      document.addEventListener('keydown', this.handleEsc);
    }
  }
  
  open() {
    this.modal.style.display = 'block';
    document.body.style.overflow = 'hidden'; // Prevent background scroll
    this.onOpen();
  }
  
  close() {
    this.modal.style.display = 'none';
    document.body.style.overflow = ''; // Restore scroll
    this.onClose();
  }
  
  isOpen() {
    return this.modal.style.display === 'block';
  }
  
  toggle() {
    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  }
  
  destroy() {
    if (this.handleEsc) {
      document.removeEventListener('keydown', this.handleEsc);
    }
  }
}

// CSS
const modalCSS = `
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  overflow: auto;
}

.modal-content {
  background-color: white;
  margin: 10% auto;
  padding: 20px;
  border-radius: 8px;
  width: 80%;
  max-width: 600px;
  position: relative;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.close {
  position: absolute;
  right: 20px;
  top: 20px;
  font-size: 28px;
  font-weight: bold;
  color: #aaa;
  cursor: pointer;
  line-height: 1;
}

.close:hover,
.close:focus {
  color: #000;
}
`;

// Usage
// const modal = new Modal(document.querySelector('#myModal'), {
//   onOpen: () => console.log('Modal opened'),
//   onClose: () => console.log('Modal closed')
// });
// 
// document.querySelector('#openModalBtn').addEventListener('click', () => {
//   modal.open();
// });
```

### **Approach 2: With Animations and Focus Trap**
```javascript
/**
 * Modal with animations and accessibility features
 */
class AnimatedModal {
  constructor(element, options = {}) {
    this.modal = element;
    this.modalContent = element.querySelector('.modal-content');
    this.closeButton = element.querySelector('.close');
    this.onOpen = options.onOpen || (() => {});
    this.onClose = options.onClose || (() => {});
    this.closeOnOverlay = options.closeOnOverlay !== false;
    this.closeOnEsc = options.closeOnEsc !== false;
    this.animation = options.animation || 'fade'; // fade, slide, zoom
    
    this.isAnimating = false;
    this.previousActiveElement = null;
    this.focusableElements = [];
    
    this.init();
  }
  
  init() {
    // Add animation class
    this.modal.classList.add(`modal-${this.animation}`);
    
    // Close button
    if (this.closeButton) {
      this.closeButton.addEventListener('click', () => this.close());
    }
    
    // Click overlay to close
    if (this.closeOnOverlay) {
      this.modal.addEventListener('click', (e) => {
        if (e.target === this.modal && !this.isAnimating) {
          this.close();
        }
      });
    }
    
    // ESC key to close
    if (this.closeOnEsc) {
      this.handleEsc = (e) => {
        if (e.key === 'Escape' && this.isOpen()) {
          this.close();
        }
      };
      document.addEventListener('keydown', this.handleEsc);
    }
    
    // Focus trap
    this.handleTab = (e) => {
      if (e.key === 'Tab' && this.isOpen()) {
        this.trapFocus(e);
      }
    };
    document.addEventListener('keydown', this.handleTab);
  }
  
  async open() {
    if (this.isAnimating || this.isOpen()) return;
    
    this.isAnimating = true;
    this.previousActiveElement = document.activeElement;
    
    // Show modal
    this.modal.style.display = 'block';
    this.modal.classList.add('modal-opening');
    
    // Prevent background scroll
    document.body.style.overflow = 'hidden';
    
    // Trigger animation
    requestAnimationFrame(() => {
      this.modal.classList.add('modal-open');
    });
    
    // Wait for animation
    await this.waitForAnimation();
    
    this.modal.classList.remove('modal-opening');
    this.isAnimating = false;
    
    // Set up focus trap
    this.setupFocusTrap();
    
    // Focus first focusable element
    if (this.focusableElements.length > 0) {
      this.focusableElements[0].focus();
    }
    
    this.onOpen();
  }
  
  async close() {
    if (this.isAnimating || !this.isOpen()) return;
    
    this.isAnimating = true;
    this.modal.classList.add('modal-closing');
    this.modal.classList.remove('modal-open');
    
    // Wait for animation
    await this.waitForAnimation();
    
    this.modal.style.display = 'none';
    this.modal.classList.remove('modal-closing');
    this.isAnimating = false;
    
    // Restore scroll
    document.body.style.overflow = '';
    
    // Restore focus
    if (this.previousActiveElement) {
      this.previousActiveElement.focus();
    }
    
    this.onClose();
  }
  
  isOpen() {
    return this.modal.style.display === 'block';
  }
  
  waitForAnimation() {
    return new Promise(resolve => {
      const duration = parseFloat(getComputedStyle(this.modal).transitionDuration) * 1000;
      setTimeout(resolve, duration || 300);
    });
  }
  
  setupFocusTrap() {
    // Get all focusable elements
    const focusableSelectors = [
      'a[href]',
      'button:not([disabled])',
      'textarea:not([disabled])',
      'input:not([disabled])',
      'select:not([disabled])',
      '[tabindex]:not([tabindex="-1"])'
    ].join(', ');
    
    this.focusableElements = Array.from(
      this.modalContent.querySelectorAll(focusableSelectors)
    );
  }
  
  trapFocus(e) {
    if (this.focusableElements.length === 0) return;
    
    const firstElement = this.focusableElements[0];
    const lastElement = this.focusableElements[this.focusableElements.length - 1];
    
    if (e.shiftKey) {
      // Shift + Tab
      if (document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      }
    } else {
      // Tab
      if (document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  }
  
  destroy() {
    if (this.handleEsc) {
      document.removeEventListener('keydown', this.handleEsc);
    }
    if (this.handleTab) {
      document.removeEventListener('keydown', this.handleTab);
    }
  }
}

// CSS with animations
const animatedModalCSS = `
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0);
  overflow: auto;
  transition: background-color 0.3s ease;
}

.modal-open {
  background-color: rgba(0, 0, 0, 0.5);
}

.modal-content {
  background-color: white;
  margin: 10% auto;
  padding: 30px;
  border-radius: 12px;
  width: 90%;
  max-width: 600px;
  position: relative;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
}

/* Fade animation */
.modal-fade .modal-content {
  opacity: 0;
  transition: opacity 0.3s ease;
}

.modal-fade.modal-open .modal-content {
  opacity: 1;
}

/* Slide animation */
.modal-slide .modal-content {
  transform: translateY(-50px);
  opacity: 0;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.modal-slide.modal-open .modal-content {
  transform: translateY(0);
  opacity: 1;
}

/* Zoom animation */
.modal-zoom .modal-content {
  transform: scale(0.7);
  opacity: 0;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.modal-zoom.modal-open .modal-content {
  transform: scale(1);
  opacity: 1;
}

.close {
  position: absolute;
  right: 20px;
  top: 20px;
  font-size: 28px;
  font-weight: bold;
  color: #aaa;
  cursor: pointer;
  line-height: 1;
  transition: color 0.2s;
}

.close:hover,
.close:focus {
  color: #000;
}
`;
```

### **Approach 3: Production-Ready with Multiple Features**
```javascript
/**
 * Full-featured modal component
 */
class AdvancedModal {
  constructor(options = {}) {
    this.title = options.title || '';
    this.content = options.content || '';
    this.size = options.size || 'medium'; // small, medium, large, full
    this.showCloseButton = options.showCloseButton !== false;
    this.closeOnOverlay = options.closeOnOverlay !== false;
    this.closeOnEsc = options.closeOnEsc !== false;
    this.animation = options.animation || 'fade';
    this.footer = options.footer || null;
    this.className = options.className || '';
    this.onOpen = options.onOpen || (() => {});
    this.onClose = options.onClose || (() => {});
    this.beforeClose = options.beforeClose || null;
    
    this.modal = null;
    this.isAnimating = false;
    this.previousActiveElement = null;
    
    this.create();
  }
  
  create() {
    // Create modal structure
    this.modal = document.createElement('div');
    this.modal.className = `modal modal-${this.animation} modal-${this.size} ${this.className}`;
    this.modal.setAttribute('role', 'dialog');
    this.modal.setAttribute('aria-modal', 'true');
    
    if (this.title) {
      this.modal.setAttribute('aria-labelledby', 'modal-title');
    }
    
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    
    // Header
    if (this.title || this.showCloseButton) {
      const header = document.createElement('div');
      header.className = 'modal-header';
      
      if (this.title) {
        const titleElement = document.createElement('h2');
        titleElement.id = 'modal-title';
        titleElement.className = 'modal-title';
        titleElement.textContent = this.title;
        header.appendChild(titleElement);
      }
      
      if (this.showCloseButton) {
        const closeBtn = document.createElement('button');
        closeBtn.className = 'modal-close';
        closeBtn.innerHTML = '&times;';
        closeBtn.setAttribute('aria-label', 'Close modal');
        closeBtn.addEventListener('click', () => this.close());
        header.appendChild(closeBtn);
      }
      
      modalContent.appendChild(header);
    }
    
    // Body
    const body = document.createElement('div');
    body.className = 'modal-body';
    
    if (typeof this.content === 'string') {
      body.innerHTML = this.content;
    } else if (this.content instanceof HTMLElement) {
      body.appendChild(this.content);
    }
    
    modalContent.appendChild(body);
    
    // Footer
    if (this.footer) {
      const footer = document.createElement('div');
      footer.className = 'modal-footer';
      
      if (typeof this.footer === 'string') {
        footer.innerHTML = this.footer;
      } else if (this.footer instanceof HTMLElement) {
        footer.appendChild(this.footer);
      } else if (Array.isArray(this.footer)) {
        this.footer.forEach(button => footer.appendChild(button));
      }
      
      modalContent.appendChild(footer);
    }
    
    this.modal.appendChild(modalContent);
    document.body.appendChild(this.modal);
    
    this.init();
  }
  
  init() {
    // Click overlay to close
    if (this.closeOnOverlay) {
      this.modal.addEventListener('click', (e) => {
        if (e.target === this.modal && !this.isAnimating) {
          this.close();
        }
      });
    }
    
    // ESC key to close
    if (this.closeOnEsc) {
      this.handleEsc = (e) => {
        if (e.key === 'Escape' && this.isOpen()) {
          this.close();
        }
      };
      document.addEventListener('keydown', this.handleEsc);
    }
    
    // Focus trap
    this.handleTab = (e) => {
      if (e.key === 'Tab' && this.isOpen()) {
        this.trapFocus(e);
      }
    };
    document.addEventListener('keydown', this.handleTab);
  }
  
  async open() {
    if (this.isAnimating || this.isOpen()) return;
    
    this.isAnimating = true;
    this.previousActiveElement = document.activeElement;
    
    this.modal.style.display = 'block';
    this.modal.classList.add('modal-opening');
    document.body.style.overflow = 'hidden';
    
    requestAnimationFrame(() => {
      this.modal.classList.add('modal-open');
    });
    
    await this.waitForAnimation();
    
    this.modal.classList.remove('modal-opening');
    this.isAnimating = false;
    
    this.setupFocusTrap();
    this.focusFirstElement();
    
    this.onOpen();
  }
  
  async close() {
    if (this.isAnimating || !this.isOpen()) return;
    
    // Call beforeClose hook
    if (this.beforeClose) {
      const canClose = await this.beforeClose();
      if (canClose === false) return;
    }
    
    this.isAnimating = true;
    this.modal.classList.add('modal-closing');
    this.modal.classList.remove('modal-open');
    
    await this.waitForAnimation();
    
    this.modal.style.display = 'none';
    this.modal.classList.remove('modal-closing');
    this.isAnimating = false;
    
    document.body.style.overflow = '';
    
    if (this.previousActiveElement) {
      this.previousActiveElement.focus();
    }
    
    this.onClose();
  }
  
  isOpen() {
    return this.modal.style.display === 'block';
  }
  
  waitForAnimation() {
    return new Promise(resolve => {
      const duration = parseFloat(getComputedStyle(this.modal).transitionDuration) * 1000;
      setTimeout(resolve, duration || 300);
    });
  }
  
  setupFocusTrap() {
    const focusableSelectors = [
      'a[href]',
      'button:not([disabled])',
      'textarea:not([disabled])',
      'input:not([disabled])',
      'select:not([disabled])',
      '[tabindex]:not([tabindex="-1"])'
    ].join(', ');
    
    this.focusableElements = Array.from(
      this.modal.querySelectorAll(focusableSelectors)
    );
  }
  
  focusFirstElement() {
    if (this.focusableElements && this.focusableElements.length > 0) {
      this.focusableElements[0].focus();
    }
  }
  
  trapFocus(e) {
    if (!this.focusableElements || this.focusableElements.length === 0) return;
    
    const firstElement = this.focusableElements[0];
    const lastElement = this.focusableElements[this.focusableElements.length - 1];
    
    if (e.shiftKey) {
      if (document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      }
    } else {
      if (document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  }
  
  setContent(content) {
    const body = this.modal.querySelector('.modal-body');
    if (body) {
      if (typeof content === 'string') {
        body.innerHTML = content;
      } else if (content instanceof HTMLElement) {
        body.innerHTML = '';
        body.appendChild(content);
      }
    }
  }
  
  setTitle(title) {
    const titleElement = this.modal.querySelector('.modal-title');
    if (titleElement) {
      titleElement.textContent = title;
    }
  }
  
  destroy() {
    if (this.handleEsc) {
      document.removeEventListener('keydown', this.handleEsc);
    }
    if (this.handleTab) {
      document.removeEventListener('keydown', this.handleTab);
    }
    if (this.modal && this.modal.parentNode) {
      this.modal.parentNode.removeChild(this.modal);
    }
  }
}

// Complete CSS
const advancedModalCSS = `
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0);
  overflow: auto;
  transition: background-color 0.3s ease;
}

.modal-open {
  background-color: rgba(0, 0, 0, 0.5);
}

.modal-content {
  background-color: white;
  margin: 5% auto;
  border-radius: 12px;
  position: relative;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
  max-height: 90vh;
  display: flex;
  flex-direction: column;
}

/* Sizes */
.modal-small .modal-content {
  width: 90%;
  max-width: 400px;
}

.modal-medium .modal-content {
  width: 90%;
  max-width: 600px;
}

.modal-large .modal-content {
  width: 90%;
  max-width: 900px;
}

.modal-full .modal-content {
  width: 95%;
  max-width: none;
  height: 95%;
  margin: 2.5%;
}

/* Header */
.modal-header {
  padding: 20px 24px;
  border-bottom: 1px solid #e0e0e0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-title {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  color: #333;
}

.modal-close {
  background: none;
  border: none;
  font-size: 32px;
  color: #aaa;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.2s;
}

.modal-close:hover {
  background: #f5f5f5;
  color: #333;
}

/* Body */
.modal-body {
  padding: 24px;
  overflow-y: auto;
  flex: 1;
}

/* Footer */
.modal-footer {
  padding: 16px 24px;
  border-top: 1px solid #e0e0e0;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.modal-footer button {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
}

.modal-footer .btn-primary {
  background: #4285f4;
  color: white;
}

.modal-footer .btn-primary:hover {
  background: #3367d6;
}

.modal-footer .btn-secondary {
  background: #f5f5f5;
  color: #333;
}

.modal-footer .btn-secondary:hover {
  background: #e0e0e0;
}

/* Animations */
.modal-fade .modal-content {
  opacity: 0;
  transition: opacity 0.3s ease;
}

.modal-fade.modal-open .modal-content {
  opacity: 1;
}

.modal-slide .modal-content {
  transform: translateY(-50px);
  opacity: 0;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.modal-slide.modal-open .modal-content {
  transform: translateY(0);
  opacity: 1;
}

.modal-zoom .modal-content {
  transform: scale(0.7);
  opacity: 0;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.modal-zoom.modal-open .modal-content {
  transform: scale(1);
  opacity: 1;
}

/* Responsive */
@media (max-width: 768px) {
  .modal-content {
    margin: 0;
    width: 100% !important;
    max-width: none !important;
    height: 100%;
    max-height: none;
    border-radius: 0;
  }
}
`;

// Usage examples
console.log('=== Basic Modal ===');
// const modal1 = new Modal(document.querySelector('#myModal'));
// document.querySelector('#openBtn').addEventListener('click', () => modal1.open());

console.log('\n=== Animated Modal ===');
// const modal2 = new AnimatedModal(document.querySelector('#animatedModal'), {
//   animation: 'slide',
//   onOpen: () => console.log('Opened'),
//   onClose: () => console.log('Closed')
// });

console.log('\n=== Advanced Modal ===');
// const modal3 = new AdvancedModal({
//   title: 'Confirm Action',
//   content: '<p>Are you sure you want to proceed?</p>',
//   size: 'medium',
//   animation: 'zoom',
//   footer: [
//     createButton('Cancel', () => modal3.close()),
//     createButton('Confirm', () => {
//       console.log('Confirmed');
//       modal3.close();
//     }, 'primary')
//   ],
//   beforeClose: async () => {
//     return confirm('Close modal?');
//   }
// });
// 
// modal3.open();

// Helper function to create buttons
function createButton(text, onClick, variant = 'secondary') {
  const button = document.createElement('button');
  button.textContent = text;
  button.className = `btn-${variant}`;
  button.addEventListener('click', onClick);
  return button;
}

// Common modal patterns
class ModalService {
  static confirm(options) {
    return new Promise((resolve) => {
      const modal = new AdvancedModal({
        title: options.title || 'Confirm',
        content: options.message || 'Are you sure?',
        size: 'small',
        footer: [
          createButton(options.cancelText || 'Cancel', () => {
            modal.close();
            resolve(false);
          }),
          createButton(options.confirmText || 'Confirm', () => {
            modal.close();
            resolve(true);
          }, 'primary')
        ]
      });
      modal.open();
    });
  }
  
  static alert(options) {
    return new Promise((resolve) => {
      const modal = new AdvancedModal({
        title: options.title || 'Alert',
        content: options.message || '',
        size: 'small',
        footer: [
          createButton(options.buttonText || 'OK', () => {
            modal.close();
            resolve();
          }, 'primary')
        ]
      });
      modal.open();
    });
  }
  
  static prompt(options) {
    return new Promise((resolve) => {
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'modal-input';
      input.value = options.defaultValue || '';
      input.placeholder = options.placeholder || '';
      
      const container = document.createElement('div');
      if (options.message) {
        const p = document.createElement('p');
        p.textContent = options.message;
        container.appendChild(p);
      }
      container.appendChild(input);
      
      const modal = new AdvancedModal({
        title: options.title || 'Input',
        content: container,
        size: 'small',
        footer: [
          createButton('Cancel', () => {
            modal.close();
            resolve(null);
          }),
          createButton('OK', () => {
            modal.close();
            resolve(input.value);
          }, 'primary')
        ]
      });
      
      modal.onOpen = () => input.focus();
      modal.open();
    });
  }
}

// Usage of modal service
// const confirmed = await ModalService.confirm({
//   title: 'Delete Item',
//   message: 'Are you sure you want to delete this item?',
//   confirmText: 'Delete',
//   cancelText: 'Cancel'
// });
// 
// if (confirmed) {
//   console.log('Item deleted');
// }

// await ModalService.alert({
//   title: 'Success',
//   message: 'Operation completed successfully!'
// });

// const name = await ModalService.prompt({
//   title: 'Enter Name',
//   message: 'Please enter your name:',
//   placeholder: 'John Doe',
//   defaultValue: ''
// });
```

### **Bonus: Stacked Modals**
```javascript
/**
 * Modal manager for handling multiple stacked modals
 */
class ModalManager {
  constructor() {
    this.modals = [];
    this.zIndexBase = 1000;
  }
  
  open(modal) {
    const zIndex = this.zIndexBase + (this.modals.length * 10);
    modal.modal.style.zIndex = zIndex;
    this.modals.push(modal);
    modal.open();
  }
  
  close(modal) {
    const index = this.modals.indexOf(modal);
    if (index > -1) {
      this.modals.splice(index, 1);
      modal.close();
    }
  }
  
  closeAll() {
    [...this.modals].reverse().forEach(modal => modal.close());
    this.modals = [];
  }
  
  getTopModal() {
    return this.modals[this.modals.length - 1];
  }
}

// Usage
// const manager = new ModalManager();
// 
// const modal1 = new AdvancedModal({ title: 'Modal 1', content: 'First modal' });
// const modal2 = new AdvancedModal({ title: 'Modal 2', content: 'Second modal' });
// 
// manager.open(modal1);
// manager.open(modal2); // Opens on top of modal1
```

**Interview Tips:**
- Modal/dialog: overlay window on top of main content
- Key features: close on overlay click, ESC key, close button
- Accessibility: focus trap, restore focus on close, ARIA attributes
- Prevent background scroll: set body overflow to hidden when open
- Animations: fade, slide, zoom using CSS transitions
- Focus management: trap Tab key, focus first element on open
- Common patterns: confirm, alert, prompt dialogs
- beforeClose hook: allow async validation before closing
- Multiple modals: z-index management, stacking context
- Responsive: full-screen on mobile devices
- Libraries: react-modal, dialog element (native), Material-UI Dialog
- HTML5: `<dialog>` element with showModal() API

</details>

60. Create a tabs component

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Tabs**
```javascript
/**
 * Simple tabs component
 * 
 * HTML:
 * <div class="tabs">
 *   <div class="tab-list">
 *     <button class="tab-button active" data-tab="tab1">Tab 1</button>
 *     <button class="tab-button" data-tab="tab2">Tab 2</button>
 *     <button class="tab-button" data-tab="tab3">Tab 3</button>
 *   </div>
 *   <div class="tab-panels">
 *     <div class="tab-panel active" id="tab1">Content 1</div>
 *     <div class="tab-panel" id="tab2">Content 2</div>
 *     <div class="tab-panel" id="tab3">Content 3</div>
 *   </div>
 * </div>
 */
class Tabs {
  constructor(element, options = {}) {
    this.container = element;
    this.tabs = Array.from(element.querySelectorAll('.tab-button'));
    this.panels = Array.from(element.querySelectorAll('.tab-panel'));
    this.activeIndex = 0;
    this.onChange = options.onChange || (() => {});
    
    this.init();
  }
  
  init() {
    // Set up click handlers
    this.tabs.forEach((tab, index) => {
      tab.addEventListener('click', () => {
        this.switchTab(index);
      });
    });
    
    // Find initially active tab
    const activeTab = this.tabs.findIndex(tab => tab.classList.contains('active'));
    if (activeTab !== -1) {
      this.activeIndex = activeTab;
    }
  }
  
  switchTab(index) {
    if (index === this.activeIndex || index < 0 || index >= this.tabs.length) {
      return;
    }
    
    // Remove active class from current tab and panel
    this.tabs[this.activeIndex].classList.remove('active');
    this.panels[this.activeIndex].classList.remove('active');
    
    // Add active class to new tab and panel
    this.activeIndex = index;
    this.tabs[this.activeIndex].classList.add('active');
    this.panels[this.activeIndex].classList.add('active');
    
    // Call onChange callback
    this.onChange(index, this.tabs[index].dataset.tab);
  }
  
  getActiveIndex() {
    return this.activeIndex;
  }
  
  getActiveTab() {
    return this.tabs[this.activeIndex];
  }
}

// CSS
const tabsCSS = `
.tabs {
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
}

.tab-list {
  display: flex;
  border-bottom: 2px solid #e0e0e0;
  gap: 8px;
}

.tab-button {
  padding: 12px 24px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  cursor: pointer;
  font-size: 16px;
  color: #666;
  transition: all 0.3s;
  position: relative;
  bottom: -2px;
}

.tab-button:hover {
  color: #333;
  background: #f5f5f5;
}

.tab-button.active {
  color: #4285f4;
  border-bottom-color: #4285f4;
  font-weight: 600;
}

.tab-panels {
  padding: 24px;
  background: white;
}

.tab-panel {
  display: none;
}

.tab-panel.active {
  display: block;
}
`;

// Usage
// const tabs = new Tabs(document.querySelector('.tabs'), {
//   onChange: (index, tabId) => {
//     console.log('Switched to tab:', index, tabId);
//   }
// });
```

### **Approach 2: With Keyboard Navigation and ARIA**
```javascript
/**
 * Accessible tabs with keyboard navigation
 */
class AccessibleTabs {
  constructor(element, options = {}) {
    this.container = element;
    this.tabList = element.querySelector('.tab-list');
    this.tabs = Array.from(element.querySelectorAll('.tab-button'));
    this.panels = Array.from(element.querySelectorAll('.tab-panel'));
    this.activeIndex = 0;
    this.onChange = options.onChange || (() => {});
    
    this.init();
  }
  
  init() {
    // Set ARIA attributes
    this.tabList.setAttribute('role', 'tablist');
    
    this.tabs.forEach((tab, index) => {
      // ARIA attributes for tabs
      tab.setAttribute('role', 'tab');
      tab.setAttribute('id', `tab-${index}`);
      tab.setAttribute('aria-controls', `panel-${index}`);
      tab.setAttribute('tabindex', index === this.activeIndex ? '0' : '-1');
      tab.setAttribute('aria-selected', index === this.activeIndex ? 'true' : 'false');
      
      // Click handler
      tab.addEventListener('click', () => {
        this.switchTab(index);
      });
      
      // Keyboard navigation
      tab.addEventListener('keydown', (e) => {
        this.handleKeyboard(e, index);
      });
    });
    
    this.panels.forEach((panel, index) => {
      // ARIA attributes for panels
      panel.setAttribute('role', 'tabpanel');
      panel.setAttribute('id', `panel-${index}`);
      panel.setAttribute('aria-labelledby', `tab-${index}`);
      panel.setAttribute('tabindex', '0');
    });
  }
  
  handleKeyboard(event, currentIndex) {
    let newIndex = currentIndex;
    
    switch (event.key) {
      case 'ArrowLeft':
        event.preventDefault();
        newIndex = currentIndex > 0 ? currentIndex - 1 : this.tabs.length - 1;
        break;
      
      case 'ArrowRight':
        event.preventDefault();
        newIndex = currentIndex < this.tabs.length - 1 ? currentIndex + 1 : 0;
        break;
      
      case 'Home':
        event.preventDefault();
        newIndex = 0;
        break;
      
      case 'End':
        event.preventDefault();
        newIndex = this.tabs.length - 1;
        break;
      
      default:
        return;
    }
    
    this.switchTab(newIndex);
    this.tabs[newIndex].focus();
  }
  
  switchTab(index) {
    if (index < 0 || index >= this.tabs.length) return;
    
    // Update previous tab
    this.tabs[this.activeIndex].classList.remove('active');
    this.tabs[this.activeIndex].setAttribute('tabindex', '-1');
    this.tabs[this.activeIndex].setAttribute('aria-selected', 'false');
    this.panels[this.activeIndex].classList.remove('active');
    
    // Update new tab
    this.activeIndex = index;
    this.tabs[this.activeIndex].classList.add('active');
    this.tabs[this.activeIndex].setAttribute('tabindex', '0');
    this.tabs[this.activeIndex].setAttribute('aria-selected', 'true');
    this.panels[this.activeIndex].classList.add('active');
    
    this.onChange(index, this.tabs[index].dataset.tab);
  }
}

// Enhanced CSS with focus styles
const accessibleTabsCSS = `
.tabs {
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
}

.tab-list {
  display: flex;
  border-bottom: 2px solid #e0e0e0;
  gap: 4px;
}

.tab-button {
  padding: 12px 24px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  cursor: pointer;
  font-size: 16px;
  color: #666;
  transition: all 0.2s;
  position: relative;
  bottom: -2px;
}

.tab-button:hover {
  color: #333;
  background: #f5f5f5;
}

.tab-button:focus {
  outline: 2px solid #4285f4;
  outline-offset: -2px;
  z-index: 1;
}

.tab-button.active {
  color: #4285f4;
  border-bottom-color: #4285f4;
  font-weight: 600;
  background: white;
}

.tab-panels {
  padding: 24px;
  background: white;
  border: 1px solid #e0e0e0;
  border-top: none;
}

.tab-panel {
  display: none;
}

.tab-panel.active {
  display: block;
  animation: fadeIn 0.3s ease;
}

.tab-panel:focus {
  outline: 2px solid #4285f4;
  outline-offset: 4px;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
`;
```

### **Approach 3: Dynamic Tabs with Features**
```javascript
/**
 * Full-featured tabs component
 */
class AdvancedTabs {
  constructor(element, options = {}) {
    this.container = element;
    this.activeIndex = options.defaultTab || 0;
    this.orientation = options.orientation || 'horizontal'; // horizontal, vertical
    this.variant = options.variant || 'underline'; // underline, enclosed, pills
    this.onChange = options.onChange || (() => {});
    this.onBeforeChange = options.onBeforeChange || null;
    this.lazy = options.lazy || false; // Lazy load panel content
    this.closeable = options.closeable || false;
    
    this.tabData = [];
    this.tabList = null;
    this.panelContainer = null;
    
    this.init();
  }
  
  init() {
    // Add classes based on options
    this.container.className = `tabs tabs-${this.orientation} tabs-${this.variant}`;
    
    // Create tab list
    this.tabList = document.createElement('div');
    this.tabList.className = 'tab-list';
    this.tabList.setAttribute('role', 'tablist');
    this.tabList.setAttribute('aria-orientation', this.orientation);
    this.container.appendChild(this.tabList);
    
    // Create panel container
    this.panelContainer = document.createElement('div');
    this.panelContainer.className = 'tab-panels';
    this.container.appendChild(this.panelContainer);
    
    // Extract existing tabs if any
    this.extractExistingTabs();
  }
  
  extractExistingTabs() {
    const existingButtons = this.container.querySelectorAll('.tab-button');
    const existingPanels = this.container.querySelectorAll('.tab-panel');
    
    existingButtons.forEach((button, index) => {
      const panel = existingPanels[index];
      if (panel) {
        this.addTab({
          id: button.dataset.tab || `tab-${index}`,
          label: button.textContent,
          content: panel.innerHTML,
          closeable: button.dataset.closeable === 'true'
        }, false);
      }
    });
    
    if (this.tabData.length > 0) {
      this.render();
      this.switchTab(this.activeIndex);
    }
  }
  
  addTab(config, render = true) {
    const tabId = config.id || `tab-${Date.now()}`;
    
    this.tabData.push({
      id: tabId,
      label: config.label || 'New Tab',
      content: config.content || '',
      closeable: config.closeable !== undefined ? config.closeable : this.closeable,
      disabled: config.disabled || false,
      badge: config.badge || null
    });
    
    if (render) {
      this.render();
      // Switch to new tab
      this.switchTab(this.tabData.length - 1);
    }
    
    return tabId;
  }
  
  removeTab(index) {
    if (this.tabData.length <= 1) return; // Keep at least one tab
    
    this.tabData.splice(index, 1);
    
    // Adjust active index if needed
    if (this.activeIndex >= this.tabData.length) {
      this.activeIndex = this.tabData.length - 1;
    }
    
    this.render();
    this.switchTab(this.activeIndex);
  }
  
  updateTab(index, updates) {
    if (index < 0 || index >= this.tabData.length) return;
    
    Object.assign(this.tabData[index], updates);
    this.render();
  }
  
  render() {
    this.tabList.innerHTML = '';
    this.panelContainer.innerHTML = '';
    
    this.tabData.forEach((tab, index) => {
      this.renderTab(tab, index);
      this.renderPanel(tab, index);
    });
  }
  
  renderTab(tab, index) {
    const button = document.createElement('button');
    button.className = 'tab-button';
    button.setAttribute('role', 'tab');
    button.setAttribute('id', `tab-${index}`);
    button.setAttribute('aria-controls', `panel-${index}`);
    button.setAttribute('aria-selected', index === this.activeIndex ? 'true' : 'false');
    button.setAttribute('tabindex', index === this.activeIndex ? '0' : '-1');
    
    if (tab.disabled) {
      button.disabled = true;
      button.classList.add('disabled');
    }
    
    if (index === this.activeIndex) {
      button.classList.add('active');
    }
    
    // Tab label
    const label = document.createElement('span');
    label.className = 'tab-label';
    label.textContent = tab.label;
    button.appendChild(label);
    
    // Badge
    if (tab.badge) {
      const badge = document.createElement('span');
      badge.className = 'tab-badge';
      badge.textContent = tab.badge;
      button.appendChild(badge);
    }
    
    // Close button
    if (tab.closeable && this.tabData.length > 1) {
      const closeBtn = document.createElement('span');
      closeBtn.className = 'tab-close';
      closeBtn.innerHTML = '×';
      closeBtn.setAttribute('aria-label', `Close ${tab.label}`);
      
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.removeTab(index);
      });
      
      button.appendChild(closeBtn);
    }
    
    // Event listeners
    button.addEventListener('click', () => {
      if (!tab.disabled) {
        this.switchTab(index);
      }
    });
    
    button.addEventListener('keydown', (e) => {
      this.handleKeyboard(e, index);
    });
    
    this.tabList.appendChild(button);
  }
  
  renderPanel(tab, index) {
    const panel = document.createElement('div');
    panel.className = 'tab-panel';
    panel.setAttribute('role', 'tabpanel');
    panel.setAttribute('id', `panel-${index}`);
    panel.setAttribute('aria-labelledby', `tab-${index}`);
    panel.setAttribute('tabindex', '0');
    
    if (index === this.activeIndex) {
      panel.classList.add('active');
      
      // Render content (lazy loading support)
      if (typeof tab.content === 'function') {
        panel.innerHTML = tab.content();
      } else {
        panel.innerHTML = tab.content;
      }
    } else if (!this.lazy) {
      // Pre-render all panels
      if (typeof tab.content === 'function') {
        panel.innerHTML = tab.content();
      } else {
        panel.innerHTML = tab.content;
      }
    }
    
    this.panelContainer.appendChild(panel);
  }
  
  async switchTab(index) {
    if (index === this.activeIndex || index < 0 || index >= this.tabData.length) {
      return;
    }
    
    if (this.tabData[index].disabled) {
      return;
    }
    
    // Call beforeChange hook
    if (this.onBeforeChange) {
      const canSwitch = await this.onBeforeChange(this.activeIndex, index);
      if (canSwitch === false) return;
    }
    
    const previousIndex = this.activeIndex;
    
    // Update tabs
    const tabs = this.tabList.querySelectorAll('.tab-button');
    tabs[previousIndex].classList.remove('active');
    tabs[previousIndex].setAttribute('aria-selected', 'false');
    tabs[previousIndex].setAttribute('tabindex', '-1');
    
    tabs[index].classList.add('active');
    tabs[index].setAttribute('aria-selected', 'true');
    tabs[index].setAttribute('tabindex', '0');
    
    // Update panels
    const panels = this.panelContainer.querySelectorAll('.tab-panel');
    panels[previousIndex].classList.remove('active');
    
    panels[index].classList.add('active');
    
    // Lazy load content if needed
    if (this.lazy && !panels[index].innerHTML) {
      const tab = this.tabData[index];
      if (typeof tab.content === 'function') {
        panels[index].innerHTML = tab.content();
      } else {
        panels[index].innerHTML = tab.content;
      }
    }
    
    this.activeIndex = index;
    this.onChange(index, this.tabData[index].id);
  }
  
  handleKeyboard(event, currentIndex) {
    let newIndex = currentIndex;
    
    switch (event.key) {
      case 'ArrowLeft':
      case 'ArrowUp':
        event.preventDefault();
        newIndex = currentIndex > 0 ? currentIndex - 1 : this.tabData.length - 1;
        // Skip disabled tabs
        while (this.tabData[newIndex].disabled && newIndex !== currentIndex) {
          newIndex = newIndex > 0 ? newIndex - 1 : this.tabData.length - 1;
        }
        break;
      
      case 'ArrowRight':
      case 'ArrowDown':
        event.preventDefault();
        newIndex = currentIndex < this.tabData.length - 1 ? currentIndex + 1 : 0;
        // Skip disabled tabs
        while (this.tabData[newIndex].disabled && newIndex !== currentIndex) {
          newIndex = newIndex < this.tabData.length - 1 ? newIndex + 1 : 0;
        }
        break;
      
      case 'Home':
        event.preventDefault();
        newIndex = 0;
        break;
      
      case 'End':
        event.preventDefault();
        newIndex = this.tabData.length - 1;
        break;
      
      default:
        return;
    }
    
    if (newIndex !== currentIndex && !this.tabData[newIndex].disabled) {
      this.switchTab(newIndex);
      this.tabList.querySelectorAll('.tab-button')[newIndex].focus();
    }
  }
  
  getActiveIndex() {
    return this.activeIndex;
  }
  
  getActiveTab() {
    return this.tabData[this.activeIndex];
  }
  
  destroy() {
    this.container.innerHTML = '';
  }
}

// Complete CSS
const advancedTabsCSS = `
.tabs {
  width: 100%;
  max-width: 900px;
  margin: 0 auto;
}

/* Horizontal tabs */
.tabs-horizontal {
  display: flex;
  flex-direction: column;
}

.tabs-horizontal .tab-list {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

/* Vertical tabs */
.tabs-vertical {
  display: flex;
  flex-direction: row;
}

.tabs-vertical .tab-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 200px;
}

/* Underline variant */
.tabs-underline .tab-list {
  border-bottom: 2px solid #e0e0e0;
}

.tabs-underline .tab-button {
  padding: 12px 20px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  position: relative;
  bottom: -2px;
}

.tabs-underline .tab-button.active {
  border-bottom-color: #4285f4;
}

/* Enclosed variant */
.tabs-enclosed .tab-button {
  padding: 12px 20px;
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
  border-bottom: none;
  border-radius: 8px 8px 0 0;
}

.tabs-enclosed .tab-button.active {
  background: white;
  border-bottom-color: white;
  position: relative;
  z-index: 1;
  margin-bottom: -1px;
}

.tabs-enclosed .tab-panels {
  border: 1px solid #e0e0e0;
  border-top-color: #e0e0e0;
}

/* Pills variant */
.tabs-pills .tab-button {
  padding: 10px 20px;
  background: #f5f5f5;
  border: none;
  border-radius: 20px;
}

.tabs-pills .tab-button.active {
  background: #4285f4;
  color: white;
}

/* Tab button common styles */
.tab-button {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
  color: #666;
  transition: all 0.2s;
  white-space: nowrap;
}

.tab-button:hover:not(.disabled) {
  color: #333;
  background: #f5f5f5;
}

.tab-button:focus {
  outline: 2px solid #4285f4;
  outline-offset: 2px;
  z-index: 2;
}

.tab-button.active {
  color: #4285f4;
  font-weight: 600;
}

.tab-button.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.tab-label {
  flex: 1;
}

.tab-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 6px;
  background: #e3f2fd;
  color: #1976d2;
  border-radius: 10px;
  font-size: 12px;
  font-weight: 600;
}

.tab-button.active .tab-badge {
  background: #4285f4;
  color: white;
}

.tab-close {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  font-size: 18px;
  line-height: 1;
  transition: background 0.2s;
}

.tab-close:hover {
  background: rgba(0, 0, 0, 0.1);
}

/* Tab panels */
.tab-panels {
  padding: 24px;
  background: white;
}

.tabs-vertical .tab-panels {
  flex: 1;
  border-left: 1px solid #e0e0e0;
}

.tab-panel {
  display: none;
}

.tab-panel.active {
  display: block;
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Responsive */
@media (max-width: 768px) {
  .tabs-vertical {
    flex-direction: column;
  }
  
  .tabs-vertical .tab-list {
    min-width: auto;
    flex-direction: row;
    overflow-x: auto;
  }
  
  .tabs-vertical .tab-panels {
    border-left: none;
    border-top: 1px solid #e0e0e0;
  }
}
`;

// Usage examples
console.log('=== Basic Tabs ===');
// const tabs1 = new Tabs(document.querySelector('.tabs'));

console.log('\n=== Accessible Tabs ===');
// const tabs2 = new AccessibleTabs(document.querySelector('.tabs'));

console.log('\n=== Advanced Tabs ===');
// const tabs3 = new AdvancedTabs(document.querySelector('#advanced-tabs'), {
//   variant: 'underline', // underline, enclosed, pills
//   orientation: 'horizontal',
//   closeable: false,
//   lazy: true,
//   onChange: (index, tabId) => {
//     console.log('Tab changed:', index, tabId);
//   }
// });
// 
// // Add dynamic tabs
// tabs3.addTab({
//   id: 'profile',
//   label: 'Profile',
//   content: '<h3>Profile Content</h3>',
//   badge: '5'
// });
// 
// tabs3.addTab({
//   id: 'settings',
//   label: 'Settings',
//   content: () => {
//     // Lazy load content
//     return '<h3>Settings loaded dynamically</h3>';
//   },
//   closeable: true
// });

// Real-world example: Browser-like tabs
class BrowserTabs extends AdvancedTabs {
  constructor(element) {
    super(element, {
      variant: 'enclosed',
      closeable: true,
      lazy: true
    });
    
    // Add "New Tab" button
    this.addNewTabButton();
  }
  
  addNewTabButton() {
    const newTabBtn = document.createElement('button');
    newTabBtn.className = 'new-tab-button';
    newTabBtn.textContent = '+';
    newTabBtn.setAttribute('aria-label', 'New tab');
    
    newTabBtn.addEventListener('click', () => {
      this.addTab({
        label: 'New Tab',
        content: '<p>Empty tab</p>',
        closeable: true
      });
    });
    
    this.tabList.appendChild(newTabBtn);
  }
}

// const browserTabs = new BrowserTabs(document.querySelector('#browser-tabs'));
```

**Interview Tips:**
- Tabs: UI pattern for organizing content in separate panels
- Key features: single active tab, keyboard navigation (arrows, Home, End)
- Accessibility: ARIA roles (tab, tablist, tabpanel), aria-selected, focus management
- Keyboard: Arrow keys to navigate, Space/Enter to activate
- Variants: underline (Google), enclosed (traditional), pills (Bootstrap)
- Orientations: horizontal (common) or vertical (sidebar)
- Advanced features: closeable tabs, badges, disabled state, lazy loading
- Dynamic: add/remove tabs programmatically
- State management: track active index, handle tab changes
- Common patterns: browser tabs, settings pages, dashboards
- Libraries: react-tabs, @reach/tabs, Material-UI Tabs
- Considerations: mobile responsiveness, overflow handling, animations

</details>

### **Data Structures**

61. Implement a Stack class

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Array-Based Stack**
```javascript
/**
 * Stack implementation using array
 * LIFO (Last In First Out)
 * Time Complexity: O(1) for all operations
 * Space Complexity: O(n)
 */
class Stack {
  constructor() {
    this.items = [];
  }
  
  // Add element to top of stack
  push(element) {
    this.items.push(element);
    return this.size();
  }
  
  // Remove and return top element
  pop() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items.pop();
  }
  
  // View top element without removing
  peek() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.items.length - 1];
  }
  
  // Check if stack is empty
  isEmpty() {
    return this.items.length === 0;
  }
  
  // Get stack size
  size() {
    return this.items.length;
  }
  
  // Clear all elements
  clear() {
    this.items = [];
  }
  
  // Convert to array
  toArray() {
    return [...this.items];
  }
  
  // Print stack
  print() {
    console.log(this.items.toString());
  }
}

// Usage
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.peek()); // 3
console.log(stack.pop());  // 3
console.log(stack.size()); // 2
console.log(stack.isEmpty()); // false

// Test examples
console.log('\n=== Array-Based Stack ===');
const stack1 = new Stack();
stack1.push(10);
stack1.push(20);
stack1.push(30);
console.log('Stack:', stack1.toArray()); // [10, 20, 30]
console.log('Pop:', stack1.pop()); // 30
console.log('Peek:', stack1.peek()); // 20
console.log('Size:', stack1.size()); // 2
```

### **Approach 2: Linked List-Based Stack**
```javascript
/**
 * Stack implementation using linked list
 * More memory efficient for large stacks
 */
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedListStack {
  constructor() {
    this.top = null;
    this.length = 0;
  }
  
  push(value) {
    const newNode = new Node(value);
    newNode.next = this.top;
    this.top = newNode;
    this.length++;
    return this.length;
  }
  
  pop() {
    if (this.isEmpty()) {
      return undefined;
    }
    
    const value = this.top.value;
    this.top = this.top.next;
    this.length--;
    return value;
  }
  
  peek() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.top.value;
  }
  
  isEmpty() {
    return this.length === 0;
  }
  
  size() {
    return this.length;
  }
  
  clear() {
    this.top = null;
    this.length = 0;
  }
  
  toArray() {
    const result = [];
    let current = this.top;
    
    while (current) {
      result.push(current.value);
      current = current.next;
    }
    
    return result.reverse(); // Reverse to show bottom-to-top
  }
  
  print() {
    console.log(this.toArray().toString());
  }
}

// Usage
console.log('\n=== Linked List Stack ===');
const stack2 = new LinkedListStack();
stack2.push('A');
stack2.push('B');
stack2.push('C');
console.log('Stack:', stack2.toArray()); // ['A', 'B', 'C']
console.log('Pop:', stack2.pop()); // 'C'
console.log('Peek:', stack2.peek()); // 'B'
```

### **Approach 3: Stack with Min/Max Tracking**
```javascript
/**
 * Stack that tracks minimum and maximum values
 * Useful for problems requiring O(1) min/max access
 */
class MinMaxStack {
  constructor() {
    this.items = [];
    this.minStack = [];
    this.maxStack = [];
  }
  
  push(value) {
    this.items.push(value);
    
    // Track minimum
    if (this.minStack.length === 0 || value <= this.getMin()) {
      this.minStack.push(value);
    }
    
    // Track maximum
    if (this.maxStack.length === 0 || value >= this.getMax()) {
      this.maxStack.push(value);
    }
    
    return this.size();
  }
  
  pop() {
    if (this.isEmpty()) {
      return undefined;
    }
    
    const value = this.items.pop();
    
    // Update min stack
    if (value === this.getMin()) {
      this.minStack.pop();
    }
    
    // Update max stack
    if (value === this.getMax()) {
      this.maxStack.pop();
    }
    
    return value;
  }
  
  peek() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.items.length - 1];
  }
  
  getMin() {
    if (this.minStack.length === 0) {
      return undefined;
    }
    return this.minStack[this.minStack.length - 1];
  }
  
  getMax() {
    if (this.maxStack.length === 0) {
      return undefined;
    }
    return this.maxStack[this.maxStack.length - 1];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  size() {
    return this.items.length;
  }
  
  clear() {
    this.items = [];
    this.minStack = [];
    this.maxStack = [];
  }
}

// Usage
console.log('\n=== Min/Max Stack ===');
const stack3 = new MinMaxStack();
stack3.push(5);
stack3.push(2);
stack3.push(8);
stack3.push(1);
console.log('Min:', stack3.getMin()); // 1
console.log('Max:', stack3.getMax()); // 8
stack3.pop();
console.log('Min after pop:', stack3.getMin()); // 2
```

### **Bonus: Stack with Capacity Limit**
```javascript
/**
 * Fixed-size stack with capacity limit
 */
class BoundedStack {
  constructor(capacity) {
    this.capacity = capacity;
    this.items = [];
  }
  
  push(value) {
    if (this.isFull()) {
      throw new Error('Stack overflow: capacity exceeded');
    }
    this.items.push(value);
    return this.size();
  }
  
  pop() {
    if (this.isEmpty()) {
      throw new Error('Stack underflow: stack is empty');
    }
    return this.items.pop();
  }
  
  peek() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.items.length - 1];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  isFull() {
    return this.items.length >= this.capacity;
  }
  
  size() {
    return this.items.length;
  }
  
  remainingCapacity() {
    return this.capacity - this.items.length;
  }
}

// Usage
console.log('\n=== Bounded Stack ===');
const stack4 = new BoundedStack(3);
stack4.push(1);
stack4.push(2);
stack4.push(3);
console.log('Full?', stack4.isFull()); // true
console.log('Remaining:', stack4.remainingCapacity()); // 0
// stack4.push(4); // Throws error
```

### **Common Stack Applications**
```javascript
// 1. Reverse a string
function reverseString(str) {
  const stack = new Stack();
  
  for (let char of str) {
    stack.push(char);
  }
  
  let reversed = '';
  while (!stack.isEmpty()) {
    reversed += stack.pop();
  }
  
  return reversed;
}

console.log('\n=== Applications ===');
console.log('Reversed:', reverseString('hello')); // 'olleh'

// 2. Check balanced parentheses
function isBalanced(str) {
  const stack = new Stack();
  const pairs = { '(': ')', '{': '}', '[': ']' };
  
  for (let char of str) {
    if (char in pairs) {
      stack.push(char);
    } else if (Object.values(pairs).includes(char)) {
      if (stack.isEmpty() || pairs[stack.pop()] !== char) {
        return false;
      }
    }
  }
  
  return stack.isEmpty();
}

console.log('Balanced:', isBalanced('{[()]}')); // true
console.log('Balanced:', isBalanced('{[(])}')); // false

// 3. Evaluate postfix expression
function evaluatePostfix(expression) {
  const stack = new Stack();
  const tokens = expression.split(' ');
  
  for (let token of tokens) {
    if (!isNaN(token)) {
      stack.push(Number(token));
    } else {
      const b = stack.pop();
      const a = stack.pop();
      
      switch (token) {
        case '+': stack.push(a + b); break;
        case '-': stack.push(a - b); break;
        case '*': stack.push(a * b); break;
        case '/': stack.push(a / b); break;
      }
    }
  }
  
  return stack.pop();
}

console.log('Postfix result:', evaluatePostfix('3 4 + 2 *')); // 14

// 4. Undo/Redo functionality
class UndoRedoManager {
  constructor() {
    this.undoStack = new Stack();
    this.redoStack = new Stack();
  }
  
  execute(action) {
    action.execute();
    this.undoStack.push(action);
    this.redoStack.clear(); // Clear redo on new action
  }
  
  undo() {
    if (!this.undoStack.isEmpty()) {
      const action = this.undoStack.pop();
      action.undo();
      this.redoStack.push(action);
    }
  }
  
  redo() {
    if (!this.redoStack.isEmpty()) {
      const action = this.redoStack.pop();
      action.execute();
      this.undoStack.push(action);
    }
  }
}
```

**Interview Tips:**
- Stack: LIFO (Last In First Out) data structure
- Core operations: push (add), pop (remove), peek (view top), O(1) time
- Implementation: array (simple) or linked list (memory efficient)
- Use cases: function call stack, undo/redo, backtracking, expression evaluation
- Common problems: balanced parentheses, reverse string, postfix evaluation
- Min/Max stack: track min/max in O(1) using auxiliary stacks
- Space complexity: O(n) where n is number of elements
- Variants: bounded stack (fixed size), double stack (two stacks in one array)
- Consider: overflow (capacity) and underflow (empty) conditions

</details>

62. Implement a Queue class

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Array-Based Queue**
```javascript
/**
 * Queue implementation using array
 * FIFO (First In First Out)
 * Time Complexity: enqueue O(1), dequeue O(n) due to shift
 * Space Complexity: O(n)
 */
class Queue {
  constructor() {
    this.items = [];
  }
  
  // Add element to rear
  enqueue(element) {
    this.items.push(element);
    return this.size();
  }
  
  // Remove and return front element
  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items.shift();
  }
  
  // View front element without removing
  front() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[0];
  }
  
  // View rear element
  rear() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.items.length - 1];
  }
  
  // Check if queue is empty
  isEmpty() {
    return this.items.length === 0;
  }
  
  // Get queue size
  size() {
    return this.items.length;
  }
  
  // Clear all elements
  clear() {
    this.items = [];
  }
  
  // Convert to array
  toArray() {
    return [...this.items];
  }
  
  // Print queue
  print() {
    console.log(this.items.toString());
  }
}

// Usage
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
console.log(queue.front()); // 1
console.log(queue.dequeue()); // 1
console.log(queue.size()); // 2

// Test examples
console.log('=== Array-Based Queue ===');
const queue1 = new Queue();
queue1.enqueue('A');
queue1.enqueue('B');
queue1.enqueue('C');
console.log('Queue:', queue1.toArray()); // ['A', 'B', 'C']
console.log('Dequeue:', queue1.dequeue()); // 'A'
console.log('Front:', queue1.front()); // 'B'
console.log('Rear:', queue1.rear()); // 'C'
```

### **Approach 2: Optimized Queue with Index Pointers**
```javascript
/**
 * Optimized queue using index pointers
 * Avoids O(n) shift operation by tracking front index
 * Time Complexity: O(1) for all operations
 */
class OptimizedQueue {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.rearIndex = 0;
  }
  
  enqueue(element) {
    this.items[this.rearIndex] = element;
    this.rearIndex++;
    return this.size();
  }
  
  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    
    const item = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    
    // Reset indices when queue is empty
    if (this.frontIndex === this.rearIndex) {
      this.frontIndex = 0;
      this.rearIndex = 0;
    }
    
    return item;
  }
  
  front() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.frontIndex];
  }
  
  rear() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.rearIndex - 1];
  }
  
  isEmpty() {
    return this.size() === 0;
  }
  
  size() {
    return this.rearIndex - this.frontIndex;
  }
  
  clear() {
    this.items = {};
    this.frontIndex = 0;
    this.rearIndex = 0;
  }
  
  toArray() {
    const result = [];
    for (let i = this.frontIndex; i < this.rearIndex; i++) {
      result.push(this.items[i]);
    }
    return result;
  }
  
  print() {
    console.log(this.toArray().toString());
  }
}

// Usage
console.log('\n=== Optimized Queue ===');
const queue2 = new OptimizedQueue();
queue2.enqueue(10);
queue2.enqueue(20);
queue2.enqueue(30);
console.log('Queue:', queue2.toArray()); // [10, 20, 30]
console.log('Dequeue:', queue2.dequeue()); // 10
console.log('Size:', queue2.size()); // 2
```

### **Approach 3: Linked List-Based Queue**
```javascript
/**
 * Queue implementation using linked list
 * Most efficient for large queues
 */
class QueueNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedListQueue {
  constructor() {
    this.head = null; // Front
    this.tail = null; // Rear
    this.length = 0;
  }
  
  enqueue(value) {
    const newNode = new QueueNode(value);
    
    if (this.isEmpty()) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }
    
    this.length++;
    return this.length;
  }
  
  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    
    const value = this.head.value;
    this.head = this.head.next;
    
    if (this.head === null) {
      this.tail = null;
    }
    
    this.length--;
    return value;
  }
  
  front() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.head.value;
  }
  
  rear() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.tail.value;
  }
  
  isEmpty() {
    return this.length === 0;
  }
  
  size() {
    return this.length;
  }
  
  clear() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  
  toArray() {
    const result = [];
    let current = this.head;
    
    while (current) {
      result.push(current.value);
      current = current.next;
    }
    
    return result;
  }
  
  print() {
    console.log(this.toArray().toString());
  }
}

// Usage
console.log('\n=== Linked List Queue ===');
const queue3 = new LinkedListQueue();
queue3.enqueue('X');
queue3.enqueue('Y');
queue3.enqueue('Z');
console.log('Queue:', queue3.toArray()); // ['X', 'Y', 'Z']
console.log('Dequeue:', queue3.dequeue()); // 'X'
console.log('Front:', queue3.front()); // 'Y'
```

### **Bonus: Priority Queue**
```javascript
/**
 * Priority Queue (Min Heap based)
 * Elements with higher priority are dequeued first
 */
class PriorityQueue {
  constructor() {
    this.items = [];
  }
  
  enqueue(element, priority = 0) {
    const queueElement = { element, priority };
    let added = false;
    
    // Insert based on priority (lower number = higher priority)
    for (let i = 0; i < this.items.length; i++) {
      if (queueElement.priority < this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }
    
    if (!added) {
      this.items.push(queueElement);
    }
    
    return this.size();
  }
  
  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items.shift().element;
  }
  
  front() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[0].element;
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  size() {
    return this.items.length;
  }
  
  clear() {
    this.items = [];
  }
  
  toArray() {
    return this.items.map(item => `${item.element}(${item.priority})`);
  }
}

// Usage
console.log('\n=== Priority Queue ===');
const pq = new PriorityQueue();
pq.enqueue('Low priority', 3);
pq.enqueue('High priority', 1);
pq.enqueue('Medium priority', 2);
console.log('Priority Queue:', pq.toArray()); // ['High priority(1)', 'Medium priority(2)', 'Low priority(3)']
console.log('Dequeue:', pq.dequeue()); // 'High priority'
```

### **Bonus: Circular Queue**
```javascript
/**
 * Circular Queue (Ring Buffer)
 * Fixed size queue with wraparound
 */
class CircularQueue {
  constructor(capacity) {
    this.capacity = capacity;
    this.items = new Array(capacity);
    this.front = -1;
    this.rear = -1;
    this.length = 0;
  }
  
  enqueue(element) {
    if (this.isFull()) {
      throw new Error('Queue is full');
    }
    
    if (this.isEmpty()) {
      this.front = 0;
    }
    
    this.rear = (this.rear + 1) % this.capacity;
    this.items[this.rear] = element;
    this.length++;
    
    return this.length;
  }
  
  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    
    const element = this.items[this.front];
    
    if (this.front === this.rear) {
      // Queue becomes empty
      this.front = -1;
      this.rear = -1;
    } else {
      this.front = (this.front + 1) % this.capacity;
    }
    
    this.length--;
    return element;
  }
  
  getFront() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.front];
  }
  
  getRear() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.rear];
  }
  
  isEmpty() {
    return this.length === 0;
  }
  
  isFull() {
    return this.length === this.capacity;
  }
  
  size() {
    return this.length;
  }
  
  clear() {
    this.items = new Array(this.capacity);
    this.front = -1;
    this.rear = -1;
    this.length = 0;
  }
  
  toArray() {
    if (this.isEmpty()) return [];
    
    const result = [];
    let i = this.front;
    
    do {
      result.push(this.items[i]);
      i = (i + 1) % this.capacity;
    } while (i !== (this.rear + 1) % this.capacity);
    
    return result;
  }
}

// Usage
console.log('\n=== Circular Queue ===');
const cq = new CircularQueue(3);
cq.enqueue(1);
cq.enqueue(2);
cq.enqueue(3);
console.log('Full?', cq.isFull()); // true
console.log('Dequeue:', cq.dequeue()); // 1
cq.enqueue(4); // Wraps around
console.log('Queue:', cq.toArray()); // [2, 3, 4]
```

### **Common Queue Applications**
```javascript
// 1. BFS (Breadth-First Search)
function bfs(graph, start) {
  const queue = new Queue();
  const visited = new Set();
  const result = [];
  
  queue.enqueue(start);
  visited.add(start);
  
  while (!queue.isEmpty()) {
    const node = queue.dequeue();
    result.push(node);
    
    for (let neighbor of graph[node] || []) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.enqueue(neighbor);
      }
    }
  }
  
  return result;
}

console.log('\n=== Applications ===');
const graph = {
  A: ['B', 'C'],
  B: ['D', 'E'],
  C: ['F'],
  D: [], E: [], F: []
};
console.log('BFS:', bfs(graph, 'A')); // ['A', 'B', 'C', 'D', 'E', 'F']

// 2. Task Scheduler
class TaskScheduler {
  constructor() {
    this.queue = new Queue();
  }
  
  addTask(task) {
    this.queue.enqueue(task);
  }
  
  processNext() {
    if (!this.queue.isEmpty()) {
      const task = this.queue.dequeue();
      console.log(`Processing: ${task}`);
      return task;
    }
  }
  
  processAll() {
    while (!this.queue.isEmpty()) {
      this.processNext();
    }
  }
}

// 3. Sliding Window Maximum
function slidingWindowMax(nums, k) {
  const result = [];
  const queue = new OptimizedQueue(); // Stores indices
  
  for (let i = 0; i < nums.length; i++) {
    // Remove elements outside window
    while (!queue.isEmpty() && queue.front() < i - k + 1) {
      queue.dequeue();
    }
    
    // Remove smaller elements (not useful)
    while (!queue.isEmpty() && nums[queue.rear()] < nums[i]) {
      // Remove from rear (would need deque)
    }
    
    queue.enqueue(i);
    
    if (i >= k - 1) {
      result.push(nums[queue.front()]);
    }
  }
  
  return result;
}
```

**Interview Tips:**
- Queue: FIFO (First In First Out) data structure
- Core operations: enqueue (add to rear), dequeue (remove from front), O(1) time
- Implementation: array (simple but shift is O(n)), object with pointers (O(1)), linked list (best)
- Use cases: BFS, task scheduling, request handling, buffering
- Priority Queue: elements dequeued by priority, not insertion order
- Circular Queue: fixed-size queue with wraparound, efficient for buffers
- Deque (double-ended queue): can add/remove from both ends
- Common problems: recent calls, moving average, sliding window
- Space complexity: O(n) where n is number of elements

</details>

63. Implement a Linked List with add, remove, and find methods

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Singly Linked List**
```javascript
/**
 * Singly Linked List implementation
 * Each node points to next node
 * Time Complexity: 
 *   - add: O(1) at head, O(n) at tail
 *   - remove: O(n)
 *   - find: O(n)
 * Space Complexity: O(n)
 */
class ListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  
  // Add to end
  add(value) {
    const newNode = new ListNode(value);
    
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }
    
    this.length++;
    return this;
  }
  
  // Add to beginning
  addFirst(value) {
    const newNode = new ListNode(value);
    newNode.next = this.head;
    this.head = newNode;
    
    if (!this.tail) {
      this.tail = newNode;
    }
    
    this.length++;
    return this;
  }
  
  // Add at specific index
  addAt(index, value) {
    if (index < 0 || index > this.length) {
      throw new Error('Index out of bounds');
    }
    
    if (index === 0) {
      return this.addFirst(value);
    }
    
    if (index === this.length) {
      return this.add(value);
    }
    
    const newNode = new ListNode(value);
    let current = this.head;
    
    for (let i = 0; i < index - 1; i++) {
      current = current.next;
    }
    
    newNode.next = current.next;
    current.next = newNode;
    this.length++;
    
    return this;
  }
  
  // Remove by value (first occurrence)
  remove(value) {
    if (!this.head) {
      return null;
    }
    
    // Remove from head
    if (this.head.value === value) {
      const removed = this.head;
      this.head = this.head.next;
      
      if (!this.head) {
        this.tail = null;
      }
      
      this.length--;
      return removed.value;
    }
    
    // Remove from middle or end
    let current = this.head;
    
    while (current.next) {
      if (current.next.value === value) {
        const removed = current.next;
        current.next = current.next.next;
        
        if (!current.next) {
          this.tail = current;
        }
        
        this.length--;
        return removed.value;
      }
      current = current.next;
    }
    
    return null;
  }
  
  // Remove from beginning
  removeFirst() {
    if (!this.head) {
      return null;
    }
    
    const value = this.head.value;
    this.head = this.head.next;
    
    if (!this.head) {
      this.tail = null;
    }
    
    this.length--;
    return value;
  }
  
  // Remove from end
  removeLast() {
    if (!this.head) {
      return null;
    }
    
    if (this.head === this.tail) {
      const value = this.head.value;
      this.head = null;
      this.tail = null;
      this.length--;
      return value;
    }
    
    let current = this.head;
    
    while (current.next !== this.tail) {
      current = current.next;
    }
    
    const value = this.tail.value;
    current.next = null;
    this.tail = current;
    this.length--;
    
    return value;
  }
  
  // Remove at specific index
  removeAt(index) {
    if (index < 0 || index >= this.length) {
      return null;
    }
    
    if (index === 0) {
      return this.removeFirst();
    }
    
    let current = this.head;
    
    for (let i = 0; i < index - 1; i++) {
      current = current.next;
    }
    
    const value = current.next.value;
    current.next = current.next.next;
    
    if (!current.next) {
      this.tail = current;
    }
    
    this.length--;
    return value;
  }
  
  // Find by value
  find(value) {
    let current = this.head;
    let index = 0;
    
    while (current) {
      if (current.value === value) {
        return { value: current.value, index };
      }
      current = current.next;
      index++;
    }
    
    return null;
  }
  
  // Find by index
  get(index) {
    if (index < 0 || index >= this.length) {
      return null;
    }
    
    let current = this.head;
    
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    
    return current.value;
  }
  
  // Check if value exists
  contains(value) {
    return this.find(value) !== null;
  }
  
  // Get size
  size() {
    return this.length;
  }
  
  // Check if empty
  isEmpty() {
    return this.length === 0;
  }
  
  // Clear all nodes
  clear() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  
  // Convert to array
  toArray() {
    const result = [];
    let current = this.head;
    
    while (current) {
      result.push(current.value);
      current = current.next;
    }
    
    return result;
  }
  
  // Print list
  print() {
    console.log(this.toArray().join(' -> '));
  }
  
  // Reverse the list
  reverse() {
    let prev = null;
    let current = this.head;
    this.tail = this.head;
    
    while (current) {
      const next = current.next;
      current.next = prev;
      prev = current;
      current = next;
    }
    
    this.head = prev;
    return this;
  }
}

// Usage
console.log('=== Singly Linked List ===');
const list = new LinkedList();
list.add(1).add(2).add(3).add(4);
console.log('List:', list.toArray()); // [1, 2, 3, 4]

list.addFirst(0);
console.log('After addFirst(0):', list.toArray()); // [0, 1, 2, 3, 4]

list.addAt(2, 1.5);
console.log('After addAt(2, 1.5):', list.toArray()); // [0, 1, 1.5, 2, 3, 4]

console.log('Find 3:', list.find(3)); // { value: 3, index: 4 }

list.remove(1.5);
console.log('After remove(1.5):', list.toArray()); // [0, 1, 2, 3, 4]

console.log('Get at index 2:', list.get(2)); // 2

list.reverse();
console.log('After reverse:', list.toArray()); // [4, 3, 2, 1, 0]
```

### **Approach 2: Doubly Linked List**
```javascript
/**
 * Doubly Linked List implementation
 * Each node has prev and next pointers
 * Better for bidirectional traversal
 */
class DoublyListNode {
  constructor(value) {
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  
  add(value) {
    const newNode = new DoublyListNode(value);
    
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      newNode.prev = this.tail;
      this.tail = newNode;
    }
    
    this.length++;
    return this;
  }
  
  addFirst(value) {
    const newNode = new DoublyListNode(value);
    
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    }
    
    this.length++;
    return this;
  }
  
  addAt(index, value) {
    if (index < 0 || index > this.length) {
      throw new Error('Index out of bounds');
    }
    
    if (index === 0) return this.addFirst(value);
    if (index === this.length) return this.add(value);
    
    const newNode = new DoublyListNode(value);
    let current = this.head;
    
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    
    newNode.prev = current.prev;
    newNode.next = current;
    current.prev.next = newNode;
    current.prev = newNode;
    
    this.length++;
    return this;
  }
  
  remove(value) {
    if (!this.head) return null;
    
    let current = this.head;
    
    while (current) {
      if (current.value === value) {
        if (current.prev) {
          current.prev.next = current.next;
        } else {
          this.head = current.next;
        }
        
        if (current.next) {
          current.next.prev = current.prev;
        } else {
          this.tail = current.prev;
        }
        
        this.length--;
        return current.value;
      }
      current = current.next;
    }
    
    return null;
  }
  
  removeFirst() {
    if (!this.head) return null;
    
    const value = this.head.value;
    this.head = this.head.next;
    
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    
    this.length--;
    return value;
  }
  
  removeLast() {
    if (!this.tail) return null;
    
    const value = this.tail.value;
    this.tail = this.tail.prev;
    
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    
    this.length--;
    return value;
  }
  
  find(value) {
    let current = this.head;
    let index = 0;
    
    while (current) {
      if (current.value === value) {
        return { value: current.value, index };
      }
      current = current.next;
      index++;
    }
    
    return null;
  }
  
  get(index) {
    if (index < 0 || index >= this.length) return null;
    
    let current;
    
    // Optimize by starting from head or tail
    if (index < this.length / 2) {
      current = this.head;
      for (let i = 0; i < index; i++) {
        current = current.next;
      }
    } else {
      current = this.tail;
      for (let i = this.length - 1; i > index; i--) {
        current = current.prev;
      }
    }
    
    return current.value;
  }
  
  contains(value) {
    return this.find(value) !== null;
  }
  
  size() {
    return this.length;
  }
  
  isEmpty() {
    return this.length === 0;
  }
  
  clear() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  
  toArray() {
    const result = [];
    let current = this.head;
    
    while (current) {
      result.push(current.value);
      current = current.next;
    }
    
    return result;
  }
  
  toArrayReverse() {
    const result = [];
    let current = this.tail;
    
    while (current) {
      result.push(current.value);
      current = current.prev;
    }
    
    return result;
  }
  
  print() {
    console.log(this.toArray().join(' <-> '));
  }
  
  reverse() {
    let current = this.head;
    let temp = null;
    
    // Swap next and prev for all nodes
    while (current) {
      temp = current.prev;
      current.prev = current.next;
      current.next = temp;
      current = current.prev;
    }
    
    // Swap head and tail
    temp = this.head;
    this.head = this.tail;
    this.tail = temp;
    
    return this;
  }
}

// Usage
console.log('\n=== Doubly Linked List ===');
const dlist = new DoublyLinkedList();
dlist.add('A').add('B').add('C');
console.log('List:', dlist.toArray()); // ['A', 'B', 'C']
console.log('Reverse:', dlist.toArrayReverse()); // ['C', 'B', 'A']

dlist.addFirst('Z');
console.log('After addFirst:', dlist.toArray()); // ['Z', 'A', 'B', 'C']

dlist.remove('A');
console.log('After remove:', dlist.toArray()); // ['Z', 'B', 'C']
```

### **Bonus: Common Linked List Operations**
```javascript
// Find middle element
LinkedList.prototype.findMiddle = function() {
  let slow = this.head;
  let fast = this.head;
  
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }
  
  return slow ? slow.value : null;
};

// Detect if list has cycle
LinkedList.prototype.hasCycle = function() {
  let slow = this.head;
  let fast = this.head;
  
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    
    if (slow === fast) {
      return true;
    }
  }
  
  return false;
};

// Get nth node from end
LinkedList.prototype.getNthFromEnd = function(n) {
  let first = this.head;
  let second = this.head;
  
  // Move first pointer n steps ahead
  for (let i = 0; i < n; i++) {
    if (!first) return null;
    first = first.next;
  }
  
  // Move both pointers until first reaches end
  while (first) {
    first = first.next;
    second = second.next;
  }
  
  return second ? second.value : null;
};

// Remove duplicates
LinkedList.prototype.removeDuplicates = function() {
  if (!this.head) return this;
  
  const seen = new Set();
  let current = this.head;
  let prev = null;
  
  while (current) {
    if (seen.has(current.value)) {
      prev.next = current.next;
      if (!prev.next) {
        this.tail = prev;
      }
      this.length--;
    } else {
      seen.add(current.value);
      prev = current;
    }
    current = current.next;
  }
  
  return this;
};

// Merge two sorted lists
function mergeSortedLists(list1, list2) {
  const dummy = new ListNode(0);
  let current = dummy;
  let p1 = list1.head;
  let p2 = list2.head;
  
  while (p1 && p2) {
    if (p1.value < p2.value) {
      current.next = p1;
      p1 = p1.next;
    } else {
      current.next = p2;
      p2 = p2.next;
    }
    current = current.next;
  }
  
  current.next = p1 || p2;
  
  const merged = new LinkedList();
  merged.head = dummy.next;
  
  // Calculate length and find tail
  let temp = merged.head;
  while (temp) {
    merged.length++;
    if (!temp.next) {
      merged.tail = temp;
    }
    temp = temp.next;
  }
  
  return merged;
}

// Test additional methods
console.log('\n=== Additional Operations ===');
const testList = new LinkedList();
testList.add(1).add(2).add(3).add(4).add(5);
console.log('Middle:', testList.findMiddle()); // 3
console.log('2nd from end:', testList.getNthFromEnd(2)); // 4

const dupList = new LinkedList();
dupList.add(1).add(2).add(2).add(3).add(1);
console.log('With duplicates:', dupList.toArray()); // [1, 2, 2, 3, 1]
dupList.removeDuplicates();
console.log('Without duplicates:', dupList.toArray()); // [1, 2, 3]
```

**Interview Tips:**
- Linked List: nodes connected via pointers, dynamic size
- Singly: each node has next pointer, one-way traversal
- Doubly: each node has prev and next, bidirectional traversal
- Operations: add O(1) at head, O(n) at tail without tail pointer
- Search/Find: O(n) time complexity (must traverse)
- Space: O(n) for n elements, each node has extra pointer overhead
- Advantages: dynamic size, O(1) insertion/deletion at known position
- Disadvantages: O(n) access time, no random access, extra memory for pointers
- Common problems: cycle detection, reverse, merge sorted lists, find middle
- Two pointer technique: slow/fast pointers for middle, cycle detection
- Use cases: undo functionality, browser history, music playlist

</details>

64. Check if a linked list has a cycle

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Floyd's Cycle Detection (Tortoise and Hare)**
```javascript
/**
 * Detect cycle using two pointers (optimal solution)
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Algorithm: Use slow and fast pointers
 * - Slow moves 1 step at a time
 * - Fast moves 2 steps at a time
 * - If they meet, there's a cycle
 */
class ListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

function hasCycle(head) {
  if (!head || !head.next) {
    return false;
  }
  
  let slow = head;
  let fast = head;
  
  while (fast && fast.next) {
    slow = slow.next;        // Move 1 step
    fast = fast.next.next;   // Move 2 steps
    
    if (slow === fast) {
      return true; // Cycle detected
    }
  }
  
  return false; // No cycle
}

// Test examples
console.log('=== Floyd\'s Cycle Detection ===');

// Create list with cycle: 1 -> 2 -> 3 -> 4 -> 2 (cycle back)
const node1 = new ListNode(1);
const node2 = new ListNode(2);
const node3 = new ListNode(3);
const node4 = new ListNode(4);

node1.next = node2;
node2.next = node3;
node3.next = node4;
node4.next = node2; // Creates cycle

console.log('Has cycle:', hasCycle(node1)); // true

// Create list without cycle: 1 -> 2 -> 3 -> 4
const a1 = new ListNode(1);
const a2 = new ListNode(2);
const a3 = new ListNode(3);
const a4 = new ListNode(4);

a1.next = a2;
a2.next = a3;
a3.next = a4;

console.log('Has cycle:', hasCycle(a1)); // false
console.log('Empty list:', hasCycle(null)); // false
```

### **Approach 2: Hash Set (Simple but uses extra space)**
```javascript
/**
 * Detect cycle using hash set to track visited nodes
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function hasCycleHashSet(head) {
  if (!head) {
    return false;
  }
  
  const visited = new Set();
  let current = head;
  
  while (current) {
    if (visited.has(current)) {
      return true; // Already visited, cycle exists
    }
    
    visited.add(current);
    current = current.next;
  }
  
  return false;
}

// Test
console.log('\n=== Hash Set Method ===');
console.log('Has cycle (hash):', hasCycleHashSet(node1)); // true
console.log('Has cycle (hash):', hasCycleHashSet(a1)); // false
```

### **Approach 3: Find Cycle Start Position**
```javascript
/**
 * Not only detect cycle but find where it starts
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Algorithm:
 * 1. Use Floyd's to detect cycle
 * 2. Reset slow to head, keep fast at meeting point
 * 3. Move both 1 step at a time until they meet
 * 4. Meeting point is cycle start
 */
function detectCycleStart(head) {
  if (!head || !head.next) {
    return null;
  }
  
  let slow = head;
  let fast = head;
  let hasCycle = false;
  
  // Detect if cycle exists
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    
    if (slow === fast) {
      hasCycle = true;
      break;
    }
  }
  
  if (!hasCycle) {
    return null;
  }
  
  // Find cycle start
  slow = head;
  
  while (slow !== fast) {
    slow = slow.next;
    fast = fast.next;
  }
  
  return slow; // Cycle start node
}

// Test
console.log('\n=== Find Cycle Start ===');
const cycleStart = detectCycleStart(node1);
console.log('Cycle starts at value:', cycleStart ? cycleStart.value : 'No cycle'); // 2
console.log('No cycle start:', detectCycleStart(a1) ? 'Found' : 'No cycle'); // No cycle
```

### **Approach 4: Get Cycle Length**
```javascript
/**
 * Find the length of the cycle if it exists
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
function getCycleLength(head) {
  if (!head || !head.next) {
    return 0;
  }
  
  let slow = head;
  let fast = head;
  
  // Detect cycle
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    
    if (slow === fast) {
      // Count nodes in cycle
      let length = 1;
      let current = slow.next;
      
      while (current !== slow) {
        length++;
        current = current.next;
      }
      
      return length;
    }
  }
  
  return 0; // No cycle
}

// Test
console.log('\n=== Cycle Length ===');
console.log('Cycle length:', getCycleLength(node1)); // 3 (nodes 2, 3, 4)
console.log('Cycle length:', getCycleLength(a1)); // 0
```

### **Bonus: Complete Cycle Analysis**
```javascript
/**
 * Complete cycle analysis - detect, find start, get length
 */
function analyzeCycle(head) {
  if (!head || !head.next) {
    return {
      hasCycle: false,
      cycleStart: null,
      cycleLength: 0,
      nodesBeforeCycle: 0
    };
  }
  
  let slow = head;
  let fast = head;
  
  // Phase 1: Detect cycle
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    
    if (slow === fast) {
      break; // Cycle detected
    }
  }
  
  // No cycle
  if (!fast || !fast.next) {
    return {
      hasCycle: false,
      cycleStart: null,
      cycleLength: 0,
      nodesBeforeCycle: 0
    };
  }
  
  // Phase 2: Find cycle start and count nodes before cycle
  slow = head;
  let nodesBeforeCycle = 0;
  
  while (slow !== fast) {
    slow = slow.next;
    fast = fast.next;
    nodesBeforeCycle++;
  }
  
  const cycleStart = slow;
  
  // Phase 3: Calculate cycle length
  let cycleLength = 1;
  let current = slow.next;
  
  while (current !== slow) {
    cycleLength++;
    current = current.next;
  }
  
  return {
    hasCycle: true,
    cycleStart: cycleStart,
    cycleStartValue: cycleStart.value,
    cycleLength: cycleLength,
    nodesBeforeCycle: nodesBeforeCycle
  };
}

// Test
console.log('\n=== Complete Analysis ===');
const analysis1 = analyzeCycle(node1);
console.log('Analysis with cycle:', {
  hasCycle: analysis1.hasCycle,
  cycleStartValue: analysis1.cycleStartValue,
  cycleLength: analysis1.cycleLength,
  nodesBeforeCycle: analysis1.nodesBeforeCycle
});
// { hasCycle: true, cycleStartValue: 2, cycleLength: 3, nodesBeforeCycle: 1 }

const analysis2 = analyzeCycle(a1);
console.log('Analysis without cycle:', analysis2);
// { hasCycle: false, cycleStart: null, cycleLength: 0, nodesBeforeCycle: 0 }
```

### **Practical Implementation with LinkedList Class**
```javascript
/**
 * Add cycle detection to LinkedList class
 */
class CycleDetectableList {
  constructor() {
    this.head = null;
    this.length = 0;
  }
  
  add(value) {
    const newNode = new ListNode(value);
    
    if (!this.head) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }
    
    this.length++;
    return this;
  }
  
  // Create cycle for testing (connect last to nth node)
  createCycle(position) {
    if (position < 0 || position >= this.length) {
      return;
    }
    
    let cycleNode = this.head;
    for (let i = 0; i < position; i++) {
      cycleNode = cycleNode.next;
    }
    
    let last = this.head;
    while (last.next) {
      last = last.next;
    }
    
    last.next = cycleNode;
  }
  
  hasCycle() {
    return hasCycle(this.head);
  }
  
  detectCycleStart() {
    return detectCycleStart(this.head);
  }
  
  getCycleLength() {
    return getCycleLength(this.head);
  }
  
  analyzeCycle() {
    return analyzeCycle(this.head);
  }
  
  // Remove cycle if exists
  removeCycle() {
    const start = this.detectCycleStart();
    if (!start) return false;
    
    let current = start;
    while (current.next !== start) {
      current = current.next;
    }
    
    current.next = null;
    return true;
  }
}

// Test
console.log('\n=== LinkedList with Cycle Detection ===');
const list = new CycleDetectableList();
list.add(1).add(2).add(3).add(4).add(5);

console.log('Before cycle:', list.hasCycle()); // false

list.createCycle(2); // Connect to node with value 3
console.log('After creating cycle:', list.hasCycle()); // true

const info = list.analyzeCycle();
console.log('Cycle info:', info);

console.log('Removing cycle:', list.removeCycle()); // true
console.log('After removal:', list.hasCycle()); // false
```

### **Edge Cases and Testing**
```javascript
// Test edge cases
console.log('\n=== Edge Cases ===');

// Single node with self cycle
const selfLoop = new ListNode(1);
selfLoop.next = selfLoop;
console.log('Self loop:', hasCycle(selfLoop)); // true

// Two nodes with cycle
const n1 = new ListNode(1);
const n2 = new ListNode(2);
n1.next = n2;
n2.next = n1;
console.log('Two node cycle:', hasCycle(n1)); // true

// Single node, no cycle
const single = new ListNode(1);
console.log('Single node:', hasCycle(single)); // false

// Empty list
console.log('Empty list:', hasCycle(null)); // false
```

**Interview Tips:**
- Floyd's Cycle Detection (Tortoise and Hare) is optimal: O(n) time, O(1) space
- Key insight: if there's a cycle, fast pointer will eventually meet slow pointer
- Hash set approach is simpler but uses O(n) space
- To find cycle start: reset slow to head after detection, move both 1 step until they meet
- Cycle length: once detected, count steps in one complete loop
- Mathematical proof: if cycle exists, fast catches slow within cycle length iterations
- Common variations: return boolean, return cycle start, return cycle length
- Edge cases: empty list, single node, self-loop, no cycle
- Applications: memory leak detection, infinite loop detection
- Follow-up questions: remove cycle, find cycle length, nodes before cycle

</details>

65. Reverse a linked list

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Iterative (Optimal)**
```javascript
/**
 * Reverse linked list iteratively
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Algorithm: Use three pointers (prev, current, next)
 * Reverse links one by one
 */
class ListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

function reverseList(head) {
  let prev = null;
  let current = head;
  
  while (current) {
    const next = current.next;  // Save next node
    current.next = prev;         // Reverse the link
    prev = current;              // Move prev forward
    current = next;              // Move current forward
  }
  
  return prev; // New head
}

// Helper to create list from array
function createList(arr) {
  if (arr.length === 0) return null;
  
  const head = new ListNode(arr[0]);
  let current = head;
  
  for (let i = 1; i < arr.length; i++) {
    current.next = new ListNode(arr[i]);
    current = current.next;
  }
  
  return head;
}

// Helper to convert list to array
function toArray(head) {
  const result = [];
  let current = head;
  
  while (current) {
    result.push(current.value);
    current = current.next;
  }
  
  return result;
}

// Test
console.log('=== Iterative Reverse ===');
let list1 = createList([1, 2, 3, 4, 5]);
console.log('Original:', toArray(list1)); // [1, 2, 3, 4, 5]

list1 = reverseList(list1);
console.log('Reversed:', toArray(list1)); // [5, 4, 3, 2, 1]

// Edge cases
console.log('Empty:', toArray(reverseList(null))); // []
console.log('Single:', toArray(reverseList(createList([1])))); // [1]
```

### **Approach 2: Recursive**
```javascript
/**
 * Reverse linked list recursively
 * Time Complexity: O(n)
 * Space Complexity: O(n) due to recursion stack
 */
function reverseListRecursive(head) {
  // Base cases
  if (!head || !head.next) {
    return head;
  }
  
  // Recursive case
  const newHead = reverseListRecursive(head.next);
  
  // Reverse the link
  head.next.next = head;
  head.next = null;
  
  return newHead;
}

// Test
console.log('\n=== Recursive Reverse ===');
let list2 = createList([1, 2, 3, 4, 5]);
console.log('Original:', toArray(list2)); // [1, 2, 3, 4, 5]

list2 = reverseListRecursive(list2);
console.log('Reversed:', toArray(list2)); // [5, 4, 3, 2, 1]
```

### **Approach 3: Reverse Between Two Positions**
```javascript
/**
 * Reverse linked list between positions left and right
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Example: 1->2->3->4->5, left=2, right=4
 * Result: 1->4->3->2->5
 */
function reverseBetween(head, left, right) {
  if (!head || left === right) {
    return head;
  }
  
  const dummy = new ListNode(0);
  dummy.next = head;
  let prev = dummy;
  
  // Move to node before left position
  for (let i = 1; i < left; i++) {
    prev = prev.next;
  }
  
  // Reverse the sublist
  let current = prev.next;
  
  for (let i = 0; i < right - left; i++) {
    const next = current.next;
    current.next = next.next;
    next.next = prev.next;
    prev.next = next;
  }
  
  return dummy.next;
}

// Test
console.log('\n=== Reverse Between ===');
let list3 = createList([1, 2, 3, 4, 5]);
console.log('Original:', toArray(list3)); // [1, 2, 3, 4, 5]

list3 = reverseBetween(list3, 2, 4);
console.log('Reversed 2-4:', toArray(list3)); // [1, 4, 3, 2, 5]
```

### **Approach 4: Reverse in K Groups**
```javascript
/**
 * Reverse nodes in k-group
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * 
 * Example: 1->2->3->4->5, k=2
 * Result: 2->1->4->3->5
 * 
 * Example: 1->2->3->4->5, k=3
 * Result: 3->2->1->4->5
 */
function reverseKGroup(head, k) {
  if (!head || k === 1) {
    return head;
  }
  
  // Check if we have k nodes
  let count = 0;
  let current = head;
  
  while (current && count < k) {
    current = current.next;
    count++;
  }
  
  if (count < k) {
    return head; // Not enough nodes to reverse
  }
  
  // Reverse first k nodes
  let prev = null;
  current = head;
  
  for (let i = 0; i < k; i++) {
    const next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }
  
  // Recursively reverse remaining groups
  head.next = reverseKGroup(current, k);
  
  return prev; // New head of reversed group
}

// Test
console.log('\n=== Reverse K Groups ===');
let list4 = createList([1, 2, 3, 4, 5, 6, 7, 8]);
console.log('Original:', toArray(list4)); // [1, 2, 3, 4, 5, 6, 7, 8]

list4 = reverseKGroup(list4, 3);
console.log('Reversed k=3:', toArray(list4)); // [3, 2, 1, 6, 5, 4, 7, 8]

let list5 = createList([1, 2, 3, 4, 5]);
list5 = reverseKGroup(list5, 2);
console.log('Reversed k=2:', toArray(list5)); // [2, 1, 4, 3, 5]
```

### **Bonus: Reverse with LinkedList Class**
```javascript
/**
 * LinkedList class with reverse methods
 */
class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  
  add(value) {
    const newNode = new ListNode(value);
    
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }
    
    this.length++;
    return this;
  }
  
  // Reverse entire list (iterative)
  reverse() {
    if (!this.head || !this.head.next) {
      return this;
    }
    
    let prev = null;
    let current = this.head;
    this.tail = this.head; // Old head becomes tail
    
    while (current) {
      const next = current.next;
      current.next = prev;
      prev = current;
      current = next;
    }
    
    this.head = prev; // New head
    return this;
  }
  
  // Reverse using recursion
  reverseRecursive() {
    if (!this.head || !this.head.next) {
      return this;
    }
    
    this.tail = this.head;
    this.head = this._reverseHelper(this.head);
    return this;
  }
  
  _reverseHelper(node) {
    if (!node || !node.next) {
      return node;
    }
    
    const newHead = this._reverseHelper(node.next);
    node.next.next = node;
    node.next = null;
    
    return newHead;
  }
  
  // Reverse between positions
  reverseBetween(left, right) {
    if (!this.head || left === right) {
      return this;
    }
    
    this.head = reverseBetween(this.head, left, right);
    
    // Update tail if needed
    this.tail = this.head;
    while (this.tail.next) {
      this.tail = this.tail.next;
    }
    
    return this;
  }
  
  // Reverse in k groups
  reverseKGroup(k) {
    this.head = reverseKGroup(this.head, k);
    
    // Update tail
    this.tail = this.head;
    while (this.tail && this.tail.next) {
      this.tail = this.tail.next;
    }
    
    return this;
  }
  
  toArray() {
    return toArray(this.head);
  }
  
  print() {
    console.log(this.toArray().join(' -> '));
  }
}

// Test
console.log('\n=== LinkedList Class ===');
const list = new LinkedList();
list.add(1).add(2).add(3).add(4).add(5);
console.log('Original:', list.toArray()); // [1, 2, 3, 4, 5]

list.reverse();
console.log('After reverse:', list.toArray()); // [5, 4, 3, 2, 1]

list.reverse(); // Reverse back
list.reverseBetween(2, 4);
console.log('Reverse 2-4:', list.toArray()); // [1, 4, 3, 2, 5]
```

### **Alternative: Stack-Based Reverse**
```javascript
/**
 * Reverse using stack (not optimal but educational)
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function reverseListWithStack(head) {
  if (!head) return null;
  
  const stack = [];
  let current = head;
  
  // Push all nodes to stack
  while (current) {
    stack.push(current.value);
    current = current.next;
  }
  
  // Rebuild list with reversed values
  const newHead = new ListNode(stack.pop());
  current = newHead;
  
  while (stack.length > 0) {
    current.next = new ListNode(stack.pop());
    current = current.next;
  }
  
  return newHead;
}

// Test
console.log('\n=== Stack-Based Reverse ===');
let list6 = createList([1, 2, 3, 4, 5]);
list6 = reverseListWithStack(list6);
console.log('Stack reversed:', toArray(list6)); // [5, 4, 3, 2, 1]
```

### **Visualizing the Reverse Process**
```javascript
/**
 * Step-by-step visualization of iterative reverse
 */
function reverseListVisualize(head) {
  console.log('\n=== Reverse Visualization ===');
  console.log('Initial:', toArray(head));
  
  let prev = null;
  let current = head;
  let step = 1;
  
  while (current) {
    console.log(`\nStep ${step}:`);
    console.log('  Current:', current.value);
    console.log('  Prev:', prev ? prev.value : 'null');
    
    const next = current.next;
    console.log('  Next:', next ? next.value : 'null');
    
    current.next = prev;
    console.log('  Action: Point', current.value, 'to', prev ? prev.value : 'null');
    
    prev = current;
    current = next;
    step++;
  }
  
  console.log('\nFinal reversed list:', toArray(prev));
  return prev;
}

// Demo
let demoList = createList([1, 2, 3]);
reverseListVisualize(demoList);
```

**Interview Tips:**
- Iterative approach is optimal: O(n) time, O(1) space
- Use three pointers: prev, current, next
- Key step: reverse the link (current.next = prev) before moving forward
- Recursive approach is elegant but uses O(n) stack space
- Common variations: reverse between positions, reverse in k groups
- Edge cases: empty list, single node, two nodes
- Don't forget to update head and tail pointers if using LinkedList class
- Practice drawing: visualize pointer movements on paper
- Common mistakes: losing reference to next node, not updating tail
- Follow-ups: reverse in place, reverse alternate nodes, reverse by value range

</details>

---

## **HARD LEVEL (66-95)**

### **Advanced Algorithms**

66. Implement binary search

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Iterative Binary Search**
```javascript
/**
 * Binary search implementation (iterative)
 * Time Complexity: O(log n)
 * Space Complexity: O(1)
 * 
 * Requirements: Array must be sorted
 * Returns index of target or -1 if not found
 */
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    // Calculate middle index (avoid overflow)
    const mid = Math.floor(left + (right - left) / 2);
    
    if (arr[mid] === target) {
      return mid; // Found target
    } else if (arr[mid] < target) {
      left = mid + 1; // Search right half
    } else {
      right = mid - 1; // Search left half
    }
  }
  
  return -1; // Target not found
}

// Test examples
console.log('=== Iterative Binary Search ===');
const arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];

console.log('Find 7:', binarySearch(arr, 7)); // 3
console.log('Find 13:', binarySearch(arr, 13)); // 6
console.log('Find 20:', binarySearch(arr, 20)); // -1
console.log('Find 1:', binarySearch(arr, 1)); // 0
console.log('Find 19:', binarySearch(arr, 19)); // 9

// Edge cases
console.log('Empty array:', binarySearch([], 5)); // -1
console.log('Single element (found):', binarySearch([5], 5)); // 0
console.log('Single element (not found):', binarySearch([5], 3)); // -1
```

### **Approach 2: Recursive Binary Search**
```javascript
/**
 * Binary search implementation (recursive)
 * Time Complexity: O(log n)
 * Space Complexity: O(log n) due to recursion stack
 */
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  // Base case: target not found
  if (left > right) {
    return -1;
  }
  
  const mid = Math.floor(left + (right - left) / 2);
  
  // Base case: found target
  if (arr[mid] === target) {
    return mid;
  }
  
  // Recursive cases
  if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  } else {
    return binarySearchRecursive(arr, target, left, mid - 1);
  }
}

// Test
console.log('\n=== Recursive Binary Search ===');
console.log('Find 9:', binarySearchRecursive(arr, 9)); // 4
console.log('Find 15:', binarySearchRecursive(arr, 15)); // 7
console.log('Find 100:', binarySearchRecursive(arr, 100)); // -1
```

### **Approach 3: Binary Search Variations**
```javascript
/**
 * Find first occurrence of target
 * Useful when array has duplicates
 */
function binarySearchFirst(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;
  
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      right = mid - 1; // Continue searching left for first occurrence
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

/**
 * Find last occurrence of target
 */
function binarySearchLast(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;
  
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      left = mid + 1; // Continue searching right for last occurrence
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

/**
 * Find number of occurrences of target
 */
function countOccurrences(arr, target) {
  const first = binarySearchFirst(arr, target);
  if (first === -1) return 0;
  
  const last = binarySearchLast(arr, target);
  return last - first + 1;
}

// Test with duplicates
console.log('\n=== Binary Search Variations ===');
const arrWithDuplicates = [1, 2, 2, 2, 3, 4, 4, 5, 5, 5, 5, 6];

console.log('First occurrence of 5:', binarySearchFirst(arrWithDuplicates, 5)); // 7
console.log('Last occurrence of 5:', binarySearchLast(arrWithDuplicates, 5)); // 10
console.log('Count of 5:', countOccurrences(arrWithDuplicates, 5)); // 4
console.log('Count of 2:', countOccurrences(arrWithDuplicates, 2)); // 3
console.log('Count of 7:', countOccurrences(arrWithDuplicates, 7)); // 0
```

### **Approach 4: Lower and Upper Bound**
```javascript
/**
 * Find lower bound (first element >= target)
 * Returns insertion position if target not found
 */
function lowerBound(arr, target) {
  let left = 0;
  let right = arr.length;
  
  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);
    
    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  
  return left;
}

/**
 * Find upper bound (first element > target)
 */
function upperBound(arr, target) {
  let left = 0;
  let right = arr.length;
  
  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);
    
    if (arr[mid] <= target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  
  return left;
}

// Test
console.log('\n=== Lower and Upper Bound ===');
const arr2 = [1, 2, 4, 4, 5, 7, 9];

console.log('Lower bound of 4:', lowerBound(arr2, 4)); // 2 (first 4)
console.log('Upper bound of 4:', upperBound(arr2, 4)); // 4 (after last 4)
console.log('Lower bound of 3:', lowerBound(arr2, 3)); // 2 (position where 3 would be)
console.log('Upper bound of 3:', upperBound(arr2, 3)); // 2 (same as lower bound)
console.log('Lower bound of 10:', lowerBound(arr2, 10)); // 7 (end of array)
```

### **Bonus: Binary Search on Answer**
```javascript
/**
 * Find square root using binary search
 * Example of "binary search on answer" pattern
 */
function sqrt(x) {
  if (x < 2) return x;
  
  let left = 1;
  let right = Math.floor(x / 2);
  let result = 0;
  
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    const square = mid * mid;
    
    if (square === x) {
      return mid;
    } else if (square < x) {
      result = mid; // Store potential answer
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

/**
 * Search in rotated sorted array
 */
function searchRotated(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    
    if (arr[mid] === target) {
      return mid;
    }
    
    // Determine which half is sorted
    if (arr[left] <= arr[mid]) {
      // Left half is sorted
      if (target >= arr[left] && target < arr[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    } else {
      // Right half is sorted
      if (target > arr[mid] && target <= arr[right]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }
  
  return -1;
}

/**
 * Find peak element (element greater than neighbors)
 */
function findPeakElement(arr) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);
    
    if (arr[mid] < arr[mid + 1]) {
      left = mid + 1; // Peak is on right
    } else {
      right = mid; // Peak is on left or at mid
    }
  }
  
  return left;
}

// Test advanced patterns
console.log('\n=== Advanced Binary Search ===');
console.log('Square root of 16:', sqrt(16)); // 4
console.log('Square root of 8:', sqrt(8)); // 2

const rotated = [4, 5, 6, 7, 0, 1, 2];
console.log('Search 0 in rotated:', searchRotated(rotated, 0)); // 4
console.log('Search 3 in rotated:', searchRotated(rotated, 3)); // -1

const peaks = [1, 2, 3, 1];
console.log('Find peak:', findPeakElement(peaks)); // 2 (element 3)
```

### **Bonus: Binary Search in 2D Matrix**
```javascript
/**
 * Search in row-wise and column-wise sorted matrix
 */
function searchMatrix(matrix, target) {
  if (!matrix.length || !matrix[0].length) return false;
  
  const rows = matrix.length;
  const cols = matrix[0].length;
  
  // Treat 2D matrix as 1D sorted array
  let left = 0;
  let right = rows * cols - 1;
  
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    
    // Convert 1D index to 2D
    const row = Math.floor(mid / cols);
    const col = mid % cols;
    const value = matrix[row][col];
    
    if (value === target) {
      return true;
    } else if (value < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return false;
}

// Test
console.log('\n=== Binary Search in 2D Matrix ===');
const matrix = [
  [1,  3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
];

console.log('Search 3:', searchMatrix(matrix, 3)); // true
console.log('Search 13:', searchMatrix(matrix, 13)); // false
```

### **Performance Comparison**
```javascript
/**
 * Compare binary search vs linear search
 */
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1;
}

function benchmark(size) {
  const arr = Array.from({ length: size }, (_, i) => i);
  const target = size - 1; // Worst case
  
  console.log(`\nArray size: ${size.toLocaleString()}`);
  
  // Binary search
  let start = performance.now();
  binarySearch(arr, target);
  let time = performance.now() - start;
  console.log(`Binary Search: ${time.toFixed(4)}ms`);
  
  // Linear search
  start = performance.now();
  linearSearch(arr, target);
  time = performance.now() - start;
  console.log(`Linear Search: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmark(1000);
benchmark(100000);
benchmark(1000000);
```

**Interview Tips:**
- Binary search requires sorted array, O(log n) time complexity
- Key concept: eliminate half of search space each iteration
- Calculate mid as `left + (right - left) / 2` to avoid integer overflow
- Iterative is better than recursive (no stack space)
- Common variations: find first/last occurrence, count occurrences
- Lower bound: first element >= target, Upper bound: first element > target
- Advanced: rotated array, peak element, 2D matrix, sqrt using binary search
- Watch out for infinite loops: ensure left/right pointers move
- Edge cases: empty array, single element, target at boundaries
- Template: while (left <= right) for exact match, while (left < right) for bounds
- Applications: searching, finding insertion point, optimization problems
- Follow-ups: search in rotated array, find peak, search in 2D matrix

</details>

67. Implement quicksort algorithm

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Classic Quicksort (Lomuto Partition)**
```javascript
/**
 * Quicksort implementation using Lomuto partition scheme
 * Time Complexity: 
 *   - Best/Average: O(n log n)
 *   - Worst: O(n²) when array is already sorted
 * Space Complexity: O(log n) for recursion stack
 */
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    // Partition and get pivot index
    const pivotIndex = partition(arr, left, right);
    
    // Recursively sort left and right partitions
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }
  
  return arr;
}

function partition(arr, left, right) {
  // Choose rightmost element as pivot
  const pivot = arr[right];
  let i = left - 1; // Index of smaller element
  
  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      // Swap arr[i] and arr[j]
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  
  // Swap pivot to its correct position
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  
  return i + 1; // Return pivot index
}

// Test
console.log('=== Classic Quicksort (Lomuto) ===');
const arr1 = [10, 7, 8, 9, 1, 5];
console.log('Original:', [...arr1]);
quickSort(arr1);
console.log('Sorted:', arr1); // [1, 5, 7, 8, 9, 10]

const arr2 = [64, 34, 25, 12, 22, 11, 90];
console.log('\nOriginal:', [...arr2]);
quickSort(arr2);
console.log('Sorted:', arr2); // [11, 12, 22, 25, 34, 64, 90]
```

### **Approach 2: Hoare Partition Scheme**
```javascript
/**
 * Quicksort using Hoare partition (more efficient)
 * Performs fewer swaps than Lomuto partition
 */
function quickSortHoare(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = partitionHoare(arr, left, right);
    
    quickSortHoare(arr, left, pivotIndex);
    quickSortHoare(arr, pivotIndex + 1, right);
  }
  
  return arr;
}

function partitionHoare(arr, left, right) {
  // Choose middle element as pivot
  const pivot = arr[Math.floor((left + right) / 2)];
  let i = left - 1;
  let j = right + 1;
  
  while (true) {
    // Find element >= pivot from left
    do {
      i++;
    } while (arr[i] < pivot);
    
    // Find element <= pivot from right
    do {
      j--;
    } while (arr[j] > pivot);
    
    if (i >= j) {
      return j;
    }
    
    // Swap elements
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

// Test
console.log('\n=== Quicksort (Hoare) ===');
const arr3 = [10, 7, 8, 9, 1, 5];
console.log('Original:', [...arr3]);
quickSortHoare(arr3);
console.log('Sorted:', arr3); // [1, 5, 7, 8, 9, 10]
```

### **Approach 3: Randomized Quicksort**
```javascript
/**
 * Randomized quicksort to avoid worst case
 * Randomly select pivot to ensure O(n log n) average case
 */
function quickSortRandomized(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = partitionRandomized(arr, left, right);
    
    quickSortRandomized(arr, left, pivotIndex - 1);
    quickSortRandomized(arr, pivotIndex + 1, right);
  }
  
  return arr;
}

function partitionRandomized(arr, left, right) {
  // Randomly select pivot
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  
  // Swap random pivot with rightmost element
  [arr[randomIndex], arr[right]] = [arr[right], arr[randomIndex]];
  
  // Use standard Lomuto partition
  return partition(arr, left, right);
}

// Test
console.log('\n=== Randomized Quicksort ===');
const arr4 = [10, 7, 8, 9, 1, 5];
console.log('Original:', [...arr4]);
quickSortRandomized(arr4);
console.log('Sorted:', arr4); // [1, 5, 7, 8, 9, 10]
```

### **Approach 4: Three-Way Quicksort (Handle Duplicates)**
```javascript
/**
 * Three-way quicksort for arrays with many duplicates
 * Partitions into: < pivot, = pivot, > pivot
 */
function quickSort3Way(arr, left = 0, right = arr.length - 1) {
  if (left >= right) return arr;
  
  // Partition into three parts
  const [lt, gt] = partition3Way(arr, left, right);
  
  // Recursively sort left and right
  quickSort3Way(arr, left, lt - 1);
  quickSort3Way(arr, gt + 1, right);
  
  return arr;
}

function partition3Way(arr, left, right) {
  const pivot = arr[left];
  let lt = left;      // arr[left..lt-1] < pivot
  let i = left + 1;   // arr[lt..i-1] = pivot
  let gt = right;     // arr[gt+1..right] > pivot
  
  while (i <= gt) {
    if (arr[i] < pivot) {
      [arr[lt], arr[i]] = [arr[i], arr[lt]];
      lt++;
      i++;
    } else if (arr[i] > pivot) {
      [arr[i], arr[gt]] = [arr[gt], arr[i]];
      gt--;
    } else {
      i++;
    }
  }
  
  return [lt, gt];
}

// Test
console.log('\n=== Three-Way Quicksort ===');
const arr5 = [4, 2, 7, 2, 9, 2, 4, 2, 1];
console.log('Original:', [...arr5]);
quickSort3Way(arr5);
console.log('Sorted:', arr5); // [1, 2, 2, 2, 2, 4, 4, 7, 9]
```

### **Approach 5: Iterative Quicksort**
```javascript
/**
 * Iterative quicksort using explicit stack
 * Avoids recursion stack overflow for large arrays
 */
function quickSortIterative(arr) {
  const stack = [];
  stack.push([0, arr.length - 1]);
  
  while (stack.length > 0) {
    const [left, right] = stack.pop();
    
    if (left < right) {
      const pivotIndex = partition(arr, left, right);
      
      // Push subarrays to stack
      stack.push([left, pivotIndex - 1]);
      stack.push([pivotIndex + 1, right]);
    }
  }
  
  return arr;
}

// Test
console.log('\n=== Iterative Quicksort ===');
const arr6 = [10, 7, 8, 9, 1, 5];
console.log('Original:', [...arr6]);
quickSortIterative(arr6);
console.log('Sorted:', arr6); // [1, 5, 7, 8, 9, 10]
```

### **Bonus: Hybrid Quicksort (with Insertion Sort)**
```javascript
/**
 * Hybrid approach: use insertion sort for small subarrays
 * More efficient for small partitions
 */
function quickSortHybrid(arr, left = 0, right = arr.length - 1) {
  const THRESHOLD = 10;
  
  if (right - left + 1 <= THRESHOLD) {
    // Use insertion sort for small subarrays
    insertionSort(arr, left, right);
    return arr;
  }
  
  if (left < right) {
    const pivotIndex = partition(arr, left, right);
    quickSortHybrid(arr, left, pivotIndex - 1);
    quickSortHybrid(arr, pivotIndex + 1, right);
  }
  
  return arr;
}

function insertionSort(arr, left, right) {
  for (let i = left + 1; i <= right; i++) {
    const key = arr[i];
    let j = i - 1;
    
    while (j >= left && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    
    arr[j + 1] = key;
  }
}

// Test
console.log('\n=== Hybrid Quicksort ===');
const arr7 = [10, 7, 8, 9, 1, 5, 3, 2, 4, 6];
console.log('Original:', [...arr7]);
quickSortHybrid(arr7);
console.log('Sorted:', arr7); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

### **Bonus: Quick Select (Find Kth Smallest)**
```javascript
/**
 * Quick select algorithm - find kth smallest element
 * Average time: O(n), Worst: O(n²)
 */
function quickSelect(arr, k) {
  return quickSelectHelper([...arr], 0, arr.length - 1, k - 1);
}

function quickSelectHelper(arr, left, right, k) {
  if (left === right) {
    return arr[left];
  }
  
  const pivotIndex = partition(arr, left, right);
  
  if (k === pivotIndex) {
    return arr[k];
  } else if (k < pivotIndex) {
    return quickSelectHelper(arr, left, pivotIndex - 1, k);
  } else {
    return quickSelectHelper(arr, pivotIndex + 1, right, k);
  }
}

// Test
console.log('\n=== Quick Select ===');
const arr8 = [10, 7, 8, 9, 1, 5];
console.log('Array:', arr8);
console.log('3rd smallest:', quickSelect(arr8, 3)); // 7
console.log('1st smallest:', quickSelect(arr8, 1)); // 1
console.log('6th smallest:', quickSelect(arr8, 6)); // 10
```

### **Visualization and Testing**
```javascript
/**
 * Quicksort with step-by-step visualization
 */
function quickSortVisualize(arr, left = 0, right = arr.length - 1, depth = 0) {
  const indent = '  '.repeat(depth);
  console.log(`${indent}Sorting [${arr.slice(left, right + 1).join(', ')}]`);
  
  if (left < right) {
    const pivotIndex = partition(arr, left, right);
    console.log(`${indent}Pivot: ${arr[pivotIndex]} at index ${pivotIndex}`);
    console.log(`${indent}After partition: [${arr.slice(left, right + 1).join(', ')}]`);
    
    quickSortVisualize(arr, left, pivotIndex - 1, depth + 1);
    quickSortVisualize(arr, pivotIndex + 1, right, depth + 1);
  }
  
  return arr;
}

// Demo
console.log('\n=== Quicksort Visualization ===');
const demo = [5, 2, 8, 1, 9];
console.log('Original:', [...demo]);
quickSortVisualize(demo);
console.log('Final:', demo);

// Edge cases
console.log('\n=== Edge Cases ===');
console.log('Empty:', quickSort([])); // []
console.log('Single:', quickSort([1])); // [1]
console.log('Two:', quickSort([2, 1])); // [1, 2]
console.log('Already sorted:', quickSort([1, 2, 3, 4, 5])); // [1, 2, 3, 4, 5]
console.log('Reverse sorted:', quickSort([5, 4, 3, 2, 1])); // [1, 2, 3, 4, 5]
console.log('All same:', quickSort([3, 3, 3, 3])); // [3, 3, 3, 3]
```

**Interview Tips:**
- Quicksort is divide-and-conquer algorithm, sorts in-place
- Average case: O(n log n), Worst case: O(n²) when already sorted
- Lomuto partition: simpler but more swaps, Hoare: fewer swaps
- Randomized pivot selection avoids worst case
- Three-way partition handles duplicates efficiently
- Not stable (doesn't preserve relative order of equal elements)
- Practical: often fastest for average case, used in many standard libraries
- Space: O(log n) for recursion, O(1) auxiliary space
- Improvements: randomization, median-of-three pivot, hybrid with insertion sort
- Quick select: find kth smallest in O(n) average time
- Common follow-ups: handle duplicates, make stable, avoid worst case
- Interview gotchas: handle edge cases (empty, single, all same)

</details>

68. Implement mergesort algorithm

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Classic Mergesort (Top-Down)**
```javascript
/**
 * Mergesort implementation using divide and conquer
 * Time Complexity: O(n log n) in all cases
 * Space Complexity: O(n) for temporary arrays
 * 
 * Algorithm:
 * 1. Divide array into two halves
 * 2. Recursively sort each half
 * 3. Merge the sorted halves
 */
function mergeSort(arr) {
  // Base case: arrays with 0 or 1 element are already sorted
  if (arr.length <= 1) {
    return arr;
  }
  
  // Divide
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);
  
  // Conquer and merge
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;
  
  // Merge elements in sorted order
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }
  
  // Add remaining elements from left
  while (i < left.length) {
    result.push(left[i]);
    i++;
  }
  
  // Add remaining elements from right
  while (j < right.length) {
    result.push(right[j]);
    j++;
  }
  
  return result;
}

// Test
console.log('=== Classic Mergesort ===');
const arr1 = [38, 27, 43, 3, 9, 82, 10];
console.log('Original:', arr1);
console.log('Sorted:', mergeSort(arr1)); // [3, 9, 10, 27, 38, 43, 82]

const arr2 = [64, 34, 25, 12, 22, 11, 90];
console.log('\nOriginal:', arr2);
console.log('Sorted:', mergeSort(arr2)); // [11, 12, 22, 25, 34, 64, 90]
```

### **Approach 2: In-Place Mergesort**
```javascript
/**
 * Mergesort that modifies the original array
 * Avoids creating new arrays in recursive calls
 */
function mergeSortInPlace(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const mid = Math.floor((left + right) / 2);
    
    // Sort left and right halves
    mergeSortInPlace(arr, left, mid);
    mergeSortInPlace(arr, mid + 1, right);
    
    // Merge sorted halves
    mergeInPlace(arr, left, mid, right);
  }
  
  return arr;
}

function mergeInPlace(arr, left, mid, right) {
  // Create temporary arrays
  const leftArr = arr.slice(left, mid + 1);
  const rightArr = arr.slice(mid + 1, right + 1);
  
  let i = 0, j = 0, k = left;
  
  // Merge back into original array
  while (i < leftArr.length && j < rightArr.length) {
    if (leftArr[i] <= rightArr[j]) {
      arr[k] = leftArr[i];
      i++;
    } else {
      arr[k] = rightArr[j];
      j++;
    }
    k++;
  }
  
  // Copy remaining elements
  while (i < leftArr.length) {
    arr[k] = leftArr[i];
    i++;
    k++;
  }
  
  while (j < rightArr.length) {
    arr[k] = rightArr[j];
    j++;
    k++;
  }
}

// Test
console.log('\n=== In-Place Mergesort ===');
const arr3 = [38, 27, 43, 3, 9, 82, 10];
console.log('Original:', [...arr3]);
mergeSortInPlace(arr3);
console.log('Sorted:', arr3); // [3, 9, 10, 27, 38, 43, 82]
```

### **Approach 3: Bottom-Up Mergesort (Iterative)**
```javascript
/**
 * Iterative mergesort (bottom-up approach)
 * Avoids recursion overhead
 * Time: O(n log n), Space: O(n)
 */
function mergeSortIterative(arr) {
  const n = arr.length;
  if (n <= 1) return arr;
  
  // Start with subarrays of size 1, then 2, 4, 8, ...
  for (let size = 1; size < n; size *= 2) {
    // Merge subarrays of current size
    for (let left = 0; left < n; left += 2 * size) {
      const mid = Math.min(left + size - 1, n - 1);
      const right = Math.min(left + 2 * size - 1, n - 1);
      
      if (mid < right) {
        mergeInPlace(arr, left, mid, right);
      }
    }
  }
  
  return arr;
}

// Test
console.log('\n=== Iterative Mergesort ===');
const arr4 = [38, 27, 43, 3, 9, 82, 10];
console.log('Original:', [...arr4]);
mergeSortIterative(arr4);
console.log('Sorted:', arr4); // [3, 9, 10, 27, 38, 43, 82]
```

### **Approach 4: Mergesort with Custom Comparator**
```javascript
/**
 * Mergesort with custom comparison function
 * Allows sorting by different criteria
 */
function mergeSortCustom(arr, compareFn = (a, b) => a - b) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSortCustom(arr.slice(0, mid), compareFn);
  const right = mergeSortCustom(arr.slice(mid), compareFn);
  
  return mergeCustom(left, right, compareFn);
}

function mergeCustom(left, right, compareFn) {
  const result = [];
  let i = 0, j = 0;
  
  while (i < left.length && j < right.length) {
    if (compareFn(left[i], right[j]) <= 0) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }
  
  return result.concat(left.slice(i)).concat(right.slice(j));
}

// Test with different comparators
console.log('\n=== Mergesort with Custom Comparator ===');

// Sort in descending order
const arr5 = [5, 2, 8, 1, 9];
console.log('Descending:', mergeSortCustom(arr5, (a, b) => b - a)); // [9, 8, 5, 2, 1]

// Sort objects by property
const people = [
  { name: 'John', age: 30 },
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 35 }
];
console.log('Sort by age:', mergeSortCustom(people, (a, b) => a.age - b.age));
// [{ name: 'Alice', age: 25 }, { name: 'John', age: 30 }, { name: 'Bob', age: 35 }]

// Sort strings by length
const words = ['banana', 'pie', 'apple', 'strawberry'];
console.log('Sort by length:', mergeSortCustom(words, (a, b) => a.length - b.length));
// ['pie', 'apple', 'banana', 'strawberry']
```

### **Bonus: Merge K Sorted Arrays**
```javascript
/**
 * Merge k sorted arrays using mergesort approach
 * Time: O(N log k) where N is total elements
 */
function mergeKSortedArrays(arrays) {
  if (arrays.length === 0) return [];
  if (arrays.length === 1) return arrays[0];
  
  // Divide and conquer
  const mid = Math.floor(arrays.length / 2);
  const left = mergeKSortedArrays(arrays.slice(0, mid));
  const right = mergeKSortedArrays(arrays.slice(mid));
  
  return merge(left, right);
}

// Test
console.log('\n=== Merge K Sorted Arrays ===');
const sortedArrays = [
  [1, 4, 7],
  [2, 5, 8],
  [3, 6, 9]
];
console.log('Merged:', mergeKSortedArrays(sortedArrays)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### **Bonus: Count Inversions Using Mergesort**
```javascript
/**
 * Count inversions (pairs where i < j but arr[i] > arr[j])
 * Uses modified mergesort
 * Time: O(n log n)
 */
function countInversions(arr) {
  if (arr.length <= 1) return { sorted: arr, count: 0 };
  
  const mid = Math.floor(arr.length / 2);
  const left = countInversions(arr.slice(0, mid));
  const right = countInversions(arr.slice(mid));
  
  const merged = mergeAndCount(left.sorted, right.sorted);
  
  return {
    sorted: merged.sorted,
    count: left.count + right.count + merged.count
  };
}

function mergeAndCount(left, right) {
  const result = [];
  let count = 0;
  let i = 0, j = 0;
  
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
      // All remaining elements in left are inversions
      count += left.length - i;
    }
  }
  
  return {
    sorted: result.concat(left.slice(i)).concat(right.slice(j)),
    count
  };
}

// Test
console.log('\n=== Count Inversions ===');
const arr6 = [8, 4, 2, 1];
const result = countInversions(arr6);
console.log('Array:', arr6);
console.log('Inversions:', result.count); // 6
console.log('Sorted:', result.sorted); // [1, 2, 4, 8]
```

### **Bonus: Natural Mergesort**
```javascript
/**
 * Natural mergesort - takes advantage of existing sorted runs
 * More efficient on partially sorted data
 */
function naturalMergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  let runs = findRuns(arr);
  
  while (runs.length > 1) {
    const newRuns = [];
    
    for (let i = 0; i < runs.length; i += 2) {
      if (i + 1 < runs.length) {
        newRuns.push(merge(runs[i], runs[i + 1]));
      } else {
        newRuns.push(runs[i]);
      }
    }
    
    runs = newRuns;
  }
  
  return runs[0];
}

function findRuns(arr) {
  const runs = [];
  let current = [arr[0]];
  
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] >= arr[i - 1]) {
      current.push(arr[i]);
    } else {
      runs.push(current);
      current = [arr[i]];
    }
  }
  
  runs.push(current);
  return runs;
}

// Test
console.log('\n=== Natural Mergesort ===');
const arr7 = [1, 3, 5, 2, 4, 6, 7, 8, 9];
console.log('Original:', arr7);
console.log('Sorted:', naturalMergeSort(arr7)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### **Visualization and Testing**
```javascript
/**
 * Mergesort with step-by-step visualization
 */
function mergeSortVisualize(arr, depth = 0) {
  const indent = '  '.repeat(depth);
  console.log(`${indent}Dividing: [${arr.join(', ')}]`);
  
  if (arr.length <= 1) {
    console.log(`${indent}Base case: [${arr.join(', ')}]`);
    return arr;
  }
  
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);
  
  const sortedLeft = mergeSortVisualize(left, depth + 1);
  const sortedRight = mergeSortVisualize(right, depth + 1);
  
  const merged = merge(sortedLeft, sortedRight);
  console.log(`${indent}Merging: [${sortedLeft.join(', ')}] + [${sortedRight.join(', ')}] = [${merged.join(', ')}]`);
  
  return merged;
}

// Demo
console.log('\n=== Mergesort Visualization ===');
const demo = [5, 2, 8, 1];
console.log('Original:', demo);
const sorted = mergeSortVisualize(demo);
console.log('Final:', sorted);

// Edge cases
console.log('\n=== Edge Cases ===');
console.log('Empty:', mergeSort([])); // []
console.log('Single:', mergeSort([1])); // [1]
console.log('Two:', mergeSort([2, 1])); // [1, 2]
console.log('Already sorted:', mergeSort([1, 2, 3, 4, 5])); // [1, 2, 3, 4, 5]
console.log('Reverse sorted:', mergeSort([5, 4, 3, 2, 1])); // [1, 2, 3, 4, 5]
console.log('Duplicates:', mergeSort([3, 1, 3, 2, 1])); // [1, 1, 2, 3, 3]
```

### **Performance Comparison**
```javascript
/**
 * Compare mergesort with other sorting algorithms
 */
function benchmark(size) {
  const arr = Array.from({ length: size }, () => Math.floor(Math.random() * size));
  
  console.log(`\nArray size: ${size.toLocaleString()}`);
  
  // Mergesort
  let start = performance.now();
  mergeSort([...arr]);
  let time = performance.now() - start;
  console.log(`Mergesort: ${time.toFixed(4)}ms`);
  
  // Built-in sort
  start = performance.now();
  [...arr].sort((a, b) => a - b);
  time = performance.now() - start;
  console.log(`Built-in sort: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmark(1000);
benchmark(10000);
```

**Interview Tips:**
- Mergesort: divide-and-conquer, stable sorting algorithm
- Time: O(n log n) in all cases (best, average, worst)
- Space: O(n) for temporary arrays, not in-place
- Stable: preserves relative order of equal elements
- Predictable performance: always O(n log n), unlike quicksort
- Divide: split array in half, Conquer: recursively sort, Combine: merge sorted halves
- Top-down (recursive) vs bottom-up (iterative)
- Applications: external sorting (large datasets), count inversions, merge k sorted arrays
- Advantages: stable, predictable, works well on linked lists
- Disadvantages: requires O(n) extra space, slower for small arrays
- Optimizations: natural mergesort (uses existing runs), hybrid with insertion sort
- Follow-ups: merge k sorted arrays, count inversions, sort linked list
- Edge cases: empty, single element, already sorted, duplicates

</details>

69. Find the kth largest element in an array

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Sorting (Simple but not optimal)**
```javascript
/**
 * Find kth largest by sorting
 * Time Complexity: O(n log n)
 * Space Complexity: O(1) or O(n) depending on sort implementation
 */
function findKthLargestSort(nums, k) {
  // Sort in descending order
  nums.sort((a, b) => b - a);
  
  // Return kth element (k-1 index)
  return nums[k - 1];
}

// Test
console.log('=== Sorting Approach ===');
const arr1 = [3, 2, 1, 5, 6, 4];
console.log('Array:', arr1);
console.log('2nd largest:', findKthLargestSort([...arr1], 2)); // 5
console.log('4th largest:', findKthLargestSort([...arr1], 4)); // 3
```

### **Approach 2: Min Heap (Optimal for small k)**
```javascript
/**
 * Find kth largest using min heap
 * Time Complexity: O(n log k)
 * Space Complexity: O(k)
 * 
 * Maintain heap of k largest elements
 */
class MinHeap {
  constructor() {
    this.heap = [];
  }
  
  size() {
    return this.heap.length;
  }
  
  peek() {
    return this.heap[0];
  }
  
  push(val) {
    this.heap.push(val);
    this.bubbleUp(this.heap.length - 1);
  }
  
  pop() {
    if (this.size() === 0) return null;
    if (this.size() === 1) return this.heap.pop();
    
    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    return min;
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      
      if (this.heap[index] >= this.heap[parentIndex]) break;
      
      [this.heap[index], this.heap[parentIndex]] = 
        [this.heap[parentIndex], this.heap[index]];
      
      index = parentIndex;
    }
  }
  
  bubbleDown(index) {
    while (true) {
      let smallest = index;
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      
      if (leftChild < this.size() && this.heap[leftChild] < this.heap[smallest]) {
        smallest = leftChild;
      }
      
      if (rightChild < this.size() && this.heap[rightChild] < this.heap[smallest]) {
        smallest = rightChild;
      }
      
      if (smallest === index) break;
      
      [this.heap[index], this.heap[smallest]] = 
        [this.heap[smallest], this.heap[index]];
      
      index = smallest;
    }
  }
}

function findKthLargestHeap(nums, k) {
  const minHeap = new MinHeap();
  
  // Maintain heap of k largest elements
  for (let num of nums) {
    minHeap.push(num);
    
    if (minHeap.size() > k) {
      minHeap.pop(); // Remove smallest
    }
  }
  
  // Root is kth largest
  return minHeap.peek();
}

// Test
console.log('\n=== Min Heap Approach ===');
const arr2 = [3, 2, 1, 5, 6, 4];
console.log('Array:', arr2);
console.log('2nd largest:', findKthLargestHeap(arr2, 2)); // 5
console.log('4th largest:', findKthLargestHeap(arr2, 4)); // 3
```

### **Approach 3: Quickselect (Optimal - Average O(n))**
```javascript
/**
 * Quickselect algorithm (partition-based)
 * Time Complexity: O(n) average, O(n²) worst case
 * Space Complexity: O(1)
 * 
 * Similar to quicksort but only recurse on one partition
 */
function findKthLargestQuickselect(nums, k) {
  // Convert to finding (n-k)th smallest (0-indexed)
  return quickselect(nums, 0, nums.length - 1, nums.length - k);
}

function quickselect(nums, left, right, k) {
  if (left === right) {
    return nums[left];
  }
  
  // Partition and get pivot index
  const pivotIndex = partition(nums, left, right);
  
  if (k === pivotIndex) {
    return nums[k];
  } else if (k < pivotIndex) {
    return quickselect(nums, left, pivotIndex - 1, k);
  } else {
    return quickselect(nums, pivotIndex + 1, right, k);
  }
}

function partition(nums, left, right) {
  // Randomize pivot to avoid worst case
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  [nums[randomIndex], nums[right]] = [nums[right], nums[randomIndex]];
  
  const pivot = nums[right];
  let i = left - 1;
  
  for (let j = left; j < right; j++) {
    if (nums[j] <= pivot) {
      i++;
      [nums[i], nums[j]] = [nums[j], nums[i]];
    }
  }
  
  [nums[i + 1], nums[right]] = [nums[right], nums[i + 1]];
  return i + 1;
}

// Test
console.log('\n=== Quickselect Approach ===');
const arr3 = [3, 2, 1, 5, 6, 4];
console.log('Array:', arr3);
console.log('2nd largest:', findKthLargestQuickselect([...arr3], 2)); // 5
console.log('4th largest:', findKthLargestQuickselect([...arr3], 4)); // 3

const arr4 = [3, 2, 3, 1, 2, 4, 5, 5, 6];
console.log('\nArray:', arr4);
console.log('4th largest:', findKthLargestQuickselect([...arr4], 4)); // 4
```

### **Approach 4: Using Median of Medians**
```javascript
/**
 * Quickselect with median of medians pivot selection
 * Guarantees O(n) worst case time
 */
function findKthLargestMedianOfMedians(nums, k) {
  return quickselectMedianOfMedians(nums, 0, nums.length - 1, nums.length - k);
}

function quickselectMedianOfMedians(nums, left, right, k) {
  if (left === right) {
    return nums[left];
  }
  
  // Use median of medians for pivot
  const pivotIndex = medianOfMedians(nums, left, right);
  const newPivotIndex = partitionAroundPivot(nums, left, right, pivotIndex);
  
  if (k === newPivotIndex) {
    return nums[k];
  } else if (k < newPivotIndex) {
    return quickselectMedianOfMedians(nums, left, newPivotIndex - 1, k);
  } else {
    return quickselectMedianOfMedians(nums, newPivotIndex + 1, right, k);
  }
}

function medianOfMedians(nums, left, right) {
  const n = right - left + 1;
  
  if (n <= 5) {
    // Sort small group and return median
    const group = nums.slice(left, right + 1).sort((a, b) => a - b);
    return left + Math.floor(group.length / 2);
  }
  
  // Find medians of groups of 5
  const medians = [];
  for (let i = left; i <= right; i += 5) {
    const groupEnd = Math.min(i + 4, right);
    const group = nums.slice(i, groupEnd + 1).sort((a, b) => a - b);
    medians.push(group[Math.floor(group.length / 2)]);
  }
  
  // Recursively find median of medians
  return medianOfMedians(medians, 0, medians.length - 1);
}

function partitionAroundPivot(nums, left, right, pivotIndex) {
  const pivotValue = nums[pivotIndex];
  
  // Move pivot to end
  [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]];
  
  let i = left - 1;
  for (let j = left; j < right; j++) {
    if (nums[j] <= pivotValue) {
      i++;
      [nums[i], nums[j]] = [nums[j], nums[i]];
    }
  }
  
  [nums[i + 1], nums[right]] = [nums[right], nums[i + 1]];
  return i + 1;
}

// Test
console.log('\n=== Median of Medians Approach ===');
const arr5 = [3, 2, 1, 5, 6, 4];
console.log('Array:', arr5);
console.log('2nd largest:', findKthLargestMedianOfMedians([...arr5], 2)); // 5
```

### **Bonus: Find Kth Largest in Stream**
```javascript
/**
 * Find kth largest in a stream of numbers
 * Uses min heap for efficient updates
 */
class KthLargest {
  constructor(k, nums) {
    this.k = k;
    this.minHeap = new MinHeap();
    
    for (let num of nums) {
      this.add(num);
    }
  }
  
  add(val) {
    this.minHeap.push(val);
    
    if (this.minHeap.size() > this.k) {
      this.minHeap.pop();
    }
    
    return this.minHeap.peek();
  }
  
  getKthLargest() {
    return this.minHeap.peek();
  }
}

// Test
console.log('\n=== Kth Largest in Stream ===');
const kthLargest = new KthLargest(3, [4, 5, 8, 2]);
console.log('Initial 3rd largest:', kthLargest.getKthLargest()); // 4
console.log('Add 3:', kthLargest.add(3)); // 4
console.log('Add 5:', kthLargest.add(5)); // 5
console.log('Add 10:', kthLargest.add(10)); // 5
console.log('Add 9:', kthLargest.add(9)); // 8
console.log('Add 4:', kthLargest.add(4)); // 8
```

### **Bonus: Find Top K Elements**
```javascript
/**
 * Find top k largest elements (not just kth)
 * Returns array of k largest elements
 */
function findTopK(nums, k) {
  const minHeap = new MinHeap();
  
  for (let num of nums) {
    minHeap.push(num);
    
    if (minHeap.size() > k) {
      minHeap.pop();
    }
  }
  
  // Extract all elements from heap
  const result = [];
  while (minHeap.size() > 0) {
    result.push(minHeap.pop());
  }
  
  return result.reverse(); // Return in descending order
}

// Test
console.log('\n=== Top K Elements ===');
const arr6 = [3, 2, 1, 5, 6, 4];
console.log('Array:', arr6);
console.log('Top 3:', findTopK(arr6, 3)); // [6, 5, 4]
console.log('Top 2:', findTopK(arr6, 2)); // [6, 5]
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Single element
console.log('Single element:', findKthLargestQuickselect([5], 1)); // 5

// All same elements
console.log('All same:', findKthLargestQuickselect([3, 3, 3, 3], 2)); // 3

// k = 1 (largest)
console.log('Largest:', findKthLargestQuickselect([3, 2, 1, 5, 6, 4], 1)); // 6

// k = n (smallest)
console.log('Smallest:', findKthLargestQuickselect([3, 2, 1, 5, 6, 4], 6)); // 1

// Negative numbers
console.log('Negative:', findKthLargestQuickselect([-1, -2, -3, -4], 2)); // -2

// Large k
const large = Array.from({ length: 1000 }, (_, i) => i);
console.log('Large array 500th:', findKthLargestQuickselect([...large], 500)); // 500
```

### **Performance Comparison**
```javascript
/**
 * Compare different approaches
 */
function benchmarkKthLargest(size, k) {
  const arr = Array.from({ length: size }, () => Math.floor(Math.random() * size));
  
  console.log(`\nArray size: ${size.toLocaleString()}, k: ${k}`);
  
  // Sorting
  let start = performance.now();
  findKthLargestSort([...arr], k);
  let time = performance.now() - start;
  console.log(`Sorting: ${time.toFixed(4)}ms`);
  
  // Min Heap
  start = performance.now();
  findKthLargestHeap([...arr], k);
  time = performance.now() - start;
  console.log(`Min Heap: ${time.toFixed(4)}ms`);
  
  // Quickselect
  start = performance.now();
  findKthLargestQuickselect([...arr], k);
  time = performance.now() - start;
  console.log(`Quickselect: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmarkKthLargest(10000, 100);
benchmarkKthLargest(10000, 5000);
```

**Interview Tips:**
- Three main approaches: sort O(n log n), heap O(n log k), quickselect O(n) average
- Quickselect is optimal for average case: O(n) time, O(1) space
- Min heap approach best when k is small or processing stream
- Sorting simplest but not optimal: O(n log n) time
- Quickselect similar to quicksort but only recurse on one partition
- Convert "kth largest" to "(n-k)th smallest" for implementation
- Median of medians guarantees O(n) worst case but complex
- For streaming data, maintain heap of size k
- Common variations: kth smallest, top k elements, kth largest in stream
- Edge cases: k = 1 (max), k = n (min), duplicates, negative numbers
- Optimization: randomize pivot to avoid worst case O(n²)
- Follow-ups: find median, top k frequent elements, kth closest to x

</details>

70. Implement a function to find all combinations of a string

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Recursive Backtracking (All Subsets)**
```javascript
/**
 * Find all combinations (subsets) of a string
 * Time Complexity: O(2^n) - 2^n subsets
 * Space Complexity: O(n) recursion depth
 * 
 * Generates all possible subsets including empty string
 */
function findCombinations(str) {
  const result = [];
  
  function backtrack(index, current) {
    // Add current combination
    result.push(current);
    
    // Try adding each remaining character
    for (let i = index; i < str.length; i++) {
      backtrack(i + 1, current + str[i]);
    }
  }
  
  backtrack(0, '');
  return result;
}

// Test
console.log('=== All Combinations (Subsets) ===');
console.log('abc:', findCombinations('abc'));
// ['', 'a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']

console.log('\nab:', findCombinations('ab'));
// ['', 'a', 'ab', 'b']

console.log('\n123:', findCombinations('123'));
// ['', '1', '12', '123', '13', '2', '23', '3']
```

### **Approach 2: Iterative with Bit Manipulation**
```javascript
/**
 * Generate all combinations using bit manipulation
 * Each bit represents whether to include character at that position
 * Time: O(n * 2^n), Space: O(1) excluding output
 */
function findCombinationsBits(str) {
  const result = [];
  const n = str.length;
  const totalCombinations = Math.pow(2, n);
  
  // Iterate through all possible bit patterns
  for (let i = 0; i < totalCombinations; i++) {
    let combination = '';
    
    // Check each bit
    for (let j = 0; j < n; j++) {
      // If jth bit is set, include str[j]
      if ((i & (1 << j)) !== 0) {
        combination += str[j];
      }
    }
    
    result.push(combination);
  }
  
  return result;
}

// Test
console.log('\n=== Combinations with Bit Manipulation ===');
console.log('abc:', findCombinationsBits('abc'));
// ['', 'a', 'b', 'ab', 'c', 'ac', 'bc', 'abc']

console.log('\n12:', findCombinationsBits('12'));
// ['', '1', '2', '12']
```

### **Approach 3: Fixed-Length Combinations**
```javascript
/**
 * Find all combinations of specific length k
 * Time: O(C(n,k) * k) where C(n,k) is binomial coefficient
 * Space: O(k) recursion depth
 */
function findCombinationsOfLength(str, k) {
  const result = [];
  
  function backtrack(index, current) {
    // Found combination of length k
    if (current.length === k) {
      result.push(current);
      return;
    }
    
    // Try remaining characters
    for (let i = index; i < str.length; i++) {
      backtrack(i + 1, current + str[i]);
    }
  }
  
  backtrack(0, '');
  return result;
}

// Test
console.log('\n=== Combinations of Specific Length ===');
console.log('abc, length 2:', findCombinationsOfLength('abc', 2));
// ['ab', 'ac', 'bc']

console.log('\nabcd, length 2:', findCombinationsOfLength('abcd', 2));
// ['ab', 'ac', 'ad', 'bc', 'bd', 'cd']

console.log('\nabcd, length 3:', findCombinationsOfLength('abcd', 3));
// ['abc', 'abd', 'acd', 'bcd']

console.log('\n12345, length 3:', findCombinationsOfLength('12345', 3));
// ['123', '124', '125', '134', '135', '145', '234', '235', '245', '345']
```

### **Approach 4: Combinations with Duplicates Handling**
```javascript
/**
 * Find unique combinations when string has duplicate characters
 * Time: O(2^n), Space: O(n)
 */
function findUniqueCombinations(str) {
  const result = new Set();
  const chars = str.split('').sort(); // Sort to group duplicates
  
  function backtrack(index, current) {
    result.add(current);
    
    for (let i = index; i < chars.length; i++) {
      // Skip duplicates at same level
      if (i > index && chars[i] === chars[i - 1]) continue;
      
      backtrack(i + 1, current + chars[i]);
    }
  }
  
  backtrack(0, '');
  return Array.from(result);
}

// Test
console.log('\n=== Unique Combinations (with duplicates) ===');
console.log('aab:', findUniqueCombinations('aab'));
// ['', 'a', 'aa', 'aab', 'ab', 'b']

console.log('\n112:', findUniqueCombinations('112'));
// ['', '1', '11', '112', '12', '2']
```

### **Approach 5: Iterative Building (Bottom-Up)**
```javascript
/**
 * Build combinations iteratively
 * Start with empty set, add each character to existing combinations
 * Time: O(2^n), Space: O(2^n)
 */
function findCombinationsIterative(str) {
  let result = [''];
  
  for (let char of str) {
    const newCombinations = [];
    
    // For each existing combination, create a new one by adding current char
    for (let combination of result) {
      newCombinations.push(combination + char);
    }
    
    result = result.concat(newCombinations);
  }
  
  return result;
}

// Test
console.log('\n=== Iterative Building ===');
console.log('abc:', findCombinationsIterative('abc'));
// ['', 'a', 'b', 'ab', 'c', 'ac', 'bc', 'abc']

console.log('\nxy:', findCombinationsIterative('xy'));
// ['', 'x', 'y', 'xy']
```

### **Bonus: Combinations with Repetition**
```javascript
/**
 * Find combinations with repetition allowed
 * Each character can be used multiple times
 * Generate combinations of length k
 */
function findCombinationsWithRepetition(str, k) {
  const result = [];
  const chars = [...new Set(str.split(''))]; // Unique characters
  
  function backtrack(current, start) {
    if (current.length === k) {
      result.push(current);
      return;
    }
    
    // Can reuse same character (start from current position, not i+1)
    for (let i = start; i < chars.length; i++) {
      backtrack(current + chars[i], i);
    }
  }
  
  backtrack('', 0);
  return result;
}

// Test
console.log('\n=== Combinations with Repetition ===');
console.log('abc, length 2:', findCombinationsWithRepetition('abc', 2));
// ['aa', 'ab', 'ac', 'bb', 'bc', 'cc']

console.log('\n12, length 3:', findCombinationsWithRepetition('12', 3));
// ['111', '112', '122', '222']
```

### **Bonus: Grouped by Length**
```javascript
/**
 * Group combinations by their length
 * Returns object with lengths as keys
 */
function findCombinationsGrouped(str) {
  const grouped = {};
  
  function backtrack(index, current) {
    const len = current.length;
    if (!grouped[len]) grouped[len] = [];
    grouped[len].push(current);
    
    for (let i = index; i < str.length; i++) {
      backtrack(i + 1, current + str[i]);
    }
  }
  
  backtrack(0, '');
  return grouped;
}

// Test
console.log('\n=== Grouped by Length ===');
const grouped = findCombinationsGrouped('abc');
console.log('Length 0:', grouped[0]); // ['']
console.log('Length 1:', grouped[1]); // ['a', 'b', 'c']
console.log('Length 2:', grouped[2]); // ['ab', 'ac', 'bc']
console.log('Length 3:', grouped[3]); // ['abc']
```

### **Bonus: Count Only (Optimization)**
```javascript
/**
 * Count combinations without generating them
 * For n characters: 2^n total combinations
 * For length k: C(n, k) = n! / (k! * (n-k)!)
 */
function countCombinations(n) {
  return Math.pow(2, n);
}

function countCombinationsOfLength(n, k) {
  if (k > n || k < 0) return 0;
  if (k === 0 || k === n) return 1;
  
  // Calculate C(n, k) = n! / (k! * (n-k)!)
  let result = 1;
  for (let i = 0; i < k; i++) {
    result = result * (n - i) / (i + 1);
  }
  return Math.floor(result);
}

// Test
console.log('\n=== Count Combinations ===');
console.log('String length 3, total combinations:', countCombinations(3)); // 8
console.log('String length 5, total combinations:', countCombinations(5)); // 32
console.log('C(5, 2):', countCombinationsOfLength(5, 2)); // 10
console.log('C(6, 3):', countCombinationsOfLength(6, 3)); // 20
```

### **Visualization and Edge Cases**
```javascript
/**
 * Visualize the combination generation process
 */
function findCombinationsVisualize(str) {
  const result = [];
  
  function backtrack(index, current, depth) {
    const indent = '  '.repeat(depth);
    console.log(`${indent}At index ${index}, current: "${current}"`);
    
    result.push(current);
    
    for (let i = index; i < str.length; i++) {
      console.log(`${indent}Adding "${str[i]}"`);
      backtrack(i + 1, current + str[i], depth + 1);
    }
  }
  
  console.log('\n=== Combination Generation Process ===');
  backtrack(0, '', 0);
  return result;
}

// Demo
console.log('\nGenerating combinations of "ab":');
findCombinationsVisualize('ab');

// Edge cases
console.log('\n=== Edge Cases ===');
console.log('Empty string:', findCombinations('')); // ['']
console.log('Single char:', findCombinations('a')); // ['', 'a']
console.log('Length 0:', findCombinationsOfLength('abc', 0)); // ['']
console.log('Length > string:', findCombinationsOfLength('ab', 3)); // []
console.log('All same chars:', findUniqueCombinations('aaa')); 
// ['', 'a', 'aa', 'aaa']
```

### **Performance Testing**
```javascript
/**
 * Test performance with different string lengths
 */
function benchmarkCombinations(length) {
  const str = 'a'.repeat(length);
  
  console.log(`\nString length: ${length}`);
  console.log(`Expected combinations: ${Math.pow(2, length)}`);
  
  const start = performance.now();
  const combinations = findCombinations(str);
  const time = performance.now() - start;
  
  console.log(`Generated: ${combinations.length} combinations`);
  console.log(`Time: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Testing ===');
benchmarkCombinations(5);   // 32 combinations
benchmarkCombinations(10);  // 1024 combinations
benchmarkCombinations(15);  // 32768 combinations
```

### **Real-World Applications**
```javascript
/**
 * Generate password combinations for brute force analysis
 */
function generatePasswordCombinations(charset, length) {
  const result = [];
  
  function backtrack(current) {
    if (current.length === length) {
      result.push(current);
      return;
    }
    
    for (let char of charset) {
      backtrack(current + char);
    }
  }
  
  backtrack('');
  return result;
}

console.log('\n=== Password Combinations ===');
const digits = '012';
console.log('2-digit pins from 012:', generatePasswordCombinations(digits, 2));
// ['00', '01', '02', '10', '11', '12', '20', '21', '22']

/**
 * Find all possible substrings (different from subsets)
 */
function findSubstrings(str) {
  const result = new Set();
  
  for (let i = 0; i < str.length; i++) {
    for (let j = i + 1; j <= str.length; j++) {
      result.add(str.substring(i, j));
    }
  }
  
  return Array.from(result).sort();
}

console.log('\n=== All Substrings (vs Combinations) ===');
console.log('Substrings of "abc":', findSubstrings('abc'));
// ['a', 'ab', 'abc', 'b', 'bc', 'c']
console.log('Combinations of "abc":', findCombinations('abc').filter(s => s));
// ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
```

**Interview Tips:**
- Combinations = subsets = power set (all possible selections)
- Total combinations of n elements: 2^n (including empty set)
- Combinations of length k from n: C(n,k) = n!/(k!(n-k)!)
- Two main approaches: backtracking O(2^n) or bit manipulation O(n*2^n)
- Backtracking more flexible: can filter, set constraints, handle duplicates
- Bit manipulation efficient for small strings, each bit = include/exclude
- Order doesn't matter in combinations: "ab" same as "ba" (vs permutations)
- Handle duplicates: sort string first, skip duplicates at same recursion level
- Fixed-length: add length constraint to backtracking
- Space complexity: O(n) for recursion, O(2^n) for storing results
- Optimizations: count without generating, early termination, pruning
- Related problems: permutations (order matters), substrings (contiguous), subsequences
- Applications: feature selection, set operations, combinations generator
- Edge cases: empty string, single character, all duplicates, k > n
- Clarify: include empty set? duplicates allowed? fixed length? order matters?
- Follow-ups: k-length combinations, with repetition, unique only, count only

</details>

71. Solve the "Two Sum" problem

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Brute Force (Two Nested Loops)**
```javascript
/**
 * Find two numbers that sum to target using brute force
 * Time Complexity: O(n²)
 * Space Complexity: O(1)
 */
function twoSumBruteForce(nums, target) {
  const n = nums.length;
  
  // Check every pair
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  
  return null; // No solution found
}

// Test
console.log('=== Brute Force Approach ===');
console.log('[2,7,11,15], target 9:', twoSumBruteForce([2, 7, 11, 15], 9)); // [0, 1]
console.log('[3,2,4], target 6:', twoSumBruteForce([3, 2, 4], 6)); // [1, 2]
console.log('[3,3], target 6:', twoSumBruteForce([3, 3], 6)); // [0, 1]
```

### **Approach 2: Hash Map (Optimal - One Pass)**
```javascript
/**
 * Use hash map to find complement in O(n) time
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 * 
 * For each number, check if (target - number) exists in map
 */
function twoSum(nums, target) {
  const map = new Map();
  
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    
    // Check if complement exists
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    
    // Store current number and index
    map.set(nums[i], i);
  }
  
  return null;
}

// Test
console.log('\n=== Hash Map Approach (Optimal) ===');
console.log('[2,7,11,15], target 9:', twoSum([2, 7, 11, 15], 9)); // [0, 1]
console.log('[3,2,4], target 6:', twoSum([3, 2, 4], 6)); // [1, 2]
console.log('[3,3], target 6:', twoSum([3, 3], 6)); // [0, 1]
console.log('[1,2,3,4], target 7:', twoSum([1, 2, 3, 4], 7)); // [2, 3]
```

### **Approach 3: Two Pointers (Sorted Array)**
```javascript
/**
 * Two pointers approach for sorted array
 * Time Complexity: O(n log n) for sorting + O(n) = O(n log n)
 * Space Complexity: O(n) to store indices
 * 
 * Only use if array is already sorted or sorting is acceptable
 */
function twoSumTwoPointers(nums, target) {
  // Create array of [value, originalIndex] pairs
  const indexed = nums.map((num, i) => [num, i]);
  
  // Sort by value
  indexed.sort((a, b) => a[0] - b[0]);
  
  let left = 0;
  let right = indexed.length - 1;
  
  while (left < right) {
    const sum = indexed[left][0] + indexed[right][0];
    
    if (sum === target) {
      return [indexed[left][1], indexed[right][1]].sort((a, b) => a - b);
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  
  return null;
}

// Test
console.log('\n=== Two Pointers Approach ===');
console.log('[2,7,11,15], target 9:', twoSumTwoPointers([2, 7, 11, 15], 9)); // [0, 1]
console.log('[3,2,4], target 6:', twoSumTwoPointers([3, 2, 4], 6)); // [1, 2]
console.log('[1,5,3,7], target 8:', twoSumTwoPointers([1, 5, 3, 7], 8)); // [0, 3]
```

### **Approach 4: Return All Pairs**
```javascript
/**
 * Find all pairs that sum to target (not just indices)
 * Returns array of pairs
 * Time: O(n), Space: O(n)
 */
function twoSumAllPairs(nums, target) {
  const seen = new Set();
  const pairs = [];
  const used = new Set();
  
  for (let num of nums) {
    const complement = target - num;
    
    if (seen.has(complement)) {
      // Create sorted pair to avoid duplicates
      const pair = [Math.min(num, complement), Math.max(num, complement)];
      const pairKey = pair.join(',');
      
      if (!used.has(pairKey)) {
        pairs.push(pair);
        used.add(pairKey);
      }
    }
    
    seen.add(num);
  }
  
  return pairs;
}

// Test
console.log('\n=== All Pairs ===');
console.log('[1,2,3,4,3], target 6:', twoSumAllPairs([1, 2, 3, 4, 3], 6));
// [[2, 4], [3, 3]]

console.log('[1,1,1,1], target 2:', twoSumAllPairs([1, 1, 1, 1], 2));
// [[1, 1]]

console.log('[2,7,11,15,4,5], target 9:', twoSumAllPairs([2, 7, 11, 15, 4, 5], 9));
// [[2, 7], [4, 5]]
```

### **Bonus: Two Sum with Multiple Solutions**
```javascript
/**
 * Find all index pairs that sum to target
 * Returns all possible index combinations
 */
function twoSumAllIndices(nums, target) {
  const result = [];
  
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        result.push([i, j]);
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== All Index Pairs ===');
console.log('[1,2,3,2,4], target 4:', twoSumAllIndices([1, 2, 3, 2, 4], 4));
// [[0, 2], [1, 3]]

console.log('[3,3,3], target 6:', twoSumAllIndices([3, 3, 3], 6));
// [[0, 1], [0, 2], [1, 2]]
```

### **Bonus: Two Sum - Count Pairs**
```javascript
/**
 * Count how many pairs sum to target
 * Time: O(n), Space: O(n)
 */
function twoSumCount(nums, target) {
  const map = new Map();
  let count = 0;
  
  for (let num of nums) {
    const complement = target - num;
    
    if (map.has(complement)) {
      count += map.get(complement);
    }
    
    map.set(num, (map.get(num) || 0) + 1);
  }
  
  return count;
}

// Test
console.log('\n=== Count Pairs ===');
console.log('[1,2,3,2,4], target 4:', twoSumCount([1, 2, 3, 2, 4], 4)); // 2
console.log('[1,1,1,1], target 2:', twoSumCount([1, 1, 1, 1], 2)); // 6
console.log('[3,3,3], target 6:', twoSumCount([3, 3, 3], 6)); // 3
```

### **Bonus: Two Sum - Sorted Array (No Extra Space)**
```javascript
/**
 * Two sum for pre-sorted array
 * Time: O(n), Space: O(1)
 */
function twoSumSorted(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  
  while (left < right) {
    const sum = nums[left] + nums[right];
    
    if (sum === target) {
      return [left, right];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  
  return null;
}

// Test
console.log('\n=== Sorted Array (No Extra Space) ===');
console.log('[1,2,3,4], target 5:', twoSumSorted([1, 2, 3, 4], 5)); // [0, 3]
console.log('[2,7,11,15], target 9:', twoSumSorted([2, 7, 11, 15], 9)); // [0, 1]
```

### **Bonus: Two Sum - Data Structure Design**
```javascript
/**
 * Design a data structure that supports add and find
 * Optimize for either add or find operation
 */
class TwoSum {
  constructor() {
    this.nums = [];
    this.map = new Map();
  }
  
  // Add number to data structure
  add(num) {
    this.nums.push(num);
    this.map.set(num, (this.map.get(num) || 0) + 1);
  }
  
  // Find if there exists any pair that sums to target
  find(target) {
    for (let num of this.map.keys()) {
      const complement = target - num;
      
      if (complement === num) {
        // Need at least 2 occurrences
        if (this.map.get(num) >= 2) return true;
      } else {
        if (this.map.has(complement)) return true;
      }
    }
    
    return false;
  }
}

// Test
console.log('\n=== TwoSum Data Structure ===');
const twoSumDS = new TwoSum();
twoSumDS.add(1);
twoSumDS.add(3);
twoSumDS.add(5);
console.log('Find 4:', twoSumDS.find(4)); // true (1 + 3)
console.log('Find 7:', twoSumDS.find(7)); // false
twoSumDS.add(2);
console.log('Find 7:', twoSumDS.find(7)); // true (2 + 5)
console.log('Find 6:', twoSumDS.find(6)); // true (1 + 5)
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// No solution
console.log('No solution:', twoSum([1, 2, 3], 7)); // null

// Negative numbers
console.log('Negative:', twoSum([-1, -2, -3, -4], -6)); // [1, 3] or [2, 3]

// Zero
console.log('With zero:', twoSum([0, 4, 3, 0], 0)); // [0, 3]

// Large numbers
console.log('Large:', twoSum([1000000000, 1000000001], 2000000001)); // [0, 1]

// Minimum array
console.log('Two elements:', twoSum([1, 2], 3)); // [0, 1]

// Same number twice
console.log('Same twice:', twoSum([3, 3], 6)); // [0, 1]

// Multiple valid pairs (returns first found)
console.log('Multiple pairs:', twoSum([1, 2, 3, 4, 5], 5)); // [0, 3] or [1, 2]
```

### **Performance Comparison**
```javascript
/**
 * Compare different approaches
 */
function benchmarkTwoSum(size) {
  const nums = Array.from({ length: size }, () => Math.floor(Math.random() * size));
  const target = nums[0] + nums[1]; // Ensure solution exists
  
  console.log(`\nArray size: ${size.toLocaleString()}`);
  
  // Brute Force
  let start = performance.now();
  twoSumBruteForce(nums, target);
  let time = performance.now() - start;
  console.log(`Brute Force: ${time.toFixed(4)}ms`);
  
  // Hash Map
  start = performance.now();
  twoSum(nums, target);
  time = performance.now() - start;
  console.log(`Hash Map: ${time.toFixed(4)}ms`);
  
  // Two Pointers
  start = performance.now();
  twoSumTwoPointers(nums, target);
  time = performance.now() - start;
  console.log(`Two Pointers: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmarkTwoSum(1000);
benchmarkTwoSum(5000);
```

**Interview Tips:**
- Classic problem, know it well - very common in interviews
- Hash map approach is optimal: O(n) time, O(n) space
- Key insight: for each number, check if (target - number) exists
- One-pass hash map: store as you iterate, check complement first
- Two pointers only works if array is sorted: O(n) time, O(1) space
- Brute force O(n²) acceptable only for very small arrays
- Handle edge cases: no solution, duplicates, negative numbers, zero
- Clarify: return indices or values? first pair or all pairs? sorted array?
- Similar problems: 3Sum, 4Sum, Two Sum II (sorted), Two Sum III (data structure)
- Variations: count pairs, find all pairs, closest to target, less than target
- Can't use same element twice (i ≠ j)
- If sorted array given, use two pointers (O(1) space)
- For unsorted, hash map is best (O(n) time)
- Follow-ups: what if multiple solutions? what if need all pairs? what about 3sum?
- Real applications: finding complements, pair matching, subset sum variant

</details>

72. Solve the "Three Sum" problem

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Sort + Two Pointers (Optimal)**
```javascript
/**
 * Find all unique triplets that sum to zero
 * Time Complexity: O(n²)
 * Space Complexity: O(1) excluding output
 * 
 * Sort array, fix one element, use two pointers for remaining two
 */
function threeSum(nums) {
  const result = [];
  const n = nums.length;
  
  // Sort array for two pointers approach
  nums.sort((a, b) => a - b);
  
  for (let i = 0; i < n - 2; i++) {
    // Skip duplicates for first element
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    
    // Two pointers for remaining elements
    let left = i + 1;
    let right = n - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]]);
        
        // Skip duplicates for second element
        while (left < right && nums[left] === nums[left + 1]) left++;
        // Skip duplicates for third element
        while (left < right && nums[right] === nums[right - 1]) right--;
        
        left++;
        right--;
      } else if (sum < 0) {
        left++;
      } else {
        right--;
      }
    }
  }
  
  return result;
}

// Test
console.log('=== Three Sum (Optimal) ===');
console.log('[-1,0,1,2,-1,-4]:', threeSum([-1, 0, 1, 2, -1, -4]));
// [[-1, -1, 2], [-1, 0, 1]]

console.log('\n[0,0,0]:', threeSum([0, 0, 0]));
// [[0, 0, 0]]

console.log('\n[0,1,1]:', threeSum([0, 1, 1]));
// []

console.log('\n[-2,0,1,1,2]:', threeSum([-2, 0, 1, 1, 2]));
// [[-2, 0, 2], [-2, 1, 1]]
```

### **Approach 2: Hash Set (Alternative)**
```javascript
/**
 * Use hash set for each pair to find third element
 * Time: O(n²), Space: O(n)
 */
function threeSumHashSet(nums) {
  const result = [];
  const n = nums.length;
  
  // Sort to handle duplicates
  nums.sort((a, b) => a - b);
  
  for (let i = 0; i < n - 2; i++) {
    // Skip duplicate first elements
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    
    const seen = new Set();
    const target = -nums[i];
    
    for (let j = i + 1; j < n; j++) {
      const complement = target - nums[j];
      
      if (seen.has(complement)) {
        result.push([nums[i], complement, nums[j]]);
        
        // Skip duplicates for second element
        while (j + 1 < n && nums[j] === nums[j + 1]) j++;
      }
      
      seen.add(nums[j]);
    }
  }
  
  return result;
}

// Test
console.log('\n=== Three Sum (Hash Set) ===');
console.log('[-1,0,1,2,-1,-4]:', threeSumHashSet([-1, 0, 1, 2, -1, -4]));
// [[-1, -1, 2], [-1, 0, 1]]

console.log('\n[-2,0,0,2,2]:', threeSumHashSet([-2, 0, 0, 2, 2]));
// [[-2, 0, 2]]
```

### **Approach 3: Three Sum with Custom Target**
```javascript
/**
 * Find triplets that sum to any target (not just 0)
 * Time: O(n²), Space: O(1)
 */
function threeSumTarget(nums, target) {
  const result = [];
  const n = nums.length;
  
  nums.sort((a, b) => a - b);
  
  for (let i = 0; i < n - 2; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    
    let left = i + 1;
    let right = n - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      if (sum === target) {
        result.push([nums[i], nums[left], nums[right]]);
        
        while (left < right && nums[left] === nums[left + 1]) left++;
        while (left < right && nums[right] === nums[right - 1]) right--;
        
        left++;
        right--;
      } else if (sum < target) {
        left++;
      } else {
        right--;
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== Three Sum with Target ===');
console.log('[1,2,3,4,5], target=9:', threeSumTarget([1, 2, 3, 4, 5], 9));
// [[1, 3, 5], [2, 3, 4]]

console.log('\n[-1,0,1,2,-1,-4], target=0:', threeSumTarget([-1, 0, 1, 2, -1, -4], 0));
// [[-1, -1, 2], [-1, 0, 1]]

console.log('\n[1,2,3,4], target=10:', threeSumTarget([1, 2, 3, 4], 10));
// []
```

### **Approach 4: Three Sum Closest**
```javascript
/**
 * Find triplet with sum closest to target
 * Time: O(n²), Space: O(1)
 */
function threeSumClosest(nums, target) {
  nums.sort((a, b) => a - b);
  let closestSum = nums[0] + nums[1] + nums[2];
  
  for (let i = 0; i < nums.length - 2; i++) {
    let left = i + 1;
    let right = nums.length - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      // Update closest sum if current is closer
      if (Math.abs(target - sum) < Math.abs(target - closestSum)) {
        closestSum = sum;
      }
      
      if (sum === target) {
        return sum; // Exact match
      } else if (sum < target) {
        left++;
      } else {
        right--;
      }
    }
  }
  
  return closestSum;
}

// Test
console.log('\n=== Three Sum Closest ===');
console.log('[-1,2,1,-4], target=1:', threeSumClosest([-1, 2, 1, -4], 1)); // 2
console.log('[0,0,0], target=1:', threeSumClosest([0, 0, 0], 1)); // 0
console.log('[1,1,1,0], target=-100:', threeSumClosest([1, 1, 1, 0], -100)); // 2
```

### **Approach 5: Three Sum Smaller**
```javascript
/**
 * Count triplets with sum less than target
 * Time: O(n²), Space: O(1)
 */
function threeSumSmaller(nums, target) {
  nums.sort((a, b) => a - b);
  let count = 0;
  
  for (let i = 0; i < nums.length - 2; i++) {
    let left = i + 1;
    let right = nums.length - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      if (sum < target) {
        // All elements between left and right work with current left
        count += right - left;
        left++;
      } else {
        right--;
      }
    }
  }
  
  return count;
}

// Test
console.log('\n=== Three Sum Smaller ===');
console.log('[-2,0,1,3], target=2:', threeSumSmaller([-2, 0, 1, 3], 2)); // 2
console.log('[0,0,0], target=0:', threeSumSmaller([0, 0, 0], 0)); // 0
console.log('[1,1,1,1], target=5:', threeSumSmaller([1, 1, 1, 1], 5)); // 4
```

### **Bonus: Three Sum with Multiplicity**
```javascript
/**
 * Count triplets (i,j,k) where i < j < k and nums[i]+nums[j]+nums[k] = target
 * Allows using same value multiple times if at different indices
 * Time: O(n²), Space: O(n)
 */
function threeSumMultiplicity(nums, target) {
  const MOD = 1e9 + 7;
  const count = new Map();
  let result = 0;
  
  // Count frequency of each number
  for (let num of nums) {
    count.set(num, (count.get(num) || 0) + 1);
  }
  
  const uniqueNums = [...count.keys()].sort((a, b) => a - b);
  
  for (let i = 0; i < uniqueNums.length; i++) {
    for (let j = i; j < uniqueNums.length; j++) {
      const k = target - uniqueNums[i] - uniqueNums[j];
      
      if (!count.has(k)) continue;
      
      if (i === j && j === k) {
        // All three same: C(n,3) = n*(n-1)*(n-2)/6
        const n = count.get(uniqueNums[i]);
        result += n * (n - 1) * (n - 2) / 6;
      } else if (i === j && j < k && uniqueNums[k] > uniqueNums[j]) {
        // Two same: C(n,2) * m = n*(n-1)/2 * m
        const n = count.get(uniqueNums[i]);
        const m = count.get(k);
        result += n * (n - 1) / 2 * m;
      } else if (j < k && uniqueNums[k] > uniqueNums[j]) {
        // All different: n * m * p
        result += count.get(uniqueNums[i]) * count.get(uniqueNums[j]) * count.get(k);
      }
    }
  }
  
  return result % MOD;
}

// Test
console.log('\n=== Three Sum Multiplicity ===');
console.log('[1,1,2,2,3,3,4,4,5,5], target=8:', threeSumMultiplicity([1,1,2,2,3,3,4,4,5,5], 8));
console.log('[1,1,2,2,2,2], target=5:', threeSumMultiplicity([1,1,2,2,2,2], 5));
```

### **Bonus: All Unique Triplets (No Duplicates)**
```javascript
/**
 * Find all unique triplets without duplicates
 * Uses Set to ensure uniqueness
 */
function threeSumUnique(nums) {
  const result = new Set();
  const n = nums.length;
  
  for (let i = 0; i < n - 2; i++) {
    const seen = new Set();
    
    for (let j = i + 1; j < n; j++) {
      const complement = -(nums[i] + nums[j]);
      
      if (seen.has(complement)) {
        // Create sorted triplet to avoid duplicates
        const triplet = [nums[i], nums[j], complement].sort((a, b) => a - b);
        result.add(triplet.join(','));
      }
      
      seen.add(nums[j]);
    }
  }
  
  return Array.from(result).map(s => s.split(',').map(Number));
}

// Test
console.log('\n=== Unique Triplets ===');
console.log('[-1,0,1,2,-1,-4]:', threeSumUnique([-1, 0, 1, 2, -1, -4]));
// [[-1, -1, 2], [-1, 0, 1]]
```

### **Visualization**
```javascript
/**
 * Visualize the three sum process
 */
function threeSumVisualize(nums) {
  console.log('\n=== Three Sum Visualization ===');
  console.log('Input:', nums);
  
  const result = [];
  nums.sort((a, b) => a - b);
  console.log('Sorted:', nums);
  
  for (let i = 0; i < nums.length - 2; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) {
      console.log(`Skipping duplicate i=${i}: ${nums[i]}`);
      continue;
    }
    
    console.log(`\nFixed nums[${i}] = ${nums[i]}, target = ${-nums[i]}`);
    
    let left = i + 1;
    let right = nums.length - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      console.log(`  Checking: ${nums[i]} + ${nums[left]} + ${nums[right]} = ${sum}`);
      
      if (sum === 0) {
        console.log(`    ✓ Found triplet!`);
        result.push([nums[i], nums[left], nums[right]]);
        
        while (left < right && nums[left] === nums[left + 1]) {
          console.log(`    Skipping duplicate left: ${nums[left]}`);
          left++;
        }
        while (left < right && nums[right] === nums[right - 1]) {
          console.log(`    Skipping duplicate right: ${nums[right]}`);
          right--;
        }
        
        left++;
        right--;
      } else if (sum < 0) {
        console.log(`    Sum too small, move left pointer`);
        left++;
      } else {
        console.log(`    Sum too large, move right pointer`);
        right--;
      }
    }
  }
  
  console.log('\nResult:', result);
  return result;
}

// Demo
threeSumVisualize([-1, 0, 1, 2, -1, -4]);
```

### **Edge Cases**
```javascript
console.log('\n=== Edge Cases ===');

// Empty array
console.log('Empty:', threeSum([])); // []

// Less than 3 elements
console.log('Two elements:', threeSum([1, 2])); // []

// All zeros
console.log('All zeros:', threeSum([0, 0, 0, 0])); // [[0, 0, 0]]

// All positive (no solution)
console.log('All positive:', threeSum([1, 2, 3, 4])); // []

// All negative (no solution)
console.log('All negative:', threeSum([-1, -2, -3, -4])); // []

// Exactly 3 elements
console.log('Exactly 3:', threeSum([1, -1, 0])); // [[1, -1, 0]]

// Multiple solutions
console.log('Multiple:', threeSum([-4, -2, -1, 0, 1, 2, 3, 4]));
// [[-4, 0, 4], [-4, 1, 3], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]

// Large numbers
console.log('Large:', threeSum([1000000, -1000000, 0])); // [[-1000000, 0, 1000000]]
```

### **Performance Comparison**
```javascript
/**
 * Compare different approaches
 */
function benchmarkThreeSum(size) {
  const nums = Array.from({ length: size }, () => Math.floor(Math.random() * size) - size / 2);
  
  console.log(`\nArray size: ${size.toLocaleString()}`);
  
  // Two Pointers
  let start = performance.now();
  threeSum([...nums]);
  let time = performance.now() - start;
  console.log(`Two Pointers: ${time.toFixed(4)}ms`);
  
  // Hash Set
  start = performance.now();
  threeSumHashSet([...nums]);
  time = performance.now() - start;
  console.log(`Hash Set: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmarkThreeSum(100);
benchmarkThreeSum(500);
benchmarkThreeSum(1000);
```

**Interview Tips:**
- Extension of Two Sum to three numbers
- Sort + two pointers is optimal: O(n²) time, O(1) space
- Key: fix one element, use two sum on remaining
- Critical: handle duplicates by skipping same consecutive values
- Sort array first: enables two pointers and duplicate handling
- For i, j, k: skip if nums[i] === nums[i-1], nums[j] === nums[j+1], nums[k] === nums[k-1]
- Why sort? Allows two pointers and easy duplicate detection
- O(n²) is best possible for this problem
- Variations: target sum, closest sum, smaller than target, count triplets
- Can't improve time complexity beyond O(n²)
- Common mistake: forgetting to skip duplicates
- Edge cases: empty, < 3 elements, all zeros, no solution, all same
- Follow-ups: 4Sum O(n³), kSum, three sum closest, three sum smaller
- Clarify: unique triplets? indices or values? sorted input?
- Optimization: break early if nums[i] > 0 and sorted (all positive)
- Applications: subset sum, combination problems, finding patterns

</details>

73. Find the longest common prefix among an array of strings

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Horizontal Scanning**
```javascript
/**
 * Compare strings one by one, reducing prefix each time
 * Time Complexity: O(S) where S is sum of all characters
 * Space Complexity: O(1)
 */
function longestCommonPrefix(strs) {
  if (strs.length === 0) return '';
  
  let prefix = strs[0];
  
  for (let i = 1; i < strs.length; i++) {
    // Reduce prefix until it matches start of current string
    while (strs[i].indexOf(prefix) !== 0) {
      prefix = prefix.substring(0, prefix.length - 1);
      if (prefix === '') return '';
    }
  }
  
  return prefix;
}

// Test
console.log('=== Horizontal Scanning ===');
console.log('["flower","flow","flight"]:', longestCommonPrefix(['flower', 'flow', 'flight'])); // "fl"
console.log('["dog","racecar","car"]:', longestCommonPrefix(['dog', 'racecar', 'car'])); // ""
console.log('["interspecies","interstellar","interstate"]:', 
  longestCommonPrefix(['interspecies', 'interstellar', 'interstate'])); // "inters"
```

### **Approach 2: Vertical Scanning**
```javascript
/**
 * Compare characters at same position across all strings
 * Time: O(S), Space: O(1)
 */
function longestCommonPrefixVertical(strs) {
  if (strs.length === 0) return '';
  
  // Check each character position
  for (let i = 0; i < strs[0].length; i++) {
    const char = strs[0][i];
    
    // Check if this character matches in all strings
    for (let j = 1; j < strs.length; j++) {
      if (i >= strs[j].length || strs[j][i] !== char) {
        return strs[0].substring(0, i);
      }
    }
  }
  
  return strs[0];
}

// Test
console.log('\n=== Vertical Scanning ===');
console.log('["flower","flow","flight"]:', longestCommonPrefixVertical(['flower', 'flow', 'flight'])); // "fl"
console.log('["ab","a"]:', longestCommonPrefixVertical(['ab', 'a'])); // "a"
console.log('["hello","hello","hello"]:', longestCommonPrefixVertical(['hello', 'hello', 'hello'])); // "hello"
```

### **Approach 3: Divide and Conquer**
```javascript
/**
 * Divide array in half, find prefix recursively, then merge
 * Time: O(S), Space: O(m log n) for recursion
 */
function longestCommonPrefixDivide(strs) {
  if (strs.length === 0) return '';
  return divideConquer(strs, 0, strs.length - 1);
}

function divideConquer(strs, left, right) {
  if (left === right) {
    return strs[left];
  }
  
  const mid = Math.floor((left + right) / 2);
  const lcpLeft = divideConquer(strs, left, mid);
  const lcpRight = divideConquer(strs, mid + 1, right);
  
  return commonPrefix(lcpLeft, lcpRight);
}

function commonPrefix(str1, str2) {
  const minLen = Math.min(str1.length, str2.length);
  
  for (let i = 0; i < minLen; i++) {
    if (str1[i] !== str2[i]) {
      return str1.substring(0, i);
    }
  }
  
  return str1.substring(0, minLen);
}

// Test
console.log('\n=== Divide and Conquer ===');
console.log('["flower","flow","flight"]:', longestCommonPrefixDivide(['flower', 'flow', 'flight'])); // "fl"
console.log('["a","a","b"]:', longestCommonPrefixDivide(['a', 'a', 'b'])); // ""
```

### **Approach 4: Binary Search**
```javascript
/**
 * Binary search on prefix length
 * Time: O(S log m) where m is length of shortest string
 * Space: O(1)
 */
function longestCommonPrefixBinary(strs) {
  if (strs.length === 0) return '';
  
  // Find minimum length
  let minLen = Math.min(...strs.map(s => s.length));
  
  let low = 0;
  let high = minLen;
  
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    
    if (isCommonPrefix(strs, mid)) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  
  return strs[0].substring(0, high);
}

function isCommonPrefix(strs, len) {
  const prefix = strs[0].substring(0, len);
  
  for (let i = 1; i < strs.length; i++) {
    if (!strs[i].startsWith(prefix)) {
      return false;
    }
  }
  
  return true;
}

// Test
console.log('\n=== Binary Search ===');
console.log('["flower","flow","flight"]:', longestCommonPrefixBinary(['flower', 'flow', 'flight'])); // "fl"
console.log('["abc","abcd","abcde"]:', longestCommonPrefixBinary(['abc', 'abcd', 'abcde'])); // "abc"
```

### **Approach 5: Trie (Efficient for Multiple Queries)**
```javascript
/**
 * Use Trie data structure
 * Useful when need to find LCP multiple times
 * Time: O(S) to build + O(m) per query
 * Space: O(S)
 */
class TrieNode {
  constructor() {
    this.children = new Map();
    this.isEnd = false;
  }
}

class Trie {
  constructor() {
    this.root = new TrieNode();
  }
  
  insert(word) {
    let node = this.root;
    
    for (let char of word) {
      if (!node.children.has(char)) {
        node.children.set(char, new TrieNode());
      }
      node = node.children.get(char);
    }
    
    node.isEnd = true;
  }
  
  longestCommonPrefix() {
    let prefix = '';
    let node = this.root;
    
    while (node.children.size === 1 && !node.isEnd) {
      const char = [...node.children.keys()][0];
      prefix += char;
      node = node.children.get(char);
    }
    
    return prefix;
  }
}

function longestCommonPrefixTrie(strs) {
  if (strs.length === 0) return '';
  if (strs.length === 1) return strs[0];
  
  const trie = new Trie();
  
  // Insert all strings
  for (let str of strs) {
    if (str === '') return ''; // Empty string means no common prefix
    trie.insert(str);
  }
  
  return trie.longestCommonPrefix();
}

// Test
console.log('\n=== Trie Approach ===');
console.log('["flower","flow","flight"]:', longestCommonPrefixTrie(['flower', 'flow', 'flight'])); // "fl"
console.log('["prefix","pretest","prepare"]:', longestCommonPrefixTrie(['prefix', 'pretest', 'prepare'])); // "pre"
```

### **Bonus: Longest Common Prefix of Two Strings**
```javascript
/**
 * Find LCP of just two strings (helper function)
 */
function lcpTwo(str1, str2) {
  const minLen = Math.min(str1.length, str2.length);
  let i = 0;
  
  while (i < minLen && str1[i] === str2[i]) {
    i++;
  }
  
  return str1.substring(0, i);
}

// Test
console.log('\n=== LCP of Two Strings ===');
console.log('flower, flow:', lcpTwo('flower', 'flow')); // "flow"
console.log('abc, xyz:', lcpTwo('abc', 'xyz')); // ""
console.log('hello, hello:', lcpTwo('hello', 'hello')); // "hello"
```

### **Bonus: Longest Common Suffix**
```javascript
/**
 * Find longest common suffix instead of prefix
 */
function longestCommonSuffix(strs) {
  if (strs.length === 0) return '';
  
  let suffix = strs[0];
  
  for (let i = 1; i < strs.length; i++) {
    while (!strs[i].endsWith(suffix)) {
      suffix = suffix.substring(1);
      if (suffix === '') return '';
    }
  }
  
  return suffix;
}

// Test
console.log('\n=== Longest Common Suffix ===');
console.log('["testing","walking","running"]:', longestCommonSuffix(['testing', 'walking', 'running'])); // "ing"
console.log('["abc","bbc","cbc"]:', longestCommonSuffix(['abc', 'bbc', 'cbc'])); // "bc"
```

### **Bonus: All Common Prefixes**
```javascript
/**
 * Find all common prefixes at each position
 */
function allCommonPrefixes(strs) {
  if (strs.length === 0) return [];
  
  const prefixes = [];
  
  for (let i = 0; i < strs[0].length; i++) {
    const char = strs[0][i];
    let isCommon = true;
    
    for (let j = 1; j < strs.length; j++) {
      if (i >= strs[j].length || strs[j][i] !== char) {
        isCommon = false;
        break;
      }
    }
    
    if (isCommon) {
      prefixes.push(strs[0].substring(0, i + 1));
    } else {
      break;
    }
  }
  
  return prefixes;
}

// Test
console.log('\n=== All Common Prefixes ===');
console.log('["flower","flow","flight"]:', allCommonPrefixes(['flower', 'flow', 'flight'])); // ["f", "fl"]
console.log('["abc","abcd","ab"]:', allCommonPrefixes(['abc', 'abcd', 'ab'])); // ["a", "ab"]
```

### **Edge Cases**
```javascript
console.log('\n=== Edge Cases ===');

// Empty array
console.log('Empty array:', longestCommonPrefix([])); // ""

// Single string
console.log('Single string:', longestCommonPrefix(['hello'])); // "hello"

// Empty string in array
console.log('Contains empty:', longestCommonPrefix(['hello', '', 'world'])); // ""

// No common prefix
console.log('No common:', longestCommonPrefix(['abc', 'def', 'ghi'])); // ""

// All same strings
console.log('All same:', longestCommonPrefix(['test', 'test', 'test'])); // "test"

// One string is prefix of another
console.log('One is prefix:', longestCommonPrefix(['flow', 'flower', 'flowing'])); // "flow"

// Very short strings
console.log('Single chars:', longestCommonPrefix(['a', 'a', 'b'])); // ""

// Case sensitive
console.log('Case sensitive:', longestCommonPrefix(['Hello', 'hello'])); // ""
```

### **Performance Comparison**
```javascript
/**
 * Compare different approaches
 */
function benchmarkLCP(size, stringLength) {
  const strs = Array.from({ length: size }, () => {
    const prefix = 'common';
    const suffix = Array.from({ length: stringLength - prefix.length }, 
      () => String.fromCharCode(97 + Math.floor(Math.random() * 26))).join('');
    return prefix + suffix;
  });
  
  console.log(`\nArray size: ${size}, String length: ${stringLength}`);
  
  // Horizontal
  let start = performance.now();
  longestCommonPrefix(strs);
  let time = performance.now() - start;
  console.log(`Horizontal: ${time.toFixed(4)}ms`);
  
  // Vertical
  start = performance.now();
  longestCommonPrefixVertical(strs);
  time = performance.now() - start;
  console.log(`Vertical: ${time.toFixed(4)}ms`);
  
  // Binary Search
  start = performance.now();
  longestCommonPrefixBinary(strs);
  time = performance.now() - start;
  console.log(`Binary Search: ${time.toFixed(4)}ms`);
  
  // Trie
  start = performance.now();
  longestCommonPrefixTrie(strs);
  time = performance.now() - start;
  console.log(`Trie: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmarkLCP(100, 50);
benchmarkLCP(1000, 100);
```

**Interview Tips:**
- Multiple valid approaches: horizontal, vertical, divide & conquer, binary search, trie
- Horizontal scanning simplest: compare strings one by one
- Vertical scanning more efficient: stops at first mismatch
- All approaches O(S) where S = sum of all characters
- Key insight: LCP can't be longer than shortest string
- Edge case: empty array, single string, empty string in array
- Optimization: find shortest string first, limit search to its length
- Trie useful when finding LCP multiple times (preprocessing)
- Binary search on prefix length: O(S log m) where m = min length
- Related problems: longest common suffix, substring problems
- Clarify: case sensitive? special characters? Unicode?
- Common mistakes: not handling empty strings, not checking bounds
- Can optimize by finding shortest string first
- Applications: autocomplete, finding common path, DNA sequence analysis
- Follow-ups: longest common substring, edit distance, pattern matching

</details>

74. Implement a function to validate a binary search tree

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Recursive with Range (Optimal)**
```javascript
/**
 * Validate BST using recursive range checking
 * Time Complexity: O(n) - visit each node once
 * Space Complexity: O(h) - recursion stack, h = height
 * 
 * BST property: left.val < node.val < right.val
 * AND all left subtree < node.val < all right subtree
 */
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function isValidBST(root) {
  return validate(root, -Infinity, Infinity);
}

function validate(node, min, max) {
  // Empty tree is valid BST
  if (node === null) return true;
  
  // Current node must be within range
  if (node.val <= min || node.val >= max) {
    return false;
  }
  
  // Recursively validate left and right subtrees
  // Left subtree: all values must be < node.val
  // Right subtree: all values must be > node.val
  return validate(node.left, min, node.val) && 
         validate(node.right, node.val, max);
}

// Test
console.log('=== Recursive with Range (Optimal) ===');

// Valid BST:     2
//               / \
//              1   3
const tree1 = new TreeNode(2, new TreeNode(1), new TreeNode(3));
console.log('Valid BST [2,1,3]:', isValidBST(tree1)); // true

// Invalid BST:   5
//               / \
//              1   4
//                 / \
//                3   6
const tree2 = new TreeNode(5, 
  new TreeNode(1),
  new TreeNode(4, new TreeNode(3), new TreeNode(6))
);
console.log('Invalid BST [5,1,4,null,null,3,6]:', isValidBST(tree2)); // false

// Valid BST:     5
//               / \
//              3   7
//             /   / \
//            2   6   8
const tree3 = new TreeNode(5,
  new TreeNode(3, new TreeNode(2)),
  new TreeNode(7, new TreeNode(6), new TreeNode(8))
);
console.log('Valid BST [5,3,7,2,null,6,8]:', isValidBST(tree3)); // true
```

### **Approach 2: Inorder Traversal (Property-Based)**
```javascript
/**
 * Use inorder traversal property
 * Inorder of BST is sorted in ascending order
 * Time: O(n), Space: O(n)
 */
function isValidBSTInorder(root) {
  const values = [];
  
  function inorder(node) {
    if (node === null) return;
    
    inorder(node.left);
    values.push(node.val);
    inorder(node.right);
  }
  
  inorder(root);
  
  // Check if array is strictly increasing
  for (let i = 1; i < values.length; i++) {
    if (values[i] <= values[i - 1]) {
      return false;
    }
  }
  
  return true;
}

// Test
console.log('\n=== Inorder Traversal ===');
const tree4 = new TreeNode(2, new TreeNode(1), new TreeNode(3));
console.log('Valid BST [2,1,3]:', isValidBSTInorder(tree4)); // true

const tree5 = new TreeNode(5,
  new TreeNode(1),
  new TreeNode(4, new TreeNode(3), new TreeNode(6))
);
console.log('Invalid BST [5,1,4,3,6]:', isValidBSTInorder(tree5)); // false
```

### **Approach 3: Inorder with Early Termination**
```javascript
/**
 * Inorder traversal with early exit
 * Don't need to store all values
 * Time: O(n), Space: O(h)
 */
function isValidBSTInorderOptimized(root) {
  let prev = -Infinity;
  
  function inorder(node) {
    if (node === null) return true;
    
    // Check left subtree
    if (!inorder(node.left)) return false;
    
    // Check current node
    if (node.val <= prev) return false;
    prev = node.val;
    
    // Check right subtree
    return inorder(node.right);
  }
  
  return inorder(root);
}

// Test
console.log('\n=== Inorder with Early Termination ===');
const tree6 = new TreeNode(2, new TreeNode(2));
console.log('Duplicate values [2,2]:', isValidBSTInorderOptimized(tree6)); // false

const tree7 = new TreeNode(10,
  new TreeNode(5, new TreeNode(3), new TreeNode(7)),
  new TreeNode(15, new TreeNode(12), new TreeNode(20))
);
console.log('Valid BST [10,5,15,3,7,12,20]:', isValidBSTInorderOptimized(tree7)); // true
```

### **Approach 4: Iterative with Stack**
```javascript
/**
 * Iterative approach using explicit stack
 * Avoids recursion overhead
 * Time: O(n), Space: O(h)
 */
function isValidBSTIterative(root) {
  const stack = [];
  let current = root;
  let prev = -Infinity;
  
  while (current !== null || stack.length > 0) {
    // Go to leftmost node
    while (current !== null) {
      stack.push(current);
      current = current.left;
    }
    
    // Process current node
    current = stack.pop();
    
    // Check if values are in ascending order
    if (current.val <= prev) {
      return false;
    }
    
    prev = current.val;
    current = current.right;
  }
  
  return true;
}

// Test
console.log('\n=== Iterative with Stack ===');
const tree8 = new TreeNode(1, null, new TreeNode(1));
console.log('Invalid [1,null,1]:', isValidBSTIterative(tree8)); // false

const tree9 = new TreeNode(3,
  new TreeNode(1, null, new TreeNode(2)),
  new TreeNode(5, new TreeNode(4), new TreeNode(6))
);
console.log('Valid BST [3,1,5,null,2,4,6]:', isValidBSTIterative(tree9)); // true
```

### **Approach 5: BFS with Range Validation**
```javascript
/**
 * Level-order traversal with min/max ranges
 * Time: O(n), Space: O(n)
 */
function isValidBSTBFS(root) {
  if (root === null) return true;
  
  const queue = [[root, -Infinity, Infinity]];
  
  while (queue.length > 0) {
    const [node, min, max] = queue.shift();
    
    // Check current node
    if (node.val <= min || node.val >= max) {
      return false;
    }
    
    // Add children with updated ranges
    if (node.left !== null) {
      queue.push([node.left, min, node.val]);
    }
    
    if (node.right !== null) {
      queue.push([node.right, node.val, max]);
    }
  }
  
  return true;
}

// Test
console.log('\n=== BFS with Range Validation ===');
const tree10 = new TreeNode(8,
  new TreeNode(4, new TreeNode(2), new TreeNode(6)),
  new TreeNode(12, new TreeNode(10), new TreeNode(14))
);
console.log('Valid BST [8,4,12,2,6,10,14]:', isValidBSTBFS(tree10)); // true
```

### **Bonus: Validate BST with Duplicates Allowed**
```javascript
/**
 * Some BST definitions allow duplicates
 * Either left.val <= node.val < right.val
 * Or left.val < node.val <= right.val
 */
function isValidBSTWithDuplicates(root, allowLeft = true) {
  return validateWithDuplicates(root, -Infinity, Infinity, allowLeft);
}

function validateWithDuplicates(node, min, max, allowLeft) {
  if (node === null) return true;
  
  if (allowLeft) {
    // Allow duplicates on left: left.val <= node.val < right.val
    if (node.val < min || node.val >= max) {
      return false;
    }
  } else {
    // Allow duplicates on right: left.val < node.val <= right.val
    if (node.val <= min || node.val > max) {
      return false;
    }
  }
  
  return validateWithDuplicates(node.left, min, node.val, allowLeft) &&
         validateWithDuplicates(node.right, node.val, max, allowLeft);
}

// Test
console.log('\n=== BST with Duplicates ===');
const tree11 = new TreeNode(2, new TreeNode(2), new TreeNode(3));
console.log('With duplicates on left [2,2,3]:', isValidBSTWithDuplicates(tree11, true)); // true
console.log('With duplicates on right [2,2,3]:', isValidBSTWithDuplicates(tree11, false)); // false
```

### **Bonus: Count Valid BST Nodes**
```javascript
/**
 * Count how many nodes satisfy BST property
 */
function countValidBSTNodes(root) {
  let count = 0;
  
  function validate(node, min, max) {
    if (node === null) return;
    
    if (node.val > min && node.val < max) {
      count++;
    }
    
    validate(node.left, min, node.val);
    validate(node.right, node.val, max);
  }
  
  validate(root, -Infinity, Infinity);
  return count;
}

// Test
console.log('\n=== Count Valid BST Nodes ===');
const tree12 = new TreeNode(5,
  new TreeNode(1),
  new TreeNode(4, new TreeNode(3), new TreeNode(6))
);
console.log('Valid nodes count:', countValidBSTNodes(tree12)); // 4 (5,1,4,6 valid, 3 invalid)
```

### **Bonus: Find Invalid Node**
```javascript
/**
 * Find the first node that violates BST property
 */
function findInvalidNode(root) {
  let result = null;
  
  function validate(node, min, max) {
    if (node === null || result !== null) return true;
    
    if (node.val <= min || node.val >= max) {
      result = node;
      return false;
    }
    
    return validate(node.left, min, node.val) &&
           validate(node.right, node.val, max);
  }
  
  validate(root, -Infinity, Infinity);
  return result;
}

// Test
console.log('\n=== Find Invalid Node ===');
const tree13 = new TreeNode(5,
  new TreeNode(1),
  new TreeNode(4, new TreeNode(3), new TreeNode(6))
);
const invalid = findInvalidNode(tree13);
console.log('Invalid node value:', invalid ? invalid.val : null); // 4
```

### **Visualization and Testing**
```javascript
/**
 * Visualize BST validation process
 */
function isValidBSTVisualize(root) {
  console.log('\n=== BST Validation Visualization ===');
  
  function validate(node, min, max, depth = 0) {
    const indent = '  '.repeat(depth);
    
    if (node === null) {
      console.log(`${indent}null - Valid (base case)`);
      return true;
    }
    
    console.log(`${indent}Node ${node.val}, range: (${min}, ${max})`);
    
    if (node.val <= min || node.val >= max) {
      console.log(`${indent}✗ Invalid! ${node.val} not in range (${min}, ${max})`);
      return false;
    }
    
    console.log(`${indent}✓ ${node.val} is in range`);
    
    console.log(`${indent}Checking left subtree (must be < ${node.val}):`);
    const leftValid = validate(node.left, min, node.val, depth + 1);
    
    console.log(`${indent}Checking right subtree (must be > ${node.val}):`);
    const rightValid = validate(node.right, node.val, max, depth + 1);
    
    return leftValid && rightValid;
  }
  
  return validate(root, -Infinity, Infinity);
}

// Demo
const demoTree = new TreeNode(5,
  new TreeNode(3, new TreeNode(2), new TreeNode(4)),
  new TreeNode(7, new TreeNode(6), new TreeNode(8))
);
console.log('Result:', isValidBSTVisualize(demoTree));
```

### **Edge Cases**
```javascript
console.log('\n=== Edge Cases ===');

// Empty tree
console.log('Empty tree:', isValidBST(null)); // true

// Single node
console.log('Single node:', isValidBST(new TreeNode(1))); // true

// Two nodes - left child
console.log('Root with left child:', isValidBST(new TreeNode(2, new TreeNode(1)))); // true

// Two nodes - right child
console.log('Root with right child:', isValidBST(new TreeNode(1, null, new TreeNode(2)))); // true

// Invalid - left child greater
console.log('Left > root:', isValidBST(new TreeNode(1, new TreeNode(2)))); // false

// Invalid - right child smaller
console.log('Right < root:', isValidBST(new TreeNode(2, null, new TreeNode(1)))); // false

// All same values
console.log('All same:', isValidBST(new TreeNode(1, new TreeNode(1), new TreeNode(1)))); // false

// Negative numbers
const negTree = new TreeNode(0, new TreeNode(-10), new TreeNode(10));
console.log('With negatives:', isValidBST(negTree)); // true

// Large tree
const largeTree = new TreeNode(50,
  new TreeNode(25, new TreeNode(12), new TreeNode(37)),
  new TreeNode(75, new TreeNode(62), new TreeNode(87))
);
console.log('Large valid BST:', isValidBST(largeTree)); // true

// Subtle invalid case: left child's right > root
const subtleInvalid = new TreeNode(5,
  new TreeNode(4, null, new TreeNode(6)),
  new TreeNode(7)
);
console.log('Subtle invalid:', isValidBST(subtleInvalid)); // false (6 > 5)
```

### **Performance Testing**
```javascript
/**
 * Build perfect BST for testing
 */
function buildPerfectBST(values) {
  if (values.length === 0) return null;
  
  const mid = Math.floor(values.length / 2);
  const node = new TreeNode(values[mid]);
  
  node.left = buildPerfectBST(values.slice(0, mid));
  node.right = buildPerfectBST(values.slice(mid + 1));
  
  return node;
}

function benchmarkBSTValidation(size) {
  const values = Array.from({ length: size }, (_, i) => i);
  const tree = buildPerfectBST(values);
  
  console.log(`\nTree size: ${size} nodes`);
  
  // Recursive with range
  let start = performance.now();
  isValidBST(tree);
  let time = performance.now() - start;
  console.log(`Recursive range: ${time.toFixed(4)}ms`);
  
  // Inorder
  start = performance.now();
  isValidBSTInorder(tree);
  time = performance.now() - start;
  console.log(`Inorder: ${time.toFixed(4)}ms`);
  
  // Iterative
  start = performance.now();
  isValidBSTIterative(tree);
  time = performance.now() - start;
  console.log(`Iterative: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmarkBSTValidation(1000);
benchmarkBSTValidation(10000);
```

**Interview Tips:**
- BST property: left subtree < node < right subtree (for ALL nodes, not just immediate children)
- Common mistake: only checking immediate children (fails for subtree violations)
- Recursive with range is most elegant: O(n) time, O(h) space
- Key insight: pass valid range (min, max) down recursively
- Inorder traversal should be strictly increasing
- Can't have duplicates in standard BST definition (clarify in interview!)
- Handle edge cases: null tree (valid), single node (valid)
- Subtle case: left subtree's right child > root (still invalid)
- Integer overflow: use -Infinity/Infinity instead of MIN_INT/MAX_INT
- Space complexity: O(h) for recursion, O(n) worst case (skewed tree)
- Iterative avoids recursion overhead
- Related problems: BST construction, BST operations, convert to sorted array
- Clarify: duplicates allowed? null tree valid? definition of BST
- Applications: validate data structures, database indexes, search trees
- Follow-ups: recover BST, find kth smallest in BST, serialize/deserialize

</details>

75. Find the lowest common ancestor in a binary tree

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Recursive Path Search**
```javascript
/**
 * Find LCA by searching for both nodes
 * Time Complexity: O(n)
 * Space Complexity: O(h) for recursion
 * 
 * LCA is the lowest node that has both p and q in its subtrees
 */
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function lowestCommonAncestor(root, p, q) {
  // Base case: reached null or found one of the nodes
  if (root === null || root === p || root === q) {
    return root;
  }
  
  // Search in left and right subtrees
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  
  // If both left and right found nodes, current node is LCA
  if (left !== null && right !== null) {
    return root;
  }
  
  // Return whichever side found a node
  return left !== null ? left : right;
}

// Test
console.log('=== Recursive Path Search ===');

//        3
//       / \
//      5   1
//     / \ / \
//    6  2 0  8
//      / \
//     7   4
const node7 = new TreeNode(7);
const node4 = new TreeNode(4);
const node2 = new TreeNode(2, node7, node4);
const node6 = new TreeNode(6);
const node5 = new TreeNode(5, node6, node2);
const node0 = new TreeNode(0);
const node8 = new TreeNode(8);
const node1 = new TreeNode(1, node0, node8);
const root = new TreeNode(3, node5, node1);

console.log('LCA(5, 1):', lowestCommonAncestor(root, node5, node1).val); // 3
console.log('LCA(5, 4):', lowestCommonAncestor(root, node5, node4).val); // 5
console.log('LCA(6, 2):', lowestCommonAncestor(root, node6, node2).val); // 5
console.log('LCA(7, 4):', lowestCommonAncestor(root, node7, node4).val); // 2
```

### **Approach 2: Store Parent Pointers**
```javascript
/**
 * Store parent pointers and trace path
 * Time: O(n), Space: O(n)
 */
function lowestCommonAncestorWithParent(root, p, q) {
  // Build parent map
  const parent = new Map();
  parent.set(root, null);
  
  const queue = [root];
  
  while (queue.length > 0) {
    const node = queue.shift();
    
    if (node.left) {
      parent.set(node.left, node);
      queue.push(node.left);
    }
    
    if (node.right) {
      parent.set(node.right, node);
      queue.push(node.right);
    }
  }
  
  // Get ancestors of p
  const ancestors = new Set();
  let current = p;
  
  while (current !== null) {
    ancestors.add(current);
    current = parent.get(current);
  }
  
  // Trace q's path until we find common ancestor
  current = q;
  while (current !== null) {
    if (ancestors.has(current)) {
      return current;
    }
    current = parent.get(current);
  }
  
  return null;
}

// Test
console.log('\n=== With Parent Pointers ===');
console.log('LCA(5, 1):', lowestCommonAncestorWithParent(root, node5, node1).val); // 3
console.log('LCA(5, 4):', lowestCommonAncestorWithParent(root, node5, node4).val); // 5
```

### **Approach 3: Store Paths**
```javascript
/**
 * Find paths from root to both nodes, then find divergence point
 * Time: O(n), Space: O(n)
 */
function lowestCommonAncestorPaths(root, p, q) {
  const pathP = [];
  const pathQ = [];
  
  findPath(root, p, pathP);
  findPath(root, q, pathQ);
  
  let lca = null;
  let i = 0;
  
  while (i < pathP.length && i < pathQ.length && pathP[i] === pathQ[i]) {
    lca = pathP[i];
    i++;
  }
  
  return lca;
}

function findPath(root, target, path) {
  if (root === null) return false;
  
  path.push(root);
  
  if (root === target) return true;
  
  if (findPath(root.left, target, path) || findPath(root.right, target, path)) {
    return true;
  }
  
  path.pop();
  return false;
}

// Test
console.log('\n=== Store Paths ===');
console.log('LCA(5, 1):', lowestCommonAncestorPaths(root, node5, node1).val); // 3
console.log('LCA(6, 2):', lowestCommonAncestorPaths(root, node6, node2).val); // 5
```

### **Approach 4: LCA in BST (Optimized for BST)**
```javascript
/**
 * If tree is BST, can optimize using values
 * Time: O(h), Space: O(1) iterative or O(h) recursive
 */
function lowestCommonAncestorBST(root, p, q) {
  const small = Math.min(p.val, q.val);
  const large = Math.max(p.val, q.val);
  
  let current = root;
  
  while (current !== null) {
    if (current.val > large) {
      // Both in left subtree
      current = current.left;
    } else if (current.val < small) {
      // Both in right subtree
      current = current.right;
    } else {
      // Split point found
      return current;
    }
  }
  
  return null;
}

// Test
console.log('\n=== LCA in BST ===');

//      6
//     / \
//    2   8
//   / \ / \
//  0  4 7  9
//    / \
//   3   5
const bst0 = new TreeNode(0);
const bst3 = new TreeNode(3);
const bst5 = new TreeNode(5);
const bst4 = new TreeNode(4, bst3, bst5);
const bst2 = new TreeNode(2, bst0, bst4);
const bst7 = new TreeNode(7);
const bst9 = new TreeNode(9);
const bst8 = new TreeNode(8, bst7, bst9);
const bstRoot = new TreeNode(6, bst2, bst8);

console.log('LCA(2, 8) in BST:', lowestCommonAncestorBST(bstRoot, bst2, bst8).val); // 6
console.log('LCA(2, 4) in BST:', lowestCommonAncestorBST(bstRoot, bst2, bst4).val); // 2
console.log('LCA(3, 5) in BST:', lowestCommonAncestorBST(bstRoot, bst3, bst5).val); // 4
```

### **Approach 5: Iterative with Stack**
```javascript
/**
 * Iterative approach avoiding recursion
 * Time: O(n), Space: O(n)
 */
function lowestCommonAncestorIterative(root, p, q) {
  const parent = new Map();
  const stack = [root];
  parent.set(root, null);
  
  // Build parent map until both p and q are found
  while (!parent.has(p) || !parent.has(q)) {
    const node = stack.pop();
    
    if (node.left) {
      parent.set(node.left, node);
      stack.push(node.left);
    }
    
    if (node.right) {
      parent.set(node.right, node);
      stack.push(node.right);
    }
  }
  
  // Collect all ancestors of p
  const ancestors = new Set();
  while (p !== null) {
    ancestors.add(p);
    p = parent.get(p);
  }
  
  // First ancestor of q that's also ancestor of p is LCA
  while (!ancestors.has(q)) {
    q = parent.get(q);
  }
  
  return q;
}

// Test
console.log('\n=== Iterative Approach ===');
console.log('LCA(5, 1):', lowestCommonAncestorIterative(root, node5, node1).val); // 3
console.log('LCA(7, 4):', lowestCommonAncestorIterative(root, node7, node4).val); // 2
```

### **Bonus: Find Distance Between Two Nodes**
```javascript
/**
 * Find distance between two nodes using LCA
 * Distance = dist(root, p) + dist(root, q) - 2 * dist(root, lca)
 */
function findDistance(root, p, q) {
  const lca = lowestCommonAncestor(root, p, q);
  
  const distP = findLevel(lca, p, 0);
  const distQ = findLevel(lca, q, 0);
  
  return distP + distQ;
}

function findLevel(root, target, level) {
  if (root === null) return -1;
  if (root === target) return level;
  
  const left = findLevel(root.left, target, level + 1);
  if (left !== -1) return left;
  
  return findLevel(root.right, target, level + 1);
}

// Test
console.log('\n=== Distance Between Nodes ===');
console.log('Distance(5, 1):', findDistance(root, node5, node1)); // 2
console.log('Distance(7, 4):', findDistance(root, node7, node4)); // 2
console.log('Distance(6, 8):', findDistance(root, node6, node8)); // 4
```

### **Bonus: All Ancestors of a Node**
```javascript
/**
 * Find all ancestors of a given node
 */
function findAllAncestors(root, target) {
  const ancestors = [];
  
  function findAncestorsHelper(node) {
    if (node === null) return false;
    
    if (node === target) return true;
    
    if (findAncestorsHelper(node.left) || findAncestorsHelper(node.right)) {
      ancestors.push(node.val);
      return true;
    }
    
    return false;
  }
  
  findAncestorsHelper(root);
  return ancestors;
}

// Test
console.log('\n=== All Ancestors ===');
console.log('Ancestors of 7:', findAllAncestors(root, node7)); // [2, 5, 3]
console.log('Ancestors of 4:', findAllAncestors(root, node4)); // [2, 5, 3]
console.log('Ancestors of 0:', findAllAncestors(root, node0)); // [1, 3]
```

### **Bonus: LCA of Multiple Nodes**
```javascript
/**
 * Find LCA of more than 2 nodes
 */
function lowestCommonAncestorMultiple(root, nodes) {
  const nodeSet = new Set(nodes);
  
  function helper(node) {
    if (node === null) return null;
    
    if (nodeSet.has(node)) return node;
    
    const left = helper(node.left);
    const right = helper(node.right);
    
    if (left !== null && right !== null) return node;
    
    return left !== null ? left : right;
  }
  
  return helper(root);
}

// Test
console.log('\n=== LCA of Multiple Nodes ===');
console.log('LCA([6, 7, 4]):', lowestCommonAncestorMultiple(root, [node6, node7, node4]).val); // 5
console.log('LCA([0, 8, 4]):', lowestCommonAncestorMultiple(root, [node0, node8, node4]).val); // 3
```

### **Visualization**
```javascript
/**
 * Visualize LCA finding process
 */
function lowestCommonAncestorVisualize(root, p, q) {
  console.log('\n=== LCA Visualization ===');
  console.log(`Finding LCA of ${p.val} and ${q.val}`);
  
  function helper(node, depth = 0) {
    const indent = '  '.repeat(depth);
    
    if (node === null) {
      console.log(`${indent}null - return null`);
      return null;
    }
    
    console.log(`${indent}At node ${node.val}`);
    
    if (node === p || node === q) {
      console.log(`${indent}Found target node ${node.val}!`);
      return node;
    }
    
    console.log(`${indent}Searching left subtree:`);
    const left = helper(node.left, depth + 1);
    
    console.log(`${indent}Searching right subtree:`);
    const right = helper(node.right, depth + 1);
    
    if (left !== null && right !== null) {
      console.log(`${indent}Both subtrees found nodes - ${node.val} is LCA!`);
      return node;
    }
    
    const result = left !== null ? left : right;
    console.log(`${indent}Returning ${result ? result.val : 'null'} from node ${node.val}`);
    return result;
  }
  
  return helper(root);
}

// Demo
const result = lowestCommonAncestorVisualize(root, node7, node4);
console.log(`\nFinal result: ${result.val}`);
```

### **Edge Cases**
```javascript
console.log('\n=== Edge Cases ===');

// One node is ancestor of another
console.log('One is ancestor (5, 6):', lowestCommonAncestor(root, node5, node6).val); // 5

// Nodes are same
const single = new TreeNode(1);
console.log('Same node:', lowestCommonAncestor(single, single, single).val); // 1

// Root is LCA
console.log('Root is LCA:', lowestCommonAncestor(root, node5, node1).val); // 3

// Two leaf nodes
console.log('Two leaves (6, 0):', lowestCommonAncestor(root, node6, node0).val); // 3

// Siblings
console.log('Siblings (5, 1):', lowestCommonAncestor(root, node5, node1).val); // 3

// Small tree
const small = new TreeNode(1, new TreeNode(2));
const leaf = small.left;
console.log('Small tree:', lowestCommonAncestor(small, small, leaf).val); // 1
```

### **Performance Testing**
```javascript
/**
 * Build balanced tree for testing
 */
function buildBalancedTree(depth) {
  if (depth === 0) return null;
  
  const node = new TreeNode(depth);
  node.left = buildBalancedTree(depth - 1);
  node.right = buildBalancedTree(depth - 1);
  
  return node;
}

function benchmarkLCA(depth) {
  const tree = buildBalancedTree(depth);
  const nodes = [];
  
  function collectNodes(node) {
    if (node === null) return;
    nodes.push(node);
    collectNodes(node.left);
    collectNodes(node.right);
  }
  
  collectNodes(tree);
  
  const p = nodes[Math.floor(nodes.length / 3)];
  const q = nodes[Math.floor(nodes.length * 2 / 3)];
  
  console.log(`\nTree depth: ${depth}, nodes: ${nodes.length}`);
  
  // Recursive
  let start = performance.now();
  lowestCommonAncestor(tree, p, q);
  let time = performance.now() - start;
  console.log(`Recursive: ${time.toFixed(4)}ms`);
  
  // Parent pointers
  start = performance.now();
  lowestCommonAncestorWithParent(tree, p, q);
  time = performance.now() - start;
  console.log(`Parent pointers: ${time.toFixed(4)}ms`);
  
  // Paths
  start = performance.now();
  lowestCommonAncestorPaths(tree, p, q);
  time = performance.now() - start;
  console.log(`Paths: ${time.toFixed(4)}ms`);
}

console.log('\n=== Performance Comparison ===');
benchmarkLCA(10);
benchmarkLCA(15);
```

**Interview Tips:**
- LCA = lowest (deepest) node that has both p and q as descendants
- Key insight: if left and right subtrees both contain target nodes, current node is LCA
- Recursive approach most elegant: O(n) time, O(h) space
- Node can be descendant of itself (if p is ancestor of q, then p is LCA)
- Base case: null or found one of target nodes
- For BST: can optimize to O(h) by using BST property
- Parent pointers approach: trace paths up and find first common ancestor
- Path storage: find paths to both nodes, then find last common node
- Handle edge cases: one is ancestor of other, nodes are same, root is LCA
- Clarify: guaranteed both nodes exist? BST or general tree? parent pointers available?
- Related problems: distance between nodes, all ancestors, LCA of multiple nodes
- Applications: file system paths, organizational hierarchy, version control
- Follow-ups: LCA in BST, LCA of multiple nodes, find distance, serialize tree
- Common mistake: assuming LCA can't be one of the input nodes
- Optimization for BST: O(h) time using value comparison

</details>

### **Asynchronous Programming**

76. Implement Promise.all() from scratch

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Promise.all Implementation**
```javascript
/**
 * Promise.all - waits for all promises to resolve or first rejection
 * Time Complexity: O(n) where n is number of promises
 * Space Complexity: O(n) for results array
 * 
 * Returns: Promise that resolves with array of results
 * Rejects: If any promise rejects
 */
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    // Handle empty array
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = [];
    let completedCount = 0;
    
    promises.forEach((promise, index) => {
      // Wrap non-promise values with Promise.resolve
      Promise.resolve(promise)
        .then(result => {
          results[index] = result;
          completedCount++;
          
          // All promises resolved
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(error => {
          // First rejection rejects entire Promise.all
          reject(error);
        });
    });
  });
}

// Test
console.log('=== Basic Promise.all ===');

const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

promiseAll([p1, p2, p3])
  .then(results => console.log('All resolved:', results)) // [1, 2, 3]
  .catch(error => console.log('Error:', error));

// Test with delay
const delay = (ms, value) => new Promise(resolve => setTimeout(() => resolve(value), ms));

promiseAll([delay(100, 'a'), delay(50, 'b'), delay(150, 'c')])
  .then(results => console.log('With delays:', results)) // ['a', 'b', 'c']
  .catch(error => console.log('Error:', error));

// Test with rejection
const p4 = Promise.resolve(1);
const p5 = Promise.reject('Error!');
const p6 = Promise.resolve(3);

promiseAll([p4, p5, p6])
  .then(results => console.log('Results:', results))
  .catch(error => console.log('Caught rejection:', error)); // 'Error!'
```

### **Approach 2: Handle Non-Promise Values**
```javascript
/**
 * More robust version handling non-promise values
 */
function promiseAllRobust(iterable) {
  return new Promise((resolve, reject) => {
    // Convert iterable to array
    const promises = Array.from(iterable);
    
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = new Array(promises.length);
    let completedCount = 0;
    let rejected = false;
    
    promises.forEach((item, index) => {
      // Handle both promises and non-promise values
      Promise.resolve(item)
        .then(result => {
          if (rejected) return; // Don't process if already rejected
          
          results[index] = result;
          completedCount++;
          
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(error => {
          if (!rejected) {
            rejected = true;
            reject(error);
          }
        });
    });
  });
}

// Test
console.log('\n=== Robust Promise.all ===');

// Mix of promises and values
promiseAllRobust([1, Promise.resolve(2), 3, delay(50, 4)])
  .then(results => console.log('Mixed values:', results)) // [1, 2, 3, 4]
  .catch(error => console.log('Error:', error));

// Test with Set
const promiseSet = new Set([
  Promise.resolve('a'),
  Promise.resolve('b'),
  Promise.resolve('c')
]);

promiseAllRobust(promiseSet)
  .then(results => console.log('From Set:', results)) // ['a', 'b', 'c']
  .catch(error => console.log('Error:', error));
```

### **Approach 3: With Index Preservation**
```javascript
/**
 * Ensure results maintain order regardless of completion order
 */
function promiseAllOrdered(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises) || promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = [];
    let settled = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          // Store at correct index
          results[index] = value;
          settled++;
          
          if (settled === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });
  });
}

// Test - results should be in order regardless of completion time
console.log('\n=== Order Preservation ===');

promiseAllOrdered([
  delay(200, 'slow'),
  delay(50, 'fast'),
  delay(100, 'medium')
])
  .then(results => console.log('Ordered:', results)) // ['slow', 'fast', 'medium']
  .catch(error => console.log('Error:', error));
```

### **Approach 4: With Detailed Error Information**
```javascript
/**
 * Enhanced version that provides error context
 */
function promiseAllWithContext(promises) {
  return new Promise((resolve, reject) => {
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = [];
    let completedCount = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(result => {
          results[index] = result;
          completedCount++;
          
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(error => {
          // Provide context about which promise failed
          reject({
            error,
            index,
            message: `Promise at index ${index} failed`
          });
        });
    });
  });
}

// Test
console.log('\n=== With Error Context ===');

promiseAllWithContext([
  Promise.resolve(1),
  Promise.reject(new Error('Failed!')),
  Promise.resolve(3)
])
  .then(results => console.log('Results:', results))
  .catch(error => console.log('Error with context:', error));
```

### **Approach 5: Async/Await Implementation**
```javascript
/**
 * Modern implementation using async/await
 */
async function promiseAllAsync(promises) {
  if (promises.length === 0) {
    return [];
  }
  
  const results = [];
  
  // Create array of promise wrappers that capture index
  const wrappedPromises = promises.map((promise, index) => 
    Promise.resolve(promise).then(result => {
      results[index] = result;
      return result;
    })
  );
  
  // Wait for all to complete
  await Promise.all(wrappedPromises);
  
  return results;
}

// Test
console.log('\n=== Async/Await Version ===');

(async () => {
  try {
    const results = await promiseAllAsync([
      delay(100, 'x'),
      delay(50, 'y'),
      delay(75, 'z')
    ]);
    console.log('Async results:', results); // ['x', 'y', 'z']
  } catch (error) {
    console.log('Error:', error);
  }
})();
```

### **Bonus: Promise.all with Progress Tracking**
```javascript
/**
 * Promise.all with progress callbacks
 */
function promiseAllWithProgress(promises, onProgress) {
  return new Promise((resolve, reject) => {
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = [];
    let completedCount = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(result => {
          results[index] = result;
          completedCount++;
          
          // Report progress
          if (onProgress) {
            onProgress({
              completed: completedCount,
              total: promises.length,
              percentage: (completedCount / promises.length) * 100,
              latest: result
            });
          }
          
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });
  });
}

// Test
console.log('\n=== With Progress Tracking ===');

promiseAllWithProgress(
  [delay(100, 'A'), delay(200, 'B'), delay(150, 'C')],
  progress => console.log(`Progress: ${progress.percentage.toFixed(0)}% (${progress.completed}/${progress.total})`)
)
  .then(results => console.log('Final:', results))
  .catch(error => console.log('Error:', error));
```

### **Bonus: Promise.all with Timeout**
```javascript
/**
 * Promise.all with overall timeout
 */
function promiseAllWithTimeout(promises, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Timeout after ${timeoutMs}ms`)), timeoutMs);
  });
  
  return Promise.race([
    promiseAll(promises),
    timeoutPromise
  ]);
}

// Test
console.log('\n=== With Timeout ===');

promiseAllWithTimeout([delay(100, 1), delay(200, 2), delay(300, 3)], 250)
  .then(results => console.log('Completed:', results))
  .catch(error => console.log('Timeout error:', error.message));

promiseAllWithTimeout([delay(50, 1), delay(100, 2)], 500)
  .then(results => console.log('Completed in time:', results))
  .catch(error => console.log('Error:', error.message));
```

### **Comparison with Native Promise.all**
```javascript
/**
 * Compare behavior with native implementation
 */
console.log('\n=== Comparison with Native ===');

const testPromises = [
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3)
];

// Custom implementation
promiseAll(testPromises)
  .then(results => console.log('Custom:', results));

// Native implementation
Promise.all(testPromises)
  .then(results => console.log('Native:', results));

// Both reject on first error
const mixedPromises = [
  Promise.resolve(1),
  Promise.reject('Error!'),
  delay(1000, 3) // This won't complete
];

promiseAll(mixedPromises)
  .then(results => console.log('Custom results:', results))
  .catch(error => console.log('Custom error:', error));

Promise.all(mixedPromises)
  .then(results => console.log('Native results:', results))
  .catch(error => console.log('Native error:', error));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty array
promiseAll([])
  .then(results => console.log('Empty array:', results)) // []
  .catch(error => console.log('Error:', error));

// Single promise
promiseAll([Promise.resolve('single')])
  .then(results => console.log('Single promise:', results)) // ['single']
  .catch(error => console.log('Error:', error));

// All rejected
promiseAll([Promise.reject('a'), Promise.reject('b')])
  .then(results => console.log('Results:', results))
  .catch(error => console.log('First rejection:', error)); // 'a'

// Mixed resolved/rejected - order matters
promiseAll([
  delay(100, 'slow resolve'),
  Promise.reject('fast reject')
])
  .then(results => console.log('Results:', results))
  .catch(error => console.log('Rejected:', error)); // 'fast reject'

// Non-promise values
promiseAll([1, 2, 3])
  .then(results => console.log('Non-promises:', results)) // [1, 2, 3]
  .catch(error => console.log('Error:', error));

// Nested promises
promiseAll([Promise.resolve(Promise.resolve(1))])
  .then(results => console.log('Nested:', results)) // [1]
  .catch(error => console.log('Error:', error));
```

### **Performance Testing**
```javascript
/**
 * Test performance with many promises
 */
async function benchmarkPromiseAll(count) {
  const promises = Array.from({ length: count }, (_, i) => 
    delay(Math.random() * 10, i)
  );
  
  console.log(`\nBenchmarking ${count} promises:`);
  
  // Custom implementation
  let start = performance.now();
  await promiseAll(promises);
  let time = performance.now() - start;
  console.log(`Custom: ${time.toFixed(2)}ms`);
  
  // Native implementation
  const promises2 = Array.from({ length: count }, (_, i) => 
    delay(Math.random() * 10, i)
  );
  
  start = performance.now();
  await Promise.all(promises2);
  time = performance.now() - start;
  console.log(`Native: ${time.toFixed(2)}ms`);
}

console.log('\n=== Performance Testing ===');
setTimeout(() => {
  benchmarkPromiseAll(100);
  setTimeout(() => benchmarkPromiseAll(1000), 200);
}, 500);
```

**Interview Tips:**
- Promise.all waits for ALL promises to resolve, or first rejection
- Returns promise that resolves with array of results in same order
- Fails fast: rejects immediately on first rejection
- Results preserve input order, not completion order
- Must handle non-promise values (wrap with Promise.resolve)
- Empty array resolves immediately with []
- Key insight: track completion count, resolve when count === length
- Common mistake: not preserving result order
- Use forEach with index to maintain order
- Difference from Promise.race: waits for all, not first
- Related: Promise.allSettled (waits for all, doesn't reject)
- Related: Promise.race (resolves/rejects with first settled)
- Related: Promise.any (resolves with first fulfilled)
- Applications: parallel API calls, batch operations, concurrent tasks
- Edge cases: empty array, single promise, all rejected, mixed values
- Clarify: should handle non-promise values? timeout? progress tracking?
- Follow-ups: implement Promise.race, Promise.allSettled, add concurrency limit

</details>

77. Implement Promise.race() from scratch

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Promise.race Implementation**
```javascript
/**
 * Promise.race - returns first settled promise (resolved or rejected)
 * Time Complexity: O(n) to set up handlers
 * Space Complexity: O(1)
 * 
 * Returns: Promise that settles with first settled promise's result
 */
function promiseRace(promises) {
  return new Promise((resolve, reject) => {
    // Empty array never settles (matches native behavior)
    if (promises.length === 0) {
      return; // Promise stays pending forever
    }
    
    promises.forEach(promise => {
      Promise.resolve(promise)
        .then(resolve)  // First to resolve wins
        .catch(reject); // First to reject wins
    });
  });
}

// Test
console.log('=== Basic Promise.race ===');

const delay = (ms, value) => new Promise(resolve => 
  setTimeout(() => resolve(value), ms)
);

promiseRace([
  delay(100, 'slow'),
  delay(50, 'fast'),
  delay(200, 'slowest')
])
  .then(result => console.log('Winner:', result)) // 'fast'
  .catch(error => console.log('Error:', error));

// Test with rejection
promiseRace([
  delay(100, 'slow resolve'),
  Promise.reject('fast reject')
])
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Rejected:', error)); // 'fast reject'
```

### **Approach 2: Handle Non-Promise Values**
```javascript
/**
 * More robust version handling non-promise values
 */
function promiseRaceRobust(iterable) {
  return new Promise((resolve, reject) => {
    const promises = Array.from(iterable);
    
    if (promises.length === 0) {
      return; // Stays pending
    }
    
    let settled = false;
    
    promises.forEach(item => {
      Promise.resolve(item)
        .then(value => {
          if (!settled) {
            settled = true;
            resolve(value);
          }
        })
        .catch(error => {
          if (!settled) {
            settled = true;
            reject(error);
          }
        });
    });
  });
}

// Test
console.log('\n=== Robust Promise.race ===');

// Immediate value wins
promiseRaceRobust([
  'immediate',
  delay(100, 'delayed')
])
  .then(result => console.log('Winner:', result)) // 'immediate'
  .catch(error => console.log('Error:', error));

// Mix of promises and values
promiseRaceRobust([
  delay(50, 'a'),
  Promise.resolve('b'),
  delay(25, 'c')
])
  .then(result => console.log('First:', result)) // 'b' (resolves immediately)
  .catch(error => console.log('Error:', error));
```

### **Approach 3: With Winner Information**
```javascript
/**
 * Enhanced version that provides context about winner
 */
function promiseRaceWithInfo(promises) {
  return new Promise((resolve, reject) => {
    if (promises.length === 0) {
      return;
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          resolve({
            value,
            index,
            status: 'fulfilled'
          });
        })
        .catch(error => {
          reject({
            error,
            index,
            status: 'rejected'
          });
        });
    });
  });
}

// Test
console.log('\n=== With Winner Info ===');

promiseRaceWithInfo([
  delay(100, 'slow'),
  delay(30, 'fast'),
  delay(200, 'slowest')
])
  .then(result => console.log('Winner:', result))
  .catch(error => console.log('Error:', error));
```

### **Approach 4: Async/Await Implementation**
```javascript
/**
 * Using async/await syntax (wrapper around native)
 */
async function promiseRaceAsync(promises) {
  if (promises.length === 0) {
    return new Promise(() => {}); // Never resolves
  }
  
  return Promise.race(promises.map(p => Promise.resolve(p)));
}

// Test
console.log('\n=== Async/Await Version ===');

(async () => {
  try {
    const result = await promiseRaceAsync([
      delay(100, 'a'),
      delay(50, 'b'),
      delay(75, 'c')
    ]);
    console.log('Async winner:', result); // 'b'
  } catch (error) {
    console.log('Error:', error);
  }
})();
```

### **Approach 5: With Cancellation**
```javascript
/**
 * Race with ability to cancel remaining promises
 */
function promiseRaceWithCancel(promises) {
  const controllers = promises.map(() => ({ cancelled: false }));
  
  return new Promise((resolve, reject) => {
    if (promises.length === 0) {
      return;
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          // Mark others as cancelled
          controllers.forEach((ctrl, i) => {
            if (i !== index) ctrl.cancelled = true;
          });
          resolve({ value, index, controllers });
        })
        .catch(error => {
          controllers.forEach((ctrl, i) => {
            if (i !== index) ctrl.cancelled = true;
          });
          reject({ error, index, controllers });
        });
    });
  });
}

// Test
console.log('\n=== With Cancellation Support ===');

promiseRaceWithCancel([
  delay(100, 'slow'),
  delay(30, 'fast')
])
  .then(result => {
    console.log('Winner:', result.value);
    console.log('Controllers:', result.controllers.map(c => c.cancelled));
  })
  .catch(error => console.log('Error:', error));
```

### **Bonus: Promise.race with Timeout**
```javascript
/**
 * Race with automatic timeout
 */
function promiseRaceWithTimeout(promises, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Timeout after ${timeoutMs}ms`)), timeoutMs);
  });
  
  return promiseRace([...promises, timeoutPromise]);
}

// Test
console.log('\n=== Race with Timeout ===');

promiseRaceWithTimeout([delay(200, 'slow')], 100)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Timed out:', error.message));

promiseRaceWithTimeout([delay(50, 'fast')], 100)
  .then(result => console.log('Completed:', result))
  .catch(error => console.log('Error:', error.message));
```

### **Bonus: First Successful (Promise.any polyfill)**
```javascript
/**
 * Similar to race but only resolves on success
 * Rejects only if all promises reject
 */
function promiseAny(promises) {
  return new Promise((resolve, reject) => {
    if (promises.length === 0) {
      reject(new Error('All promises were rejected'));
      return;
    }
    
    const errors = [];
    let rejectedCount = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(resolve) // First success wins
        .catch(error => {
          errors[index] = error;
          rejectedCount++;
          
          if (rejectedCount === promises.length) {
            reject(new Error('All promises rejected'));
          }
        });
    });
  });
}

// Test
console.log('\n=== Promise.any (First Success) ===');

promiseAny([
  Promise.reject('error 1'),
  delay(50, 'success'),
  Promise.reject('error 2')
])
  .then(result => console.log('First success:', result)) // 'success'
  .catch(error => console.log('All failed:', error));

promiseAny([
  Promise.reject('error 1'),
  Promise.reject('error 2')
])
  .then(result => console.log('Result:', result))
  .catch(error => console.log('All rejected:', error.message));
```

### **Bonus: Race with All Results**
```javascript
/**
 * Race but track all completions
 */
function promiseRaceWithAll(promises) {
  return new Promise((resolve, reject) => {
    if (promises.length === 0) {
      resolve({ winner: null, all: [] });
      return;
    }
    
    let winner = null;
    const results = [];
    let completedCount = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          if (winner === null) {
            winner = { value, index, status: 'fulfilled' };
            resolve(winner);
          }
          
          results[index] = { value, status: 'fulfilled' };
          completedCount++;
        })
        .catch(error => {
          if (winner === null) {
            winner = { error, index, status: 'rejected' };
            reject(winner);
          }
          
          results[index] = { error, status: 'rejected' };
          completedCount++;
        });
    });
  });
}

// Test
console.log('\n=== Race with All Results ===');

promiseRaceWithAll([
  delay(100, 'a'),
  delay(50, 'b'),
  delay(75, 'c')
])
  .then(result => console.log('Winner:', result))
  .catch(error => console.log('Error:', error));
```

### **Comparison with Native Promise.race**
```javascript
/**
 * Compare behavior with native implementation
 */
console.log('\n=== Comparison with Native ===');

const testPromises = [
  delay(100, 'slow'),
  delay(50, 'fast'),
  delay(150, 'slowest')
];

// Custom implementation
promiseRace(testPromises)
  .then(result => console.log('Custom winner:', result));

// Native implementation
Promise.race(testPromises)
  .then(result => console.log('Native winner:', result));

// Both handle rejection
const mixedPromises = [
  delay(100, 'slow'),
  Promise.reject('fast error')
];

promiseRace(mixedPromises)
  .then(result => console.log('Custom result:', result))
  .catch(error => console.log('Custom error:', error));

Promise.race(mixedPromises)
  .then(result => console.log('Native result:', result))
  .catch(error => console.log('Native error:', error));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty array - stays pending
const emptyRace = promiseRace([]);
setTimeout(() => console.log('Empty race still pending'), 100);

// Single promise
promiseRace([Promise.resolve('only')])
  .then(result => console.log('Single:', result)) // 'only'
  .catch(error => console.log('Error:', error));

// Immediate vs delayed
promiseRace([
  Promise.resolve('immediate'),
  delay(1000, 'delayed')
])
  .then(result => console.log('Immediate wins:', result)) // 'immediate'
  .catch(error => console.log('Error:', error));

// All rejected - first rejection wins
promiseRace([
  delay(50, Promise.reject('slow error')),
  Promise.reject('fast error')
])
  .then(result => console.log('Result:', result))
  .catch(error => console.log('First error:', error)); // 'fast error'

// Non-promise values
promiseRace([1, 2, 3])
  .then(result => console.log('Non-promise:', result)) // 1
  .catch(error => console.log('Error:', error));

// Mixed types
promiseRace([
  delay(100, 'promise'),
  'immediate value',
  delay(50, 'another promise')
])
  .then(result => console.log('Mixed:', result)) // 'immediate value'
  .catch(error => console.log('Error:', error));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of Promise.race
 */

// 1. Request with timeout
function fetchWithTimeout(url, timeout) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Request timeout')), timeout)
  );
  
  return promiseRace([fetchPromise, timeoutPromise]);
}

// 2. First available resource
function getFirstAvailableServer(servers) {
  const requests = servers.map(server => 
    fetch(`${server}/health`).then(() => server)
  );
  
  return promiseRace(requests);
}

// 3. Race between cache and network
function getCachedOrFresh(key, fetchFn) {
  const cachePromise = caches.match(key);
  const networkPromise = fetchFn().then(data => {
    // Update cache in background
    return data;
  });
  
  return promiseRace([cachePromise, networkPromise]);
}

console.log('\n=== Use Cases ===');
console.log('fetchWithTimeout - race between fetch and timeout');
console.log('getFirstAvailableServer - first healthy server wins');
console.log('getCachedOrFresh - cache vs network, fastest wins');
```

### **Performance Testing**
```javascript
/**
 * Test performance with many promises
 */
async function benchmarkPromiseRace(count) {
  const promises = Array.from({ length: count }, (_, i) => 
    delay(Math.random() * 100, i)
  );
  
  console.log(`\nBenchmarking race with ${count} promises:`);
  
  // Custom implementation
  let start = performance.now();
  await promiseRace(promises);
  let time = performance.now() - start;
  console.log(`Custom: ${time.toFixed(2)}ms`);
  
  // Native implementation
  const promises2 = Array.from({ length: count }, (_, i) => 
    delay(Math.random() * 100, i)
  );
  
  start = performance.now();
  await Promise.race(promises2);
  time = performance.now() - start;
  console.log(`Native: ${time.toFixed(2)}ms`);
}

console.log('\n=== Performance Testing ===');
setTimeout(() => {
  benchmarkPromiseRace(100);
  setTimeout(() => benchmarkPromiseRace(1000), 200);
}, 600);
```

**Interview Tips:**
- Promise.race settles with FIRST promise to settle (resolve or reject)
- Unlike Promise.all, doesn't wait for all promises
- Empty array stays pending forever (never resolves or rejects)
- First to finish wins, whether success or failure
- Other promises continue executing (can't be cancelled in JS)
- Must wrap non-promise values with Promise.resolve
- Key insight: attach handlers to all, first to call resolve/reject wins
- Promise.race vs Promise.any: race takes first settled, any takes first fulfilled
- Promise.race vs Promise.all: race takes first, all waits for all
- Common use cases: timeouts, first available resource, cache vs network
- Applications: request timeouts, fastest server, redundant requests
- Edge cases: empty array, single promise, immediate values, all rejected
- Can't cancel other promises after winner determined (limitation of JS)
- Useful for implementing timeouts by racing with delay promise
- Related: Promise.any (first success), Promise.allSettled (all settled)
- Clarify: what happens to other promises? need winner info? timeout?
- Follow-ups: implement Promise.any, add timeout, track all results

</details>

78. Implement Promise.allSettled() from scratch

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Promise.allSettled Implementation**
```javascript
/**
 * Promise.allSettled - waits for all promises to settle (resolve or reject)
 * Time Complexity: O(n) where n is number of promises
 * Space Complexity: O(n) for results array
 * 
 * Returns: Promise that resolves with array of result objects
 * Never rejects - always waits for all to settle
 */
function promiseAllSettled(promises) {
  return new Promise((resolve) => {
    // Handle empty array
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = [];
    let settledCount = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          results[index] = {
            status: 'fulfilled',
            value: value
          };
          settledCount++;
          
          if (settledCount === promises.length) {
            resolve(results);
          }
        })
        .catch(reason => {
          results[index] = {
            status: 'rejected',
            reason: reason
          };
          settledCount++;
          
          if (settledCount === promises.length) {
            resolve(results);
          }
        });
    });
  });
}

// Test
console.log('=== Basic Promise.allSettled ===');

const delay = (ms, value) => new Promise(resolve => 
  setTimeout(() => resolve(value), ms)
);

promiseAllSettled([
  Promise.resolve(1),
  Promise.reject('Error!'),
  delay(100, 3)
])
  .then(results => {
    console.log('All settled:', results);
    // [
    //   { status: 'fulfilled', value: 1 },
    //   { status: 'rejected', reason: 'Error!' },
    //   { status: 'fulfilled', value: 3 }
    // ]
  });

// Test with all rejected
promiseAllSettled([
  Promise.reject('error 1'),
  Promise.reject('error 2'),
  Promise.reject('error 3')
])
  .then(results => {
    console.log('\nAll rejected:', results);
    // All have status: 'rejected'
  });
```

### **Approach 2: Handle Non-Promise Values**
```javascript
/**
 * More robust version handling non-promise values
 */
function promiseAllSettledRobust(iterable) {
  return new Promise((resolve) => {
    const promises = Array.from(iterable);
    
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = new Array(promises.length);
    let settledCount = 0;
    
    promises.forEach((item, index) => {
      Promise.resolve(item)
        .then(value => {
          results[index] = { status: 'fulfilled', value };
        })
        .catch(reason => {
          results[index] = { status: 'rejected', reason };
        })
        .finally(() => {
          settledCount++;
          if (settledCount === promises.length) {
            resolve(results);
          }
        });
    });
  });
}

// Test
console.log('\n=== Robust Promise.allSettled ===');

// Mix of promises and values
promiseAllSettledRobust([
  1,
  Promise.resolve(2),
  Promise.reject('error'),
  delay(50, 4)
])
  .then(results => console.log('Mixed values:', results));
```

### **Approach 3: Without Promise.finally**
```javascript
/**
 * Implementation without using .finally() for older environments
 */
function promiseAllSettledCompat(promises) {
  return new Promise((resolve) => {
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = [];
    let settledCount = 0;
    
    const checkComplete = () => {
      settledCount++;
      if (settledCount === promises.length) {
        resolve(results);
      }
    };
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(
          value => {
            results[index] = { status: 'fulfilled', value };
            checkComplete();
          },
          reason => {
            results[index] = { status: 'rejected', reason };
            checkComplete();
          }
        );
    });
  });
}

// Test
console.log('\n=== Compatible Version ===');

promiseAllSettledCompat([
  Promise.resolve('success'),
  Promise.reject('failure'),
  delay(75, 'delayed')
])
  .then(results => console.log('Compat results:', results));
```

### **Approach 4: Async/Await Implementation**
```javascript
/**
 * Modern implementation using async/await
 */
async function promiseAllSettledAsync(promises) {
  if (promises.length === 0) {
    return [];
  }
  
  const settledPromises = promises.map(async (promise, index) => {
    try {
      const value = await Promise.resolve(promise);
      return { status: 'fulfilled', value };
    } catch (reason) {
      return { status: 'rejected', reason };
    }
  });
  
  return Promise.all(settledPromises);
}

// Test
console.log('\n=== Async/Await Version ===');

(async () => {
  const results = await promiseAllSettledAsync([
    Promise.resolve('a'),
    Promise.reject('b'),
    delay(50, 'c')
  ]);
  console.log('Async results:', results);
})();
```

### **Approach 5: With Statistics**
```javascript
/**
 * Enhanced version that provides statistics
 */
function promiseAllSettledWithStats(promises) {
  return new Promise((resolve) => {
    if (promises.length === 0) {
      resolve({ results: [], stats: { fulfilled: 0, rejected: 0 } });
      return;
    }
    
    const results = [];
    let settledCount = 0;
    let fulfilledCount = 0;
    let rejectedCount = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          results[index] = { status: 'fulfilled', value };
          fulfilledCount++;
          settledCount++;
          
          if (settledCount === promises.length) {
            resolve({
              results,
              stats: {
                fulfilled: fulfilledCount,
                rejected: rejectedCount,
                total: promises.length
              }
            });
          }
        })
        .catch(reason => {
          results[index] = { status: 'rejected', reason };
          rejectedCount++;
          settledCount++;
          
          if (settledCount === promises.length) {
            resolve({
              results,
              stats: {
                fulfilled: fulfilledCount,
                rejected: rejectedCount,
                total: promises.length
              }
            });
          }
        });
    });
  });
}

// Test
console.log('\n=== With Statistics ===');

promiseAllSettledWithStats([
  Promise.resolve(1),
  Promise.reject('error'),
  Promise.resolve(3),
  Promise.reject('another error')
])
  .then(result => {
    console.log('Results:', result.results);
    console.log('Stats:', result.stats); // { fulfilled: 2, rejected: 2, total: 4 }
  });
```

### **Bonus: With Progress Tracking**
```javascript
/**
 * Promise.allSettled with progress callbacks
 */
function promiseAllSettledWithProgress(promises, onProgress) {
  return new Promise((resolve) => {
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    
    const results = [];
    let settledCount = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          results[index] = { status: 'fulfilled', value };
        })
        .catch(reason => {
          results[index] = { status: 'rejected', reason };
        })
        .finally(() => {
          settledCount++;
          
          if (onProgress) {
            onProgress({
              settled: settledCount,
              total: promises.length,
              percentage: (settledCount / promises.length) * 100,
              latest: results[index]
            });
          }
          
          if (settledCount === promises.length) {
            resolve(results);
          }
        });
    });
  });
}

// Test
console.log('\n=== With Progress ===');

promiseAllSettledWithProgress(
  [
    delay(100, 'A'),
    Promise.reject('Error B'),
    delay(200, 'C')
  ],
  progress => console.log(`Progress: ${progress.percentage.toFixed(0)}% (${progress.settled}/${progress.total})`)
)
  .then(results => console.log('Final:', results));
```

### **Bonus: Filter Results by Status**
```javascript
/**
 * Helper functions to filter settled results
 */
function getFulfilled(results) {
  return results
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value);
}

function getRejected(results) {
  return results
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);
}

function getByStatus(results, status) {
  return results.filter(r => r.status === status);
}

// Test
console.log('\n=== Filter Results ===');

promiseAllSettled([
  Promise.resolve(1),
  Promise.reject('error 1'),
  Promise.resolve(3),
  Promise.reject('error 2'),
  Promise.resolve(5)
])
  .then(results => {
    console.log('All results:', results);
    console.log('Fulfilled values:', getFulfilled(results)); // [1, 3, 5]
    console.log('Rejected reasons:', getRejected(results)); // ['error 1', 'error 2']
    console.log('Success count:', getByStatus(results, 'fulfilled').length); // 3
  });
```

### **Bonus: With Timeout**
```javascript
/**
 * allSettled with per-promise timeout
 */
function promiseAllSettledWithTimeout(promises, timeoutMs) {
  const wrappedPromises = promises.map((promise, index) => {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error(`Promise ${index} timeout`)), timeoutMs);
    });
    
    return Promise.race([Promise.resolve(promise), timeoutPromise]);
  });
  
  return promiseAllSettled(wrappedPromises);
}

// Test
console.log('\n=== With Timeout ===');

promiseAllSettledWithTimeout([
  delay(50, 'fast'),
  delay(200, 'slow'),
  delay(100, 'medium')
], 150)
  .then(results => {
    console.log('With timeout results:', results);
    // fast and medium succeed, slow times out
  });
```

### **Comparison with Promise.all**
```javascript
/**
 * Demonstrate difference between allSettled and all
 */
console.log('\n=== allSettled vs all ===');

const mixedPromises = [
  Promise.resolve(1),
  Promise.reject('Error!'),
  Promise.resolve(3)
];

// Promise.all - rejects on first error
Promise.all(mixedPromises)
  .then(results => console.log('Promise.all results:', results))
  .catch(error => console.log('Promise.all error:', error)); // 'Error!'

// Promise.allSettled - waits for all
promiseAllSettled(mixedPromises)
  .then(results => {
    console.log('Promise.allSettled results:');
    results.forEach((r, i) => console.log(`  [${i}]:`, r));
  });
```

### **Comparison with Native Implementation**
```javascript
/**
 * Compare with native Promise.allSettled
 */
console.log('\n=== Comparison with Native ===');

const testPromises = [
  Promise.resolve('success'),
  Promise.reject('failure'),
  delay(50, 'delayed')
];

// Custom implementation
promiseAllSettled(testPromises)
  .then(results => console.log('Custom:', results));

// Native implementation (if available)
if (Promise.allSettled) {
  Promise.allSettled(testPromises)
    .then(results => console.log('Native:', results));
}
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty array
promiseAllSettled([])
  .then(results => console.log('Empty array:', results)); // []

// Single promise - resolved
promiseAllSettled([Promise.resolve('single')])
  .then(results => console.log('Single resolved:', results));
// [{ status: 'fulfilled', value: 'single' }]

// Single promise - rejected
promiseAllSettled([Promise.reject('error')])
  .then(results => console.log('Single rejected:', results));
// [{ status: 'rejected', reason: 'error' }]

// All resolved
promiseAllSettled([
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3)
])
  .then(results => console.log('All resolved:', results));

// All rejected
promiseAllSettled([
  Promise.reject('a'),
  Promise.reject('b'),
  Promise.reject('c')
])
  .then(results => console.log('All rejected:', results));

// Non-promise values
promiseAllSettled([1, 2, 3])
  .then(results => console.log('Non-promises:', results));
// All have status: 'fulfilled'

// Mixed timing
promiseAllSettled([
  delay(100, 'slow'),
  Promise.resolve('fast'),
  delay(50, 'medium')
])
  .then(results => console.log('Mixed timing:', results));

// Nested promises
promiseAllSettled([
  Promise.resolve(Promise.resolve(1))
])
  .then(results => console.log('Nested:', results));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Batch API calls with partial failures
async function fetchMultipleEndpoints(urls) {
  const requests = urls.map(url => fetch(url).then(r => r.json()));
  const results = await promiseAllSettled(requests);
  
  const successful = getFulfilled(results);
  const failed = getRejected(results);
  
  return { successful, failed, results };
}

// 2. Process all regardless of failures
async function processAllItems(items, processFunc) {
  const promises = items.map(item => processFunc(item));
  const results = await promiseAllSettled(promises);
  
  return {
    processed: results.filter(r => r.status === 'fulfilled').length,
    failed: results.filter(r => r.status === 'rejected').length,
    details: results
  };
}

// 3. Cleanup operations that might fail
async function cleanupResources(resources) {
  const cleanupPromises = resources.map(r => r.cleanup());
  const results = await promiseAllSettled(cleanupPromises);
  
  const failures = results.filter(r => r.status === 'rejected');
  if (failures.length > 0) {
    console.warn(`${failures.length} cleanups failed`);
  }
}

console.log('\n=== Use Cases ===');
console.log('fetchMultipleEndpoints - continue despite some failures');
console.log('processAllItems - get success/failure counts');
console.log('cleanupResources - attempt all cleanups');
```

### **Performance Testing**
```javascript
/**
 * Test performance with many promises
 */
async function benchmarkAllSettled(count) {
  // Mix of resolved and rejected
  const promises = Array.from({ length: count }, (_, i) => 
    i % 3 === 0 
      ? Promise.reject(`error ${i}`)
      : delay(Math.random() * 10, i)
  );
  
  console.log(`\nBenchmarking ${count} promises (some rejected):`);
  
  // Custom implementation
  let start = performance.now();
  await promiseAllSettled(promises);
  let time = performance.now() - start;
  console.log(`Custom: ${time.toFixed(2)}ms`);
  
  // Native implementation
  if (Promise.allSettled) {
    const promises2 = Array.from({ length: count }, (_, i) => 
      i % 3 === 0 
        ? Promise.reject(`error ${i}`)
        : delay(Math.random() * 10, i)
    );
    
    start = performance.now();
    await Promise.allSettled(promises2);
    time = performance.now() - start;
    console.log(`Native: ${time.toFixed(2)}ms`);
  }
}

console.log('\n=== Performance Testing ===');
setTimeout(() => {
  benchmarkAllSettled(100);
  setTimeout(() => benchmarkAllSettled(500), 200);
}, 800);
```

**Interview Tips:**
- Promise.allSettled waits for ALL promises to settle (never rejects)
- Returns array of result objects: { status, value/reason }
- Status is either 'fulfilled' or 'rejected'
- Different from Promise.all: doesn't reject on first failure
- Use when you need results from all promises regardless of failures
- Results preserve input order, not completion order
- Empty array resolves immediately with []
- Always resolves (never rejects), even if all promises reject
- Each result has status field to identify fulfilled vs rejected
- Fulfilled: { status: 'fulfilled', value }
- Rejected: { status: 'rejected', reason }
- Added in ES2020, may need polyfill for older environments
- Key insight: track settled count, resolve when all settled
- Common use cases: batch operations, partial failures acceptable, cleanup
- Difference from Promise.all: all rejects on first error, allSettled waits
- Can filter results by status to separate successes from failures
- Applications: batch API calls, parallel processing, resource cleanup
- Edge cases: empty array, all resolved, all rejected, non-promises
- Follow-ups: implement Promise.any, Promise.race, add progress tracking
- Clarify: need statistics? progress updates? timeout per promise?

</details>

79. Create a function to retry failed promises n times

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Retry with Recursion**
```javascript
/**
 * Retry a promise-returning function n times
 * Time Complexity: O(n) attempts
 * Space Complexity: O(n) call stack
 */
async function retry(fn, maxRetries) {
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const result = await fn();
      return result;
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries) {
        console.log(`Attempt ${attempt + 1} failed, retrying...`);
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries + 1} attempts: ${lastError.message}`);
}

// Test
console.log('=== Basic Retry ===');

let callCount = 0;
const unreliableFunction = () => {
  callCount++;
  console.log(`Call ${callCount}`);
  
  if (callCount < 3) {
    return Promise.reject(new Error('Failed!'));
  }
  
  return Promise.resolve('Success!');
};

retry(unreliableFunction, 5)
  .then(result => console.log('Result:', result)) // 'Success!' after 3 attempts
  .catch(error => console.log('Error:', error.message));
```

### **Approach 2: Retry with Delay**
```javascript
/**
 * Retry with delay between attempts
 */
function retryWithDelay(fn, maxRetries, delay) {
  return new Promise(async (resolve, reject) => {
    let lastError;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const result = await fn();
        resolve(result);
        return;
      } catch (error) {
        lastError = error;
        
        if (attempt < maxRetries) {
          console.log(`Attempt ${attempt + 1} failed, waiting ${delay}ms...`);
          await new Promise(r => setTimeout(r, delay));
        }
      }
    }
    
    reject(new Error(`Failed after ${maxRetries + 1} attempts: ${lastError.message}`));
  });
}

// Test
console.log('\n=== Retry with Delay ===');

let attempts = 0;
const delayedFunction = () => {
  attempts++;
  console.log(`Attempt ${attempts} at ${new Date().toLocaleTimeString()}`);
  
  if (attempts < 3) {
    return Promise.reject(new Error('Not yet'));
  }
  
  return Promise.resolve('Done!');
};

retryWithDelay(delayedFunction, 5, 500)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Error:', error.message));
```

### **Approach 3: Exponential Backoff**
```javascript
/**
 * Retry with exponential backoff
 * Delay increases exponentially: delay, delay*2, delay*4, etc.
 */
async function retryWithBackoff(fn, maxRetries, initialDelay = 1000) {
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries) {
        const delay = initialDelay * Math.pow(2, attempt);
        console.log(`Attempt ${attempt + 1} failed, waiting ${delay}ms (exponential backoff)...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries + 1} attempts: ${lastError.message}`);
}

// Test
console.log('\n=== Exponential Backoff ===');

let backoffAttempts = 0;
const backoffFunction = () => {
  backoffAttempts++;
  console.log(`Backoff attempt ${backoffAttempts}`);
  
  if (backoffAttempts < 4) {
    return Promise.reject(new Error('Failed'));
  }
  
  return Promise.resolve('Finally succeeded!');
};

retryWithBackoff(backoffFunction, 5, 100)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Error:', error.message));
```

### **Approach 4: Retry with Custom Condition**
```javascript
/**
 * Retry only if condition is met (e.g., certain error types)
 */
async function retryIf(fn, maxRetries, shouldRetry) {
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries && shouldRetry(error, attempt)) {
        console.log(`Attempt ${attempt + 1} failed with retryable error, retrying...`);
      } else if (attempt < maxRetries) {
        console.log(`Non-retryable error, aborting...`);
        throw error;
      }
    }
  }
  
  throw lastError;
}

// Test
console.log('\n=== Retry with Condition ===');

let conditionalAttempts = 0;
const conditionalFunction = () => {
  conditionalAttempts++;
  
  if (conditionalAttempts === 1) {
    return Promise.reject({ code: 'NETWORK_ERROR', retryable: true });
  } else if (conditionalAttempts === 2) {
    return Promise.reject({ code: 'AUTH_ERROR', retryable: false });
  }
  
  return Promise.resolve('Success');
};

retryIf(
  conditionalFunction,
  5,
  (error) => error.retryable === true
)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Caught non-retryable error:', error.code));
```

### **Approach 5: Retry with Callbacks**
```javascript
/**
 * Retry with callbacks for monitoring
 */
async function retryWithCallbacks(fn, maxRetries, options = {}) {
  const {
    delay = 0,
    onRetry = () => {},
    onError = () => {},
    onSuccess = () => {}
  } = options;
  
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const result = await fn();
      onSuccess(result, attempt);
      return result;
    } catch (error) {
      lastError = error;
      onError(error, attempt);
      
      if (attempt < maxRetries) {
        onRetry(attempt + 1, maxRetries);
        
        if (delay > 0) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries + 1} attempts: ${lastError.message}`);
}

// Test
console.log('\n=== Retry with Callbacks ===');

let callbackAttempts = 0;
const callbackFunction = () => {
  callbackAttempts++;
  
  if (callbackAttempts < 3) {
    return Promise.reject(new Error('Temporary failure'));
  }
  
  return Promise.resolve('Success!');
};

retryWithCallbacks(callbackFunction, 5, {
  delay: 100,
  onRetry: (attempt, max) => console.log(`Retrying... (${attempt}/${max})`),
  onError: (error, attempt) => console.log(`Error on attempt ${attempt + 1}: ${error.message}`),
  onSuccess: (result, attempt) => console.log(`Succeeded on attempt ${attempt + 1}`)
})
  .then(result => console.log('Final result:', result))
  .catch(error => console.log('Final error:', error.message));
```

### **Bonus: Retry Multiple Functions**
```javascript
/**
 * Retry multiple promise functions with shared retry logic
 */
async function retryAll(functions, maxRetries) {
  const results = await Promise.all(
    functions.map(fn => retry(fn, maxRetries))
  );
  return results;
}

// Test
console.log('\n=== Retry Multiple Functions ===');

const func1 = () => Promise.resolve('Function 1 success');

let func2Attempts = 0;
const func2 = () => {
  func2Attempts++;
  return func2Attempts < 2 
    ? Promise.reject(new Error('Func 2 fail'))
    : Promise.resolve('Function 2 success');
};

retryAll([func1, func2], 3)
  .then(results => console.log('All results:', results))
  .catch(error => console.log('Error:', error));
```

### **Bonus: Retry with Timeout**
```javascript
/**
 * Retry with timeout for each attempt
 */
async function retryWithTimeout(fn, maxRetries, timeout) {
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeout)
      );
      
      const result = await Promise.race([fn(), timeoutPromise]);
      return result;
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries) {
        console.log(`Attempt ${attempt + 1} failed (${error.message}), retrying...`);
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries + 1} attempts: ${lastError.message}`);
}

// Test
console.log('\n=== Retry with Timeout ===');

let timeoutAttempts = 0;
const slowFunction = () => {
  timeoutAttempts++;
  const delay = timeoutAttempts < 3 ? 2000 : 100; // First 2 attempts timeout
  
  return new Promise(resolve => 
    setTimeout(() => resolve(`Success on attempt ${timeoutAttempts}`), delay)
  );
};

retryWithTimeout(slowFunction, 3, 500)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Error:', error.message));
```

### **Bonus: Retry Class**
```javascript
/**
 * Reusable retry class with configuration
 */
class Retrier {
  constructor(options = {}) {
    this.maxRetries = options.maxRetries || 3;
    this.delay = options.delay || 1000;
    this.backoff = options.backoff || false;
    this.onRetry = options.onRetry || (() => {});
  }
  
  async execute(fn) {
    let lastError;
    
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        
        if (attempt < this.maxRetries) {
          this.onRetry(attempt + 1, error);
          
          const delay = this.backoff 
            ? this.delay * Math.pow(2, attempt)
            : this.delay;
          
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw new Error(`Failed after ${this.maxRetries + 1} attempts: ${lastError.message}`);
  }
}

// Test
console.log('\n=== Retry Class ===');

const retrier = new Retrier({
  maxRetries: 3,
  delay: 200,
  backoff: true,
  onRetry: (attempt, error) => console.log(`Retry attempt ${attempt}: ${error.message}`)
});

let classAttempts = 0;
const testFunction = () => {
  classAttempts++;
  
  if (classAttempts < 3) {
    return Promise.reject(new Error('Not ready'));
  }
  
  return Promise.resolve('Ready!');
};

retrier.execute(testFunction)
  .then(result => console.log('Class result:', result))
  .catch(error => console.log('Class error:', error.message));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Immediate success (no retries needed)
retry(() => Promise.resolve('immediate'), 3)
  .then(result => console.log('Immediate success:', result))
  .catch(error => console.log('Error:', error));

// Always fails
let alwaysFails = 0;
retry(() => {
  alwaysFails++;
  return Promise.reject(new Error(`Failure ${alwaysFails}`));
}, 2)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Always fails:', error.message));

// Zero retries
retry(() => Promise.reject(new Error('No retries')), 0)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Zero retries:', error.message));

// Synchronous error
retry(() => {
  throw new Error('Sync error');
}, 2)
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Sync error caught:', error.message));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Retry HTTP request
async function fetchWithRetry(url, options, maxRetries = 3) {
  return retry(
    () => fetch(url, options).then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    }),
    maxRetries
  );
}

// 2. Retry database connection
async function connectWithRetry(connectionString, maxRetries = 5) {
  return retryWithBackoff(
    () => database.connect(connectionString),
    maxRetries,
    2000 // Start with 2 second delay
  );
}

// 3. Retry only on network errors
async function apiCallWithRetry(endpoint) {
  return retryIf(
    () => api.call(endpoint),
    3,
    (error) => error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT'
  );
}

console.log('\n=== Use Cases ===');
console.log('fetchWithRetry - retry failed HTTP requests');
console.log('connectWithRetry - retry database connections with backoff');
console.log('apiCallWithRetry - retry only network errors, not auth errors');
```

**Interview Tips:**
- Retry pattern: attempt operation, if fails, try again up to max attempts
- Common strategies: fixed delay, exponential backoff, jittered backoff
- Exponential backoff: delay doubles each retry (1s, 2s, 4s, 8s...)
- Use for transient failures: network issues, rate limits, temporary unavailability
- Don't retry: authentication errors, validation errors, 404s
- Key decisions: max retries, delay strategy, which errors to retry
- For loop approach cleaner than recursion (avoids stack overflow)
- Track attempt number for logging and decision making
- Add callbacks/hooks for monitoring and debugging
- Consider timeout per attempt to prevent hanging
- Jitter: add randomness to prevent thundering herd
- Circuit breaker pattern: stop retrying after threshold
- Idempotency important: operation should be safe to retry
- Applications: API calls, database operations, file uploads, message queues
- Edge cases: immediate success, always fails, zero retries, sync errors
- Clarify: fixed delay or backoff? which errors to retry? timeout needed?
- Follow-ups: implement circuit breaker, add jitter, retry with rate limiting
- Common mistakes: infinite retries, no delay, retrying non-idempotent operations

</details>

80. Implement a promise-based delay function

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Delay Function**
```javascript
/**
 * Simple promise-based delay function
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Returns a promise that resolves after specified milliseconds
 */
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Test
console.log('=== Basic Delay ===');

(async () => {
  console.log('Start:', new Date().toLocaleTimeString());
  await delay(1000);
  console.log('After 1s:', new Date().toLocaleTimeString());
  await delay(500);
  console.log('After 0.5s more:', new Date().toLocaleTimeString());
})();
```

### **Approach 2: Delay with Value**
```javascript
/**
 * Delay that resolves with a specific value
 */
function delayWithValue(ms, value) {
  return new Promise(resolve => setTimeout(() => resolve(value), ms));
}

// Test
console.log('\n=== Delay with Value ===');

(async () => {
  const result1 = await delayWithValue(500, 'Hello');
  console.log('Result 1:', result1); // 'Hello'
  
  const result2 = await delayWithValue(300, { data: 'World' });
  console.log('Result 2:', result2); // { data: 'World' }
})();
```

### **Approach 3: Cancellable Delay**
```javascript
/**
 * Delay with cancellation support
 */
function cancellableDelay(ms) {
  let timeoutId;
  let rejectFn;
  
  const promise = new Promise((resolve, reject) => {
    rejectFn = reject;
    timeoutId = setTimeout(resolve, ms);
  });
  
  promise.cancel = () => {
    clearTimeout(timeoutId);
    rejectFn(new Error('Delay cancelled'));
  };
  
  return promise;
}

// Test
console.log('\n=== Cancellable Delay ===');

(async () => {
  const delayPromise = cancellableDelay(2000);
  
  // Cancel after 500ms
  setTimeout(() => {
    console.log('Cancelling delay...');
    delayPromise.cancel();
  }, 500);
  
  try {
    await delayPromise;
    console.log('Delay completed');
  } catch (error) {
    console.log('Caught:', error.message); // 'Delay cancelled'
  }
})();
```

### **Approach 4: Delay with Callback**
```javascript
/**
 * Delay with optional callback on completion
 */
function delayWithCallback(ms, callback) {
  return new Promise(resolve => {
    setTimeout(() => {
      const result = callback ? callback() : undefined;
      resolve(result);
    }, ms);
  });
}

// Test
console.log('\n=== Delay with Callback ===');

(async () => {
  const result = await delayWithCallback(400, () => {
    console.log('Callback executed!');
    return 'Callback result';
  });
  
  console.log('Returned:', result); // 'Callback result'
})();
```

### **Approach 5: Delay with Progress**
```javascript
/**
 * Delay with progress callbacks
 */
function delayWithProgress(ms, onProgress, interval = 100) {
  return new Promise(resolve => {
    const startTime = Date.now();
    
    const progressInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / ms, 1);
      
      if (onProgress) {
        onProgress({
          elapsed,
          total: ms,
          progress: progress * 100,
          remaining: ms - elapsed
        });
      }
      
      if (elapsed >= ms) {
        clearInterval(progressInterval);
      }
    }, interval);
    
    setTimeout(() => {
      clearInterval(progressInterval);
      resolve();
    }, ms);
  });
}

// Test
console.log('\n=== Delay with Progress ===');

(async () => {
  console.log('Starting delay with progress...');
  
  await delayWithProgress(1000, (info) => {
    console.log(`Progress: ${info.progress.toFixed(0)}% (${info.elapsed}ms / ${info.total}ms)`);
  }, 250);
  
  console.log('Delay complete!');
})();
```

### **Bonus: Minimum Delay Wrapper**
```javascript
/**
 * Ensure a function takes at least a minimum time
 * Useful for showing loading indicators
 */
async function withMinDelay(fn, minMs) {
  const [result] = await Promise.all([
    fn(),
    delay(minMs)
  ]);
  return result;
}

// Test
console.log('\n=== Minimum Delay Wrapper ===');

(async () => {
  const fastFunction = () => Promise.resolve('Fast result');
  
  console.log('Starting...');
  const start = Date.now();
  
  const result = await withMinDelay(fastFunction, 1000);
  
  const elapsed = Date.now() - start;
  console.log('Result:', result);
  console.log('Took at least:', elapsed, 'ms'); // ~1000ms
})();
```

### **Bonus: Delay Between Operations**
```javascript
/**
 * Add delay between async operations
 */
async function delayBetween(operations, delayMs) {
  const results = [];
  
  for (let i = 0; i < operations.length; i++) {
    const result = await operations[i]();
    results.push(result);
    
    // Don't delay after last operation
    if (i < operations.length - 1) {
      await delay(delayMs);
    }
  }
  
  return results;
}

// Test
console.log('\n=== Delay Between Operations ===');

(async () => {
  const operations = [
    () => Promise.resolve('Op 1'),
    () => Promise.resolve('Op 2'),
    () => Promise.resolve('Op 3')
  ];
  
  console.log('Starting operations with delays...');
  const start = Date.now();
  
  const results = await delayBetween(operations, 300);
  
  const elapsed = Date.now() - start;
  console.log('Results:', results);
  console.log('Total time:', elapsed, 'ms'); // ~600ms (2 delays)
})();
```

### **Bonus: Timeout Function**
```javascript
/**
 * Create timeout wrapper using delay
 */
function timeout(promise, ms) {
  const timeoutPromise = delay(ms).then(() => {
    throw new Error(`Operation timed out after ${ms}ms`);
  });
  
  return Promise.race([promise, timeoutPromise]);
}

// Test
console.log('\n=== Timeout Function ===');

(async () => {
  // Fast operation - succeeds
  try {
    const fast = delayWithValue(200, 'Quick!');
    const result = await timeout(fast, 500);
    console.log('Fast operation:', result);
  } catch (error) {
    console.log('Error:', error.message);
  }
  
  // Slow operation - times out
  try {
    const slow = delayWithValue(2000, 'Slow...');
    const result = await timeout(slow, 500);
    console.log('Slow operation:', result);
  } catch (error) {
    console.log('Timeout error:', error.message);
  }
})();
```

### **Bonus: Throttled Delay**
```javascript
/**
 * Throttle function calls with delay
 */
function throttleWithDelay(fn, delayMs) {
  let lastCall = 0;
  
  return async function(...args) {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;
    
    if (timeSinceLastCall < delayMs) {
      await delay(delayMs - timeSinceLastCall);
    }
    
    lastCall = Date.now();
    return fn(...args);
  };
}

// Test
console.log('\n=== Throttled with Delay ===');

(async () => {
  let callCount = 0;
  const apiCall = (msg) => {
    callCount++;
    console.log(`Call ${callCount}: ${msg} at ${new Date().toLocaleTimeString()}`);
    return Promise.resolve(`Result ${callCount}`);
  };
  
  const throttled = throttleWithDelay(apiCall, 500);
  
  // These calls will be spaced at least 500ms apart
  await throttled('First');
  await throttled('Second');
  await throttled('Third');
})();
```

### **Bonus: Sleep Function (Alias)**
```javascript
/**
 * Sleep function - common alias for delay
 */
const sleep = delay;

// Can also be written as:
function sleep2(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Test
console.log('\n=== Sleep Function ===');

(async () => {
  console.log('Going to sleep...');
  await sleep(800);
  console.log('Woke up!');
})();
```

### **Bonus: Delay Class**
```javascript
/**
 * Delay class with utilities
 */
class Delay {
  constructor(ms) {
    this.ms = ms;
    this.timeoutId = null;
    this.promise = null;
  }
  
  start() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      this.timeoutId = setTimeout(() => resolve(), this.ms);
    });
    return this.promise;
  }
  
  cancel() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.reject(new Error('Delay cancelled'));
    }
  }
  
  static wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  static async sequence(delays) {
    for (const ms of delays) {
      await Delay.wait(ms);
    }
  }
}

// Test
console.log('\n=== Delay Class ===');

(async () => {
  // Instance usage
  const d = new Delay(500);
  d.start().then(() => console.log('Instance delay done'));
  
  // Static usage
  await Delay.wait(600);
  console.log('Static delay done');
  
  // Sequence
  console.log('Starting sequence...');
  await Delay.sequence([200, 300, 400]);
  console.log('Sequence done');
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of delay function
 */

// 1. Rate limiting API calls
async function rateLimitedFetch(urls, delayBetween = 1000) {
  const results = [];
  
  for (const url of urls) {
    const response = await fetch(url);
    results.push(await response.json());
    
    if (urls.indexOf(url) < urls.length - 1) {
      await delay(delayBetween);
    }
  }
  
  return results;
}

// 2. Retry with exponential backoff
async function retryWithDelay(fn, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) throw error;
      
      const delayMs = Math.pow(2, i) * 1000;
      console.log(`Retry ${i + 1} after ${delayMs}ms`);
      await delay(delayMs);
    }
  }
}

// 3. Simulate loading state
async function fetchWithMinLoading(fetchFn, minLoadingTime = 1000) {
  const startTime = Date.now();
  const data = await fetchFn();
  const elapsed = Date.now() - startTime;
  
  if (elapsed < minLoadingTime) {
    await delay(minLoadingTime - elapsed);
  }
  
  return data;
}

// 4. Debounce with delay
function debounceAsync(fn, wait) {
  let timeoutId;
  
  return function(...args) {
    return new Promise((resolve) => {
      clearTimeout(timeoutId);
      
      timeoutId = setTimeout(async () => {
        const result = await fn(...args);
        resolve(result);
      }, wait);
    });
  };
}

console.log('\n=== Use Cases ===');
console.log('rateLimitedFetch - delay between API calls');
console.log('retryWithDelay - exponential backoff retry');
console.log('fetchWithMinLoading - minimum loading indicator time');
console.log('debounceAsync - debounce async operations');
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Zero delay
(async () => {
  console.log('Zero delay start');
  await delay(0);
  console.log('Zero delay end (next tick)');
})();

// Very long delay (shouldn't cause issues)
delay(100000).then(() => console.log('Very long delay'));

// Negative delay (treated as 0)
(async () => {
  await delay(-100);
  console.log('Negative delay completed immediately');
})();

// Chained delays
(async () => {
  await delay(100)
    .then(() => delay(100))
    .then(() => delay(100));
  console.log('Chained delays completed');
})();

// Parallel delays
(async () => {
  const start = Date.now();
  
  await Promise.all([
    delay(300),
    delay(200),
    delay(400)
  ]);
  
  const elapsed = Date.now() - start;
  console.log(`Parallel delays: ~${elapsed}ms (should be ~400ms, not 900ms)`);
})();
```

### **Performance Considerations**
```javascript
/**
 * Compare different delay patterns
 */
console.log('\n=== Performance Patterns ===');

// Sequential delays - total time = sum of delays
async function sequential() {
  const start = Date.now();
  
  await delay(100);
  await delay(100);
  await delay(100);
  
  console.log('Sequential:', Date.now() - start, 'ms'); // ~300ms
}

// Parallel delays - total time = max delay
async function parallel() {
  const start = Date.now();
  
  await Promise.all([
    delay(100),
    delay(100),
    delay(100)
  ]);
  
  console.log('Parallel:', Date.now() - start, 'ms'); // ~100ms
}

setTimeout(() => {
  sequential().then(() => parallel());
}, 1500);
```

### **Comparison with setTimeout**
```javascript
/**
 * Demonstrate advantages of promise-based delay
 */
console.log('\n=== Promise Delay vs setTimeout ===');

// setTimeout - callback based
setTimeout(() => {
  console.log('setTimeout callback');
}, 500);

// Promise delay - async/await
(async () => {
  await delay(500);
  console.log('Promise delay with await');
})();

// Chaining with setTimeout is messy
setTimeout(() => {
  console.log('Step 1');
  setTimeout(() => {
    console.log('Step 2');
    setTimeout(() => {
      console.log('Step 3');
    }, 100);
  }, 100);
}, 100);

// Promise delay is cleaner
(async () => {
  await delay(600);
  console.log('Clean Step 1');
  await delay(100);
  console.log('Clean Step 2');
  await delay(100);
  console.log('Clean Step 3');
})();
```

**Interview Tips:**
- Promise-based delay wraps setTimeout in a Promise
- Enables use with async/await for cleaner async code
- Basic: `new Promise(resolve => setTimeout(resolve, ms))`
- Can resolve with value: `setTimeout(() => resolve(value), ms)`
- Common aliases: sleep, wait, pause
- Use cases: rate limiting, delays between operations, retries, animations
- Advantages over setTimeout: composable, can use with async/await, chainable
- Can add cancellation by tracking timeoutId and calling clearTimeout
- Zero/negative delay still defers to next event loop tick
- Parallel delays: Promise.all waits for slowest, not sum of all
- Sequential delays: await each one, total = sum of delays
- Useful for: debouncing, throttling, polling, retries, loading states
- Related patterns: timeout wrapper, minimum delay, throttle, debounce
- Applications: API rate limiting, UI animations, simulating network delay
- Edge cases: zero delay, negative delay, very long delay, cancellation
- Clarify: need cancellation? resolve with value? progress tracking?
- Follow-ups: implement timeout, debounce, throttle, retry with backoff

</details>

81. Create a function to execute promises sequentially

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Sequential Execution with Async/Await**
```javascript
/**
 * Execute promise-returning functions sequentially
 * Time Complexity: O(n) where n is number of functions
 * Space Complexity: O(n) for results array
 */
async function executeSequentially(promiseFunctions) {
  const results = [];
  
  for (const fn of promiseFunctions) {
    const result = await fn();
    results.push(result);
  }
  
  return results;
}

// Test
console.log('=== Basic Sequential Execution ===');

const delay = (ms, value) => new Promise(resolve => 
  setTimeout(() => resolve(value), ms)
);

(async () => {
  const functions = [
    () => delay(300, 'First'),
    () => delay(100, 'Second'),
    () => delay(200, 'Third')
  ];
  
  console.log('Starting sequential execution...');
  const start = Date.now();
  
  const results = await executeSequentially(functions);
  
  console.log('Results:', results); // ['First', 'Second', 'Third']
  console.log('Time:', Date.now() - start, 'ms'); // ~600ms (300+100+200)
})();
```

### **Approach 2: Using Reduce**
```javascript
/**
 * Sequential execution using Array.reduce
 */
async function executeSequentiallyReduce(promiseFunctions) {
  return promiseFunctions.reduce(async (previousPromise, currentFn) => {
    const results = await previousPromise;
    const result = await currentFn();
    return [...results, result];
  }, Promise.resolve([]));
}

// Test
console.log('\n=== Using Reduce ===');

(async () => {
  const functions = [
    () => delay(200, 'A'),
    () => delay(150, 'B'),
    () => delay(100, 'C')
  ];
  
  const results = await executeSequentiallyReduce(functions);
  console.log('Reduce results:', results); // ['A', 'B', 'C']
})();
```

### **Approach 3: Sequential with Error Handling**
```javascript
/**
 * Sequential execution with individual error handling
 */
async function executeSequentiallyWithErrors(promiseFunctions, options = {}) {
  const { stopOnError = true, defaultValue = null } = options;
  const results = [];
  
  for (let i = 0; i < promiseFunctions.length; i++) {
    try {
      const result = await promiseFunctions[i]();
      results.push({ status: 'fulfilled', value: result, index: i });
    } catch (error) {
      results.push({ status: 'rejected', reason: error, index: i });
      
      if (stopOnError) {
        throw new Error(`Stopped at index ${i}: ${error.message}`);
      }
    }
  }
  
  return results;
}

// Test
console.log('\n=== With Error Handling ===');

(async () => {
  const functions = [
    () => Promise.resolve('Success 1'),
    () => Promise.reject(new Error('Failed!')),
    () => Promise.resolve('Success 3')
  ];
  
  // Continue on error
  const results = await executeSequentiallyWithErrors(functions, { stopOnError: false });
  console.log('Results:', results);
  
  // Stop on error
  try {
    await executeSequentiallyWithErrors(functions, { stopOnError: true });
  } catch (error) {
    console.log('Stopped:', error.message);
  }
})();
```

### **Approach 4: Sequential with Index and Context**
```javascript
/**
 * Sequential execution with access to previous results
 */
async function executeSequentiallyWithContext(promiseFunctions) {
  const results = [];
  
  for (let i = 0; i < promiseFunctions.length; i++) {
    const result = await promiseFunctions[i](results, i);
    results.push(result);
  }
  
  return results;
}

// Test
console.log('\n=== With Context ===');

(async () => {
  const functions = [
    () => delay(100, 1),
    (prev) => delay(100, prev[0] + 1), // Access previous results
    (prev) => delay(100, prev[0] + prev[1]) // Sum of previous
  ];
  
  const results = await executeSequentiallyWithContext(functions);
  console.log('Context results:', results); // [1, 2, 3]
})();
```

### **Approach 5: Sequential Pipeline**
```javascript
/**
 * Pipeline where output of one becomes input of next
 */
async function pipeline(initialValue, ...functions) {
  let result = initialValue;
  
  for (const fn of functions) {
    result = await fn(result);
  }
  
  return result;
}

// Test
console.log('\n=== Pipeline ===');

(async () => {
  const result = await pipeline(
    5,
    async (x) => { await delay(100); return x * 2; },
    async (x) => { await delay(100); return x + 3; },
    async (x) => { await delay(100); return x - 1; }
  );
  
  console.log('Pipeline result:', result); // ((5 * 2) + 3) - 1 = 12
})();
```

### **Bonus: Sequential with Batching**
```javascript
/**
 * Execute in sequential batches
 */
async function executeInBatches(promiseFunctions, batchSize) {
  const results = [];
  
  for (let i = 0; i < promiseFunctions.length; i += batchSize) {
    const batch = promiseFunctions.slice(i, i + batchSize);
    
    // Execute batch in parallel
    const batchResults = await Promise.all(batch.map(fn => fn()));
    results.push(...batchResults);
    
    console.log(`Batch ${Math.floor(i / batchSize) + 1} complete`);
  }
  
  return results;
}

// Test
console.log('\n=== Sequential Batches ===');

(async () => {
  const functions = Array.from({ length: 10 }, (_, i) => 
    () => delay(100, `Item ${i + 1}`)
  );
  
  const start = Date.now();
  const results = await executeInBatches(functions, 3);
  
  console.log('Batch results:', results.length, 'items');
  console.log('Time:', Date.now() - start, 'ms'); // ~400ms (4 batches)
})();
```

### **Bonus: Sequential with Progress**
```javascript
/**
 * Sequential execution with progress tracking
 */
async function executeSequentiallyWithProgress(promiseFunctions, onProgress) {
  const results = [];
  const total = promiseFunctions.length;
  
  for (let i = 0; i < total; i++) {
    const result = await promiseFunctions[i]();
    results.push(result);
    
    if (onProgress) {
      onProgress({
        completed: i + 1,
        total,
        percentage: ((i + 1) / total) * 100,
        current: result
      });
    }
  }
  
  return results;
}

// Test
console.log('\n=== With Progress ===');

(async () => {
  const functions = [
    () => delay(200, 'Task 1'),
    () => delay(300, 'Task 2'),
    () => delay(100, 'Task 3')
  ];
  
  const results = await executeSequentiallyWithProgress(functions, (progress) => {
    console.log(`Progress: ${progress.percentage.toFixed(0)}% - ${progress.current}`);
  });
  
  console.log('All done:', results);
})();
```

### **Bonus: Sequential with Retry**
```javascript
/**
 * Sequential execution with retry on failure
 */
async function executeSequentiallyWithRetry(promiseFunctions, maxRetries = 3) {
  const results = [];
  
  for (let i = 0; i < promiseFunctions.length; i++) {
    let lastError;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const result = await promiseFunctions[i]();
        results.push(result);
        break; // Success, move to next function
      } catch (error) {
        lastError = error;
        
        if (attempt < maxRetries) {
          console.log(`Function ${i} failed, retry ${attempt + 1}/${maxRetries}`);
          await delay(100 * Math.pow(2, attempt)); // Exponential backoff
        }
      }
    }
    
    if (results.length !== i + 1) {
      throw new Error(`Function ${i} failed after ${maxRetries + 1} attempts: ${lastError.message}`);
    }
  }
  
  return results;
}

// Test
console.log('\n=== With Retry ===');

(async () => {
  let attempts = 0;
  const functions = [
    () => Promise.resolve('Success 1'),
    () => {
      attempts++;
      return attempts < 3 
        ? Promise.reject(new Error('Temporary failure'))
        : Promise.resolve('Success 2');
    },
    () => Promise.resolve('Success 3')
  ];
  
  const results = await executeSequentiallyWithRetry(functions, 3);
  console.log('Retry results:', results);
})();
```

### **Bonus: Comparison - Sequential vs Parallel**
```javascript
/**
 * Compare execution times
 */
async function compareExecution() {
  const functions = [
    () => delay(300, 'A'),
    () => delay(200, 'B'),
    () => delay(100, 'C')
  ];
  
  console.log('\n=== Sequential vs Parallel ===');
  
  // Sequential
  const seqStart = Date.now();
  await executeSequentially(functions);
  console.log('Sequential time:', Date.now() - seqStart, 'ms'); // ~600ms
  
  // Parallel
  const parStart = Date.now();
  await Promise.all(functions.map(fn => fn()));
  console.log('Parallel time:', Date.now() - parStart, 'ms'); // ~300ms
}

setTimeout(() => compareExecution(), 1500);
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty array
(async () => {
  const results = await executeSequentially([]);
  console.log('Empty array:', results); // []
})();

// Single function
(async () => {
  const results = await executeSequentially([
    () => Promise.resolve('Single')
  ]);
  console.log('Single function:', results); // ['Single']
})();

// Functions returning non-promises
(async () => {
  const results = await executeSequentially([
    () => 'Sync 1',
    () => Promise.resolve('Async'),
    () => 'Sync 2'
  ]);
  console.log('Mixed sync/async:', results); // ['Sync 1', 'Async', 'Sync 2']
})();

// One function rejects
(async () => {
  try {
    await executeSequentially([
      () => Promise.resolve('OK'),
      () => Promise.reject(new Error('Failed')),
      () => Promise.resolve('Never reached')
    ]);
  } catch (error) {
    console.log('Rejection stops execution:', error.message);
  }
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Sequential database migrations
async function runMigrations(migrations) {
  console.log('\n=== Database Migrations ===');
  
  for (let i = 0; i < migrations.length; i++) {
    console.log(`Running migration ${i + 1}/${migrations.length}...`);
    await migrations[i]();
  }
  
  console.log('All migrations complete');
}

// 2. Sequential file processing
async function processFiles(files) {
  const results = [];
  
  for (const file of files) {
    const content = await readFile(file);
    const processed = await processContent(content);
    await writeFile(file, processed);
    results.push({ file, status: 'processed' });
  }
  
  return results;
}

// 3. Step-by-step wizard/form
async function processWizardSteps(steps) {
  const answers = [];
  
  for (const step of steps) {
    const answer = await step.prompt();
    answers.push(answer);
    
    // Each step might depend on previous answers
    if (step.validate && !step.validate(answers)) {
      throw new Error('Validation failed');
    }
  }
  
  return answers;
}

// 4. Sequential API calls with dependencies
async function fetchUserData(userId) {
  const user = await fetchUser(userId);
  const posts = await fetchUserPosts(user.id);
  const comments = await fetchPostComments(posts.map(p => p.id));
  
  return { user, posts, comments };
}

console.log('\nUse Cases:');
console.log('runMigrations - database migrations must run in order');
console.log('processFiles - avoid file conflicts');
console.log('processWizardSteps - each step depends on previous');
console.log('fetchUserData - each request needs data from previous');
```

### **Performance Considerations**
```javascript
/**
 * When to use sequential vs parallel
 */
console.log('\n=== Sequential vs Parallel Decision ===');

// Use Sequential When:
// 1. Operations have dependencies
// 2. Need to avoid race conditions
// 3. Rate limiting (don't overwhelm server)
// 4. Order matters
// 5. Limited resources (memory, connections)

// Use Parallel When:
// 1. No dependencies between operations
// 2. Want maximum speed
// 3. Operations are independent
// 4. Order doesn't matter

// Example: Rate-limited API calls
async function rateLimitedFetch(urls) {
  const results = [];
  
  for (const url of urls) {
    const result = await fetch(url);
    results.push(await result.json());
    
    // Delay between requests to respect rate limits
    await delay(1000);
  }
  
  return results;
}

console.log('Sequential good for: dependencies, rate limiting, resource constraints');
console.log('Parallel good for: independent operations, maximum speed');
```

**Interview Tips:**
- Sequential execution: wait for each promise before starting next
- Use for: dependent operations, rate limiting, ordered execution
- Basic: use for loop with await (not forEach!)
- forEach won't work with await - it doesn't wait for async functions
- Use for...of loop for sequential execution with await
- Array.reduce can work but for loop is clearer
- Sequential time = sum of all operation times
- Parallel time = max of all operation times
- Sequential vs Parallel: know when to use each
- Dependencies require sequential execution
- Pipeline pattern: output of one becomes input of next
- Can combine: sequential batches where each batch runs in parallel
- Error handling: decide if one failure should stop all
- Progress tracking useful for long-running sequential tasks
- Applications: migrations, file processing, dependent API calls, wizards
- Edge cases: empty array, single item, mixed sync/async, early rejection
- Common mistake: using forEach with await (doesn't work!)
- Clarify: should errors stop execution? need progress? retries?
- Follow-ups: implement batching, add retry logic, rate limiting

</details>

82. Implement parallel promise execution with concurrency limit

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Concurrency Limiter**
```javascript
/**
 * Execute promises with limited concurrency
 * Time Complexity: O(n) where n is number of tasks
 * Space Complexity: O(concurrency) for active promises
 * 
 * Limits number of promises running simultaneously
 */
async function promiseConcurrency(tasks, concurrency) {
  const results = [];
  const executing = [];
  
  for (const [index, task] of tasks.entries()) {
    const promise = Promise.resolve().then(() => task()).then(result => {
      results[index] = result;
    });
    
    executing.push(promise);
    
    if (executing.length >= concurrency) {
      await Promise.race(executing);
      // Remove completed promises
      executing.splice(executing.findIndex(p => p === promise), 1);
    }
  }
  
  await Promise.all(executing);
  return results;
}

// Test
console.log('=== Basic Concurrency Limiter ===');

const delay = (ms, value) => new Promise(resolve => 
  setTimeout(() => {
    console.log(`Completed: ${value}`);
    resolve(value);
  }, ms)
);

(async () => {
  const tasks = [
    () => delay(1000, 'Task 1'),
    () => delay(500, 'Task 2'),
    () => delay(800, 'Task 3'),
    () => delay(300, 'Task 4'),
    () => delay(600, 'Task 5')
  ];
  
  console.log('Starting with concurrency 2...');
  const start = Date.now();
  
  const results = await promiseConcurrency(tasks, 2);
  
  console.log('Results:', results);
  console.log('Time:', Date.now() - start, 'ms');
  // With concurrency 2: ~2300ms (not all at once)
})();
```

### **Approach 2: Using Promise Pool**
```javascript
/**
 * Better implementation using promise pool
 */
async function promisePool(tasks, concurrency) {
  const results = [];
  let index = 0;
  
  async function worker() {
    while (index < tasks.length) {
      const currentIndex = index++;
      const task = tasks[currentIndex];
      
      try {
        results[currentIndex] = await task();
      } catch (error) {
        results[currentIndex] = { error };
      }
    }
  }
  
  // Create worker pool
  const workers = Array(Math.min(concurrency, tasks.length))
    .fill(null)
    .map(() => worker());
  
  await Promise.all(workers);
  return results;
}

// Test
console.log('\n=== Promise Pool ===');

(async () => {
  const tasks = Array.from({ length: 10 }, (_, i) => 
    () => delay(Math.random() * 1000, `Task ${i + 1}`)
  );
  
  console.log('Starting pool with concurrency 3...');
  const start = Date.now();
  
  const results = await promisePool(tasks, 3);
  
  console.log('Pool results:', results.length, 'tasks');
  console.log('Time:', Date.now() - start, 'ms');
})();
```

### **Approach 3: With Error Handling and Retry**
```javascript
/**
 * Concurrency with comprehensive error handling
 */
async function promiseConcurrencyWithRetry(tasks, concurrency, options = {}) {
  const { maxRetries = 0, onProgress = null } = options;
  const results = [];
  let index = 0;
  let completed = 0;
  
  async function worker() {
    while (index < tasks.length) {
      const currentIndex = index++;
      const task = tasks[currentIndex];
      let lastError;
      
      // Retry logic
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          results[currentIndex] = {
            status: 'fulfilled',
            value: await task()
          };
          break;
        } catch (error) {
          lastError = error;
          
          if (attempt < maxRetries) {
            console.log(`Task ${currentIndex} failed, retry ${attempt + 1}/${maxRetries}`);
            await new Promise(r => setTimeout(r, 100 * Math.pow(2, attempt)));
          }
        }
      }
      
      if (!results[currentIndex]) {
        results[currentIndex] = {
          status: 'rejected',
          reason: lastError
        };
      }
      
      completed++;
      
      if (onProgress) {
        onProgress({
          completed,
          total: tasks.length,
          percentage: (completed / tasks.length) * 100
        });
      }
    }
  }
  
  const workers = Array(Math.min(concurrency, tasks.length))
    .fill(null)
    .map(() => worker());
  
  await Promise.all(workers);
  return results;
}

// Test
console.log('\n=== With Retry ===');

(async () => {
  let taskFailCount = 0;
  
  const tasks = [
    () => Promise.resolve('Success 1'),
    () => {
      taskFailCount++;
      return taskFailCount < 2 
        ? Promise.reject(new Error('Temporary failure'))
        : Promise.resolve('Success 2');
    },
    () => Promise.resolve('Success 3'),
    () => Promise.reject(new Error('Permanent failure'))
  ];
  
  const results = await promiseConcurrencyWithRetry(tasks, 2, {
    maxRetries: 2,
    onProgress: (p) => console.log(`Progress: ${p.percentage.toFixed(0)}%`)
  });
  
  console.log('Retry results:', results);
})();
```

### **Approach 4: P-Limit Style Implementation**
```javascript
/**
 * Popular p-limit library style
 */
function pLimit(concurrency) {
  const queue = [];
  let activeCount = 0;
  
  const next = () => {
    activeCount--;
    
    if (queue.length > 0) {
      queue.shift()();
    }
  };
  
  const run = async (fn, resolve, reject) => {
    activeCount++;
    
    try {
      const result = await fn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      next();
    }
  };
  
  const enqueue = (fn) => {
    return new Promise((resolve, reject) => {
      const execute = () => run(fn, resolve, reject);
      
      if (activeCount < concurrency) {
        execute();
      } else {
        queue.push(execute);
      }
    });
  };
  
  return enqueue;
}

// Test
console.log('\n=== P-Limit Style ===');

(async () => {
  const limit = pLimit(2);
  
  const tasks = [
    () => delay(500, 'A'),
    () => delay(300, 'B'),
    () => delay(700, 'C'),
    () => delay(200, 'D'),
    () => delay(400, 'E')
  ];
  
  console.log('P-Limit with concurrency 2...');
  const start = Date.now();
  
  const results = await Promise.all(tasks.map(task => limit(task)));
  
  console.log('P-Limit results:', results);
  console.log('Time:', Date.now() - start, 'ms');
})();
```

### **Approach 5: Class-Based Implementation**
```javascript
/**
 * Reusable class for concurrent execution
 */
class ConcurrencyLimiter {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async run(task) {
    while (this.running >= this.concurrency) {
      await new Promise(resolve => this.queue.push(resolve));
    }
    
    this.running++;
    
    try {
      return await task();
    } finally {
      this.running--;
      
      const resolve = this.queue.shift();
      if (resolve) resolve();
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
  
  getStatus() {
    return {
      running: this.running,
      queued: this.queue.length,
      concurrency: this.concurrency
    };
  }
}

// Test
console.log('\n=== Class-Based Limiter ===');

(async () => {
  const limiter = new ConcurrencyLimiter(3);
  
  const tasks = Array.from({ length: 8 }, (_, i) => 
    () => delay(500, `Task ${i + 1}`)
  );
  
  console.log('Class-based with concurrency 3...');
  
  // Monitor status
  const statusInterval = setInterval(() => {
    const status = limiter.getStatus();
    console.log(`Running: ${status.running}, Queued: ${status.queued}`);
  }, 200);
  
  const results = await limiter.runAll(tasks);
  
  clearInterval(statusInterval);
  console.log('Class results:', results.length, 'tasks');
})();
```

### **Bonus: With Rate Limiting**
```javascript
/**
 * Combine concurrency with rate limiting
 */
async function promiseWithRateLimit(tasks, concurrency, rateLimit) {
  const { requestsPerInterval, interval } = rateLimit;
  const results = [];
  let index = 0;
  let requestsInInterval = 0;
  let intervalStart = Date.now();
  
  async function worker() {
    while (index < tasks.length) {
      const currentIndex = index++;
      
      // Check rate limit
      if (requestsInInterval >= requestsPerInterval) {
        const elapsed = Date.now() - intervalStart;
        if (elapsed < interval) {
          await new Promise(r => setTimeout(r, interval - elapsed));
        }
        requestsInInterval = 0;
        intervalStart = Date.now();
      }
      
      requestsInInterval++;
      results[currentIndex] = await tasks[currentIndex]();
    }
  }
  
  const workers = Array(concurrency).fill(null).map(() => worker());
  await Promise.all(workers);
  return results;
}

// Test
console.log('\n=== With Rate Limiting ===');

(async () => {
  const tasks = Array.from({ length: 10 }, (_, i) => 
    () => delay(100, `Task ${i + 1}`)
  );
  
  console.log('Rate limit: 3 requests per second, concurrency: 5');
  const start = Date.now();
  
  const results = await promiseWithRateLimit(tasks, 5, {
    requestsPerInterval: 3,
    interval: 1000
  });
  
  console.log('Rate limited results:', results.length);
  console.log('Time:', Date.now() - start, 'ms'); // ~4000ms (10 tasks / 3 per sec)
})();
```

### **Bonus: Batch Processing**
```javascript
/**
 * Process tasks in fixed-size batches
 */
async function batchProcess(tasks, batchSize) {
  const results = [];
  
  for (let i = 0; i < tasks.length; i += batchSize) {
    const batch = tasks.slice(i, i + batchSize);
    console.log(`Processing batch ${Math.floor(i / batchSize) + 1}...`);
    
    const batchResults = await Promise.all(batch.map(task => task()));
    results.push(...batchResults);
  }
  
  return results;
}

// Test
console.log('\n=== Batch Processing ===');

(async () => {
  const tasks = Array.from({ length: 10 }, (_, i) => 
    () => delay(200, `Batch item ${i + 1}`)
  );
  
  const results = await batchProcess(tasks, 3);
  console.log('Batch results:', results.length, 'items');
})();
```

### **Bonus: Priority Queue**
```javascript
/**
 * Concurrency with task priorities
 */
class PriorityConcurrencyLimiter {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async run(task, priority = 0) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, priority, resolve, reject });
      this.queue.sort((a, b) => b.priority - a.priority);
      this.processQueue();
    });
  }
  
  async processQueue() {
    while (this.running < this.concurrency && this.queue.length > 0) {
      const { task, resolve, reject } = this.queue.shift();
      this.running++;
      
      task()
        .then(resolve)
        .catch(reject)
        .finally(() => {
          this.running--;
          this.processQueue();
        });
    }
  }
}

// Test
console.log('\n=== Priority Queue ===');

(async () => {
  const limiter = new PriorityConcurrencyLimiter(2);
  
  const results = await Promise.all([
    limiter.run(() => delay(300, 'Low priority'), 1),
    limiter.run(() => delay(300, 'High priority'), 10),
    limiter.run(() => delay(300, 'Medium priority'), 5),
    limiter.run(() => delay(300, 'Highest priority'), 20)
  ]);
  
  console.log('Priority results:', results);
})();
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty tasks
(async () => {
  const results = await promisePool([], 5);
  console.log('Empty tasks:', results); // []
})();

// Concurrency higher than task count
(async () => {
  const tasks = [
    () => delay(100, 'A'),
    () => delay(100, 'B')
  ];
  
  const results = await promisePool(tasks, 10);
  console.log('High concurrency:', results); // All run in parallel
})();

// Concurrency of 1 (sequential)
(async () => {
  const tasks = [
    () => delay(100, '1'),
    () => delay(100, '2'),
    () => delay(100, '3')
  ];
  
  const start = Date.now();
  const results = await promisePool(tasks, 1);
  console.log('Concurrency 1 (sequential):', results);
  console.log('Time:', Date.now() - start, 'ms'); // ~300ms
})();

// Mix of fast and slow tasks
(async () => {
  const tasks = [
    () => delay(1000, 'Slow'),
    () => delay(10, 'Fast 1'),
    () => delay(10, 'Fast 2'),
    () => delay(10, 'Fast 3')
  ];
  
  const start = Date.now();
  const results = await promisePool(tasks, 2);
  console.log('Mixed speed results:', results);
  console.log('Time:', Date.now() - start, 'ms');
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Batch API requests
async function batchFetchUsers(userIds, concurrency = 5) {
  const limit = pLimit(concurrency);
  
  const tasks = userIds.map(id => 
    () => fetch(`/api/users/${id}`).then(r => r.json())
  );
  
  return Promise.all(tasks.map(task => limit(task)));
}

// 2. File processing
async function processFilesInParallel(files, maxConcurrent = 3) {
  const limiter = new ConcurrencyLimiter(maxConcurrent);
  
  const tasks = files.map(file => async () => {
    const content = await readFile(file);
    const processed = await processContent(content);
    await writeFile(file, processed);
    return { file, status: 'processed' };
  });
  
  return limiter.runAll(tasks);
}

// 3. Web scraping
async function scrapeUrls(urls, concurrency = 5) {
  return promisePool(
    urls.map(url => () => scrapeUrl(url)),
    concurrency
  );
}

// 4. Image resizing
async function resizeImages(images, concurrency = 4) {
  const limit = pLimit(concurrency);
  
  return Promise.all(
    images.map(image => 
      limit(async () => {
        const resized = await resizeImage(image);
        await saveImage(resized);
        return resized;
      })
    )
  );
}

console.log('\nUse Cases:');
console.log('batchFetchUsers - avoid overwhelming API');
console.log('processFilesInParallel - limit CPU/memory usage');
console.log('scrapeUrls - respectful web scraping');
console.log('resizeImages - prevent memory overflow');
```

### **Performance Comparison**
```javascript
/**
 * Compare different concurrency levels
 */
async function benchmarkConcurrency() {
  console.log('\n=== Concurrency Benchmarks ===');
  
  const createTasks = () => Array.from({ length: 20 }, (_, i) => 
    () => delay(100, `Task ${i + 1}`)
  );
  
  // No limit (all parallel)
  let start = Date.now();
  await Promise.all(createTasks().map(t => t()));
  console.log('No limit (20 parallel):', Date.now() - start, 'ms'); // ~100ms
  
  // Concurrency 5
  start = Date.now();
  await promisePool(createTasks(), 5);
  console.log('Concurrency 5:', Date.now() - start, 'ms'); // ~400ms
  
  // Concurrency 2
  start = Date.now();
  await promisePool(createTasks(), 2);
  console.log('Concurrency 2:', Date.now() - start, 'ms'); // ~1000ms
  
  // Sequential (concurrency 1)
  start = Date.now();
  await promisePool(createTasks(), 1);
  console.log('Sequential (1):', Date.now() - start, 'ms'); // ~2000ms
}

setTimeout(() => benchmarkConcurrency(), 3000);
```

**Interview Tips:**
- Concurrency limit controls max simultaneous promises
- Use worker pool pattern: workers pull from queue
- Key insight: start new task when one completes
- Different from batching: dynamic vs fixed grouping
- Track active promises, start new when one finishes
- Common approaches: worker pool, semaphore, queue
- Worker pool best: create N workers that process queue
- Index variable shared across workers ensures order preservation
- Benefits: prevent overwhelming resources, rate limiting, memory control
- Applications: API calls, file I/O, CPU-intensive tasks, web scraping
- Concurrency vs Parallelism: concurrency limits tasks, parallelism is hardware
- Total time ≈ (total tasks / concurrency) * average task time
- Error handling: decide if one failure stops all or continues
- Can combine with: retries, rate limiting, priorities, progress tracking
- Popular libraries: p-limit, p-queue, bottleneck
- Edge cases: empty array, concurrency > tasks, concurrency = 1, all fail
- Clarify: error handling? retries? rate limiting? priorities?
- Follow-ups: add rate limiting, implement priority queue, add backpressure

</details>

83. Create a function to cache async function results (memoization)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Async Memoization**
```javascript
/**
 * Simple async memoization
 * Time Complexity: O(1) for cached results, O(n) for new calls
 * Space Complexity: O(n) where n is number of unique inputs
 */
function memoizeAsync(fn) {
  const cache = new Map();
  
  return async function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('Cache hit:', key);
      return cache.get(key);
    }
    
    console.log('Cache miss, computing:', key);
    const result = await fn(...args);
    cache.set(key, result);
    
    return result;
  };
}

// Test
console.log('=== Basic Async Memoization ===');

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const expensiveAsync = async (x, y) => {
  await delay(1000);
  return x + y;
};

(async () => {
  const memoized = memoizeAsync(expensiveAsync);
  
  console.log('First call (5, 3):');
  console.log('Result:', await memoized(5, 3)); // Takes 1s
  
  console.log('\nSecond call (5, 3):');
  console.log('Result:', await memoized(5, 3)); // Instant (cached)
  
  console.log('\nThird call (2, 4):');
  console.log('Result:', await memoized(2, 4)); // Takes 1s (new args)
})();
```

### **Approach 2: Handle Concurrent Calls**
```javascript
/**
 * Prevent duplicate calls for same arguments
 * If multiple calls made while first is pending, reuse same promise
 */
function memoizeAsyncWithPending(fn) {
  const cache = new Map();
  const pending = new Map();
  
  return async function(...args) {
    const key = JSON.stringify(args);
    
    // Return cached result
    if (cache.has(key)) {
      console.log('Cache hit:', key);
      return cache.get(key);
    }
    
    // Return pending promise
    if (pending.has(key)) {
      console.log('Returning pending promise:', key);
      return pending.get(key);
    }
    
    console.log('New call:', key);
    
    // Create new promise
    const promise = fn(...args).then(result => {
      cache.set(key, result);
      pending.delete(key);
      return result;
    }).catch(error => {
      pending.delete(key);
      throw error;
    });
    
    pending.set(key, promise);
    return promise;
  };
}

// Test
console.log('\n=== Handle Concurrent Calls ===');

let callCount = 0;
const slowFunction = async (x) => {
  callCount++;
  console.log(`Actual call #${callCount} for x=${x}`);
  await delay(1000);
  return x * 2;
};

(async () => {
  const memoized = memoizeAsyncWithPending(slowFunction);
  
  // Make 3 concurrent calls with same argument
  const [r1, r2, r3] = await Promise.all([
    memoized(5),
    memoized(5),
    memoized(5)
  ]);
  
  console.log('Results:', r1, r2, r3); // Only 1 actual call!
})();
```

### **Approach 3: With TTL (Time To Live)**
```javascript
/**
 * Memoization with cache expiration
 */
function memoizeAsyncWithTTL(fn, ttl = 60000) {
  const cache = new Map();
  
  return async function(...args) {
    const key = JSON.stringify(args);
    const now = Date.now();
    
    if (cache.has(key)) {
      const { value, timestamp } = cache.get(key);
      
      if (now - timestamp < ttl) {
        console.log('Cache hit (fresh):', key);
        return value;
      } else {
        console.log('Cache expired:', key);
        cache.delete(key);
      }
    }
    
    console.log('Cache miss:', key);
    const result = await fn(...args);
    
    cache.set(key, {
      value: result,
      timestamp: now
    });
    
    return result;
  };
}

// Test
console.log('\n=== With TTL ===');

const apiCall = async (id) => {
  await delay(500);
  return { id, data: `Data for ${id}`, timestamp: Date.now() };
};

(async () => {
  const memoized = memoizeAsyncWithTTL(apiCall, 2000); // 2 second TTL
  
  console.log('Call 1:');
  const r1 = await memoized(123);
  console.log('Result:', r1);
  
  await delay(500);
  
  console.log('\nCall 2 (within TTL):');
  const r2 = await memoized(123);
  console.log('Result:', r2);
  
  await delay(2000);
  
  console.log('\nCall 3 (after TTL):');
  const r3 = await memoized(123);
  console.log('Result:', r3);
})();
```

### **Approach 4: With Max Cache Size (LRU)**
```javascript
/**
 * LRU cache for async functions
 */
function memoizeAsyncLRU(fn, maxSize = 100) {
  const cache = new Map();
  
  return async function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('LRU cache hit:', key);
      // Move to end (most recently used)
      const value = cache.get(key);
      cache.delete(key);
      cache.set(key, value);
      return value;
    }
    
    console.log('LRU cache miss:', key);
    const result = await fn(...args);
    
    // Evict oldest if at capacity
    if (cache.size >= maxSize) {
      const oldestKey = cache.keys().next().value;
      console.log('Evicting oldest:', oldestKey);
      cache.delete(oldestKey);
    }
    
    cache.set(key, result);
    return result;
  };
}

// Test
console.log('\n=== LRU Cache ===');

(async () => {
  const memoized = memoizeAsyncLRU(async (x) => {
    await delay(100);
    return x * 2;
  }, 3); // Max 3 items
  
  await memoized(1);
  await memoized(2);
  await memoized(3);
  await memoized(4); // Evicts 1
  
  console.log('\nAccessing 1 again (should be cache miss):');
  await memoized(1);
})();
```

### **Approach 5: With Custom Key Generator**
```javascript
/**
 * Memoization with custom key generation
 */
function memoizeAsyncCustomKey(fn, keyGenerator) {
  const cache = new Map();
  
  return async function(...args) {
    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('Custom key hit:', key);
      return cache.get(key);
    }
    
    console.log('Custom key miss:', key);
    const result = await fn(...args);
    cache.set(key, result);
    
    return result;
  };
}

// Test
console.log('\n=== Custom Key Generator ===');

const fetchUser = async (user) => {
  await delay(500);
  return { ...user, fetchedAt: Date.now() };
};

(async () => {
  // Use user.id as key instead of whole object
  const memoized = memoizeAsyncCustomKey(
    fetchUser,
    (user) => user.id
  );
  
  const user1 = { id: 123, name: 'Alice' };
  const user2 = { id: 123, name: 'Alice (different instance)' };
  
  await memoized(user1);
  await memoized(user2); // Cache hit! Same id
})();
```

### **Bonus: Memoization Class with Features**
```javascript
/**
 * Full-featured memoization class
 */
class AsyncMemoizer {
  constructor(fn, options = {}) {
    this.fn = fn;
    this.cache = new Map();
    this.pending = new Map();
    this.options = {
      ttl: options.ttl || Infinity,
      maxSize: options.maxSize || Infinity,
      keyGenerator: options.keyGenerator || JSON.stringify,
      onCacheHit: options.onCacheHit || (() => {}),
      onCacheMiss: options.onCacheMiss || (() => {})
    };
  }
  
  async execute(...args) {
    const key = this.options.keyGenerator(args);
    
    // Check cache
    if (this.cache.has(key)) {
      const { value, timestamp } = this.cache.get(key);
      
      if (Date.now() - timestamp < this.options.ttl) {
        this.options.onCacheHit(key);
        return value;
      } else {
        this.cache.delete(key);
      }
    }
    
    // Check pending
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }
    
    this.options.onCacheMiss(key);
    
    // Execute
    const promise = this.fn(...args).then(result => {
      this.cache.set(key, {
        value: result,
        timestamp: Date.now()
      });
      this.pending.delete(key);
      
      // LRU eviction
      if (this.cache.size > this.options.maxSize) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
      
      return result;
    }).catch(error => {
      this.pending.delete(key);
      throw error;
    });
    
    this.pending.set(key, promise);
    return promise;
  }
  
  clear() {
    this.cache.clear();
    this.pending.clear();
  }
  
  delete(...args) {
    const key = this.options.keyGenerator(args);
    this.cache.delete(key);
  }
  
  getStats() {
    return {
      cacheSize: this.cache.size,
      pendingSize: this.pending.size
    };
  }
}

// Test
console.log('\n=== Memoization Class ===');

(async () => {
  const memoizer = new AsyncMemoizer(
    async (x) => {
      await delay(500);
      return x * 2;
    },
    {
      ttl: 3000,
      maxSize: 5,
      onCacheHit: (key) => console.log('Hit:', key),
      onCacheMiss: (key) => console.log('Miss:', key)
    }
  );
  
  await memoizer.execute(5);
  await memoizer.execute(5);
  
  console.log('Stats:', memoizer.getStats());
  
  memoizer.clear();
  console.log('After clear:', memoizer.getStats());
})();
```

### **Bonus: Selective Caching**
```javascript
/**
 * Cache only successful results
 */
function memoizeAsyncSelective(fn, shouldCache) {
  const cache = new Map();
  
  return async function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = await fn(...args);
    
    if (!shouldCache || shouldCache(result, args)) {
      cache.set(key, result);
    }
    
    return result;
  };
}

// Test
console.log('\n=== Selective Caching ===');

(async () => {
  const api = async (id) => {
    await delay(200);
    return id > 0 ? { id, data: 'success' } : { id, error: 'invalid' };
  };
  
  // Only cache successful results
  const memoized = memoizeAsyncSelective(
    api,
    (result) => !result.error
  );
  
  await memoized(5); // Cached
  await memoized(-1); // Not cached
  await memoized(5); // Cache hit
  await memoized(-1); // Called again
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. API response caching
const cachedFetch = memoizeAsyncWithTTL(
  async (url) => {
    const response = await fetch(url);
    return response.json();
  },
  300000 // 5 minutes
);

// 2. Database query caching
const getUserById = memoizeAsyncWithPending(
  async (userId) => {
    return database.query('SELECT * FROM users WHERE id = ?', [userId]);
  }
);

// 3. Expensive computation caching
const complexCalculation = memoizeAsync(
  async (input) => {
    // Heavy computation
    await delay(5000);
    return performComplexMath(input);
  }
);

// 4. File system operations
const readFileCache = memoizeAsyncWithTTL(
  async (filePath) => {
    return fs.promises.readFile(filePath, 'utf8');
  },
  60000 // 1 minute
);

console.log('\nUse Cases:');
console.log('cachedFetch - reduce API calls');
console.log('getUserById - avoid duplicate DB queries');
console.log('complexCalculation - cache expensive operations');
console.log('readFileCache - reduce file I/O');
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// No arguments
(async () => {
  const noArgs = memoizeAsync(async () => {
    await delay(100);
    return Math.random();
  });
  
  const r1 = await noArgs();
  const r2 = await noArgs();
  console.log('No args - same result?', r1 === r2); // true
})();

// Rejected promises
(async () => {
  let attempts = 0;
  const failing = memoizeAsync(async () => {
    attempts++;
    await delay(100);
    throw new Error(`Attempt ${attempts}`);
  });
  
  try {
    await failing();
  } catch (e) {
    console.log('First error:', e.message);
  }
  
  // Should NOT cache errors
  try {
    await failing();
  } catch (e) {
    console.log('Second error:', e.message);
  }
})();

// Object arguments
(async () => {
  const withObject = memoizeAsync(async (obj) => {
    await delay(100);
    return obj.value * 2;
  });
  
  await withObject({ value: 5 });
  await withObject({ value: 5 }); // Cache hit (JSON.stringify makes same key)
})();

// Array arguments
(async () => {
  const withArray = memoizeAsync(async (arr) => {
    await delay(100);
    return arr.reduce((a, b) => a + b, 0);
  });
  
  await withArray([1, 2, 3]);
  await withArray([1, 2, 3]); // Cache hit
})();
```

### **Performance Comparison**
```javascript
/**
 * Measure cache effectiveness
 */
async function benchmarkMemoization() {
  console.log('\n=== Memoization Benchmarks ===');
  
  const expensive = async (x) => {
    await delay(100);
    return x * 2;
  };
  
  // Without memoization
  let start = Date.now();
  await Promise.all([
    expensive(5),
    expensive(5),
    expensive(5),
    expensive(5),
    expensive(5)
  ]);
  console.log('Without cache (5 calls):', Date.now() - start, 'ms'); // ~100ms
  
  // With memoization
  const memoized = memoizeAsyncWithPending(expensive);
  start = Date.now();
  await Promise.all([
    memoized(5),
    memoized(5),
    memoized(5),
    memoized(5),
    memoized(5)
  ]);
  console.log('With cache (5 calls, same arg):', Date.now() - start, 'ms'); // ~100ms (1 call)
}

setTimeout(() => benchmarkMemoization(), 4000);
```

**Interview Tips:**
- Memoization: cache function results to avoid recalculation
- For async: must handle promises, concurrent calls, errors
- Basic: Map with JSON.stringify(args) as key
- Handle pending: prevent duplicate concurrent calls
- TTL: expire cache after time period
- LRU: limit cache size, evict least recently used
- Custom key: for complex objects, use specific properties
- Don't cache errors (usually) - allow retry
- Key generation critical: must be deterministic and unique
- Benefits: reduce API calls, database queries, expensive computations
- Trade-offs: memory usage vs speed, stale data risk
- Popular libraries: memoizee, p-memoize, mem
- Applications: API responses, DB queries, file reads, calculations
- Edge cases: no args, objects, arrays, errors, concurrent calls
- Clarify: TTL needed? max cache size? error handling? key generation?
- Follow-ups: implement cache warming, add statistics, distributed cache

</details>

84. Implement a polling function that checks a condition repeatedly

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Polling with Interval**
```javascript
/**
 * Simple polling that checks condition at intervals
 * Time Complexity: O(1) per check
 * Space Complexity: O(1)
 * 
 * Polls a condition function until it returns true or timeout
 */
async function poll(conditionFn, interval = 1000, timeout = 30000) {
  const startTime = Date.now();
  
  return new Promise((resolve, reject) => {
    const checkCondition = async () => {
      try {
        const result = await conditionFn();
        
        if (result) {
          console.log('Condition met!');
          resolve(result);
        } else if (Date.now() - startTime >= timeout) {
          reject(new Error('Polling timeout'));
        } else {
          console.log('Condition not met, retrying...');
          setTimeout(checkCondition, interval);
        }
      } catch (error) {
        reject(error);
      }
    };
    
    checkCondition();
  });
}

// Test
console.log('=== Basic Polling ===');

(async () => {
  let attempts = 0;
  
  const condition = async () => {
    attempts++;
    console.log(`Attempt ${attempts}`);
    // Succeed after 3 attempts
    return attempts >= 3;
  };
  
  try {
    await poll(condition, 500, 5000);
    console.log('Success after', attempts, 'attempts');
  } catch (error) {
    console.error('Failed:', error.message);
  }
})();
```

### **Approach 2: With Exponential Backoff**
```javascript
/**
 * Polling with increasing intervals (exponential backoff)
 */
async function pollWithBackoff(conditionFn, options = {}) {
  const {
    initialInterval = 1000,
    maxInterval = 30000,
    multiplier = 2,
    timeout = 60000
  } = options;
  
  const startTime = Date.now();
  let currentInterval = initialInterval;
  
  return new Promise((resolve, reject) => {
    const checkCondition = async () => {
      try {
        const result = await conditionFn();
        
        if (result) {
          console.log('Condition met!');
          resolve(result);
          return;
        }
        
        if (Date.now() - startTime >= timeout) {
          reject(new Error('Polling timeout'));
          return;
        }
        
        console.log(`Retrying in ${currentInterval}ms...`);
        setTimeout(checkCondition, currentInterval);
        
        // Increase interval (exponential backoff)
        currentInterval = Math.min(currentInterval * multiplier, maxInterval);
      } catch (error) {
        reject(error);
      }
    };
    
    checkCondition();
  });
}

// Test
console.log('\n=== With Exponential Backoff ===');

(async () => {
  let attempts = 0;
  
  const condition = async () => {
    attempts++;
    console.log(`Attempt ${attempts} at ${new Date().toLocaleTimeString()}`);
    return attempts >= 4;
  };
  
  await pollWithBackoff(condition, {
    initialInterval: 500,
    multiplier: 2,
    maxInterval: 5000,
    timeout: 30000
  });
  
  console.log('Success with backoff');
})();
```

### **Approach 3: With Validation and Callbacks**
```javascript
/**
 * Advanced polling with lifecycle callbacks
 */
async function pollAdvanced(conditionFn, options = {}) {
  const {
    interval = 1000,
    timeout = 30000,
    validate = null,
    onAttempt = null,
    onSuccess = null,
    onError = null,
    onTimeout = null
  } = options;
  
  const startTime = Date.now();
  let attemptCount = 0;
  
  return new Promise((resolve, reject) => {
    const checkCondition = async () => {
      attemptCount++;
      
      try {
        if (onAttempt) {
          onAttempt(attemptCount, Date.now() - startTime);
        }
        
        const result = await conditionFn();
        
        // Validate result if validator provided
        const isValid = validate ? validate(result) : result;
        
        if (isValid) {
          if (onSuccess) {
            onSuccess(result, attemptCount);
          }
          resolve(result);
          return;
        }
        
        if (Date.now() - startTime >= timeout) {
          const error = new Error(`Polling timeout after ${attemptCount} attempts`);
          if (onTimeout) {
            onTimeout(attemptCount);
          }
          reject(error);
          return;
        }
        
        setTimeout(checkCondition, interval);
      } catch (error) {
        if (onError) {
          onError(error, attemptCount);
        }
        reject(error);
      }
    };
    
    checkCondition();
  });
}

// Test
console.log('\n=== Advanced Polling with Callbacks ===');

(async () => {
  let value = 0;
  
  const condition = async () => {
    value += 10;
    return value;
  };
  
  try {
    const result = await pollAdvanced(condition, {
      interval: 300,
      timeout: 5000,
      validate: (val) => val >= 50,
      onAttempt: (count, elapsed) => {
        console.log(`Attempt ${count} (${elapsed}ms elapsed)`);
      },
      onSuccess: (result, count) => {
        console.log(`Success! Value: ${result} after ${count} attempts`);
      }
    });
    
    console.log('Final result:', result);
  } catch (error) {
    console.error('Failed:', error.message);
  }
})();
```

### **Approach 4: Polling Class with Control**
```javascript
/**
 * Reusable polling class with start/stop control
 */
class Poller {
  constructor(conditionFn, options = {}) {
    this.conditionFn = conditionFn;
    this.interval = options.interval || 1000;
    this.timeout = options.timeout || 30000;
    this.onAttempt = options.onAttempt;
    this.onSuccess = options.onSuccess;
    this.onError = options.onError;
    
    this.isPolling = false;
    this.timeoutId = null;
    this.startTime = null;
    this.attemptCount = 0;
  }
  
  start() {
    if (this.isPolling) {
      throw new Error('Polling already in progress');
    }
    
    this.isPolling = true;
    this.startTime = Date.now();
    this.attemptCount = 0;
    
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      this.check();
    });
  }
  
  async check() {
    if (!this.isPolling) return;
    
    this.attemptCount++;
    
    try {
      if (this.onAttempt) {
        this.onAttempt(this.attemptCount);
      }
      
      const result = await this.conditionFn();
      
      if (result) {
        this.stop();
        if (this.onSuccess) {
          this.onSuccess(result, this.attemptCount);
        }
        this.resolve(result);
        return;
      }
      
      const elapsed = Date.now() - this.startTime;
      
      if (elapsed >= this.timeout) {
        this.stop();
        this.reject(new Error(`Timeout after ${this.attemptCount} attempts`));
        return;
      }
      
      this.timeoutId = setTimeout(() => this.check(), this.interval);
    } catch (error) {
      this.stop();
      if (this.onError) {
        this.onError(error, this.attemptCount);
      }
      this.reject(error);
    }
  }
  
  stop() {
    this.isPolling = false;
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  
  getStatus() {
    return {
      isPolling: this.isPolling,
      attemptCount: this.attemptCount,
      elapsed: this.startTime ? Date.now() - this.startTime : 0
    };
  }
}

// Test
console.log('\n=== Polling Class ===');

(async () => {
  let count = 0;
  
  const poller = new Poller(
    async () => {
      count++;
      return count >= 5;
    },
    {
      interval: 300,
      timeout: 10000,
      onAttempt: (attempt) => {
        const status = poller.getStatus();
        console.log(`Attempt ${attempt}, elapsed: ${status.elapsed}ms`);
      }
    }
  );
  
  try {
    await poller.start();
    console.log('Poller succeeded!');
  } catch (error) {
    console.error('Poller failed:', error.message);
  }
})();
```

### **Approach 5: With Immediate First Check**
```javascript
/**
 * Poll with immediate first check (no initial delay)
 */
async function pollImmediate(conditionFn, interval = 1000, timeout = 30000) {
  const startTime = Date.now();
  
  const check = async () => {
    try {
      const result = await conditionFn();
      
      if (result) {
        return result;
      }
      
      if (Date.now() - startTime >= timeout) {
        throw new Error('Polling timeout');
      }
      
      // Wait before next check
      await new Promise(resolve => setTimeout(resolve, interval));
      
      // Recursive check
      return check();
    } catch (error) {
      throw error;
    }
  };
  
  return check();
}

// Test
console.log('\n=== Immediate First Check ===');

(async () => {
  let attempts = 0;
  
  const condition = async () => {
    attempts++;
    console.log(`Immediate check attempt ${attempts}`);
    return attempts >= 3;
  };
  
  const start = Date.now();
  await pollImmediate(condition, 400, 5000);
  console.log('Completed in:', Date.now() - start, 'ms');
})();
```

### **Bonus: Poll Until Stable**
```javascript
/**
 * Poll until value stabilizes (doesn't change for N checks)
 */
async function pollUntilStable(getFn, options = {}) {
  const {
    interval = 1000,
    timeout = 30000,
    stableChecks = 3
  } = options;
  
  const startTime = Date.now();
  let previousValue = Symbol('initial');
  let stableCount = 0;
  
  while (Date.now() - startTime < timeout) {
    const currentValue = await getFn();
    
    if (currentValue === previousValue) {
      stableCount++;
      console.log(`Stable check ${stableCount}/${stableChecks}`);
      
      if (stableCount >= stableChecks) {
        console.log('Value stabilized!');
        return currentValue;
      }
    } else {
      console.log('Value changed:', previousValue, '->', currentValue);
      stableCount = 0;
      previousValue = currentValue;
    }
    
    await new Promise(resolve => setTimeout(resolve, interval));
  }
  
  throw new Error('Timeout waiting for stable value');
}

// Test
console.log('\n=== Poll Until Stable ===');

(async () => {
  let value = 0;
  let attempts = 0;
  
  const getValue = async () => {
    attempts++;
    if (attempts <= 3) {
      value = Math.random();
    }
    // After attempt 3, value stays the same
    return value;
  };
  
  const result = await pollUntilStable(getValue, {
    interval: 300,
    stableChecks: 3
  });
  
  console.log('Stable value:', result);
})();
```

### **Bonus: Conditional Polling (Rate Aware)**
```javascript
/**
 * Poll with rate limiting and conditional checks
 */
async function pollConditional(conditionFn, options = {}) {
  const {
    interval = 1000,
    timeout = 30000,
    maxAttempts = Infinity,
    shouldContinue = () => true
  } = options;
  
  const startTime = Date.now();
  let attempts = 0;
  
  while (Date.now() - startTime < timeout && attempts < maxAttempts) {
    attempts++;
    
    // Check if should continue polling
    if (!shouldContinue(attempts)) {
      throw new Error('Polling stopped by shouldContinue');
    }
    
    const result = await conditionFn();
    
    if (result) {
      return { result, attempts, elapsed: Date.now() - startTime };
    }
    
    await new Promise(resolve => setTimeout(resolve, interval));
  }
  
  throw new Error(`Failed after ${attempts} attempts`);
}

// Test
console.log('\n=== Conditional Polling ===');

(async () => {
  let attempts = 0;
  
  try {
    const { result, attempts: totalAttempts } = await pollConditional(
      async () => {
        attempts++;
        return attempts >= 10; // Won't reach this
      },
      {
        interval: 200,
        maxAttempts: 5, // Stop after 5 attempts
        shouldContinue: (attempt) => {
          console.log(`Attempt ${attempt}`);
          return true;
        }
      }
    );
    console.log('Result:', result);
  } catch (error) {
    console.log('Stopped:', error.message);
  }
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical polling scenarios
 */

// 1. Wait for API resource to be ready
async function waitForResource(resourceId) {
  return poll(
    async () => {
      const response = await fetch(`/api/resources/${resourceId}`);
      const data = await response.json();
      return data.status === 'ready' ? data : false;
    },
    2000, // Check every 2 seconds
    60000 // 1 minute timeout
  );
}

// 2. Wait for file upload to complete
async function waitForUpload(uploadId) {
  return pollAdvanced(
    async () => {
      const status = await checkUploadStatus(uploadId);
      return status;
    },
    {
      interval: 1000,
      timeout: 300000, // 5 minutes
      validate: (status) => status.state === 'completed',
      onAttempt: (count) => {
        console.log(`Checking upload status (attempt ${count})...`);
      }
    }
  );
}

// 3. Wait for DOM element to appear
async function waitForElement(selector, maxWait = 10000) {
  return poll(
    () => document.querySelector(selector),
    100, // Check every 100ms
    maxWait
  );
}

// 4. Wait for service health check
async function waitForServiceHealth(serviceUrl) {
  return pollWithBackoff(
    async () => {
      try {
        const response = await fetch(`${serviceUrl}/health`);
        return response.ok;
      } catch {
        return false;
      }
    },
    {
      initialInterval: 1000,
      multiplier: 2,
      maxInterval: 30000,
      timeout: 300000 // 5 minutes
    }
  );
}

// 5. Wait for async job completion
async function waitForJobCompletion(jobId) {
  const poller = new Poller(
    async () => {
      const job = await fetchJob(jobId);
      return job.status === 'completed' ? job : false;
    },
    {
      interval: 5000,
      timeout: 600000, // 10 minutes
      onAttempt: (attempt) => console.log(`Checking job ${jobId} (${attempt})...`)
    }
  );
  
  return poller.start();
}

console.log('\nReal-world use cases:');
console.log('1. waitForResource - poll API until ready');
console.log('2. waitForUpload - track file upload progress');
console.log('3. waitForElement - wait for DOM element');
console.log('4. waitForServiceHealth - service readiness check');
console.log('5. waitForJobCompletion - async job tracking');
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Immediate success
(async () => {
  console.log('Test: Immediate success');
  let attempts = 0;
  
  await poll(
    async () => {
      attempts++;
      return true; // Success immediately
    },
    1000,
    5000
  );
  
  console.log('Attempts:', attempts); // 1
})();

// Immediate timeout
(async () => {
  console.log('\nTest: Zero timeout');
  
  try {
    await poll(
      async () => false,
      1000,
      0 // Immediate timeout
    );
  } catch (error) {
    console.log('Caught timeout:', error.message);
  }
})();

// Condition throws error
(async () => {
  console.log('\nTest: Condition throws error');
  
  try {
    await poll(
      async () => {
        throw new Error('Condition error');
      },
      500,
      2000
    );
  } catch (error) {
    console.log('Caught error:', error.message);
  }
})();

// Synchronous condition
(async () => {
  console.log('\nTest: Synchronous condition');
  let count = 0;
  
  await poll(
    () => {
      count++;
      return count >= 3;
    },
    200,
    5000
  );
  
  console.log('Sync condition worked, count:', count);
})();
```

### **Performance Considerations**
```javascript
/**
 * Optimize polling performance
 */

// Avoid polling - use events when possible
class EventBasedWaiter {
  constructor() {
    this.listeners = new Map();
  }
  
  wait(eventName, timeout = 30000) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.listeners.delete(eventName);
        reject(new Error('Timeout'));
      }, timeout);
      
      this.listeners.set(eventName, (data) => {
        clearTimeout(timeoutId);
        resolve(data);
      });
    });
  }
  
  emit(eventName, data) {
    const listener = this.listeners.get(eventName);
    if (listener) {
      listener(data);
      this.listeners.delete(eventName);
    }
  }
}

// Compare polling vs events
console.log('\n=== Performance: Polling vs Events ===');

(async () => {
  // Polling approach
  let pollingValue = null;
  setTimeout(() => { pollingValue = 'ready'; }, 2000);
  
  const pollStart = Date.now();
  await poll(() => pollingValue === 'ready', 100, 5000);
  console.log('Polling took:', Date.now() - pollStart, 'ms');
  
  // Event approach
  const waiter = new EventBasedWaiter();
  setTimeout(() => waiter.emit('ready', 'ready'), 2000);
  
  const eventStart = Date.now();
  await waiter.wait('ready', 5000);
  console.log('Event took:', Date.now() - eventStart, 'ms');
  
  console.log('\nEvents are instant, polling has check interval overhead');
})();
```

**Interview Tips:**
- Polling: repeatedly check condition until success or timeout
- Key params: condition function, interval, timeout
- Basic pattern: check → if false, wait interval → repeat
- Always include timeout to prevent infinite loops
- Exponential backoff reduces server load for long waits
- First check can be immediate (no initial delay) or after first interval
- Return meaningful data: result, attempt count, elapsed time
- Handle errors in condition function - should stop or retry?
- Class-based allows start/stop control, useful for cleanup
- Consider rate limiting for API polling
- Validate results: condition true doesn't always mean success
- Applications: API status checks, job completion, DOM elements, service health
- Better alternatives: WebSockets, Server-Sent Events, webhooks when available
- Trade-offs: simple but inefficient, adds latency and load
- Edge cases: immediate success, immediate timeout, errors, sync conditions
- Clarify: interval strategy? backoff? max attempts? immediate check? callbacks?
- Follow-ups: implement backoff, add jitter, combine with events, distributed polling

</details>

85. Build a simple task queue with priority

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic FIFO Queue**
```javascript
/**
 * Simple First-In-First-Out task queue
 * Time Complexity: O(1) for enqueue, O(1) for dequeue
 * Space Complexity: O(n) where n is queue size
 */
class TaskQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.queue = [];
    this.running = 0;
  }
  
  async add(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { task, resolve, reject } = this.queue.shift();
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process(); // Process next task
    }
  }
  
  size() {
    return this.queue.length;
  }
  
  pending() {
    return this.running;
  }
}

// Test
console.log('=== Basic FIFO Queue ===');

(async () => {
  const queue = new TaskQueue(2); // Concurrency of 2
  
  const delay = (ms, value) => new Promise(resolve => 
    setTimeout(() => {
      console.log(`Completed: ${value}`);
      resolve(value);
    }, ms)
  );
  
  console.log('Adding 5 tasks with concurrency 2...');
  
  const results = await Promise.all([
    queue.add(() => delay(1000, 'Task 1')),
    queue.add(() => delay(500, 'Task 2')),
    queue.add(() => delay(800, 'Task 3')),
    queue.add(() => delay(300, 'Task 4')),
    queue.add(() => delay(600, 'Task 5'))
  ]);
  
  console.log('All tasks completed:', results);
})();
```

### **Approach 2: Priority Queue**
```javascript
/**
 * Task queue with priority levels
 * Higher priority tasks execute first
 */
class PriorityTaskQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.queue = [];
    this.running = 0;
  }
  
  async add(task, priority = 0) {
    return new Promise((resolve, reject) => {
      const item = { task, priority, resolve, reject };
      
      // Insert in priority order (higher priority first)
      let inserted = false;
      for (let i = 0; i < this.queue.length; i++) {
        if (priority > this.queue[i].priority) {
          this.queue.splice(i, 0, item);
          inserted = true;
          break;
        }
      }
      
      if (!inserted) {
        this.queue.push(item);
      }
      
      console.log(`Added task with priority ${priority}`);
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { task, priority, resolve, reject } = this.queue.shift();
    
    console.log(`Executing task with priority ${priority}`);
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
  
  size() {
    return this.queue.length;
  }
  
  clear() {
    this.queue = [];
  }
}

// Test
console.log('\n=== Priority Queue ===');

(async () => {
  const queue = new PriorityTaskQueue(1); // Process one at a time
  
  const delay = (ms, value) => new Promise(resolve => 
    setTimeout(() => {
      console.log(`Result: ${value}`);
      resolve(value);
    }, ms)
  );
  
  // Add tasks with different priorities
  queue.add(() => delay(100, 'Low priority (1)'), 1);
  queue.add(() => delay(100, 'High priority (10)'), 10);
  queue.add(() => delay(100, 'Medium priority (5)'), 5);
  queue.add(() => delay(100, 'Highest priority (20)'), 20);
  
  await new Promise(resolve => setTimeout(resolve, 1000));
  console.log('Execution order should be: 20, 10, 5, 1');
})();
```

### **Approach 3: With Named Priorities**
```javascript
/**
 * Queue with named priority levels
 */
class NamedPriorityQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.priorities = {
      LOW: 1,
      NORMAL: 5,
      HIGH: 10,
      URGENT: 20
    };
    this.queue = [];
    this.running = 0;
  }
  
  async add(task, priority = 'NORMAL') {
    const numericPriority = this.priorities[priority] || this.priorities.NORMAL;
    
    return new Promise((resolve, reject) => {
      const item = { task, priority: numericPriority, name: priority, resolve, reject };
      
      // Binary search insertion for better performance
      let left = 0;
      let right = this.queue.length;
      
      while (left < right) {
        const mid = Math.floor((left + right) / 2);
        if (this.queue[mid].priority < numericPriority) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      
      this.queue.splice(left, 0, item);
      console.log(`Added ${priority} task (${numericPriority})`);
      
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { task, name, resolve, reject } = this.queue.shift();
    
    console.log(`Executing ${name} task`);
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
  
  getStats() {
    return {
      queued: this.queue.length,
      running: this.running,
      queueByPriority: this.queue.reduce((acc, item) => {
        acc[item.name] = (acc[item.name] || 0) + 1;
        return acc;
      }, {})
    };
  }
}

// Test
console.log('\n=== Named Priority Queue ===');

(async () => {
  const queue = new NamedPriorityQueue(2);
  
  const task = (name) => async () => {
    await new Promise(r => setTimeout(r, 200));
    return name;
  };
  
  queue.add(task('Task A'), 'LOW');
  queue.add(task('Task B'), 'URGENT');
  queue.add(task('Task C'), 'HIGH');
  queue.add(task('Task D'), 'NORMAL');
  queue.add(task('Task E'), 'URGENT');
  
  console.log('Stats:', queue.getStats());
  
  await new Promise(r => setTimeout(r, 1500));
})();
```

### **Approach 4: Advanced Queue with Features**
```javascript
/**
 * Full-featured task queue
 */
class AdvancedTaskQueue {
  constructor(options = {}) {
    this.concurrency = options.concurrency || 1;
    this.queue = [];
    this.running = 0;
    this.completed = 0;
    this.failed = 0;
    this.listeners = {
      start: [],
      success: [],
      error: [],
      complete: []
    };
  }
  
  on(event, callback) {
    if (this.listeners[event]) {
      this.listeners[event].push(callback);
    }
  }
  
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(cb => cb(data));
    }
  }
  
  async add(task, options = {}) {
    const {
      priority = 0,
      retry = 0,
      timeout = null,
      name = 'unnamed'
    } = options;
    
    return new Promise((resolve, reject) => {
      const item = {
        task,
        priority,
        retry,
        timeout,
        name,
        resolve,
        reject,
        attempts: 0
      };
      
      // Insert by priority
      let inserted = false;
      for (let i = 0; i < this.queue.length; i++) {
        if (priority > this.queue[i].priority) {
          this.queue.splice(i, 0, item);
          inserted = true;
          break;
        }
      }
      
      if (!inserted) {
        this.queue.push(item);
      }
      
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const item = this.queue.shift();
    
    this.emit('start', { name: item.name, priority: item.priority });
    
    try {
      item.attempts++;
      
      let result;
      if (item.timeout) {
        result = await this.withTimeout(item.task(), item.timeout);
      } else {
        result = await item.task();
      }
      
      this.completed++;
      this.emit('success', { name: item.name, result });
      item.resolve(result);
    } catch (error) {
      // Retry logic
      if (item.attempts <= item.retry) {
        console.log(`Retrying ${item.name} (${item.attempts}/${item.retry})`);
        this.queue.unshift(item); // Add back to front
      } else {
        this.failed++;
        this.emit('error', { name: item.name, error });
        item.reject(error);
      }
    } finally {
      this.running--;
      this.emit('complete', this.getStats());
      this.process();
    }
  }
  
  withTimeout(promise, ms) {
    return Promise.race([
      promise,
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Task timeout')), ms)
      )
    ]);
  }
  
  getStats() {
    return {
      queued: this.queue.length,
      running: this.running,
      completed: this.completed,
      failed: this.failed
    };
  }
  
  pause() {
    this.paused = true;
  }
  
  resume() {
    this.paused = false;
    this.process();
  }
  
  clear() {
    this.queue = [];
  }
}

// Test
console.log('\n=== Advanced Queue ===');

(async () => {
  const queue = new AdvancedTaskQueue({ concurrency: 2 });
  
  queue.on('start', (data) => console.log(`Started: ${data.name}`));
  queue.on('success', (data) => console.log(`Success: ${data.name}`));
  queue.on('error', (data) => console.log(`Error: ${data.name}`));
  
  const task = (name, shouldFail = false) => async () => {
    await new Promise(r => setTimeout(r, 300));
    if (shouldFail) throw new Error(`${name} failed`);
    return `${name} result`;
  };
  
  await Promise.allSettled([
    queue.add(task('Task 1'), { priority: 5, name: 'Task 1' }),
    queue.add(task('Task 2', true), { priority: 10, retry: 2, name: 'Task 2' }),
    queue.add(task('Task 3'), { priority: 1, name: 'Task 3' })
  ]);
  
  console.log('Final stats:', queue.getStats());
})();
```

### **Approach 5: Using Heap for Optimal Priority**
```javascript
/**
 * Priority queue using min-heap for O(log n) insertions
 */
class HeapPriorityQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.heap = [];
    this.running = 0;
  }
  
  async add(task, priority = 0) {
    return new Promise((resolve, reject) => {
      const item = { task, priority, resolve, reject };
      this.heap.push(item);
      this.bubbleUp(this.heap.length - 1);
      this.process();
    });
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      
      // Max heap (higher priority = higher value)
      if (this.heap[index].priority <= this.heap[parentIndex].priority) {
        break;
      }
      
      [this.heap[index], this.heap[parentIndex]] = 
        [this.heap[parentIndex], this.heap[index]];
      
      index = parentIndex;
    }
  }
  
  extractMax() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();
    
    const max = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    
    return max;
  }
  
  bubbleDown(index) {
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let largest = index;
      
      if (leftChild < this.heap.length && 
          this.heap[leftChild].priority > this.heap[largest].priority) {
        largest = leftChild;
      }
      
      if (rightChild < this.heap.length && 
          this.heap[rightChild].priority > this.heap[largest].priority) {
        largest = rightChild;
      }
      
      if (largest === index) break;
      
      [this.heap[index], this.heap[largest]] = 
        [this.heap[largest], this.heap[index]];
      
      index = largest;
    }
  }
  
  async process() {
    if (this.running >= this.concurrency || this.heap.length === 0) {
      return;
    }
    
    this.running++;
    const { task, priority, resolve, reject } = this.extractMax();
    
    console.log(`Processing priority ${priority}`);
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}

// Test
console.log('\n=== Heap Priority Queue ===');

(async () => {
  const queue = new HeapPriorityQueue(1);
  
  const task = (value) => async () => {
    await new Promise(r => setTimeout(r, 100));
    console.log(`Executed: ${value}`);
    return value;
  };
  
  // Add in random order
  queue.add(task('P3'), 3);
  queue.add(task('P8'), 8);
  queue.add(task('P1'), 1);
  queue.add(task('P5'), 5);
  queue.add(task('P10'), 10);
  
  await new Promise(r => setTimeout(r, 1000));
  console.log('Should execute in order: 10, 8, 5, 3, 1');
})();
```

### **Bonus: Rate-Limited Queue**
```javascript
/**
 * Task queue with rate limiting
 */
class RateLimitedQueue {
  constructor(options = {}) {
    this.concurrency = options.concurrency || 1;
    this.rateLimit = options.rateLimit || null; // { requests, per (ms) }
    this.queue = [];
    this.running = 0;
    this.requestTimestamps = [];
  }
  
  async add(task, priority = 0) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, priority, resolve, reject });
      this.queue.sort((a, b) => b.priority - a.priority);
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    // Check rate limit
    if (this.rateLimit) {
      const now = Date.now();
      const windowStart = now - this.rateLimit.per;
      
      // Remove old timestamps
      this.requestTimestamps = this.requestTimestamps.filter(t => t > windowStart);
      
      if (this.requestTimestamps.length >= this.rateLimit.requests) {
        const oldestRequest = this.requestTimestamps[0];
        const waitTime = this.rateLimit.per - (now - oldestRequest);
        console.log(`Rate limit reached, waiting ${waitTime}ms...`);
        setTimeout(() => this.process(), waitTime);
        return;
      }
      
      this.requestTimestamps.push(now);
    }
    
    this.running++;
    const { task, resolve, reject } = this.queue.shift();
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}

// Test
console.log('\n=== Rate-Limited Queue ===');

(async () => {
  const queue = new RateLimitedQueue({
    concurrency: 5,
    rateLimit: { requests: 3, per: 1000 } // 3 requests per second
  });
  
  const task = (id) => async () => {
    console.log(`Task ${id} at ${new Date().toLocaleTimeString()}`);
    await new Promise(r => setTimeout(r, 100));
    return id;
  };
  
  // Add 10 tasks
  for (let i = 1; i <= 10; i++) {
    queue.add(task(i));
  }
  
  await new Promise(r => setTimeout(r, 5000));
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical queue applications
 */

// 1. Background job processing
const jobQueue = new PriorityTaskQueue(3);

async function processJob(job) {
  return jobQueue.add(
    async () => {
      console.log(`Processing job ${job.id}`);
      await performWork(job);
      return { jobId: job.id, status: 'completed' };
    },
    job.priority
  );
}

// 2. API request batching
const apiQueue = new RateLimitedQueue({
  concurrency: 5,
  rateLimit: { requests: 100, per: 60000 } // 100 requests per minute
});

async function makeApiCall(endpoint, data) {
  return apiQueue.add(async () => {
    return fetch(endpoint, { method: 'POST', body: JSON.stringify(data) });
  });
}

// 3. Image processing pipeline
const imageQueue = new AdvancedTaskQueue({ concurrency: 4 });

async function processImage(image, priority) {
  return imageQueue.add(
    async () => {
      const resized = await resize(image);
      const optimized = await optimize(resized);
      await save(optimized);
      return optimized;
    },
    { priority, retry: 2, timeout: 30000, name: image.filename }
  );
}

// 4. Email sending queue
const emailQueue = new PriorityTaskQueue(2);

async function sendEmail(email, priority = 'NORMAL') {
  const priorities = { LOW: 1, NORMAL: 5, HIGH: 10, URGENT: 20 };
  
  return emailQueue.add(
    async () => {
      await emailService.send(email);
      return { sent: true, messageId: email.id };
    },
    priorities[priority]
  );
}

console.log('\nReal-world use cases:');
console.log('1. processJob - background job processing');
console.log('2. makeApiCall - rate-limited API requests');
console.log('3. processImage - concurrent image processing');
console.log('4. sendEmail - priority email queue');
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty queue
const emptyQueue = new TaskQueue(1);
console.log('Empty queue size:', emptyQueue.size()); // 0

// Single task
(async () => {
  const singleQueue = new TaskQueue(1);
  const result = await singleQueue.add(async () => 'single');
  console.log('Single task result:', result);
})();

// Task that throws error
(async () => {
  const errorQueue = new TaskQueue(1);
  try {
    await errorQueue.add(async () => {
      throw new Error('Task failed');
    });
  } catch (error) {
    console.log('Caught task error:', error.message);
  }
})();

// Same priority tasks (FIFO within priority)
(async () => {
  const fifoQueue = new PriorityTaskQueue(1);
  
  const results = [];
  fifoQueue.add(async () => { results.push('A'); }, 5);
  fifoQueue.add(async () => { results.push('B'); }, 5);
  fifoQueue.add(async () => { results.push('C'); }, 5);
  
  await new Promise(r => setTimeout(r, 500));
  console.log('FIFO within priority:', results); // ['A', 'B', 'C']
})();
```

### **Performance Comparison**
```javascript
/**
 * Compare different queue implementations
 */
async function benchmarkQueues() {
  console.log('\n=== Queue Benchmarks ===');
  
  const taskCount = 100;
  const task = () => async () => {
    await new Promise(r => setTimeout(r, 10));
    return 'done';
  };
  
  // Basic queue
  let start = Date.now();
  const basicQueue = new TaskQueue(10);
  await Promise.all(Array.from({ length: taskCount }, () => 
    basicQueue.add(task())
  ));
  console.log('Basic queue (100 tasks, concurrency 10):', Date.now() - start, 'ms');
  
  // Priority queue (with sorting overhead)
  start = Date.now();
  const priorityQueue = new PriorityTaskQueue(10);
  await Promise.all(Array.from({ length: taskCount }, (_, i) => 
    priorityQueue.add(task(), Math.random() * 10)
  ));
  console.log('Priority queue (100 tasks, random priorities):', Date.now() - start, 'ms');
  
  // Heap queue (optimal for many priority changes)
  start = Date.now();
  const heapQueue = new HeapPriorityQueue(10);
  await Promise.all(Array.from({ length: taskCount }, (_, i) => 
    heapQueue.add(task(), Math.random() * 10)
  ));
  console.log('Heap queue (100 tasks, random priorities):', Date.now() - start, 'ms');
}

setTimeout(() => benchmarkQueues(), 6000);
```

**Interview Tips:**
- Task queue: manages async task execution with concurrency control
- Basic queue: FIFO (first in, first out), process tasks in order
- Priority queue: higher priority tasks execute first
- Key operations: add (enqueue), process (dequeue), size, stats
- Concurrency: limit simultaneous task execution
- Priority implementation: array with sorting (simple) or heap (optimal O(log n))
- Heap best for frequent priority insertions (O(log n) vs O(n))
- Handle task errors: catch and continue processing queue
- Features: retry logic, timeouts, events, pause/resume, stats
- Rate limiting: prevent overwhelming external services
- Applications: job processing, API calls, image processing, email sending
- Trade-offs: memory for queued tasks, complexity vs features
- Named priorities easier to use: LOW, NORMAL, HIGH, URGENT
- Events useful for monitoring: start, success, error, complete
- Edge cases: empty queue, errors, same priorities, zero concurrency
- Clarify: priority levels? retry logic? rate limits? events? max queue size?
- Follow-ups: add persistence, distributed queue, dead letter queue, scheduling

</details>

### **Advanced Functions**

86. Implement function currying

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Currying**
```javascript
/**
 * Simple curry implementation
 * Time Complexity: O(1) per call
 * Space Complexity: O(n) where n is number of arguments
 * 
 * Transforms f(a, b, c) into f(a)(b)(c)
 */
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// Test
console.log('=== Basic Currying ===');

function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
console.log(curriedAdd(1, 2, 3)); // 6

function multiply(a, b, c, d) {
  return a * b * c * d;
}

const curriedMultiply = curry(multiply);
console.log(curriedMultiply(2)(3)(4)(5)); // 120
console.log(curriedMultiply(2, 3)(4)(5)); // 120
console.log(curriedMultiply(2)(3, 4, 5)); // 120
```

### **Approach 2: Infinite Currying**
```javascript
/**
 * Curry that accepts unlimited arguments
 * Keeps accepting until explicitly converted
 */
function infiniteCurry(fn) {
  const accumulated = [];
  
  function curried(...args) {
    accumulated.push(...args);
    return curried;
  }
  
  curried.valueOf = function() {
    return fn(...accumulated);
  };
  
  curried.toString = function() {
    return fn(...accumulated).toString();
  };
  
  return curried;
}

// Test
console.log('\n=== Infinite Currying ===');

const sum = (...args) => args.reduce((a, b) => a + b, 0);
const infiniteSum = infiniteCurry(sum);

console.log(+infiniteSum(1)(2)(3)(4)(5)); // 15
console.log(+infiniteSum(10)(20)(30)); // 60

// Another approach: sum with terminator
function infiniteSum2(a) {
  let total = a;
  
  function add(b) {
    if (b === undefined) {
      return total;
    }
    total += b;
    return add;
  }
  
  return add;
}

console.log(infiniteSum2(1)(2)(3)(4)()); // 10
console.log(infiniteSum2(5)(10)()); // 15
```

### **Approach 3: Placeholder Support**
```javascript
/**
 * Currying with placeholder support
 * Allows skipping arguments using placeholder
 */
function curryWithPlaceholder(fn, placeholder = curry.placeholder) {
  return function curried(...args) {
    // Check if we have enough non-placeholder arguments
    const nonPlaceholderCount = args.filter(arg => arg !== placeholder).length;
    
    if (nonPlaceholderCount >= fn.length && !args.includes(placeholder)) {
      return fn.apply(this, args);
    }
    
    return function(...nextArgs) {
      // Merge args, replacing placeholders with new args
      const mergedArgs = args.map(arg => 
        arg === placeholder && nextArgs.length ? nextArgs.shift() : arg
      );
      
      // Add remaining nextArgs
      return curried.apply(this, [...mergedArgs, ...nextArgs]);
    };
  };
}

curryWithPlaceholder.placeholder = Symbol('placeholder');
const _ = curryWithPlaceholder.placeholder;

// Test
console.log('\n=== Placeholder Support ===');

function subtract(a, b, c) {
  return a - b - c;
}

const curriedSubtract = curryWithPlaceholder(subtract);

console.log(curriedSubtract(10)(5)(2)); // 3
console.log(curriedSubtract(_, 5)(10)(2)); // 3 (10 - 5 - 2)
console.log(curriedSubtract(_, _, 2)(10)(5)); // 3 (10 - 5 - 2)
console.log(curriedSubtract(10, _, 2)(5)); // 3

function greet(greeting, name, punctuation) {
  return `${greeting}, ${name}${punctuation}`;
}

const curriedGreet = curryWithPlaceholder(greet);
console.log(curriedGreet('Hello')(_, '!')('World')); // "Hello, World!"
console.log(curriedGreet(_, 'Alice')('Hi')('.')); // "Hi, Alice."
```

### **Approach 4: Partial Application**
```javascript
/**
 * Partial application (similar to currying but more flexible)
 */
function partial(fn, ...presetArgs) {
  return function(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

// Advanced partial with placeholder
function partialWithPlaceholder(fn, ...presetArgs) {
  const _ = partialWithPlaceholder.placeholder;
  
  return function(...laterArgs) {
    const args = presetArgs.map(arg => 
      arg === _ && laterArgs.length ? laterArgs.shift() : arg
    );
    
    return fn(...args, ...laterArgs);
  };
}

partialWithPlaceholder.placeholder = Symbol('_');
const __ = partialWithPlaceholder.placeholder;

// Test
console.log('\n=== Partial Application ===');

function divide(a, b, c) {
  return a / b / c;
}

const divideBy2 = partial(divide, __, 2);
console.log(divideBy2(100, 5)); // 100 / 2 / 5 = 10

const divideBy2And5 = partial(divide, __, 2, 5);
console.log(divideBy2And5(100)); // 100 / 2 / 5 = 10

function log(level, timestamp, message) {
  return `[${level}] ${timestamp}: ${message}`;
}

const logError = partial(log, 'ERROR');
console.log(logError('2024-01-01', 'System failure'));

const logWithTime = partial(log, __, '2024-01-01');
console.log(logWithTime('INFO', 'System started'));
```

### **Approach 5: Auto-Currying with Variable Arguments**
```javascript
/**
 * Smart curry that handles variable argument functions
 */
function autoCurry(fn, arity = fn.length) {
  return function curried(...args) {
    if (args.length >= arity) {
      return fn.apply(this, args);
    }
    
    return function(...nextArgs) {
      return curried.apply(this, [...args, ...nextArgs]);
    };
  };
}

// For functions with rest parameters
function flexibleCurry(fn, minArgs) {
  return function curried(...args) {
    if (args.length >= minArgs) {
      return fn(...args);
    }
    
    return (...nextArgs) => curried(...args, ...nextArgs);
  };
}

// Test
console.log('\n=== Auto-Currying ===');

// Fixed arity
function sum3(a, b, c) {
  return a + b + c;
}

const curriedSum = autoCurry(sum3);
console.log(curriedSum(1)(2)(3)); // 6

// Variable arity
function sumAll(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}

const curriedSumAll = flexibleCurry(sumAll, 3);
console.log(curriedSumAll(1)(2)(3)); // 6
console.log(curriedSumAll(1, 2)(3, 4, 5)); // 15

// With explicit arity
function multiply(...args) {
  return args.reduce((a, b) => a * b, 1);
}

const multiply4 = autoCurry(multiply, 4);
console.log(multiply4(2)(3)(4)(5)); // 120
```

### **Bonus: Curry Right (Right-to-Left)**
```javascript
/**
 * Curry from right to left
 */
function curryRight(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    
    return function(...nextArgs) {
      return curried.apply(this, [...nextArgs, ...args]);
    };
  };
}

// Test
console.log('\n=== Curry Right ===');

function describe(adj1, adj2, noun) {
  return `${adj1} ${adj2} ${noun}`;
}

const curriedDescribe = curryRight(describe);

// Arguments fill from right
console.log(curriedDescribe('cat')('lazy')('old')); // "old lazy cat"
console.log(curriedDescribe('dog', 'brown')('happy')); // "happy brown dog"

// Compare with regular curry
const normalCurried = curry(describe);
console.log(normalCurried('old')('lazy')('cat')); // "old lazy cat"
```

### **Bonus: Named Parameters Curry**
```javascript
/**
 * Curry with named parameters
 */
function curriedFunction(config) {
  const required = Object.keys(config);
  const values = {};
  
  function curried(params = {}) {
    Object.assign(values, params);
    
    const hasAll = required.every(key => key in values);
    
    if (hasAll) {
      return config.fn(values);
    }
    
    return curried;
  }
  
  return curried;
}

// Test
console.log('\n=== Named Parameters ===');

const createUser = curriedFunction({
  fn: ({ name, email, age }) => ({ name, email, age }),
  name: true,
  email: true,
  age: true
});

const withName = createUser({ name: 'Alice' });
const withEmail = withName({ email: 'alice@example.com' });
const user = withEmail({ age: 30 });

console.log('User:', user);

// Can provide multiple at once
const user2 = createUser({ name: 'Bob', age: 25 })({ email: 'bob@example.com' });
console.log('User 2:', user2);
```

### **Real-World Use Cases**
```javascript
/**
 * Practical curry applications
 */

// 1. Reusable validators
function validate(predicate, message, value) {
  return predicate(value) ? { valid: true, value } : { valid: false, message };
}

const curriedValidate = curry(validate);

const isRequired = curriedValidate(
  value => value != null && value !== '',
  'This field is required'
);

const isEmail = curriedValidate(
  value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
  'Invalid email format'
);

const minLength = (min) => curriedValidate(
  value => value.length >= min,
  `Minimum length is ${min}`
);

console.log('\n=== Validators ===');
console.log(isRequired('hello')); // { valid: true, value: 'hello' }
console.log(isRequired('')); // { valid: false, message: ... }
console.log(isEmail('test@example.com')); // { valid: true, ... }
console.log(minLength(5)('hi')); // { valid: false, ... }

// 2. API request builder
function makeRequest(method, baseUrl, endpoint, params) {
  const url = `${baseUrl}${endpoint}?${new URLSearchParams(params)}`;
  return { method, url };
}

const curriedRequest = curry(makeRequest);
const getRequest = curriedRequest('GET');
const apiGet = getRequest('https://api.example.com');

console.log('\n=== API Builder ===');
console.log(apiGet('/users')({ page: 1, limit: 10 }));
console.log(apiGet('/posts')({ category: 'tech' }));

// 3. Logger with levels
function log(level, timestamp, component, message) {
  return `[${level}] ${timestamp} [${component}]: ${message}`;
}

const curriedLog = curry(log);
const errorLog = curriedLog('ERROR');
const errorLogNow = errorLog(new Date().toISOString());
const authErrorLog = errorLogNow('Auth');

console.log('\n=== Logger ===');
console.log(authErrorLog('Login failed'));
console.log(authErrorLog('Invalid token'));

// 4. Data transformation pipeline
function map(fn, array) {
  return array.map(fn);
}

function filter(predicate, array) {
  return array.filter(predicate);
}

const curriedMap = curry(map);
const curriedFilter = curry(filter);

const double = curriedMap(x => x * 2);
const onlyEven = curriedFilter(x => x % 2 === 0);

console.log('\n=== Data Pipeline ===');
const numbers = [1, 2, 3, 4, 5];
console.log('Original:', numbers);
console.log('Doubled:', double(numbers));
console.log('Even only:', onlyEven(numbers));
console.log('Even then doubled:', double(onlyEven(numbers)));

// 5. HTML builder
function createElement(tag, attrs, children) {
  const attrStr = Object.entries(attrs)
    .map(([k, v]) => `${k}="${v}"`)
    .join(' ');
  return `<${tag} ${attrStr}>${children}</${tag}>`;
}

const curriedElement = curry(createElement);
const div = curriedElement('div');
const button = curriedElement('button');

const primaryButton = button({ class: 'btn-primary' });
const dangerButton = button({ class: 'btn-danger' });

console.log('\n=== HTML Builder ===');
console.log(primaryButton('Click Me'));
console.log(dangerButton('Delete'));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Zero arguments
function noArgs() {
  return 'no arguments';
}

const curriedNoArgs = curry(noArgs);
console.log('No args:', curriedNoArgs()); // "no arguments"

// Single argument
function single(a) {
  return a * 2;
}

const curriedSingle = curry(single);
console.log('Single arg:', curriedSingle(5)); // 10

// With 'this' context
const obj = {
  multiplier: 10,
  multiply: function(a, b) {
    return this.multiplier * a * b;
  }
};

const curriedMethod = curry(obj.multiply);
const boundMethod = curriedMethod.bind(obj);
console.log('With context:', boundMethod(2)(3)); // 60

// Extra arguments ignored
function twoArgs(a, b) {
  return a + b;
}

const curriedTwo = curry(twoArgs);
console.log('Extra args:', curriedTwo(1, 2, 3, 4)); // 3 (extra ignored)

// Curried function as argument
function apply(fn, value) {
  return fn(value);
}

const curriedApply = curry(apply);
const applyDouble = curriedApply(x => x * 2);
console.log('Higher-order:', applyDouble(5)); // 10
```

### **Performance Comparison**
```javascript
/**
 * Measure curry overhead
 */
console.log('\n=== Performance ===');

function regularAdd(a, b, c) {
  return a + b + c;
}

const curriedAddPerf = curry(regularAdd);

// Regular function
console.time('Regular (1000 calls)');
for (let i = 0; i < 1000; i++) {
  regularAdd(1, 2, 3);
}
console.timeEnd('Regular (1000 calls)');

// Curried function (all at once)
console.time('Curried all args (1000 calls)');
for (let i = 0; i < 1000; i++) {
  curriedAddPerf(1, 2, 3);
}
console.timeEnd('Curried all args (1000 calls)');

// Curried function (one by one)
console.time('Curried step by step (1000 calls)');
for (let i = 0; i < 1000; i++) {
  curriedAddPerf(1)(2)(3);
}
console.timeEnd('Curried step by step (1000 calls)');

console.log('\nNote: Currying adds overhead but provides flexibility');
```

### **Advanced: Curry with Memoization**
```javascript
/**
 * Combine curry with memoization
 */
function curriedMemoize(fn) {
  const cache = new Map();
  
  return function curried(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('Cache hit:', key);
      return cache.get(key);
    }
    
    if (args.length >= fn.length) {
      const result = fn.apply(this, args);
      cache.set(key, result);
      return result;
    }
    
    return function(...nextArgs) {
      return curried.apply(this, [...args, ...nextArgs]);
    };
  };
}

// Test
console.log('\n=== Curry with Memoization ===');

function expensiveAdd(a, b, c) {
  console.log('Computing...');
  return a + b + c;
}

const memoizedCurry = curriedMemoize(expensiveAdd);

console.log(memoizedCurry(1)(2)(3)); // Computing... 6
console.log(memoizedCurry(1, 2)(3)); // Cache hit: [1,2,3]
console.log(memoizedCurry(1, 2, 3)); // Cache hit: [1,2,3]
```

**Interview Tips:**
- Currying: transform f(a, b, c) into f(a)(b)(c)
- Enables partial application: fix some arguments, get function for rest
- Check if enough arguments: args.length >= fn.length
- If not enough: return function that accepts more
- If enough: call original function with all arguments
- Recursive approach: keep accepting until satisfied
- Use Function.length to get expected parameter count
- Spread operator (...) to collect and merge arguments
- Preserve 'this' context with apply/call
- Benefits: reusability, composition, point-free style
- Difference from partial: curry always returns unary, partial can take multiple
- Placeholder support: skip arguments using special symbol
- Auto-currying: can provide multiple args at once f(a, b)(c) or f(a)(b)(c)
- Applications: validators, loggers, API builders, data transformations
- Trade-offs: flexibility vs performance overhead
- Popular libraries: lodash.curry, ramda.curry
- Edge cases: no args, single arg, extra args, 'this' binding, rest parameters
- Clarify: fixed arity? placeholder support? right-to-left? memoization?
- Follow-ups: implement uncurry, curry with default values, async curry

</details>

87. Implement function composition (compose and pipe)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Compose (Right-to-Left)**
```javascript
/**
 * Compose functions from right to left
 * compose(f, g, h)(x) = f(g(h(x)))
 * Time Complexity: O(n) where n is number of functions
 * Space Complexity: O(1)
 */
function compose(...fns) {
  return function(value) {
    return fns.reduceRight((acc, fn) => fn(acc), value);
  };
}

// Test
console.log('=== Basic Compose (Right-to-Left) ===');

const add5 = x => x + 5;
const multiply3 = x => x * 3;
const subtract2 = x => x - 2;

const composed = compose(subtract2, multiply3, add5);

console.log('Input: 10');
console.log('Steps: 10 -> add5 -> 15 -> multiply3 -> 45 -> subtract2 -> 43');
console.log('Result:', composed(10)); // 43

// Another example
const toUpper = str => str.toUpperCase();
const exclaim = str => str + '!';
const greet = name => `Hello, ${name}`;

const shout = compose(exclaim, toUpper, greet);
console.log(shout('alice')); // "HELLO, ALICE!"
```

### **Approach 2: Pipe (Left-to-Right)**
```javascript
/**
 * Pipe functions from left to right
 * pipe(f, g, h)(x) = h(g(f(x)))
 */
function pipe(...fns) {
  return function(value) {
    return fns.reduce((acc, fn) => fn(acc), value);
  };
}

// Test
console.log('\n=== Pipe (Left-to-Right) ===');

const piped = pipe(add5, multiply3, subtract2);

console.log('Input: 10');
console.log('Steps: 10 -> add5 -> 15 -> multiply3 -> 45 -> subtract2 -> 43');
console.log('Result:', piped(10)); // 43

// More readable flow
const processName = pipe(
  name => name.trim(),
  name => name.toLowerCase(),
  name => name.charAt(0).toUpperCase() + name.slice(1)
);

console.log(processName('  ALICE  ')); // "Alice"
console.log(processName('  bOb  ')); // "Bob"
```

### **Approach 3: Async Compose and Pipe**
```javascript
/**
 * Compose and pipe for async functions
 */
function composeAsync(...fns) {
  return async function(value) {
    return fns.reduceRight(
      async (acc, fn) => fn(await acc),
      value
    );
  };
}

function pipeAsync(...fns) {
  return async function(value) {
    return fns.reduce(
      async (acc, fn) => fn(await acc),
      value
    );
  };
}

// Test
console.log('\n=== Async Composition ===');

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const asyncAdd5 = async (x) => {
  await delay(100);
  console.log('Adding 5:', x, '->', x + 5);
  return x + 5;
};

const asyncMultiply3 = async (x) => {
  await delay(100);
  console.log('Multiplying by 3:', x, '->', x * 3);
  return x * 3;
};

const asyncSubtract2 = async (x) => {
  await delay(100);
  console.log('Subtracting 2:', x, '->', x - 2);
  return x - 2;
};

(async () => {
  const asyncPiped = pipeAsync(asyncAdd5, asyncMultiply3, asyncSubtract2);
  const result = await asyncPiped(10);
  console.log('Async result:', result); // 43
})();
```

### **Approach 4: Compose with Multiple Arguments**
```javascript
/**
 * Compose that handles multiple arguments for first function
 */
function composeMulti(...fns) {
  return function(...args) {
    const [first, ...rest] = fns.reverse();
    const firstResult = first(...args);
    
    return rest.reduce((acc, fn) => fn(acc), firstResult);
  };
}

// Test
console.log('\n=== Compose with Multiple Args ===');

const sum = (a, b, c) => a + b + c;
const double = x => x * 2;
const addTen = x => x + 10;

const calculate = composeMulti(addTen, double, sum);

console.log('calculate(2, 3, 5)');
console.log('Steps: sum(2,3,5) -> 10 -> double -> 20 -> addTen -> 30');
console.log('Result:', calculate(2, 3, 5)); // 30

// Format and log
const formatName = (first, last) => `${first} ${last}`;
const uppercase = str => str.toUpperCase();
const wrap = str => `[${str}]`;

const formatAndWrap = composeMulti(wrap, uppercase, formatName);
console.log(formatAndWrap('john', 'doe')); // "[JOHN DOE]"
```

### **Approach 5: Point-Free Style Utilities**
```javascript
/**
 * Helper functions for point-free composition
 */
function map(fn) {
  return array => array.map(fn);
}

function filter(predicate) {
  return array => array.filter(predicate);
}

function reduce(fn, initial) {
  return array => array.reduce(fn, initial);
}

function prop(key) {
  return obj => obj[key];
}

function trace(label) {
  return value => {
    console.log(`${label}:`, value);
    return value;
  };
}

// Test
console.log('\n=== Point-Free Style ===');

const users = [
  { name: 'Alice', age: 30, active: true },
  { name: 'Bob', age: 25, active: false },
  { name: 'Charlie', age: 35, active: true },
  { name: 'David', age: 28, active: true }
];

const getActiveUserNames = pipe(
  trace('Input'),
  filter(user => user.active),
  trace('After filter'),
  map(prop('name')),
  trace('After map'),
  map(name => name.toUpperCase())
);

console.log('Result:', getActiveUserNames(users));

// Math pipeline
const numbers = [1, 2, 3, 4, 5];

const sumOfDoubledEvens = pipe(
  filter(x => x % 2 === 0),
  map(x => x * 2),
  reduce((a, b) => a + b, 0)
);

console.log('Sum of doubled evens:', sumOfDoubledEvens(numbers)); // 12
```

### **Bonus: Compose with Error Handling**
```javascript
/**
 * Composition with try-catch for each function
 */
function composeSafe(...fns) {
  return function(value) {
    return fns.reduceRight((acc, fn, index) => {
      try {
        return fn(acc);
      } catch (error) {
        console.error(`Error in function ${fns.length - index}:`, error.message);
        throw error;
      }
    }, value);
  };
}

// Test
console.log('\n=== Safe Composition ===');

const divide10 = x => 10 / x;
const addOne = x => x + 1;
const maybeError = x => {
  if (x > 5) throw new Error('Value too large');
  return x;
};

const safeCalc = composeSafe(maybeError, divide10, addOne);

try {
  console.log(safeCalc(1)); // Works: (1+1) = 2, 10/2 = 5, 5 ok
} catch (e) {
  console.log('Caught:', e.message);
}

try {
  console.log(safeCalc(0)); // Error: 10/1 = 10, too large
} catch (e) {
  console.log('Caught:', e.message);
}
```

### **Bonus: Transducers**
```javascript
/**
 * Advanced: Transducers for efficient composition
 */
function transduce(xform, reducer, initial, collection) {
  const transformedReducer = xform(reducer);
  return collection.reduce(transformedReducer, initial);
}

const mapTransducer = (fn) => (reducer) => (acc, value) => 
  reducer(acc, fn(value));

const filterTransducer = (predicate) => (reducer) => (acc, value) =>
  predicate(value) ? reducer(acc, value) : acc;

// Test
console.log('\n=== Transducers ===');

const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Compose transducers
const xform = compose(
  mapTransducer(x => x * 2),
  filterTransducer(x => x > 10)
);

const result = transduce(
  xform,
  (acc, value) => [...acc, value],
  [],
  data
);

console.log('Transducer result:', result); // [12, 14, 16, 18, 20]

// Without transducers (less efficient - multiple iterations)
const traditional = data
  .map(x => x * 2)
  .filter(x => x > 10);

console.log('Traditional result:', traditional);
console.log('Transducers iterate once, traditional iterates twice');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical composition examples
 */

// 1. Data validation pipeline
const isString = val => typeof val === 'string';
const isNotEmpty = val => val.trim().length > 0;
const hasValidLength = val => val.length >= 3 && val.length <= 20;
const hasNoSpecialChars = val => /^[a-zA-Z0-9]+$/.test(val);

const validate = (checks) => (value) => {
  for (const check of checks) {
    if (!check(value)) return false;
  }
  return true;
};

const isValidUsername = validate([
  isString,
  isNotEmpty,
  hasValidLength,
  hasNoSpecialChars
]);

console.log('\n=== Validation Pipeline ===');
console.log('alice123:', isValidUsername('alice123')); // true
console.log('ab:', isValidUsername('ab')); // false (too short)
console.log('alice@123:', isValidUsername('alice@123')); // false (special char)

// 2. Data transformation pipeline
const parseJSON = str => JSON.parse(str);
const extractUsers = data => data.users;
const sortByAge = users => [...users].sort((a, b) => a.age - b.age);
const formatUsers = users => users.map(u => `${u.name} (${u.age})`);

const processUserData = pipe(
  parseJSON,
  extractUsers,
  sortByAge,
  formatUsers
);

const jsonData = '{"users":[{"name":"Alice","age":30},{"name":"Bob","age":25}]}';
console.log('\n=== Data Pipeline ===');
console.log(processUserData(jsonData));

// 3. Middleware pattern
const logRequest = (req) => {
  console.log('Request:', req.method, req.url);
  return req;
};

const authenticate = (req) => {
  req.user = req.headers.auth ? { id: 1, name: 'User' } : null;
  return req;
};

const authorize = (req) => {
  if (!req.user) throw new Error('Unauthorized');
  return req;
};

const handleRequest = (req) => {
  return { status: 200, data: 'Success' };
};

const middleware = pipe(
  logRequest,
  authenticate,
  authorize,
  handleRequest
);

console.log('\n=== Middleware ===');
try {
  const response = middleware({
    method: 'GET',
    url: '/api/users',
    headers: { auth: 'token123' }
  });
  console.log('Response:', response);
} catch (e) {
  console.log('Error:', e.message);
}

// 4. String manipulation
const removeSpaces = str => str.replace(/\s+/g, '');
const toLowerCase = str => str.toLowerCase();
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);
const addPrefix = prefix => str => `${prefix}${str}`;

const slugify = pipe(
  toLowerCase,
  str => str.replace(/\s+/g, '-'),
  str => str.replace(/[^a-z0-9-]/g, '')
);

console.log('\n=== String Processing ===');
console.log(slugify('Hello World! 123')); // "hello-world-123"

const formatTitle = pipe(
  toLowerCase,
  str => str.split(' '),
  words => words.map(capitalize),
  words => words.join(' ')
);

console.log(formatTitle('hello world from javascript')); // "Hello World From Javascript"

// 5. Promise chain
const fetchUser = (id) => Promise.resolve({ id, name: 'User' + id });
const fetchPosts = (user) => Promise.resolve({ ...user, posts: ['Post1', 'Post2'] });
const fetchComments = (data) => Promise.resolve({ ...data, comments: ['Comment1'] });

const getUserWithData = pipeAsync(
  fetchUser,
  fetchPosts,
  fetchComments
);

console.log('\n=== Promise Chain ===');
getUserWithData(123).then(result => {
  console.log('User data:', result);
});
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty composition
const emptyCompose = compose();
console.log('Empty compose:', emptyCompose(5)); // 5

const emptyPipe = pipe();
console.log('Empty pipe:', emptyPipe(5)); // 5

// Single function
const singleCompose = compose(x => x * 2);
console.log('Single compose:', singleCompose(5)); // 10

// Identity function
const identity = x => x;
const withIdentity = compose(identity, x => x * 2, identity);
console.log('With identity:', withIdentity(5)); // 10

// Composition of compositions
const composed1 = compose(x => x + 1, x => x * 2);
const composed2 = compose(x => x - 3, x => x / 2);
const superCompose = compose(composed2, composed1);
console.log('Composed compositions:', superCompose(10)); // ((10*2)+1)/2-3 = 7.5

// Type changes through pipeline
const toNumber = pipe(
  str => str.trim(),
  str => parseInt(str, 10),
  num => num * 2,
  num => num.toString()
);

console.log('Type changes:', toNumber('  42  ')); // "84"
```

### **Performance Considerations**
```javascript
/**
 * Optimize composition
 */
console.log('\n=== Performance ===');

// Manual vs composed
function manual(x) {
  return subtract2(multiply3(add5(x)));
}

const composed2 = compose(subtract2, multiply3, add5);

console.time('Manual (10000 calls)');
for (let i = 0; i < 10000; i++) {
  manual(10);
}
console.timeEnd('Manual (10000 calls)');

console.time('Composed (10000 calls)');
for (let i = 0; i < 10000; i++) {
  composed2(10);
}
console.timeEnd('Composed (10000 calls)');

console.log('Composition adds minimal overhead for readability benefits');
```

**Interview Tips:**
- Composition: combine functions to create new functions
- Compose: right-to-left execution (like math: f(g(x)))
- Pipe: left-to-right execution (more intuitive for data flow)
- Implementation: use reduce/reduceRight with initial value
- Each function takes output of previous as input
- Unary functions (one argument) compose best
- For multiple args: only first function needs to accept them
- Benefits: reusability, testability, readability, declarative style
- Point-free style: define functions without mentioning arguments
- Async composition: use async/await with reduce
- Error handling: wrap each function in try-catch or use Either monad
- Transducers: efficient composition avoiding multiple iterations
- Applications: validation, data transformation, middleware, string processing
- Compose vs pipe: same behavior, different order (preference)
- Works well with: map, filter, reduce (array methods)
- Debugging: add trace function to log intermediate values
- Edge cases: empty composition (identity), single function, type changes
- Clarify: compose or pipe? async support? error handling? multiple args?
- Follow-ups: implement flow (alias for pipe), add tap for side effects, partial composition

</details>

88. Implement a deep equality check function

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Deep Equality**
```javascript
/**
 * Deep equality check for objects and arrays
 * Time Complexity: O(n) where n is total number of properties
 * Space Complexity: O(d) where d is depth (recursion stack)
 */
function deepEqual(a, b) {
  // Same reference or both primitives equal
  if (a === b) return true;
  
  // If either is null or not an object
  if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
    return false;
  }
  
  // Get keys
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  // Different number of keys
  if (keysA.length !== keysB.length) return false;
  
  // Check each key
  for (const key of keysA) {
    if (!keysB.includes(key)) return false;
    if (!deepEqual(a[key], b[key])) return false;
  }
  
  return true;
}

// Test
console.log('=== Basic Deep Equality ===');

console.log(deepEqual(1, 1)); // true
console.log(deepEqual('hello', 'hello')); // true
console.log(deepEqual(null, null)); // true

console.log(deepEqual({ a: 1 }, { a: 1 })); // true
console.log(deepEqual({ a: 1, b: 2 }, { b: 2, a: 1 })); // true

console.log(deepEqual([1, 2, 3], [1, 2, 3])); // true
console.log(deepEqual([1, [2, 3]], [1, [2, 3]])); // true

console.log(deepEqual({ a: 1 }, { a: 2 })); // false
console.log(deepEqual([1, 2], [1, 2, 3])); // false

const nested = { a: { b: { c: 1 } } };
console.log(deepEqual(nested, { a: { b: { c: 1 } } })); // true
```

### **Approach 2: Handle Special Cases**
```javascript
/**
 * Deep equality with special type handling
 */
function deepEqualAdvanced(a, b) {
  // Strict equality
  if (a === b) return true;
  
  // Handle NaN
  if (Number.isNaN(a) && Number.isNaN(b)) return true;
  
  // Handle Date objects
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  
  // Handle RegExp
  if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.flags === b.flags;
  }
  
  // Handle Arrays
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    
    for (let i = 0; i < a.length; i++) {
      if (!deepEqualAdvanced(a[i], b[i])) return false;
    }
    
    return true;
  }
  
  // Handle null or primitives
  if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
    return false;
  }
  
  // Handle objects
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (!keysB.includes(key)) return false;
    if (!deepEqualAdvanced(a[key], b[key])) return false;
  }
  
  return true;
}

// Test
console.log('\n=== Advanced Deep Equality ===');

// NaN
console.log('NaN vs NaN:', deepEqualAdvanced(NaN, NaN)); // true

// Dates
const date1 = new Date('2024-01-01');
const date2 = new Date('2024-01-01');
const date3 = new Date('2024-01-02');
console.log('Same dates:', deepEqualAdvanced(date1, date2)); // true
console.log('Different dates:', deepEqualAdvanced(date1, date3)); // false

// RegExp
const regex1 = /test/gi;
const regex2 = /test/gi;
const regex3 = /test/i;
console.log('Same regex:', deepEqualAdvanced(regex1, regex2)); // true
console.log('Different flags:', deepEqualAdvanced(regex1, regex3)); // false

// Mixed
const obj1 = {
  date: new Date('2024-01-01'),
  regex: /test/i,
  array: [1, 2, 3]
};
const obj2 = {
  date: new Date('2024-01-01'),
  regex: /test/i,
  array: [1, 2, 3]
};
console.log('Complex object:', deepEqualAdvanced(obj1, obj2)); // true
```

### **Approach 3: With Circular Reference Detection**
```javascript
/**
 * Deep equality that handles circular references
 */
function deepEqualCircular(a, b, seenA = new WeakMap(), seenB = new WeakMap()) {
  // Strict equality
  if (a === b) return true;
  
  // Handle primitives and null
  if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
    return a === b;
  }
  
  // Check for circular references
  if (seenA.has(a)) {
    return seenA.get(a) === b;
  }
  if (seenB.has(b)) {
    return seenB.get(b) === a;
  }
  
  // Mark as seen
  seenA.set(a, b);
  seenB.set(b, a);
  
  // Handle Arrays
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    
    for (let i = 0; i < a.length; i++) {
      if (!deepEqualCircular(a[i], b[i], seenA, seenB)) return false;
    }
    
    return true;
  }
  
  // Handle objects
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (!keysB.includes(key)) return false;
    if (!deepEqualCircular(a[key], b[key], seenA, seenB)) return false;
  }
  
  return true;
}

// Test
console.log('\n=== Circular Reference Handling ===');

// Create circular references
const circular1 = { name: 'obj1' };
circular1.self = circular1;

const circular2 = { name: 'obj1' };
circular2.self = circular2;

console.log('Circular objects:', deepEqualCircular(circular1, circular2)); // true

// Different circular structures
const circular3 = { name: 'obj3' };
circular3.self = circular3;

const circular4 = { name: 'obj4' };
circular4.self = circular4;

console.log('Different circular:', deepEqualCircular(circular3, circular4)); // false

// Complex circular
const a = { x: 1 };
const b = { x: 1 };
a.ref = a;
b.ref = b;

console.log('Complex circular:', deepEqualCircular(a, b)); // true
```

### **Approach 4: Complete Implementation with All Types**
```javascript
/**
 * Comprehensive deep equality check
 */
function isDeepEqual(a, b, seen = new WeakMap()) {
  // Strict equality (handles primitives, same reference)
  if (Object.is(a, b)) return true;
  
  // Different types
  if (typeof a !== typeof b) return false;
  
  // Both are primitives but not equal
  if (typeof a !== 'object' || a === null || b === null) {
    return false;
  }
  
  // Check constructors
  if (a.constructor !== b.constructor) return false;
  
  // Handle Date
  if (a instanceof Date) {
    return a.getTime() === b.getTime();
  }
  
  // Handle RegExp
  if (a instanceof RegExp) {
    return a.source === b.source && a.flags === b.flags;
  }
  
  // Handle Map
  if (a instanceof Map) {
    if (a.size !== b.size) return false;
    
    for (const [key, value] of a) {
      if (!b.has(key) || !isDeepEqual(value, b.get(key), seen)) {
        return false;
      }
    }
    
    return true;
  }
  
  // Handle Set
  if (a instanceof Set) {
    if (a.size !== b.size) return false;
    
    for (const value of a) {
      if (!b.has(value)) return false;
    }
    
    return true;
  }
  
  // Handle ArrayBuffer
  if (a instanceof ArrayBuffer) {
    if (a.byteLength !== b.byteLength) return false;
    const viewA = new Uint8Array(a);
    const viewB = new Uint8Array(b);
    
    for (let i = 0; i < viewA.length; i++) {
      if (viewA[i] !== viewB[i]) return false;
    }
    
    return true;
  }
  
  // Handle TypedArrays
  if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
    if (a.length !== b.length) return false;
    
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    
    return true;
  }
  
  // Circular reference check
  if (seen.has(a)) {
    return seen.get(a) === b;
  }
  seen.set(a, b);
  
  // Handle Arrays
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    
    for (let i = 0; i < a.length; i++) {
      if (!isDeepEqual(a[i], b[i], seen)) return false;
    }
    
    return true;
  }
  
  // Handle plain objects
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  // Check own properties
  for (const key of keysA) {
    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
    if (!isDeepEqual(a[key], b[key], seen)) return false;
  }
  
  return true;
}

// Test
console.log('\n=== Complete Implementation ===');

// Map
const map1 = new Map([['a', 1], ['b', 2]]);
const map2 = new Map([['a', 1], ['b', 2]]);
const map3 = new Map([['b', 2], ['a', 1]]);
console.log('Maps equal:', isDeepEqual(map1, map2)); // true
console.log('Maps different order:', isDeepEqual(map1, map3)); // true

// Set
const set1 = new Set([1, 2, 3]);
const set2 = new Set([1, 2, 3]);
const set3 = new Set([1, 2, 4]);
console.log('Sets equal:', isDeepEqual(set1, set2)); // true
console.log('Sets different:', isDeepEqual(set1, set3)); // false

// TypedArray
const arr1 = new Uint8Array([1, 2, 3]);
const arr2 = new Uint8Array([1, 2, 3]);
const arr3 = new Uint8Array([1, 2, 4]);
console.log('TypedArrays equal:', isDeepEqual(arr1, arr2)); // true
console.log('TypedArrays different:', isDeepEqual(arr1, arr3)); // false

// Complex nested
const complex1 = {
  date: new Date('2024-01-01'),
  regex: /test/gi,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3]),
  nested: { a: 1, b: [2, 3, { c: 4 }] }
};

const complex2 = {
  date: new Date('2024-01-01'),
  regex: /test/gi,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3]),
  nested: { a: 1, b: [2, 3, { c: 4 }] }
};

console.log('Complex nested:', isDeepEqual(complex1, complex2)); // true
```

### **Approach 5: Optimized with Early Exit**
```javascript
/**
 * Optimized version with early exits
 */
function deepEqualOptimized(a, b) {
  // Fast path: same reference
  if (a === b) return true;
  
  // Fast path: different types
  const typeA = typeof a;
  const typeB = typeof b;
  if (typeA !== typeB) return false;
  
  // Fast path: primitives
  if (typeA !== 'object') return false;
  
  // Fast path: null
  if (a === null || b === null) return a === b;
  
  // Fast path: different constructors
  const ctorA = a.constructor;
  const ctorB = b.constructor;
  if (ctorA !== ctorB) return false;
  
  // Arrays
  if (Array.isArray(a)) {
    const len = a.length;
    if (len !== b.length) return false;
    
    for (let i = 0; i < len; i++) {
      if (!deepEqualOptimized(a[i], b[i])) return false;
    }
    
    return true;
  }
  
  // Date
  if (a instanceof Date) {
    return a.getTime() === b.getTime();
  }
  
  // RegExp
  if (a instanceof RegExp) {
    return a.toString() === b.toString();
  }
  
  // Objects
  const keysA = Object.keys(a);
  const len = keysA.length;
  
  // Fast path: different key counts
  if (len !== Object.keys(b).length) return false;
  
  // Check each property
  for (let i = 0; i < len; i++) {
    const key = keysA[i];
    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
    if (!deepEqualOptimized(a[key], b[key])) return false;
  }
  
  return true;
}

// Test
console.log('\n=== Optimized Deep Equality ===');

const large1 = {
  a: 1, b: 2, c: 3, d: 4, e: 5,
  nested: { x: 1, y: 2, z: 3 },
  array: [1, 2, 3, 4, 5]
};

const large2 = {
  a: 1, b: 2, c: 3, d: 4, e: 5,
  nested: { x: 1, y: 2, z: 3 },
  array: [1, 2, 3, 4, 5]
};

console.time('Optimized');
for (let i = 0; i < 10000; i++) {
  deepEqualOptimized(large1, large2);
}
console.timeEnd('Optimized');

console.log('Result:', deepEqualOptimized(large1, large2)); // true
```

### **Bonus: Shallow Equality**
```javascript
/**
 * Shallow equality (one level deep)
 */
function shallowEqual(a, b) {
  if (a === b) return true;
  
  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) {
    return false;
  }
  
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (a[key] !== b[key] || !Object.prototype.hasOwnProperty.call(b, key)) {
      return false;
    }
  }
  
  return true;
}

// Test
console.log('\n=== Shallow Equality ===');

console.log(shallowEqual({ a: 1 }, { a: 1 })); // true
console.log(shallowEqual({ a: {} }, { a: {} })); // false (different references)

const shared = { x: 1 };
console.log(shallowEqual({ a: shared }, { a: shared })); // true (same reference)
```

### **Bonus: Partial Equality (Subset Check)**
```javascript
/**
 * Check if b contains all properties of a (subset)
 */
function isSubset(subset, superset) {
  if (subset === superset) return true;
  
  if (typeof subset !== 'object' || typeof superset !== 'object' ||
      subset === null || superset === null) {
    return subset === superset;
  }
  
  for (const key of Object.keys(subset)) {
    if (!Object.prototype.hasOwnProperty.call(superset, key)) {
      return false;
    }
    
    if (!isSubset(subset[key], superset[key])) {
      return false;
    }
  }
  
  return true;
}

// Test
console.log('\n=== Subset Check ===');

const small = { a: 1, b: 2 };
const large = { a: 1, b: 2, c: 3 };

console.log('Is subset:', isSubset(small, large)); // true
console.log('Is subset (reverse):', isSubset(large, small)); // false

const nested1 = { a: { b: 1 } };
const nested2 = { a: { b: 1, c: 2 }, d: 3 };

console.log('Nested subset:', isSubset(nested1, nested2)); // true
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of deep equality
 */

// 1. React shouldComponentUpdate
class MyComponent {
  shouldComponentUpdate(nextProps, nextState) {
    return !deepEqual(this.props, nextProps) || 
           !deepEqual(this.state, nextState);
  }
}

// 2. Memoization cache key comparison
const memoCache = new Map();

function memoizeDeep(fn) {
  return function(...args) {
    for (const [cachedArgs, result] of memoCache) {
      if (deepEqual(cachedArgs, args)) {
        console.log('Cache hit!');
        return result;
      }
    }
    
    console.log('Cache miss, computing...');
    const result = fn(...args);
    memoCache.set(args, result);
    return result;
  };
}

const compute = memoizeDeep((obj) => {
  return obj.a + obj.b;
});

console.log('\n=== Memoization ===');
console.log(compute({ a: 1, b: 2 })); // Cache miss
console.log(compute({ a: 1, b: 2 })); // Cache hit!

// 3. Testing/Assertions
function assertEqual(actual, expected, message = '') {
  if (!deepEqual(actual, expected)) {
    throw new Error(
      `Assertion failed: ${message}\n` +
      `Expected: ${JSON.stringify(expected)}\n` +
      `Actual: ${JSON.stringify(actual)}`
    );
  }
  console.log('✓ Test passed:', message);
}

console.log('\n=== Testing ===');
assertEqual({ a: 1, b: [2, 3] }, { a: 1, b: [2, 3] }, 'Objects equal');

// 4. Change detection
class ChangeDetector {
  constructor(data) {
    this.data = data;
    this.snapshot = JSON.parse(JSON.stringify(data));
  }
  
  hasChanged() {
    return !deepEqual(this.data, this.snapshot);
  }
  
  getChanges() {
    if (!this.hasChanged()) return null;
    
    return {
      before: this.snapshot,
      after: this.data
    };
  }
  
  commit() {
    this.snapshot = JSON.parse(JSON.stringify(this.data));
  }
}

console.log('\n=== Change Detection ===');
const detector = new ChangeDetector({ name: 'Alice', age: 30 });
console.log('Changed?', detector.hasChanged()); // false

detector.data.age = 31;
console.log('Changed?', detector.hasChanged()); // true
console.log('Changes:', detector.getChanges());

// 5. Form dirty state
function isFormDirty(initialValues, currentValues) {
  return !deepEqual(initialValues, currentValues);
}

console.log('\n=== Form Dirty State ===');
const initial = { username: 'alice', email: 'alice@example.com' };
const current1 = { username: 'alice', email: 'alice@example.com' };
const current2 = { username: 'alice', email: 'newemail@example.com' };

console.log('Form dirty (no change):', isFormDirty(initial, current1)); // false
console.log('Form dirty (changed):', isFormDirty(initial, current2)); // true
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Primitives
console.log('Numbers:', deepEqual(42, 42)); // true
console.log('Strings:', deepEqual('hello', 'hello')); // true
console.log('Booleans:', deepEqual(true, true)); // true
console.log('undefined:', deepEqual(undefined, undefined)); // true
console.log('null:', deepEqual(null, null)); // true

// Special numbers
console.log('NaN:', deepEqual(NaN, NaN)); // false (use Object.is or special handling)
console.log('Infinity:', deepEqual(Infinity, Infinity)); // true
console.log('+0 vs -0:', deepEqual(0, -0)); // true (use Object.is for distinction)

// Empty structures
console.log('Empty objects:', deepEqual({}, {})); // true
console.log('Empty arrays:', deepEqual([], [])); // true

// Different types
console.log('Number vs String:', deepEqual(1, '1')); // false
console.log('Array vs Object:', deepEqual([], {})); // false
console.log('null vs undefined:', deepEqual(null, undefined)); // false

// Property order (shouldn't matter)
console.log('Property order:', deepEqual(
  { a: 1, b: 2 },
  { b: 2, a: 1 }
)); // true

// Nested arrays
console.log('Nested arrays:', deepEqual(
  [[1, 2], [3, 4]],
  [[1, 2], [3, 4]]
)); // true

// Functions (by reference only)
const fn1 = () => {};
const fn2 = () => {};
console.log('Same function:', deepEqual(fn1, fn1)); // true
console.log('Different functions:', deepEqual(fn1, fn2)); // false

// Symbols
const sym1 = Symbol('test');
const sym2 = Symbol('test');
console.log('Same symbol:', deepEqual(sym1, sym1)); // true
console.log('Different symbols:', deepEqual(sym1, sym2)); // false

// Object with null prototype
const obj1 = Object.create(null);
obj1.a = 1;
const obj2 = Object.create(null);
obj2.a = 1;
console.log('Null prototype:', deepEqual(obj1, obj2)); // true
```

### **Performance Comparison**
```javascript
/**
 * Compare different implementations
 */
console.log('\n=== Performance Comparison ===');

const testObj1 = {
  a: 1, b: 2, c: 3,
  nested: {
    x: [1, 2, 3],
    y: { z: 'hello' }
  }
};

const testObj2 = {
  a: 1, b: 2, c: 3,
  nested: {
    x: [1, 2, 3],
    y: { z: 'hello' }
  }
};

const iterations = 10000;

console.time('Basic deepEqual');
for (let i = 0; i < iterations; i++) {
  deepEqual(testObj1, testObj2);
}
console.timeEnd('Basic deepEqual');

console.time('Optimized deepEqual');
for (let i = 0; i < iterations; i++) {
  deepEqualOptimized(testObj1, testObj2);
}
console.timeEnd('Optimized deepEqual');

console.time('JSON.stringify (not recommended)');
for (let i = 0; i < iterations; i++) {
  JSON.stringify(testObj1) === JSON.stringify(testObj2);
}
console.timeEnd('JSON.stringify (not recommended)');

console.log('\nNote: JSON.stringify can fail with circular refs, different order, etc.');
```

**Interview Tips:**
- Deep equality: recursively compare all nested properties
- Base case: strict equality (===) for primitives and same reference
- For objects: compare keys count, then each property recursively
- For arrays: compare length, then each element recursively
- Handle special types: Date (getTime), RegExp (source + flags), NaN
- Circular references: use WeakMap to track seen objects
- Object.keys() doesn't guarantee order, but that's okay for equality
- Don't use JSON.stringify: fails on circular refs, functions, undefined, Symbol
- Performance: early exit on first difference, cache computed checks
- Constructor check: new Date() !== plain object even if same properties
- Map/Set: compare size, then iterate and check membership
- TypedArrays: compare length and byte-by-byte
- Shallow equality: only compare direct properties (===), not nested
- Use Object.is() for NaN and ±0 distinction
- Applications: React reconciliation, memoization, testing, change detection
- Edge cases: null, undefined, NaN, empty objects, different types, functions
- Clarify: shallow or deep? circular refs? special types? performance critical?
- Follow-ups: implement shallowEqual, handle custom classes, add path tracking

</details>

89. Create a function to flatten a deeply nested object

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Flattening with Dot Notation**
```javascript
/**
 * Flatten nested object using dot notation for keys
 * Time Complexity: O(n) where n is total number of properties
 * Space Complexity: O(n) for the result object
 */
function flattenObject(obj, prefix = '', result = {}) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = prefix ? `${prefix}.${key}` : key;
      
      if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
        flattenObject(obj[key], newKey, result);
      } else {
        result[newKey] = obj[key];
      }
    }
  }
  
  return result;
}

// Test
console.log('=== Basic Flattening ===');

const nested = {
  name: 'John',
  age: 30,
  address: {
    street: '123 Main St',
    city: 'NYC',
    coordinates: {
      lat: 40.7128,
      lng: -74.0060
    }
  },
  hobbies: ['reading', 'coding']
};

console.log('Original:', JSON.stringify(nested, null, 2));
console.log('Flattened:', flattenObject(nested));
// {
//   name: 'John',
//   age: 30,
//   'address.street': '123 Main St',
//   'address.city': 'NYC',
//   'address.coordinates.lat': 40.7128,
//   'address.coordinates.lng': -74.0060,
//   hobbies: ['reading', 'coding']
// }
```

### **Approach 2: Flatten with Custom Separator**
```javascript
/**
 * Flatten with configurable separator
 */
function flattenWithSeparator(obj, separator = '.', prefix = '', result = {}) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = prefix ? `${prefix}${separator}${key}` : key;
      const value = obj[key];
      
      if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
        flattenWithSeparator(value, separator, newKey, result);
      } else {
        result[newKey] = value;
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== Custom Separator ===');

const data = {
  user: {
    profile: {
      name: 'Alice',
      email: 'alice@example.com'
    }
  }
};

console.log('Dot separator:', flattenWithSeparator(data, '.'));
// { 'user.profile.name': 'Alice', 'user.profile.email': 'alice@example.com' }

console.log('Underscore separator:', flattenWithSeparator(data, '_'));
// { 'user_profile_name': 'Alice', 'user_profile_email': 'alice@example.com' }

console.log('Slash separator:', flattenWithSeparator(data, '/'));
// { 'user/profile/name': 'Alice', 'user/profile/email': 'alice@example.com' }
```

### **Approach 3: Flatten with Array Handling**
```javascript
/**
 * Flatten including array indices
 */
function flattenWithArrays(obj, prefix = '', result = {}) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = prefix ? `${prefix}.${key}` : key;
      const value = obj[key];
      
      if (Array.isArray(value)) {
        // Flatten array elements
        value.forEach((item, index) => {
          const arrayKey = `${newKey}[${index}]`;
          
          if (typeof item === 'object' && item !== null) {
            flattenWithArrays(item, arrayKey, result);
          } else {
            result[arrayKey] = item;
          }
        });
      } else if (typeof value === 'object' && value !== null) {
        flattenWithArrays(value, newKey, result);
      } else {
        result[newKey] = value;
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== With Arrays ===');

const withArrays = {
  name: 'Company',
  employees: [
    { name: 'Alice', role: 'Developer' },
    { name: 'Bob', role: 'Designer' }
  ],
  offices: ['NYC', 'SF', 'London']
};

console.log('Flattened with arrays:', flattenWithArrays(withArrays));
// {
//   name: 'Company',
//   'employees[0].name': 'Alice',
//   'employees[0].role': 'Developer',
//   'employees[1].name': 'Bob',
//   'employees[1].role': 'Designer',
//   'offices[0]': 'NYC',
//   'offices[1]': 'SF',
//   'offices[2]': 'London'
// }
```

### **Approach 4: Unflatten (Reverse Operation)**
```javascript
/**
 * Unflatten a flattened object back to nested structure
 */
function unflattenObject(obj) {
  const result = {};
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const keys = key.split('.');
      let current = result;
      
      for (let i = 0; i < keys.length - 1; i++) {
        const k = keys[i];
        
        if (!current[k]) {
          current[k] = {};
        }
        
        current = current[k];
      }
      
      current[keys[keys.length - 1]] = obj[key];
    }
  }
  
  return result;
}

// Test
console.log('\n=== Unflatten ===');

const flattened = {
  'name': 'John',
  'address.street': '123 Main St',
  'address.city': 'NYC',
  'address.zip': '10001'
};

console.log('Flattened:', flattened);
console.log('Unflattened:', unflattenObject(flattened));
// {
//   name: 'John',
//   address: {
//     street: '123 Main St',
//     city: 'NYC',
//     zip: '10001'
//   }
// }

// Round trip
const original = { a: { b: { c: 1 } } };
const flat = flattenObject(original);
const restored = unflattenObject(flat);
console.log('Round trip:', JSON.stringify(original) === JSON.stringify(restored)); // true
```

### **Approach 5: Flatten with Max Depth**
```javascript
/**
 * Flatten up to a specified depth
 */
function flattenWithDepth(obj, maxDepth = Infinity, currentDepth = 0, prefix = '', result = {}) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = prefix ? `${prefix}.${key}` : key;
      const value = obj[key];
      
      if (currentDepth < maxDepth && 
          typeof value === 'object' && 
          value !== null && 
          !Array.isArray(value)) {
        flattenWithDepth(value, maxDepth, currentDepth + 1, newKey, result);
      } else {
        result[newKey] = value;
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== Flatten with Max Depth ===');

const deep = {
  level1: {
    level2: {
      level3: {
        level4: {
          value: 'deep'
        }
      }
    }
  }
};

console.log('Depth 0:', flattenWithDepth(deep, 0));
// { level1: { level2: { level3: { level4: { value: 'deep' } } } } }

console.log('Depth 1:', flattenWithDepth(deep, 1));
// { 'level1.level2': { level3: { level4: { value: 'deep' } } } }

console.log('Depth 2:', flattenWithDepth(deep, 2));
// { 'level1.level2.level3': { level4: { value: 'deep' } } }

console.log('Depth Infinity:', flattenWithDepth(deep));
// { 'level1.level2.level3.level4.value': 'deep' }
```

### **Bonus: Flatten with Path Array**
```javascript
/**
 * Flatten with path as array instead of string
 */
function flattenToPath(obj, prefix = [], result = {}) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const path = [...prefix, key];
      const value = obj[key];
      
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        flattenToPath(value, path, result);
      } else {
        result[JSON.stringify(path)] = value;
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== Flatten to Path Array ===');

const obj = {
  a: {
    b: {
      c: 1
    }
  }
};

console.log('Path arrays:', flattenToPath(obj));
// { '["a","b","c"]': 1 }

// Can retrieve value using path
const flatPaths = flattenToPath(obj);
for (const [pathStr, value] of Object.entries(flatPaths)) {
  const path = JSON.parse(pathStr);
  console.log(`Path ${path.join('.')}:`, value);
}
```

### **Bonus: Flatten with Circular Reference Detection**
```javascript
/**
 * Safe flatten that handles circular references
 */
function flattenSafe(obj, prefix = '', result = {}, seen = new WeakSet()) {
  // Check for circular reference
  if (seen.has(obj)) {
    result[prefix] = '[Circular]';
    return result;
  }
  
  // Mark as seen
  if (typeof obj === 'object' && obj !== null) {
    seen.add(obj);
  }
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = prefix ? `${prefix}.${key}` : key;
      const value = obj[key];
      
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        flattenSafe(value, newKey, result, seen);
      } else {
        result[newKey] = value;
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== Safe Flatten (Circular) ===');

const circular = { name: 'obj' };
circular.self = circular;
circular.nested = { ref: circular };

console.log('Circular object:', flattenSafe(circular));
// {
//   name: 'obj',
//   self: '[Circular]',
//   'nested.ref': '[Circular]'
// }
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Convert nested config to environment variables
function toEnvVars(config) {
  const flattened = flattenObject(config);
  const envVars = {};
  
  for (const [key, value] of Object.entries(flattened)) {
    const envKey = key.toUpperCase().replace(/\./g, '_');
    envVars[envKey] = String(value);
  }
  
  return envVars;
}

console.log('\n=== Config to Env Vars ===');
const config = {
  database: {
    host: 'localhost',
    port: 5432,
    credentials: {
      username: 'admin',
      password: 'secret'
    }
  }
};

console.log('Env vars:', toEnvVars(config));
// {
//   DATABASE_HOST: 'localhost',
//   DATABASE_PORT: '5432',
//   DATABASE_CREDENTIALS_USERNAME: 'admin',
//   DATABASE_CREDENTIALS_PASSWORD: 'secret'
// }

// 2. Extract all values for a specific key
function extractKey(obj, targetKey) {
  const values = [];
  
  function traverse(current) {
    for (const key in current) {
      if (current.hasOwnProperty(key)) {
        if (key === targetKey) {
          values.push(current[key]);
        }
        
        if (typeof current[key] === 'object' && current[key] !== null) {
          traverse(current[key]);
        }
      }
    }
  }
  
  traverse(obj);
  return values;
}

console.log('\n=== Extract Specific Key ===');
const data2 = {
  user: { id: 1, name: 'Alice' },
  posts: [
    { id: 101, name: 'Post 1' },
    { id: 102, name: 'Post 2' }
  ]
};

console.log('All ids:', extractKey(data2, 'id')); // [1, 101, 102]
console.log('All names:', extractKey(data2, 'name')); // ['Alice', 'Post 1', 'Post 2']

// 3. Diff two objects
function diffObjects(obj1, obj2) {
  const flat1 = flattenObject(obj1);
  const flat2 = flattenObject(obj2);
  const diff = { added: {}, removed: {}, changed: {} };
  
  // Check for added and changed
  for (const key in flat2) {
    if (!(key in flat1)) {
      diff.added[key] = flat2[key];
    } else if (flat1[key] !== flat2[key]) {
      diff.changed[key] = { from: flat1[key], to: flat2[key] };
    }
  }
  
  // Check for removed
  for (const key in flat1) {
    if (!(key in flat2)) {
      diff.removed[key] = flat1[key];
    }
  }
  
  return diff;
}

console.log('\n=== Object Diff ===');
const v1 = { a: 1, b: { c: 2, d: 3 } };
const v2 = { a: 1, b: { c: 5 }, e: 6 };

console.log('Diff:', diffObjects(v1, v2));
// {
//   added: { e: 6 },
//   removed: { 'b.d': 3 },
//   changed: { 'b.c': { from: 2, to: 5 } }
// }

// 4. Query nested objects
function query(obj, path) {
  const keys = path.split('.');
  let current = obj;
  
  for (const key of keys) {
    if (current && typeof current === 'object' && key in current) {
      current = current[key];
    } else {
      return undefined;
    }
  }
  
  return current;
}

console.log('\n=== Query Nested Object ===');
const userData = {
  user: {
    profile: {
      name: 'Alice',
      settings: {
        theme: 'dark'
      }
    }
  }
};

console.log('Query "user.profile.name":', query(userData, 'user.profile.name')); // 'Alice'
console.log('Query "user.profile.settings.theme":', query(userData, 'user.profile.settings.theme')); // 'dark'
console.log('Query "user.invalid":', query(userData, 'user.invalid')); // undefined

// 5. Set nested value
function setNested(obj, path, value) {
  const keys = path.split('.');
  let current = obj;
  
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    
    if (!(key in current) || typeof current[key] !== 'object') {
      current[key] = {};
    }
    
    current = current[key];
  }
  
  current[keys[keys.length - 1]] = value;
}

console.log('\n=== Set Nested Value ===');
const target = {};
setNested(target, 'user.profile.name', 'Bob');
setNested(target, 'user.settings.theme', 'light');
console.log('Result:', target);
// { user: { profile: { name: 'Bob' }, settings: { theme: 'light' } } }
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty object
console.log('Empty:', flattenObject({})); // {}

// Null values
console.log('With null:', flattenObject({ a: null, b: { c: null } }));
// { a: null, 'b.c': null }

// Undefined values
console.log('With undefined:', flattenObject({ a: undefined, b: { c: 1 } }));
// { a: undefined, 'b.c': 1 }

// Arrays as values
console.log('Arrays:', flattenObject({ a: [1, 2], b: { c: [3, 4] } }));
// { a: [1, 2], 'b.c': [3, 4] }

// Single level
console.log('Single level:', flattenObject({ a: 1, b: 2 }));
// { a: 1, b: 2 }

// Deep nesting
const veryDeep = { a: { b: { c: { d: { e: { f: 1 } } } } } };
console.log('Very deep:', flattenObject(veryDeep));
// { 'a.b.c.d.e.f': 1 }

// Special characters in keys
console.log('Special keys:', flattenObject({ 'key.with.dots': { value: 1 } }));
// { 'key.with.dots.value': 1 } - may need escaping
```

### **Performance Considerations**
```javascript
/**
 * Benchmark flattening
 */
console.log('\n=== Performance ===');

const largeObj = {};
for (let i = 0; i < 100; i++) {
  largeObj[`key${i}`] = {
    nested: {
      value: i,
      data: { x: i * 2 }
    }
  };
}

console.time('Flatten 100 nested objects');
const flattened2 = flattenObject(largeObj);
console.timeEnd('Flatten 100 nested objects');

console.log('Flattened keys:', Object.keys(flattened2).length);

console.time('Unflatten back');
const unflattened = unflattenObject(flattened2);
console.timeEnd('Unflatten back');

console.log('Restored keys:', Object.keys(unflattened).length);
```

**Interview Tips:**
- Flatten: convert nested object to single-level with composite keys
- Use dot notation for nested keys: "a.b.c"
- Recursive approach: traverse tree, build flat result
- Base case: primitive or array → add to result
- Recursive case: object → recurse with updated prefix
- Arrays: can treat as values or flatten with indices [0], [1]
- Unflatten: reverse operation, split keys by delimiter
- Custom separator: . (dot), _ (underscore), / (slash)
- Max depth: control flattening level, useful for partial flatten
- Circular references: use WeakSet to track visited objects
- Applications: env vars, config files, form data, diff/patch, query paths
- Object.keys vs for...in: keys better (only own properties)
- hasOwnProperty check prevents prototype pollution
- Path arrays alternative: store paths as arrays instead of strings
- Query/set helpers: navigate nested structures by path string
- Edge cases: empty object, null, undefined, arrays, single level, special chars
- Performance: O(n) time, O(n) space where n = total properties
- Clarify: handle arrays? max depth? separator? circular refs? preserve types?
- Follow-ups: implement with path arrays, add type preservation, streaming flatten

</details>

90. Implement call, apply, and bind from scratch

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Implement call()**
```javascript
/**
 * Implement Function.prototype.call()
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * call() invokes function with specific 'this' context and arguments
 */
Function.prototype.myCall = function(context, ...args) {
  // Handle null/undefined context (becomes globalThis in non-strict mode)
  context = context || globalThis;
  
  // Create unique property to avoid name collision
  const fnSymbol = Symbol('fn');
  
  // Assign function to context
  context[fnSymbol] = this;
  
  // Call function with context
  const result = context[fnSymbol](...args);
  
  // Clean up
  delete context[fnSymbol];
  
  return result;
};

// Test
console.log('=== myCall() Implementation ===');

function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: 'Alice' };

console.log(greet.myCall(person, 'Hello', '!')); // "Hello, Alice!"
console.log(greet.myCall(person, 'Hi', '.')); // "Hi, Alice."

// Compare with native
console.log(greet.call(person, 'Hello', '!')); // "Hello, Alice!"

// With different context
const person2 = { name: 'Bob' };
console.log(greet.myCall(person2, 'Hey', '~')); // "Hey, Bob~"
```

### **Approach 2: Implement apply()**
```javascript
/**
 * Implement Function.prototype.apply()
 * Similar to call but takes arguments as array
 */
Function.prototype.myApply = function(context, argsArray = []) {
  // Handle null/undefined context
  context = context || globalThis;
  
  // Validate argsArray
  if (!Array.isArray(argsArray) && argsArray !== null && argsArray !== undefined) {
    throw new TypeError('Second argument must be an array or array-like object');
  }
  
  // Create unique property
  const fnSymbol = Symbol('fn');
  
  // Assign function to context
  context[fnSymbol] = this;
  
  // Call function with spread arguments
  const result = context[fnSymbol](...(argsArray || []));
  
  // Clean up
  delete context[fnSymbol];
  
  return result;
};

// Test
console.log('\n=== myApply() Implementation ===');

function introduce(greeting, hobby, age) {
  return `${greeting}, I'm ${this.name}. I like ${hobby} and I'm ${age} years old.`;
}

const user = { name: 'Charlie' };

console.log(introduce.myApply(user, ['Hi', 'coding', 25]));
// "Hi, I'm Charlie. I like coding and I'm 25 years old."

// Compare with native
console.log(introduce.apply(user, ['Hi', 'coding', 25]));

// With Math.max example
const numbers = [5, 6, 2, 3, 7];
console.log('Max with myApply:', Math.max.myApply(null, numbers)); // 7
console.log('Max with apply:', Math.max.apply(null, numbers)); // 7
```

### **Approach 3: Implement bind()**
```javascript
/**
 * Implement Function.prototype.bind()
 * Returns new function with bound context
 */
Function.prototype.myBind = function(context, ...boundArgs) {
  const originalFunction = this;
  
  // Return new function
  return function(...args) {
    // Combine bound args with new args
    return originalFunction.myApply(context, [...boundArgs, ...args]);
  };
};

// Test
console.log('\n=== myBind() Implementation ===');

function multiply(a, b) {
  return `${this.name}: ${a} × ${b} = ${a * b}`;
}

const calculator = { name: 'Calculator' };

const boundMultiply = multiply.myBind(calculator);
console.log(boundMultiply(5, 3)); // "Calculator: 5 × 3 = 15"

const boundMultiplyWith10 = multiply.myBind(calculator, 10);
console.log(boundMultiplyWith10(5)); // "Calculator: 10 × 5 = 50"

// Compare with native
const nativeBound = multiply.bind(calculator, 10);
console.log(nativeBound(5)); // "Calculator: 10 × 5 = 50"
```

### **Approach 4: Handle Constructor Functions with bind()**
```javascript
/**
 * Enhanced bind that handles constructor invocation
 */
Function.prototype.myBindAdvanced = function(context, ...boundArgs) {
  const originalFunction = this;
  
  const boundFunction = function(...args) {
    // Check if called with 'new'
    if (this instanceof boundFunction) {
      // Called as constructor
      return new originalFunction(...boundArgs, ...args);
    } else {
      // Called as regular function
      return originalFunction.apply(context, [...boundArgs, ...args]);
    }
  };
  
  // Maintain prototype chain
  if (originalFunction.prototype) {
    boundFunction.prototype = Object.create(originalFunction.prototype);
  }
  
  return boundFunction;
};

// Test
console.log('\n=== Advanced bind() with Constructor ===');

function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  return `Hi, I'm ${this.name} and I'm ${this.age}`;
};

const BoundPerson = Person.myBindAdvanced(null, 'Alice');

// Used as constructor
const alice = new BoundPerson(30);
console.log(alice.name); // "Alice"
console.log(alice.age); // 30
console.log(alice.greet()); // "Hi, I'm Alice and I'm 30"
console.log(alice instanceof Person); // true

// Regular function
function regularFunc() {
  return this.value;
}

const obj = { value: 42 };
const bound = regularFunc.myBindAdvanced(obj);
console.log(bound()); // 42
```

### **Approach 5: Complete Implementation with Edge Cases**
```javascript
/**
 * Production-ready implementations
 */

// Complete call implementation
Function.prototype.myCallComplete = function(context, ...args) {
  // Check if called on a function
  if (typeof this !== 'function') {
    throw new TypeError('Function.prototype.call called on non-function');
  }
  
  // Handle primitive contexts
  if (context === null || context === undefined) {
    context = globalThis;
  } else {
    context = Object(context); // Convert primitives to objects
  }
  
  const fnSymbol = Symbol('fn');
  context[fnSymbol] = this;
  
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  
  return result;
};

// Complete apply implementation
Function.prototype.myApplyComplete = function(context, argsArray) {
  if (typeof this !== 'function') {
    throw new TypeError('Function.prototype.apply called on non-function');
  }
  
  if (context === null || context === undefined) {
    context = globalThis;
  } else {
    context = Object(context);
  }
  
  // Validate argsArray
  if (argsArray !== null && argsArray !== undefined) {
    if (typeof argsArray !== 'object') {
      throw new TypeError('Second argument must be an array or array-like object');
    }
  }
  
  const fnSymbol = Symbol('fn');
  context[fnSymbol] = this;
  
  const result = argsArray
    ? context[fnSymbol](...Array.from(argsArray))
    : context[fnSymbol]();
  
  delete context[fnSymbol];
  
  return result;
};

// Complete bind implementation
Function.prototype.myBindComplete = function(context, ...boundArgs) {
  if (typeof this !== 'function') {
    throw new TypeError('Function.prototype.bind called on non-function');
  }
  
  const originalFunction = this;
  
  const boundFunction = function(...args) {
    const isConstructor = this instanceof boundFunction;
    
    return originalFunction.myApplyComplete(
      isConstructor ? this : context,
      [...boundArgs, ...args]
    );
  };
  
  // Preserve prototype
  if (originalFunction.prototype) {
    boundFunction.prototype = Object.create(originalFunction.prototype);
  }
  
  // Set length property
  Object.defineProperty(boundFunction, 'length', {
    value: Math.max(0, originalFunction.length - boundArgs.length),
    configurable: true
  });
  
  // Set name property
  Object.defineProperty(boundFunction, 'name', {
    value: 'bound ' + (originalFunction.name || 'anonymous'),
    configurable: true
  });
  
  return boundFunction;
};

// Test
console.log('\n=== Complete Implementations ===');

function testFunc(a, b, c) {
  return { name: this.name, args: [a, b, c] };
}

const context = { name: 'TestContext' };

// Test call
console.log('myCallComplete:', testFunc.myCallComplete(context, 1, 2, 3));

// Test apply
console.log('myApplyComplete:', testFunc.myApplyComplete(context, [4, 5, 6]));

// Test bind
const boundFunc = testFunc.myBindComplete(context, 7);
console.log('myBindComplete:', boundFunc(8, 9));
console.log('Bound name:', boundFunc.name); // "bound testFunc"
console.log('Bound length:', boundFunc.length); // 2 (3 - 1 bound arg)
```

### **Bonus: Soft Bind**
```javascript
/**
 * Soft bind: allows overriding context with explicit call/apply
 */
Function.prototype.softBind = function(context, ...boundArgs) {
  const originalFunction = this;
  
  return function(...args) {
    // Use 'this' if it's defined and not global, otherwise use bound context
    const effectiveContext = (!this || this === globalThis) ? context : this;
    
    return originalFunction.apply(effectiveContext, [...boundArgs, ...args]);
  };
};

// Test
console.log('\n=== Soft Bind ===');

function showName() {
  return this.name;
}

const obj1 = { name: 'Object 1' };
const obj2 = { name: 'Object 2' };

// Hard bind (normal bind)
const hardBound = showName.myBind(obj1);
console.log('Hard bound:', hardBound()); // "Object 1"
console.log('Hard bound with call:', hardBound.call(obj2)); // Still "Object 1"

// Soft bind
const softBound = showName.softBind(obj1);
console.log('Soft bound:', softBound()); // "Object 1"
console.log('Soft bound with call:', softBound.call(obj2)); // "Object 2" (overridden!)
```

### **Bonus: Partial Application**
```javascript
/**
 * Partial application using bind
 */
function partial(fn, ...presetArgs) {
  return fn.myBind(null, ...presetArgs);
}

// Test
console.log('\n=== Partial Application ===');

function volume(length, width, height) {
  return length * width * height;
}

const volumeWith5 = partial(volume, 5);
console.log('Volume with 5:', volumeWith5(10, 2)); // 100

const volumeWith5And10 = partial(volume, 5, 10);
console.log('Volume with 5 and 10:', volumeWith5And10(2)); // 100

// Practical example: logging
function log(level, timestamp, message) {
  return `[${level}] ${timestamp}: ${message}`;
}

const errorLog = partial(log, 'ERROR');
console.log(errorLog('2024-01-01', 'System failure'));

const errorLogWithTime = partial(log, 'ERROR', '2024-01-01');
console.log(errorLogWithTime('Database connection lost'));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Event handlers with context
class Button {
  constructor(label) {
    this.label = label;
    this.clicks = 0;
  }
  
  handleClick() {
    this.clicks++;
    console.log(`${this.label} clicked ${this.clicks} times`);
  }
  
  attachTo(element) {
    // Without bind, 'this' would be the element
    element.addEventListener('click', this.handleClick.myBind(this));
  }
}

console.log('\n=== Event Handler Example ===');
const button = new Button('Submit');
const mockElement = {
  addEventListener(event, handler) {
    console.log('Attached handler for:', event);
    handler(); // Simulate click
  }
};
button.attachTo(mockElement);

// 2. Borrowing methods
const person1 = {
  name: 'Alice',
  greet() {
    return `Hello, I'm ${this.name}`;
  }
};

const person2 = { name: 'Bob' };

console.log('\n=== Borrowing Methods ===');
console.log('Borrowed with call:', person1.greet.myCall(person2)); // "Hello, I'm Bob"

// Borrowing array methods
const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
const array = Array.prototype.slice.myCall(arrayLike);
console.log('Array-like to array:', array); // ['a', 'b', 'c']

// 3. Function currying with bind
function add(a, b) {
  return a + b;
}

console.log('\n=== Currying with Bind ===');
const add5 = add.myBind(null, 5);
console.log('add5(3):', add5(3)); // 8
console.log('add5(10):', add5(10)); // 15

// 4. Debounce with context preservation
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.myApply(this, args);
    }, delay);
  };
}

console.log('\n=== Debounce Example ===');
const obj3 = {
  value: 0,
  increment() {
    this.value++;
    console.log('Value:', this.value);
  }
};

const debouncedIncrement = debounce(obj3.increment, 100);
debouncedIncrement.myCall(obj3);
setTimeout(() => debouncedIncrement.myCall(obj3), 50);
setTimeout(() => debouncedIncrement.myCall(obj3), 150); // Only this fires

// 5. Method chaining
class Calculator {
  constructor(value = 0) {
    this.value = value;
  }
  
  add(n) {
    this.value += n;
    return this;
  }
  
  multiply(n) {
    this.value *= n;
    return this;
  }
  
  getResult() {
    return this.value;
  }
}

console.log('\n=== Method Chaining ===');
const calc = new Calculator(5);
const result = calc.add(10).multiply(2).getResult();
console.log('Result:', result); // 30

// Using bind to create pre-configured calculators
const addTen = calc.add.myBind(calc, 10);
addTen();
console.log('After addTen:', calc.value); // 40
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Primitive context
function showThis() {
  return this;
}

console.log('With number:', typeof showThis.myCall(5)); // "object" (Number wrapper)
console.log('With string:', typeof showThis.myCall('hello')); // "object" (String wrapper)
console.log('With boolean:', typeof showThis.myCall(true)); // "object" (Boolean wrapper)

// null/undefined context
function getGlobal() {
  return this === globalThis;
}

console.log('null context:', getGlobal.myCall(null)); // true
console.log('undefined context:', getGlobal.myCall(undefined)); // true

// No arguments
function noArgs() {
  return 'no arguments';
}

console.log('myCall no args:', noArgs.myCall({})); // "no arguments"
console.log('myApply no args:', noArgs.myApply({})); // "no arguments"

// Empty array
function withArgs(...args) {
  return args.length;
}

console.log('myApply empty array:', withArgs.myApply({}, [])); // 0

// Return value
function returnValue(x) {
  return x * 2;
}

console.log('myCall return:', returnValue.myCall(null, 21)); // 42
console.log('myApply return:', returnValue.myApply(null, [21])); // 42

const boundReturn = returnValue.myBind(null, 21);
console.log('myBind return:', boundReturn()); // 42

// Arrow functions (don't have own 'this')
const arrowFunc = () => this;
const boundArrow = arrowFunc.myBind({ name: 'test' });
// Arrow functions ignore bind's context

// Binding already bound function
function original() {
  return this.value;
}

const bound1 = original.myBind({ value: 1 });
const bound2 = bound1.myBind({ value: 2 });
console.log('Double bind:', bound2()); // 1 (first bind wins)
```

### **Performance Comparison**
```javascript
/**
 * Benchmark implementations
 */
console.log('\n=== Performance Comparison ===');

function testFunc2(a, b) {
  return this.x + a + b;
}

const ctx = { x: 10 };
const iterations = 100000;

// Native call
console.time('Native call');
for (let i = 0; i < iterations; i++) {
  testFunc2.call(ctx, 5, 3);
}
console.timeEnd('Native call');

// Custom call
console.time('Custom call');
for (let i = 0; i < iterations; i++) {
  testFunc2.myCall(ctx, 5, 3);
}
console.timeEnd('Custom call');

// Native bind
console.time('Native bind');
const nativeBound2 = testFunc2.bind(ctx);
for (let i = 0; i < iterations; i++) {
  nativeBound2(5, 3);
}
console.timeEnd('Native bind');

// Custom bind
console.time('Custom bind');
const customBound2 = testFunc2.myBind(ctx);
for (let i = 0; i < iterations; i++) {
  customBound2(5, 3);
}
console.timeEnd('Custom bind');

console.log('\nNote: Native implementations are optimized at engine level');
```

### **Comparison Table**
```javascript
console.log('\n=== call vs apply vs bind ===');
console.log(`
┌──────────┬────────────────────┬──────────────┬────────────────┐
│ Method   │ Arguments          │ Returns      │ Invokes Now    │
├──────────┼────────────────────┼──────────────┼────────────────┤
│ call     │ Individual args    │ Result       │ Yes            │
│ apply    │ Array of args      │ Result       │ Yes            │
│ bind     │ Individual args    │ New function │ No (later)     │
└──────────┴────────────────────┴──────────────┴────────────────┘

Usage:
  func.call(context, arg1, arg2, arg3)
  func.apply(context, [arg1, arg2, arg3])
  func.bind(context, arg1, arg2) // returns function
`);

// Examples of when to use each
function example(a, b, c) {
  return `${this.name}: ${a}, ${b}, ${c}`;
}

const ctx2 = { name: 'Example' };

console.log('call:', example.call(ctx2, 1, 2, 3));
console.log('apply:', example.apply(ctx2, [1, 2, 3]));

const bound3 = example.bind(ctx2, 1);
console.log('bind:', bound3(2, 3));
```

**Interview Tips:**
- call: invoke function with specific 'this' and individual arguments
- apply: same as call but takes arguments as array
- bind: returns new function with bound context (doesn't invoke immediately)
- Implementation strategy: assign function to context as temporary property
- Use Symbol to avoid property name collision
- Clean up temporary property after execution
- Handle null/undefined context (becomes globalThis)
- Convert primitive contexts to objects (Object(context))
- bind must handle constructor invocation with 'new'
- Preserve prototype chain for bound constructors
- bind can do partial application (preset arguments)
- Difference: call/apply invoke immediately, bind returns function
- Use call when you know arguments count
- Use apply with array/array-like or unknown argument count (e.g., Math.max)
- Use bind for event handlers, callbacks to preserve 'this'
- Soft bind: allows re-binding context later
- Edge cases: primitives, null, undefined, no args, arrow functions
- Arrow functions ignore bind/call/apply context
- Double binding: first bind wins, can't re-bind
- Applications: borrowing methods, event handlers, currying, debounce
- Clarify: handle constructors? preserve prototype? partial application?
- Follow-ups: implement softBind, add validation, optimize performance

</details>

91. Create a memoization function for recursive functions

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Memoization**
```javascript
/**
 * Simple memoization for any function
 * Time Complexity: O(1) for cache hit, O(f(n)) for cache miss
 * Space Complexity: O(n) where n is number of unique inputs
 */
function memoize(fn) {
  const cache = {};
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (key in cache) {
      console.log('Cache hit:', key);
      return cache[key];
    }
    
    console.log('Cache miss, computing:', key);
    const result = fn.apply(this, args);
    cache[key] = result;
    
    return result;
  };
}

// Test
console.log('=== Basic Memoization ===');

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log('fib(10):', memoizedFib(10)); // Cache miss
console.log('fib(10) again:', memoizedFib(10)); // Cache hit

// Problem: recursive calls inside aren't memoized!
console.log('\nNote: Internal recursive calls not cached');
```

### **Approach 2: Memoization for Recursive Functions**
```javascript
/**
 * Proper memoization that caches recursive calls
 */
function memoizeRecursive(fn) {
  const cache = {};
  
  const memoized = function(...args) {
    const key = JSON.stringify(args);
    
    if (key in cache) {
      return cache[key];
    }
    
    // Pass memoized version to function so recursive calls are cached
    const result = fn.call(this, memoized, ...args);
    cache[key] = result;
    
    return result;
  };
  
  return memoized;
}

// Test
console.log('\n=== Recursive Memoization ===');

// Function must accept itself as first parameter
const fibRecursive = memoizeRecursive((fib, n) => {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2); // Use passed memoized version
});

console.time('fib(40) first call');
console.log('fib(40):', fibRecursive(40));
console.timeEnd('fib(40) first call');

console.time('fib(40) second call');
console.log('fib(40) again:', fibRecursive(40));
console.timeEnd('fib(40) second call');

console.time('fib(50)');
console.log('fib(50):', fibRecursive(50)); // Uses cached fib(40), fib(39), etc.
console.timeEnd('fib(50)');
```

### **Approach 3: Auto-Memoizing Recursive Functions**
```javascript
/**
 * Automatically memoize recursive function without modifying it
 */
function memoizeAuto(fn) {
  const cache = new Map();
  
  const memoized = function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    // Temporarily replace original function in scope
    const originalFn = fn;
    const context = this;
    
    // Replace function with memoized version during execution
    const result = fn.apply(context, args);
    
    cache.set(key, result);
    return result;
  };
  
  return memoized;
}

// Better approach: Y Combinator style
function memoizeY(fn) {
  const cache = new Map();
  
  return function memoized(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    // Create wrapper that replaces function name with memoized version
    const wrapper = fn.bind(this, memoized);
    const result = wrapper(...args);
    
    cache.set(key, result);
    return result;
  };
}

// Test
console.log('\n=== Auto-Memoizing ===');

const factorial = memoizeY((fact, n) => {
  if (n <= 1) return 1;
  return n * fact(n - 1);
});

console.log('factorial(10):', factorial(10)); // 3628800
console.log('factorial(5):', factorial(5)); // Uses cached values
console.log('factorial(15):', factorial(15)); // Uses cached 10!
```

### **Approach 4: With Cache Management**
```javascript
/**
 * Memoization with cache size limit and statistics
 */
function memoizeAdvanced(fn, options = {}) {
  const { maxSize = 100, ttl = Infinity } = options;
  const cache = new Map();
  let hits = 0;
  let misses = 0;
  
  const memoized = function(...args) {
    const key = JSON.stringify(args);
    
    // Check cache
    if (cache.has(key)) {
      const entry = cache.get(key);
      
      // Check TTL
      if (Date.now() - entry.timestamp < ttl) {
        hits++;
        
        // Move to end (LRU)
        cache.delete(key);
        cache.set(key, entry);
        
        return entry.value;
      } else {
        cache.delete(key);
      }
    }
    
    misses++;
    
    // Compute result
    const result = fn.call(this, memoized, ...args);
    
    // Evict oldest if at capacity (LRU)
    if (cache.size >= maxSize) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    // Store with timestamp
    cache.set(key, {
      value: result,
      timestamp: Date.now()
    });
    
    return result;
  };
  
  // Add utility methods
  memoized.clear = () => cache.clear();
  memoized.delete = (...args) => cache.delete(JSON.stringify(args));
  memoized.stats = () => ({
    hits,
    misses,
    hitRate: hits / (hits + misses) || 0,
    size: cache.size
  });
  
  return memoized;
}

// Test
console.log('\n=== Advanced Memoization ===');

const expensiveFib = memoizeAdvanced(
  (fib, n) => {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
  },
  { maxSize: 50, ttl: 5000 }
);

expensiveFib(20);
expensiveFib(25);
expensiveFib(20); // Hit

console.log('Stats:', expensiveFib.stats());
// { hits: ..., misses: ..., hitRate: ..., size: ... }
```

### **Approach 5: Multi-Argument Hash Function**
```javascript
/**
 * Custom hash function for complex arguments
 */
function memoizeWithHash(fn, hashFn) {
  const cache = new Map();
  
  const memoized = function(...args) {
    const key = hashFn ? hashFn(...args) : JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn.call(this, memoized, ...args);
    cache.set(key, result);
    
    return result;
  };
  
  return memoized;
}

// Test
console.log('\n=== Custom Hash Function ===');

// For objects, use specific property
function expensiveCompute(obj, n) {
  // Some expensive operation
  return obj.id * n;
}

const memoizedCompute = memoizeWithHash(
  (fn, obj, n) => fn.call(this, obj, n),
  (obj, n) => `${obj.id}-${n}` // Hash by id only
);

const obj1 = { id: 1, data: 'large data' };
const obj2 = { id: 1, data: 'different data' };

console.log(memoizedCompute(obj1, 10)); // Cache miss
console.log(memoizedCompute(obj2, 10)); // Cache hit! (same id)

// Custom hash for arrays
const sumMemoized = memoizeWithHash(
  (fn, arr) => arr.reduce((a, b) => a + b, 0),
  (arr) => arr.join(',')
);

console.log(sumMemoized([1, 2, 3])); // Cache miss
console.log(sumMemoized([1, 2, 3])); // Cache hit
```

### **Bonus: Memoize Multiple Functions Together**
```javascript
/**
 * Shared cache across multiple functions
 */
function createMemoCache() {
  const cache = new Map();
  
  return function memoize(fn) {
    return function(...args) {
      const key = fn.name + JSON.stringify(args);
      
      if (cache.has(key)) {
        return cache.get(key);
      }
      
      const result = fn(...args);
      cache.set(key, result);
      
      return result;
    };
  };
}

// Test
console.log('\n=== Shared Cache ===');

const sharedMemoize = createMemoCache();

function double(n) {
  return n * 2;
}

function triple(n) {
  return n * 3;
}

const memoDouble = sharedMemoize(double);
const memoTriple = sharedMemoize(triple);

memoDouble(5);
memoTriple(5);

console.log('Both functions share same cache');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Dynamic Programming - Longest Common Subsequence
const lcs = memoizeRecursive((lcs, s1, s2, i = s1.length - 1, j = s2.length - 1) => {
  if (i < 0 || j < 0) return 0;
  
  if (s1[i] === s2[i]) {
    return 1 + lcs(s1, s2, i - 1, j - 1);
  }
  
  return Math.max(
    lcs(s1, s2, i - 1, j),
    lcs(s1, s2, i, j - 1)
  );
});

console.log('\n=== LCS Example ===');
console.log('LCS("ABCDGH", "AEDFHR"):', lcs('ABCDGH', 'AEDFHR')); // 3 (ADH)

// 2. Path finding - Count paths in grid
const countPaths = memoizeRecursive((count, m, n) => {
  if (m === 1 || n === 1) return 1;
  return count(m - 1, n) + count(m, n - 1);
});

console.log('\n=== Grid Paths ===');
console.log('Paths in 3x3 grid:', countPaths(3, 3)); // 6

// 3. Coin change problem
const coinChange = memoizeRecursive((change, coins, amount) => {
  if (amount === 0) return 1;
  if (amount < 0 || coins.length === 0) return 0;
  
  return change(coins, amount - coins[0]) + 
         change(coins.slice(1), amount);
});

console.log('\n=== Coin Change ===');
console.log('Ways to make 5:', coinChange([1, 2, 5], 5)); // 4 ways

// 4. API request caching
function createApiCache(ttl = 60000) {
  return memoizeAdvanced(
    async (fn, endpoint) => {
      const response = await fetch(endpoint);
      return response.json();
    },
    { ttl }
  );
}

console.log('\n=== API Caching ===');
console.log('API requests cached for', 60, 'seconds');

// 5. Expensive calculations
const calculatePrimes = memoizeRecursive((calc, n) => {
  if (n < 2) return [];
  
  const primes = [];
  for (let i = 2; i <= n; i++) {
    let isPrime = true;
    for (let j = 2; j * j <= i; j++) {
      if (i % j === 0) {
        isPrime = false;
        break;
      }
    }
    if (isPrime) primes.push(i);
  }
  
  return primes;
});

console.log('\n=== Prime Calculation ===');
console.time('Primes up to 1000');
console.log('Count:', calculatePrimes(1000).length);
console.timeEnd('Primes up to 1000');

console.time('Primes up to 1000 (cached)');
console.log('Count:', calculatePrimes(1000).length);
console.timeEnd('Primes up to 1000 (cached)');
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// No arguments
const noArgs = memoize(() => Math.random());
console.log('No args 1:', noArgs()); // Random
console.log('No args 2:', noArgs()); // Same (cached)

// Different argument types
const typeTest = memoize((a, b) => `${a}-${b}`);
console.log(typeTest(1, 2)); // "1-2"
console.log(typeTest('1', '2')); // Different key, new computation
console.log(typeTest(1, 2)); // Cached

// Object arguments
const objMemo = memoize((obj) => obj.value * 2);
console.log(objMemo({ value: 5 })); // 10
console.log(objMemo({ value: 5 })); // Cached (same JSON)

// undefined vs null
const nullTest = memoize((x) => x);
console.log(nullTest(null)); // null
console.log(nullTest(undefined)); // undefined (different key)

// Array order matters
const arrayMemo = memoize((arr) => arr.reduce((a, b) => a + b, 0));
console.log(arrayMemo([1, 2, 3])); // 6
console.log(arrayMemo([3, 2, 1])); // Not cached (different order)
```

### **Performance Comparison**
```javascript
/**
 * Benchmark memoization impact
 */
console.log('\n=== Performance Impact ===');

function slowFib(n) {
  if (n <= 1) return n;
  return slowFib(n - 1) + slowFib(n - 2);
}

const fastFib = memoizeRecursive((fib, n) => {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
});

console.time('Without memoization fib(35)');
slowFib(35);
console.timeEnd('Without memoization fib(35)');

console.time('With memoization fib(35)');
fastFib(35);
console.timeEnd('With memoization fib(35)');

console.time('With memoization fib(100)');
fastFib(100);
console.timeEnd('With memoization fib(100)');

console.log('\nMemoization reduces O(2^n) to O(n) for recursive functions!');
```

**Interview Tips:**
- Memoization: cache function results to avoid recomputation
- Key challenge: recursive calls inside function must also be cached
- Solution: pass memoized version as argument to function
- Function signature: (memoizedSelf, ...originalArgs)
- Cache key: JSON.stringify for simple types, custom hash for complex
- Map better than object for non-string keys
- Handle cache size: implement LRU eviction
- TTL for time-sensitive data (API responses)
- Clear/delete methods for cache management
- Statistics: track hits/misses for optimization
- Transforms O(2^n) to O(n) for recursive algorithms
- Perfect for: DP problems, Fibonacci, path finding, expensive calculations
- Not suitable for: side effects, I/O operations, time-sensitive functions
- JSON.stringify limitations: order matters, circular refs fail
- Custom hash for objects: use specific properties (id)
- Trade-off: memory for speed
- Applications: DP, API caching, expensive math, recursive algorithms
- Edge cases: no args, different types, objects, arrays, null/undefined
- Clarify: cache size? TTL? LRU? stats? custom hash?
- Follow-ups: implement weak memoization, add cache warming, serialize to disk

</details>

92. Implement a function to convert callback-based functions to promises (promisify)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Promisify**
```javascript
/**
 * Convert callback-based function to promise-based
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 * 
 * Assumes callback follows Node.js convention: (err, result)
 */
function promisify(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };
}

// Test
console.log('=== Basic Promisify ===');

// Simulate Node.js-style callback function
function readFile(filename, callback) {
  setTimeout(() => {
    if (filename === 'error.txt') {
      callback(new Error('File not found'), null);
    } else {
      callback(null, `Contents of ${filename}`);
    }
  }, 100);
}

const readFilePromise = promisify(readFile);

(async () => {
  try {
    const content = await readFilePromise('test.txt');
    console.log('Success:', content); // "Contents of test.txt"
  } catch (error) {
    console.error('Error:', error.message);
  }
  
  try {
    await readFilePromise('error.txt');
  } catch (error) {
    console.error('Expected error:', error.message); // "File not found"
  }
})();
```

### **Approach 2: Promisify with Context Binding**
```javascript
/**
 * Promisify that preserves 'this' context
 */
function promisifyWithContext(fn, context) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn.call(context, ...args, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };
}

// Test
console.log('\n=== Promisify with Context ===');

const db = {
  name: 'MyDatabase',
  query(sql, callback) {
    console.log(`${this.name} executing: ${sql}`);
    setTimeout(() => {
      callback(null, { rows: [{ id: 1, name: 'Alice' }] });
    }, 100);
  }
};

const queryPromise = promisifyWithContext(db.query, db);

(async () => {
  const result = await queryPromise('SELECT * FROM users');
  console.log('Query result:', result);
})();
```

### **Approach 3: Promisify with Multiple Results**
```javascript
/**
 * Handle callbacks with multiple success values
 */
function promisifyMulti(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (err, ...results) => {
        if (err) {
          reject(err);
        } else {
          // If multiple results, return as array
          resolve(results.length <= 1 ? results[0] : results);
        }
      });
    });
  };
}

// Test
console.log('\n=== Multiple Results ===');

function getCoordinates(address, callback) {
  setTimeout(() => {
    callback(null, 40.7128, -74.0060); // lat, lng
  }, 100);
}

const getCoordsPromise = promisifyMulti(getCoordinates);

(async () => {
  const coords = await getCoordsPromise('New York');
  console.log('Coordinates:', coords); // [40.7128, -74.0060]
})();
```

### **Approach 4: Promisify.all() for Entire Module**
```javascript
/**
 * Promisify all methods of an object
 */
function promisifyAll(obj, options = {}) {
  const { suffix = 'Async', exclude = [] } = options;
  const promisified = {};
  
  for (const key in obj) {
    if (typeof obj[key] === 'function' && !exclude.includes(key)) {
      // Create promisified version with suffix
      promisified[key + suffix] = promisify(obj[key].bind(obj));
      // Keep original
      promisified[key] = obj[key].bind(obj);
    } else {
      promisified[key] = obj[key];
    }
  }
  
  return promisified;
}

// Test
console.log('\n=== Promisify All ===');

const fs = {
  readFile(path, callback) {
    setTimeout(() => callback(null, `Content of ${path}`), 50);
  },
  writeFile(path, content, callback) {
    setTimeout(() => callback(null, `Written to ${path}`), 50);
  },
  deleteFile(path, callback) {
    setTimeout(() => callback(null, `Deleted ${path}`), 50);
  }
};

const fsPromise = promisifyAll(fs);

(async () => {
  const content = await fsPromise.readFileAsync('test.txt');
  console.log(content);
  
  const writeResult = await fsPromise.writeFileAsync('new.txt', 'data');
  console.log(writeResult);
  
  // Original callback version still available
  fsPromise.readFile('test.txt', (err, data) => {
    console.log('Callback version:', data);
  });
})();
```

### **Approach 5: Custom Callback Format**
```javascript
/**
 * Promisify with custom callback position and format
 */
function promisifyCustom(fn, options = {}) {
  const {
    callbackPosition = -1, // -1 means last argument
    errorFirst = true,
    multiArgs = false
  } = options;
  
  return function(...args) {
    return new Promise((resolve, reject) => {
      const callback = errorFirst
        ? (err, ...results) => {
            if (err) {
              reject(err);
            } else {
              resolve(multiArgs ? results : results[0]);
            }
          }
        : (...results) => {
            resolve(multiArgs ? results : results[0]);
          };
      
      if (callbackPosition === -1) {
        args.push(callback);
      } else {
        args.splice(callbackPosition, 0, callback);
      }
      
      fn(...args);
    });
  };
}

// Test
console.log('\n=== Custom Callback Format ===');

// Non-error-first callback
function setTimeout2(delay, callback) {
  setTimeout(() => callback('Done!'), delay);
}

const sleep = promisifyCustom(setTimeout2, { errorFirst: false });

(async () => {
  const result = await sleep(100);
  console.log('Sleep result:', result); // "Done!"
})();

// Callback in middle position
function processData(data, callback, options) {
  setTimeout(() => callback(null, `Processed: ${data}`), 50);
}

const processPromise = promisifyCustom(processData, { callbackPosition: 1 });

(async () => {
  const result = await processPromise('data', { timeout: 1000 });
  console.log('Process result:', result);
})();
```

### **Bonus: Promisify with Timeout**
```javascript
/**
 * Promisify with automatic timeout
 */
function promisifyWithTimeout(fn, defaultTimeout = 5000) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      let timeoutId;
      let completed = false;
      
      const callback = (err, result) => {
        if (completed) return;
        completed = true;
        clearTimeout(timeoutId);
        
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      };
      
      // Set timeout
      timeoutId = setTimeout(() => {
        if (!completed) {
          completed = true;
          reject(new Error('Operation timed out'));
        }
      }, defaultTimeout);
      
      fn(...args, callback);
    });
  };
}

// Test
console.log('\n=== Promisify with Timeout ===');

function slowOperation(data, callback) {
  setTimeout(() => {
    callback(null, `Result: ${data}`);
  }, 3000);
}

const slowPromise = promisifyWithTimeout(slowOperation, 1000);

(async () => {
  try {
    await slowPromise('test');
  } catch (error) {
    console.log('Timeout error:', error.message); // "Operation timed out"
  }
})();
```

### **Bonus: Reverse - Callbackify**
```javascript
/**
 * Convert promise-based function to callback-based
 */
function callbackify(fn) {
  return function(...args) {
    const callback = args.pop();
    
    if (typeof callback !== 'function') {
      throw new TypeError('Last argument must be a callback function');
    }
    
    fn(...args)
      .then(result => callback(null, result))
      .catch(err => callback(err));
  };
}

// Test
console.log('\n=== Callbackify (Reverse) ===');

async function fetchData(url) {
  await new Promise(resolve => setTimeout(resolve, 100));
  return `Data from ${url}`;
}

const fetchDataCallback = callbackify(fetchData);

fetchDataCallback('http://api.example.com', (err, data) => {
  if (err) {
    console.error('Error:', err);
  } else {
    console.log('Callback result:', data);
  }
});
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Node.js fs module
console.log('\n=== File System Example ===');

// Simulated fs functions
const fsModule = {
  readFile(path, encoding, callback) {
    setTimeout(() => {
      callback(null, `File content from ${path}`);
    }, 100);
  },
  
  writeFile(path, data, callback) {
    setTimeout(() => {
      callback(null);
    }, 100);
  },
  
  stat(path, callback) {
    setTimeout(() => {
      callback(null, { size: 1024, isFile: () => true });
    }, 100);
  }
};

const fs2 = promisifyAll(fsModule);

(async () => {
  const content = await fs2.readFileAsync('file.txt', 'utf8');
  console.log('Read:', content);
  
  await fs2.writeFileAsync('output.txt', content);
  console.log('Written successfully');
  
  const stats = await fs2.statAsync('file.txt');
  console.log('File size:', stats.size);
})();

// 2. Database queries
console.log('\n=== Database Example ===');

const database = {
  connect(config, callback) {
    setTimeout(() => callback(null, 'Connected'), 50);
  },
  
  query(sql, params, callback) {
    setTimeout(() => {
      callback(null, [{ id: 1 }, { id: 2 }]);
    }, 50);
  },
  
  close(callback) {
    setTimeout(() => callback(null), 50);
  }
};

const db2 = promisifyAll(database);

(async () => {
  await db2.connectAsync({ host: 'localhost' });
  console.log('Database connected');
  
  const results = await db2.queryAsync('SELECT * FROM users', []);
  console.log('Query results:', results);
  
  await db2.closeAsync();
  console.log('Database closed');
})();

// 3. HTTP requests
console.log('\n=== HTTP Request Example ===');

function httpGet(url, callback) {
  setTimeout(() => {
    if (url.includes('error')) {
      callback(new Error('HTTP 404'));
    } else {
      callback(null, { status: 200, body: 'Response data' });
    }
  }, 100);
}

const httpGetPromise = promisify(httpGet);

(async () => {
  try {
    const response = await httpGetPromise('http://api.example.com/users');
    console.log('HTTP response:', response);
  } catch (error) {
    console.error('HTTP error:', error.message);
  }
})();

// 4. setTimeout promisified (delay utility)
console.log('\n=== Delay Utility ===');

const delay = (ms) => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

(async () => {
  console.log('Waiting 500ms...');
  await delay(500);
  console.log('Done waiting!');
})();

// 5. Event-based to promise
console.log('\n=== Event to Promise ===');

function eventToPromise(emitter, successEvent, errorEvent) {
  return new Promise((resolve, reject) => {
    emitter.once(successEvent, resolve);
    if (errorEvent) {
      emitter.once(errorEvent, reject);
    }
  });
}

// Simulated event emitter
const emitter = {
  listeners: {},
  once(event, handler) {
    this.listeners[event] = handler;
  },
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event](data);
    }
  }
};

(async () => {
  setTimeout(() => emitter.emit('complete', 'Success!'), 200);
  
  const result = await eventToPromise(emitter, 'complete', 'error');
  console.log('Event result:', result);
})();
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// No arguments
function noArgsCallback(callback) {
  setTimeout(() => callback(null, 'result'), 50);
}

const noArgsPromise = promisify(noArgsCallback);

(async () => {
  const result = await noArgsPromise();
  console.log('No args:', result);
})();

// Multiple error types
function customError(callback) {
  setTimeout(() => {
    const error = new TypeError('Custom error');
    error.code = 'CUSTOM_ERROR';
    callback(error);
  }, 50);
}

const customErrorPromise = promisify(customError);

(async () => {
  try {
    await customErrorPromise();
  } catch (error) {
    console.log('Custom error type:', error.constructor.name); // TypeError
    console.log('Error code:', error.code); // CUSTOM_ERROR
  }
})();

// Sync callback (edge case)
function syncCallback(callback) {
  callback(null, 'immediate');
}

const syncPromise = promisify(syncCallback);

(async () => {
  const result = await syncPromise();
  console.log('Sync callback:', result);
})();

// Multiple calls
function counter(callback) {
  counter.count = (counter.count || 0) + 1;
  setTimeout(() => callback(null, counter.count), 50);
}

const counterPromise = promisify(counter);

(async () => {
  const [r1, r2, r3] = await Promise.all([
    counterPromise(),
    counterPromise(),
    counterPromise()
  ]);
  console.log('Multiple calls:', r1, r2, r3);
})();

// Callback called multiple times (error case)
function badCallback(callback) {
  setTimeout(() => callback(null, 'first'), 50);
  setTimeout(() => callback(null, 'second'), 100); // Bad! Called twice
}

const badPromise = promisify(badCallback);

(async () => {
  const result = await badPromise();
  console.log('Bad callback (only first resolves):', result); // "first"
})();
```

### **Advanced: Promisify with Cancelation**
```javascript
/**
 * Promisify with ability to cancel
 */
function promisifyCancelable(fn) {
  return function(...args) {
    let cancelled = false;
    
    const promise = new Promise((resolve, reject) => {
      fn(...args, (err, result) => {
        if (cancelled) return;
        
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
    
    promise.cancel = () => {
      cancelled = true;
    };
    
    return promise;
  };
}

// Test
console.log('\n=== Cancelable Promise ===');

function longOperation(data, callback) {
  const timeoutId = setTimeout(() => {
    callback(null, `Result: ${data}`);
  }, 2000);
  
  // Return cleanup function
  return () => clearTimeout(timeoutId);
}

const cancelableOp = promisifyCancelable(longOperation);

(async () => {
  const promise = cancelableOp('test');
  
  setTimeout(() => {
    console.log('Canceling operation...');
    promise.cancel();
  }, 500);
  
  try {
    const result = await promise;
    console.log('Result:', result);
  } catch (error) {
    console.log('Canceled or error');
  }
})();
```

### **Performance Considerations**
```javascript
/**
 * Compare callback vs promise performance
 */
console.log('\n=== Performance Comparison ===');

function callbackVersion(x, callback) {
  callback(null, x * 2);
}

const promiseVersion = promisify(callbackVersion);

// Callback benchmark
console.time('Callbacks (10000 calls)');
let callbackCount = 0;
for (let i = 0; i < 10000; i++) {
  callbackVersion(i, (err, result) => {
    callbackCount++;
  });
}
console.timeEnd('Callbacks (10000 calls)');

// Promise benchmark
console.time('Promises (10000 calls)');
(async () => {
  for (let i = 0; i < 10000; i++) {
    await promiseVersion(i);
  }
  console.timeEnd('Promises (10000 calls)');
  
  console.log('\nNote: Promises have overhead but provide better error handling and async/await syntax');
})();
```

### **Node.js util.promisify Comparison**
```javascript
/**
 * Compare with Node.js built-in
 */
console.log('\n=== Comparison with Node.js util.promisify ===');

// Our implementation
function customPromisify(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });
  };
}

// Features comparison
console.log(`
Feature Comparison:
┌─────────────────────────┬─────────────┬──────────────┐
│ Feature                 │ Custom      │ util.promisify│
├─────────────────────────┼─────────────┼──────────────┤
│ Basic promisify         │ ✓           │ ✓            │
│ Context preservation    │ Manual      │ Automatic    │
│ Custom symbols          │ ✗           │ ✓            │
│ Multiple results        │ Manual      │ ✗            │
│ Timeout                 │ Manual      │ ✗            │
│ Cancelation             │ Manual      │ ✗            │
└─────────────────────────┴─────────────┴──────────────┘

Usage:
  const util = require('util');
  const readFilePromise = util.promisify(fs.readFile);
  
  // With custom promisify symbol
  function customFn(callback) {
    // ...
  }
  customFn[util.promisify.custom] = () => {
    return Promise.resolve('custom behavior');
  };
`);
```

**Interview Tips:**
- Promisify: convert callback-based function to promise-based
- Node.js convention: callback is last parameter, format (err, result)
- Return new function that returns a Promise
- Callback invokes resolve(result) on success, reject(err) on error
- Preserve 'this' context: use Function.call or bind
- Handle multiple results: return array if callback has >1 success params
- promisifyAll: convert entire module/object at once
- Suffix convention: add 'Async' to promisified method names
- Custom formats: adjust for non-error-first or different callback positions
- Timeout: wrap with timeout to prevent hanging
- Callbackify: reverse operation (promise → callback)
- Edge cases: sync callbacks, no args, multiple calls, errors
- Cancelation: track state to ignore callback after cancel
- Performance: promises have overhead but better ergonomics
- util.promisify in Node.js: built-in with custom symbol support
- Applications: fs, database, HTTP, setTimeout, events
- Modern approach: prefer async/await over callbacks
- Error handling: promise rejections easier to catch than callback errors
- Clarify: error-first? context preservation? multiple results? timeout?
- Follow-ups: add util.promisify.custom symbol, implement throttling, add retry logic

</details>

93. Create a once() function that executes only once

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic once() Function**
```javascript
/**
 * Execute function only once, subsequent calls return cached result
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 */
function once(fn) {
  let called = false;
  let result;
  
  return function(...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    
    return result;
  };
}

// Test
console.log('=== Basic once() ===');

function expensiveOperation(x) {
  console.log('Computing...');
  return x * 2;
}

const compute = once(expensiveOperation);

console.log('First call:', compute(5)); // Computing... 10
console.log('Second call:', compute(10)); // 10 (uses cached result, ignores new arg)
console.log('Third call:', compute(15)); // 10 (still cached)
```

### **Approach 2: once() with Context Preservation**
```javascript
/**
 * Preserve 'this' context in once function
 */
function onceWithContext(fn) {
  let called = false;
  let result;
  
  return function(...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    
    return result;
  };
}

// Test
console.log('\n=== once() with Context ===');

const obj = {
  value: 10,
  multiply: onceWithContext(function(x) {
    console.log('Multiplying...');
    return this.value * x;
  })
};

console.log('First:', obj.multiply(3)); // Multiplying... 30
console.log('Second:', obj.multiply(5)); // 30 (cached)
```

### **Approach 3: once() that Returns Undefined After First Call**
```javascript
/**
 * Alternative: subsequent calls return undefined
 */
function onceUndefined(fn) {
  let called = false;
  
  return function(...args) {
    if (!called) {
      called = true;
      return fn.apply(this, args);
    }
    
    return undefined;
  };
}

// Test
console.log('\n=== once() Returns Undefined ===');

const greet = onceUndefined((name) => {
  console.log(`Hello, ${name}!`);
  return 'greeted';
});

console.log('First:', greet('Alice')); // Hello, Alice! "greeted"
console.log('Second:', greet('Bob')); // undefined
console.log('Third:', greet('Charlie')); // undefined
```

### **Approach 4: once() with Reset Capability**
```javascript
/**
 * once() with ability to reset
 */
function onceResettable(fn) {
  let called = false;
  let result;
  
  const wrapped = function(...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    
    return result;
  };
  
  wrapped.reset = function() {
    called = false;
    result = undefined;
  };
  
  wrapped.hasBeenCalled = function() {
    return called;
  };
  
  return wrapped;
}

// Test
console.log('\n=== Resettable once() ===');

const counter = onceResettable((start) => {
  console.log(`Starting from ${start}`);
  return start;
});

console.log('Call 1:', counter(1)); // Starting from 1, returns 1
console.log('Call 2:', counter(2)); // returns 1 (cached)
console.log('Has been called?', counter.hasBeenCalled()); // true

counter.reset();
console.log('After reset, has been called?', counter.hasBeenCalled()); // false

console.log('Call 3:', counter(10)); // Starting from 10, returns 10
console.log('Call 4:', counter(20)); // returns 10 (cached again)
```

### **Approach 5: once() for Async Functions**
```javascript
/**
 * once() for async functions with promise caching
 */
function onceAsync(fn) {
  let called = false;
  let promise;
  
  return function(...args) {
    if (!called) {
      called = true;
      promise = Promise.resolve(fn.apply(this, args));
    }
    
    return promise;
  };
}

// Test
console.log('\n=== Async once() ===');

const fetchData = onceAsync(async (url) => {
  console.log(`Fetching from ${url}...`);
  await new Promise(resolve => setTimeout(resolve, 500));
  return `Data from ${url}`;
});

(async () => {
  console.log('Request 1 started');
  const result1 = await fetchData('http://api.example.com');
  console.log('Result 1:', result1);
  
  console.log('Request 2 started');
  const result2 = await fetchData('http://different.com'); // Uses cached promise
  console.log('Result 2:', result2); // Same as result1
})();
```

### **Bonus: before() - Execute N Times**
```javascript
/**
 * Execute function up to N times
 */
function before(n, fn) {
  let count = 0;
  let lastResult;
  
  return function(...args) {
    if (count < n) {
      count++;
      lastResult = fn.apply(this, args);
    }
    
    return lastResult;
  };
}

// Test
console.log('\n=== before() - N Times ===');

const greet3Times = before(3, (name) => {
  console.log(`Hello, ${name}!`);
  return `Greeted ${name}`;
});

console.log('1:', greet3Times('Alice')); // Hello, Alice!
console.log('2:', greet3Times('Bob')); // Hello, Bob!
console.log('3:', greet3Times('Charlie')); // Hello, Charlie!
console.log('4:', greet3Times('David')); // (no output, returns last result)
```

### **Bonus: after() - Execute After N Calls**
```javascript
/**
 * Execute function only after N calls
 */
function after(n, fn) {
  let count = 0;
  
  return function(...args) {
    count++;
    
    if (count >= n) {
      return fn.apply(this, args);
    }
  };
}

// Test
console.log('\n=== after() - After N Calls ===');

const afterThreeCalls = after(3, () => {
  console.log('Finally executed after 3 calls!');
  return 'result';
});

console.log('Call 1:', afterThreeCalls()); // undefined
console.log('Call 2:', afterThreeCalls()); // undefined
console.log('Call 3:', afterThreeCalls()); // Finally executed! "result"
console.log('Call 4:', afterThreeCalls()); // Finally executed! "result"
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Initialize once
console.log('\n=== Initialization Example ===');

class Database {
  constructor() {
    this.connection = null;
    this.connect = once(this._connect.bind(this));
  }
  
  _connect() {
    console.log('Establishing database connection...');
    this.connection = { connected: true };
    return this.connection;
  }
  
  query(sql) {
    this.connect(); // Safe to call multiple times
    console.log(`Executing: ${sql}`);
    return 'query result';
  }
}

const db = new Database();
db.query('SELECT * FROM users'); // Establishes connection
db.query('SELECT * FROM posts'); // Uses existing connection

// 2. Event listener that fires once
console.log('\n=== Event Listener Once ===');

class EventEmitter {
  constructor() {
    this.listeners = {};
  }
  
  on(event, handler) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(handler);
  }
  
  once(event, handler) {
    const onceHandler = once((...args) => {
      handler(...args);
      this.off(event, onceHandler);
    });
    
    this.on(event, onceHandler);
  }
  
  off(event, handler) {
    if (this.listeners[event]) {
      this.listeners[event] = this.listeners[event].filter(h => h !== handler);
    }
  }
  
  emit(event, ...args) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(handler => handler(...args));
    }
  }
}

const emitter = new EventEmitter();

emitter.once('start', (data) => {
  console.log('Started once:', data);
});

emitter.emit('start', 'first'); // Started once: first
emitter.emit('start', 'second'); // (no output)

// 3. Lazy initialization
console.log('\n=== Lazy Initialization ===');

class Config {
  constructor() {
    this.getConfig = once(() => {
      console.log('Loading configuration...');
      return {
        apiKey: 'secret-key',
        endpoint: 'https://api.example.com'
      };
    });
  }
  
  get(key) {
    const config = this.getConfig();
    return config[key];
  }
}

const config = new Config();
console.log('API Key:', config.get('apiKey')); // Loads config
console.log('Endpoint:', config.get('endpoint')); // Uses cached config

// 4. Payment processing (prevent double submission)
console.log('\n=== Payment Processing ===');

class PaymentProcessor {
  processPayment(amount) {
    console.log(`Processing payment of $${amount}...`);
    return { success: true, transactionId: Math.random() };
  }
  
  createOneTimeProcessor(amount) {
    return once(() => this.processPayment(amount));
  }
}

const processor = new PaymentProcessor();
const payOnce = processor.createOneTimeProcessor(100);

console.log('Submit 1:', payOnce()); // Processes payment
console.log('Submit 2:', payOnce()); // Returns cached result (no double charge)

// 5. Resource cleanup
console.log('\n=== Resource Cleanup ===');

class Resource {
  constructor() {
    this.active = true;
    this.cleanup = once(() => {
      console.log('Cleaning up resources...');
      this.active = false;
      return 'cleaned';
    });
  }
  
  use() {
    if (this.active) {
      console.log('Using resource');
    }
  }
  
  close() {
    this.cleanup(); // Safe to call multiple times
  }
}

const resource = new Resource();
resource.use();
resource.close(); // Cleaning up resources...
resource.close(); // (no output, already cleaned)
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// No arguments
const noArgs = once(() => {
  console.log('No arguments');
  return 'result';
});

console.log(noArgs()); // No arguments, "result"
console.log(noArgs()); // "result" (cached)

// Returning undefined
const returnsUndefined = once(() => {
  console.log('Returns undefined');
  return undefined;
});

console.log('First:', returnsUndefined()); // Returns undefined, undefined
console.log('Second:', returnsUndefined()); // undefined (cached)

// Throwing error
const throwsError = once(() => {
  console.log('Throwing error...');
  throw new Error('Once error');
});

try {
  throwsError();
} catch (e) {
  console.log('Caught:', e.message);
}

try {
  throwsError(); // Still cached!
} catch (e) {
  console.log('Second call caught:', e.message);
}

// Different arguments ignored
const adder = once((a, b) => {
  console.log(`Adding ${a} + ${b}`);
  return a + b;
});

console.log('5 + 3 =', adder(5, 3)); // Adding 5 + 3, 8
console.log('10 + 20 =', adder(10, 20)); // 8 (cached, args ignored)

// With 'this' context
const obj2 = {
  value: 100,
  getValue: once(function() {
    console.log('Getting value...');
    return this.value;
  })
};

console.log('Value:', obj2.getValue()); // Getting value... 100
console.log('Value again:', obj2.getValue()); // 100 (cached)

// Async error handling
const asyncError = onceAsync(async () => {
  console.log('Async operation failing...');
  throw new Error('Async error');
});

(async () => {
  try {
    await asyncError();
  } catch (e) {
    console.log('Async error 1:', e.message);
  }
  
  try {
    await asyncError(); // Same promise, same error
  } catch (e) {
    console.log('Async error 2:', e.message);
  }
})();
```

### **Comparison with Lodash**
```javascript
/**
 * Compare with lodash.once
 */
console.log('\n=== Comparison ===');

console.log(`
Feature Comparison with lodash.once:
┌────────────────────────┬──────────┬─────────┐
│ Feature                │ Custom   │ Lodash  │
├────────────────────────┼──────────┼─────────┤
│ Execute once           │ ✓        │ ✓       │
│ Cache result           │ ✓        │ ✓       │
│ Context preservation   │ ✓        │ ✓       │
│ Reset capability       │ Manual   │ ✗       │
│ Check if called        │ Manual   │ ✗       │
│ Async support          │ Manual   │ ✗       │
└────────────────────────┴──────────┴─────────┘

Usage:
  import once from 'lodash/once';
  
  const initialize = once(() => {
    console.log('initialized');
  });
  
  initialize(); // 'initialized'
  initialize(); // (no output)
`);

// Implementation comparison
function customOnce(fn) {
  let called = false;
  let result;
  
  return function(...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    return result;
  };
}

// Lodash-like implementation
function lodashStyleOnce(fn) {
  let result;
  
  function onceWrapper(...args) {
    if (fn) {
      result = fn.apply(this, args);
      fn = null; // Clear reference
    }
    return result;
  }
  
  return onceWrapper;
}

const custom = customOnce(() => 'custom');
const lodashStyle = lodashStyleOnce(() => 'lodash');

console.log('Custom:', custom(), custom());
console.log('Lodash style:', lodashStyle(), lodashStyle());
```

### **Performance Considerations**
```javascript
/**
 * Benchmark once() overhead
 */
console.log('\n=== Performance ===');

function regularFunction() {
  return 42;
}

const oncedFunction = once(() => 42);

console.time('Regular (100000 calls)');
for (let i = 0; i < 100000; i++) {
  regularFunction();
}
console.timeEnd('Regular (100000 calls)');

console.time('Onced (100000 calls)');
for (let i = 0; i < 100000; i++) {
  oncedFunction();
}
console.timeEnd('Onced (100000 calls)');

console.log('\nNote: once() adds minimal overhead, mostly on first call');
```

**Interview Tips:**
- once(): execute function only on first call, subsequent calls return cached result
- Implementation: use closure with boolean flag and result variable
- Key insight: check flag, if false execute and cache, always return cached result
- Preserve 'this' context: use Function.apply(this, args)
- Arguments on subsequent calls are ignored (uses first call's result)
- Variants: return undefined after first, reset capability, async support
- before(n): execute up to n times, then return last result
- after(n): execute only after n calls
- Applications: initialization, event listeners, lazy loading, payment processing, cleanup
- Use cases: database connection, config loading, prevent double submission
- Edge cases: no args, undefined return, errors, different args, 'this' binding
- Error handling: cached errors will be re-thrown on subsequent calls
- Async: cache the promise, not the resolved value
- Lodash once(): similar but clears function reference after first call
- Memory: stores one result, minimal overhead
- Performance: minimal overhead after first call
- Similar to memoization but simpler (no argument-based keys)
- Clarify: cache result or undefined? reset capability? async? error handling?
- Follow-ups: implement before/after, add telemetry, make thread-safe

</details>

94. Implement a sleep/delay function using promises

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Sleep Function**
```javascript
/**
 * Simple sleep/delay using setTimeout and Promise
 * Time Complexity: O(1)
 * Space Complexity: O(1)
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Test
console.log('=== Basic Sleep ===');

(async () => {
  console.log('Start:', new Date().toLocaleTimeString());
  
  await sleep(1000); // Sleep for 1 second
  
  console.log('After 1s:', new Date().toLocaleTimeString());
  
  await sleep(500);
  
  console.log('After 1.5s:', new Date().toLocaleTimeString());
})();
```

### **Approach 2: Sleep with Return Value**
```javascript
/**
 * Sleep that returns a value after delay
 */
function sleepWithValue(ms, value) {
  return new Promise(resolve => setTimeout(() => resolve(value), ms));
}

// Test
console.log('\n=== Sleep with Value ===');

(async () => {
  const result = await sleepWithValue(500, 'Hello after 500ms');
  console.log('Result:', result);
  
  const data = await sleepWithValue(300, { status: 'ready', code: 200 });
  console.log('Data:', data);
})();
```

### **Approach 3: Cancelable Sleep**
```javascript
/**
 * Sleep that can be canceled
 */
function cancelableSleep(ms) {
  let timeoutId;
  let rejectFn;
  
  const promise = new Promise((resolve, reject) => {
    rejectFn = reject;
    timeoutId = setTimeout(resolve, ms);
  });
  
  promise.cancel = () => {
    clearTimeout(timeoutId);
    rejectFn(new Error('Sleep canceled'));
  };
  
  return promise;
}

// Test
console.log('\n=== Cancelable Sleep ===');

(async () => {
  const sleepPromise = cancelableSleep(2000);
  
  setTimeout(() => {
    console.log('Canceling sleep...');
    sleepPromise.cancel();
  }, 500);
  
  try {
    await sleepPromise;
    console.log('Sleep completed');
  } catch (error) {
    console.log('Caught:', error.message);
  }
})();
```

### **Approach 4: Sleep with Progress Callback**
```javascript
/**
 * Sleep with periodic progress updates
 */
function sleepWithProgress(ms, interval = 100, onProgress) {
  return new Promise((resolve) => {
    const startTime = Date.now();
    
    const progressInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min((elapsed / ms) * 100, 100);
      
      if (onProgress) {
        onProgress(progress, elapsed);
      }
      
      if (elapsed >= ms) {
        clearInterval(progressInterval);
        resolve();
      }
    }, interval);
  });
}

// Test
console.log('\n=== Sleep with Progress ===');

(async () => {
  console.log('Starting sleep with progress...');
  
  await sleepWithProgress(1000, 200, (progress, elapsed) => {
    console.log(`Progress: ${progress.toFixed(1)}% (${elapsed}ms)`);
  });
  
  console.log('Sleep complete!');
})();
```

### **Approach 5: Sleep with Timeout Racing**
```javascript
/**
 * Utility to race a promise against a timeout
 */
function withTimeout(promise, ms, timeoutError = 'Operation timed out') {
  const timeout = new Promise((_, reject) => 
    setTimeout(() => reject(new Error(timeoutError)), ms)
  );
  
  return Promise.race([promise, timeout]);
}

// Test
console.log('\n=== Timeout Racing ===');

async function longOperation() {
  await sleep(2000);
  return 'Operation complete';
}

(async () => {
  try {
    const result = await withTimeout(longOperation(), 1000);
    console.log('Result:', result);
  } catch (error) {
    console.log('Timeout:', error.message);
  }
})();
```

### **Bonus: Delay Decorator**
```javascript
/**
 * Decorator to add delay before function execution
 */
function delayed(ms) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args) {
      await sleep(ms);
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

// Functional version
function addDelay(fn, ms) {
  return async function(...args) {
    await sleep(ms);
    return fn.apply(this, args);
  };
}

// Test
console.log('\n=== Delayed Function ===');

function greet(name) {
  console.log(`Hello, ${name}!`);
  return `Greeted ${name}`;
}

const delayedGreet = addDelay(greet, 500);

(async () => {
  console.log('Calling delayed greet...');
  const result = await delayedGreet('Alice');
  console.log('Result:', result);
})();
```

### **Bonus: Retry with Exponential Backoff**
```javascript
/**
 * Retry operation with exponential backoff delays
 */
async function retryWithBackoff(fn, options = {}) {
  const {
    maxRetries = 3,
    initialDelay = 1000,
    maxDelay = 10000,
    factor = 2
  } = options;
  
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries) {
        const delay = Math.min(initialDelay * Math.pow(factor, attempt), maxDelay);
        console.log(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
        await sleep(delay);
      }
    }
  }
  
  throw lastError;
}

// Test
console.log('\n=== Retry with Backoff ===');

let attemptCount = 0;

async function unreliableOperation() {
  attemptCount++;
  console.log(`Attempt ${attemptCount}`);
  
  if (attemptCount < 3) {
    throw new Error('Operation failed');
  }
  
  return 'Success!';
}

(async () => {
  try {
    const result = await retryWithBackoff(unreliableOperation, {
      maxRetries: 3,
      initialDelay: 100,
      factor: 2
    });
    console.log('Final result:', result);
  } catch (error) {
    console.log('All retries failed:', error.message);
  }
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Rate limiting / Throttling
console.log('\n=== Rate Limiting ===');

async function rateLimitedFetch(urls, delayBetween = 1000) {
  const results = [];
  
  for (const url of urls) {
    console.log(`Fetching ${url}...`);
    // Simulated fetch
    results.push({ url, data: `Data from ${url}` });
    
    if (urls.indexOf(url) < urls.length - 1) {
      await sleep(delayBetween);
    }
  }
  
  return results;
}

(async () => {
  const urls = ['url1', 'url2', 'url3'];
  const results = await rateLimitedFetch(urls, 300);
  console.log('All fetched:', results.length);
})();

// 2. Polling with delay
console.log('\n=== Polling ===');

async function pollUntilReady(checkFn, options = {}) {
  const { interval = 1000, maxAttempts = 10 } = options;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    console.log(`Poll attempt ${attempt}...`);
    
    const result = await checkFn();
    
    if (result) {
      return result;
    }
    
    if (attempt < maxAttempts) {
      await sleep(interval);
    }
  }
  
  throw new Error('Polling timeout');
}

(async () => {
  let ready = false;
  setTimeout(() => { ready = true; }, 2000);
  
  try {
    const result = await pollUntilReady(
      () => ready ? 'Ready!' : false,
      { interval: 500, maxAttempts: 5 }
    );
    console.log('Poll result:', result);
  } catch (error) {
    console.log('Poll failed:', error.message);
  }
})();

// 3. Debounce with delay
console.log('\n=== Debounce ===');

function debounce(fn, delay) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    
    return new Promise((resolve) => {
      timeoutId = setTimeout(() => {
        resolve(fn.apply(this, args));
      }, delay);
    });
  };
}

const search = debounce((query) => {
  console.log(`Searching for: ${query}`);
  return `Results for ${query}`;
}, 500);

(async () => {
  search('a'); // Won't execute
  search('ab'); // Won't execute
  const result = await search('abc'); // Executes after 500ms
  console.log('Search result:', result);
})();

// 4. Animation frames
console.log('\n=== Animation ===');

async function animate(duration, onFrame) {
  const startTime = Date.now();
  const fps = 60;
  const frameDelay = 1000 / fps;
  
  while (Date.now() - startTime < duration) {
    const elapsed = Date.now() - startTime;
    const progress = elapsed / duration;
    
    onFrame(progress);
    
    await sleep(frameDelay);
  }
  
  onFrame(1); // Final frame
}

(async () => {
  console.log('Starting animation...');
  
  await animate(1000, (progress) => {
    const bar = '█'.repeat(Math.floor(progress * 20));
    console.log(`[${bar.padEnd(20, '░')}] ${(progress * 100).toFixed(0)}%`);
  });
  
  console.log('Animation complete!');
})();

// 5. Sequential execution with delays
console.log('\n=== Sequential Tasks ===');

async function executeSequentially(tasks, delayBetween = 500) {
  const results = [];
  
  for (const [index, task] of tasks.entries()) {
    console.log(`Executing task ${index + 1}...`);
    const result = await task();
    results.push(result);
    
    if (index < tasks.length - 1) {
      await sleep(delayBetween);
    }
  }
  
  return results;
}

(async () => {
  const tasks = [
    () => 'Task 1 done',
    () => 'Task 2 done',
    () => 'Task 3 done'
  ];
  
  const results = await executeSequentially(tasks, 200);
  console.log('All tasks:', results);
})();
```

### **Advanced Patterns**
```javascript
/**
 * Complex delay patterns
 */

// 1. Jittered delay (randomized for distributed systems)
function sleepWithJitter(ms, jitterPercent = 0.1) {
  const jitter = ms * jitterPercent * (Math.random() * 2 - 1);
  const actualDelay = Math.max(0, ms + jitter);
  return sleep(actualDelay);
}

console.log('\n=== Jittered Sleep ===');

(async () => {
  console.time('Jittered sleep');
  await sleepWithJitter(1000, 0.2); // 800-1200ms
  console.timeEnd('Jittered sleep');
})();

// 2. Minimum delay wrapper
function withMinDelay(fn, minDelay) {
  return async function(...args) {
    const start = Date.now();
    const result = await fn(...args);
    const elapsed = Date.now() - start;
    
    if (elapsed < minDelay) {
      await sleep(minDelay - elapsed);
    }
    
    return result;
  };
}

console.log('\n=== Minimum Delay ===');

const fastFunction = () => 'instant';
const slowFunction = withMinDelay(fastFunction, 500);

(async () => {
  console.time('With min delay');
  const result = await slowFunction();
  console.timeEnd('With min delay');
  console.log('Result:', result);
})();

// 3. Delay between operations
async function delayBetween(operations, delay) {
  const results = [];
  
  for (let i = 0; i < operations.length; i++) {
    results.push(await operations[i]());
    
    if (i < operations.length - 1) {
      await sleep(delay);
    }
  }
  
  return results;
}

// 4. Batch with delays
async function batchWithDelay(items, batchSize, processBatch, delayBetween = 1000) {
  const results = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    console.log(`Processing batch ${Math.floor(i / batchSize) + 1}...`);
    
    const batchResults = await processBatch(batch);
    results.push(...batchResults);
    
    if (i + batchSize < items.length) {
      await sleep(delayBetween);
    }
  }
  
  return results;
}

console.log('\n=== Batch Processing ===');

(async () => {
  const items = Array.from({ length: 10 }, (_, i) => i + 1);
  
  const results = await batchWithDelay(
    items,
    3,
    async (batch) => {
      console.log('  Batch:', batch);
      return batch.map(x => x * 2);
    },
    200
  );
  
  console.log('Final results:', results);
})();

// 5. Conditional delay
async function delayIf(condition, ms) {
  if (condition) {
    await sleep(ms);
  }
}

async function sleepUnless(condition, ms) {
  if (!condition) {
    await sleep(ms);
  }
}
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Zero delay
(async () => {
  console.log('Before zero delay');
  await sleep(0);
  console.log('After zero delay (still async)');
})();

// Negative delay (treated as 0)
(async () => {
  await sleep(-100);
  console.log('Negative delay handled');
})();

// Very long delay
(async () => {
  const longSleep = sleep(5000);
  console.log('Started long sleep');
  
  // Can cancel by not awaiting
  setTimeout(() => console.log('Meanwhile, doing other work'), 100);
})();

// Chaining delays
(async () => {
  console.log('Chaining delays...');
  
  await sleep(100)
    .then(() => console.log('After 100ms'))
    .then(() => sleep(100))
    .then(() => console.log('After 200ms'));
})();

// Promise.all with delays
(async () => {
  console.log('Parallel delays starting...');
  
  await Promise.all([
    sleep(100).then(() => console.log('Delay 1 done')),
    sleep(200).then(() => console.log('Delay 2 done')),
    sleep(150).then(() => console.log('Delay 3 done'))
  ]);
  
  console.log('All parallel delays done');
})();
```

### **Performance Considerations**
```javascript
/**
 * Memory and timing accuracy
 */
console.log('\n=== Performance Notes ===');

console.log(`
Performance Characteristics:
• setTimeout accuracy: ~4ms minimum in browsers (HTML5 spec)
• Node.js: ~1ms minimum
• Actual delay may be longer due to event loop
• Not suitable for precise timing
• Multiple timers share event loop queue
• Heavy computations block sleep resolution

Best Practices:
• Use sleep for delays, not precise timing
• Combine with requestAnimationFrame for animations
• Clear timers if operation is canceled
• Avoid creating too many concurrent timers
• Consider Worker threads for CPU-intensive work
`);

// Measuring accuracy
async function measureAccuracy(targetDelay, iterations = 5) {
  console.log(`\nMeasuring ${targetDelay}ms sleep accuracy:`);
  
  for (let i = 0; i < iterations; i++) {
    const start = Date.now();
    await sleep(targetDelay);
    const actual = Date.now() - start;
    const diff = actual - targetDelay;
    
    console.log(`  Iteration ${i + 1}: ${actual}ms (diff: +${diff}ms)`);
  }
}

setTimeout(() => measureAccuracy(100, 3), 3000);
```

### **Comparison with Alternatives**
```javascript
/**
 * Compare different delay methods
 */
console.log('\n=== Alternatives Comparison ===');

console.log(`
Method Comparison:
┌─────────────────────┬────────────┬──────────────┬────────────┐
│ Method              │ Async      │ Cancelable   │ Accuracy   │
├─────────────────────┼────────────┼──────────────┼────────────┤
│ Promise + setTimeout│ Yes        │ With wrapper │ ~4ms       │
│ async/await + sleep │ Yes        │ With wrapper │ ~4ms       │
│ setTimeout callback │ No         │ clearTimeout │ ~4ms       │
│ setInterval         │ No         │ clearInterval│ ~4ms       │
│ requestAnimationFrame│ Yes       │ cancelAnimationFrame│ 16ms│
│ process.nextTick    │ Yes (Node) │ No           │ Immediate  │
│ setImmediate        │ Yes (Node) │ clearImmediate│ Next tick│
└─────────────────────┴────────────┴──────────────┴────────────┘

Usage Guidelines:
• sleep(): General delays, rate limiting
• requestAnimationFrame(): Smooth animations
• setImmediate/nextTick: Non-blocking I/O (Node.js)
• setTimeout: Callbacks, legacy code
• setInterval: Repeated tasks (prefer recursive setTimeout)
`);
```

### **Utility Functions**
```javascript
/**
 * Collection of delay utilities
 */

// Create sleep instance with methods
const Sleep = {
  // Basic sleep
  delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
  
  // Sleep with value
  value: (ms, val) => new Promise(resolve => setTimeout(() => resolve(val), ms)),
  
  // Sleep until condition
  until: async (condition, checkInterval = 100, timeout = 5000) => {
    const start = Date.now();
    while (!condition() && Date.now() - start < timeout) {
      await Sleep.delay(checkInterval);
    }
    if (!condition()) throw new Error('Timeout waiting for condition');
  },
  
  // Random sleep
  random: (min, max) => Sleep.delay(min + Math.random() * (max - min)),
  
  // Sleep with callback
  then: (ms, callback) => Sleep.delay(ms).then(callback)
};

console.log('\n=== Sleep Utilities ===');

(async () => {
  await Sleep.delay(100);
  console.log('Basic delay done');
  
  const val = await Sleep.value(100, 'returned value');
  console.log('Value:', val);
  
  await Sleep.random(50, 150);
  console.log('Random delay done');
})();
```

**Interview Tips:**
- sleep/delay: pause execution using setTimeout wrapped in Promise
- Basic pattern: `new Promise(resolve => setTimeout(resolve, ms))`
- async/await makes it look synchronous: `await sleep(1000)`
- No blocking: JavaScript is single-threaded, sleep uses event loop
- Cancelable: store timeout ID, clear on cancel, reject promise
- Return value: setTimeout callback can resolve with value
- Progress: use setInterval for periodic updates during delay
- Timeout: race promise against setTimeout for max wait time
- Applications: rate limiting, polling, retries, animations, sequential tasks
- Exponential backoff: increase delay between retries (1s, 2s, 4s, 8s)
- Jitter: add randomness to avoid thundering herd in distributed systems
- Minimum delay: ensure operation takes at least N ms
- Batch processing: delay between batches to avoid overwhelming systems
- Not precise: setTimeout accuracy ~4ms in browsers, affected by event loop
- Zero delay: still async, allows other events to process
- Negative delay: typically treated as 0
- Edge cases: zero delay, very long delays, multiple concurrent delays
- Alternatives: requestAnimationFrame for animations, setImmediate for Node.js
- Clarify: cancelable? progress updates? return value? timeout? accuracy requirements?
- Follow-ups: implement with AbortController, add high-resolution timing, create sleep class

</details>

95. Build a custom event emitter (pub/sub system)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Event Emitter**
```javascript
/**
 * Simple event emitter with on/emit/off
 * Time Complexity: O(n) for emit where n is number of listeners
 * Space Complexity: O(n) for stored listeners
 */
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return this;
  }
  
  emit(event, ...args) {
    if (!this.events[event]) {
      return false;
    }
    
    this.events[event].forEach(listener => {
      listener(...args);
    });
    
    return true;
  }
  
  off(event, listenerToRemove) {
    if (!this.events[event]) {
      return this;
    }
    
    this.events[event] = this.events[event].filter(
      listener => listener !== listenerToRemove
    );
    
    return this;
  }
}

// Test
console.log('=== Basic Event Emitter ===');

const emitter = new EventEmitter();

function onMessage(data) {
  console.log('Received:', data);
}

emitter.on('message', onMessage);
emitter.on('message', (data) => console.log('Also received:', data));

emitter.emit('message', 'Hello!'); // Both listeners fire

emitter.off('message', onMessage);
emitter.emit('message', 'World!'); // Only second listener fires
```

### **Approach 2: Event Emitter with once()**
```javascript
/**
 * Event emitter with one-time listeners
 */
class EventEmitterWithOnce extends EventEmitter {
  once(event, listener) {
    const onceWrapper = (...args) => {
      listener(...args);
      this.off(event, onceWrapper);
    };
    
    // Store original listener reference for removal
    onceWrapper.listener = listener;
    
    return this.on(event, onceWrapper);
  }
  
  off(event, listenerToRemove) {
    if (!this.events[event]) {
      return this;
    }
    
    this.events[event] = this.events[event].filter(listener => {
      return listener !== listenerToRemove && 
             listener.listener !== listenerToRemove;
    });
    
    return this;
  }
}

// Test
console.log('\n=== Event Emitter with once() ===');

const emitter2 = new EventEmitterWithOnce();

emitter2.once('startup', () => {
  console.log('App started (once)');
});

emitter2.on('startup', () => {
  console.log('App started (always)');
});

emitter2.emit('startup'); // Both fire
emitter2.emit('startup'); // Only 'always' fires
```

### **Approach 3: Event Emitter with Priority**
```javascript
/**
 * Listeners can have priority levels
 */
class PriorityEventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, listener, priority = 0) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    
    this.events[event].push({ listener, priority });
    
    // Sort by priority (highest first)
    this.events[event].sort((a, b) => b.priority - a.priority);
    
    return this;
  }
  
  emit(event, ...args) {
    if (!this.events[event]) {
      return false;
    }
    
    this.events[event].forEach(({ listener }) => {
      listener(...args);
    });
    
    return true;
  }
  
  off(event, listenerToRemove) {
    if (!this.events[event]) {
      return this;
    }
    
    this.events[event] = this.events[event].filter(
      ({ listener }) => listener !== listenerToRemove
    );
    
    return this;
  }
}

// Test
console.log('\n=== Priority Event Emitter ===');

const emitter3 = new PriorityEventEmitter();

emitter3.on('task', () => console.log('Priority 0 (default)'), 0);
emitter3.on('task', () => console.log('Priority 10 (high)'), 10);
emitter3.on('task', () => console.log('Priority 5 (medium)'), 5);

emitter3.emit('task'); // Fires in order: 10, 5, 0
```

### **Approach 4: Async Event Emitter**
```javascript
/**
 * Support async listeners with Promise.all
 */
class AsyncEventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return this;
  }
  
  async emit(event, ...args) {
    if (!this.events[event]) {
      return false;
    }
    
    await Promise.all(
      this.events[event].map(listener => listener(...args))
    );
    
    return true;
  }
  
  off(event, listenerToRemove) {
    if (!this.events[event]) {
      return this;
    }
    
    this.events[event] = this.events[event].filter(
      listener => listener !== listenerToRemove
    );
    
    return this;
  }
  
  // Sequential async emit
  async emitSerial(event, ...args) {
    if (!this.events[event]) {
      return false;
    }
    
    for (const listener of this.events[event]) {
      await listener(...args);
    }
    
    return true;
  }
}

// Test
console.log('\n=== Async Event Emitter ===');

const asyncEmitter = new AsyncEventEmitter();

asyncEmitter.on('process', async (data) => {
  await new Promise(r => setTimeout(r, 100));
  console.log('Async listener 1:', data);
});

asyncEmitter.on('process', async (data) => {
  await new Promise(r => setTimeout(r, 50));
  console.log('Async listener 2:', data);
});

(async () => {
  console.log('Emitting...');
  await asyncEmitter.emit('process', 'data');
  console.log('All async listeners completed');
})();
```

### **Approach 5: Feature-Complete Event Emitter**
```javascript
/**
 * Production-ready event emitter with all features
 */
class AdvancedEventEmitter {
  constructor(options = {}) {
    this.events = {};
    this.maxListeners = options.maxListeners || 10;
    this.wildcard = options.wildcard || false;
  }
  
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    
    if (this.events[event].length >= this.maxListeners) {
      console.warn(`Warning: Max listeners (${this.maxListeners}) exceeded for event "${event}"`);
    }
    
    this.events[event].push(listener);
    this.emit('newListener', event, listener);
    
    return this;
  }
  
  once(event, listener) {
    const onceWrapper = (...args) => {
      listener(...args);
      this.off(event, onceWrapper);
    };
    
    onceWrapper.listener = listener;
    return this.on(event, onceWrapper);
  }
  
  emit(event, ...args) {
    let fired = false;
    
    // Fire specific event listeners
    if (this.events[event]) {
      this.events[event].forEach(listener => {
        listener(...args);
      });
      fired = true;
    }
    
    // Fire wildcard listeners
    if (this.wildcard && this.events['*']) {
      this.events['*'].forEach(listener => {
        listener(event, ...args);
      });
      fired = true;
    }
    
    return fired;
  }
  
  off(event, listenerToRemove) {
    if (!listenerToRemove) {
      // Remove all listeners for event
      delete this.events[event];
      return this;
    }
    
    if (!this.events[event]) {
      return this;
    }
    
    this.events[event] = this.events[event].filter(listener => {
      const match = listener === listenerToRemove || 
                    listener.listener === listenerToRemove;
      
      if (match) {
        this.emit('removeListener', event, listener);
      }
      
      return !match;
    });
    
    return this;
  }
  
  removeAllListeners(event) {
    if (event) {
      delete this.events[event];
    } else {
      this.events = {};
    }
    
    return this;
  }
  
  listenerCount(event) {
    return this.events[event] ? this.events[event].length : 0;
  }
  
  listeners(event) {
    return this.events[event] ? [...this.events[event]] : [];
  }
  
  eventNames() {
    return Object.keys(this.events);
  }
  
  setMaxListeners(n) {
    this.maxListeners = n;
    return this;
  }
}

// Test
console.log('\n=== Advanced Event Emitter ===');

const advanced = new AdvancedEventEmitter({ wildcard: true });

advanced.on('newListener', (event) => {
  console.log(`New listener added for: ${event}`);
});

advanced.on('data', (data) => console.log('Data:', data));
advanced.on('data', (data) => console.log('Data again:', data));

console.log('Listener count:', advanced.listenerCount('data'));
console.log('Event names:', advanced.eventNames());

advanced.emit('data', 'test');

// Wildcard
advanced.on('*', (event, ...args) => {
  console.log(`Wildcard caught: ${event}`, args);
});

advanced.emit('custom', 'anything');
```

### **Bonus: Pub/Sub Pattern**
```javascript
/**
 * Pub/Sub with topics and subscriptions
 */
class PubSub {
  constructor() {
    this.subscribers = {};
    this.subId = 0;
  }
  
  subscribe(topic, callback) {
    if (!this.subscribers[topic]) {
      this.subscribers[topic] = {};
    }
    
    const id = this.subId++;
    this.subscribers[topic][id] = callback;
    
    // Return unsubscribe function
    return () => {
      delete this.subscribers[topic][id];
    };
  }
  
  publish(topic, data) {
    if (!this.subscribers[topic]) {
      return 0;
    }
    
    let count = 0;
    
    Object.values(this.subscribers[topic]).forEach(callback => {
      callback(data);
      count++;
    });
    
    return count;
  }
  
  clear(topic) {
    if (topic) {
      delete this.subscribers[topic];
    } else {
      this.subscribers = {};
    }
  }
}

// Test
console.log('\n=== Pub/Sub Pattern ===');

const pubsub = new PubSub();

const unsubscribe1 = pubsub.subscribe('news', (data) => {
  console.log('Subscriber 1 got:', data);
});

const unsubscribe2 = pubsub.subscribe('news', (data) => {
  console.log('Subscriber 2 got:', data);
});

pubsub.publish('news', 'Breaking news!'); // Both receive

unsubscribe1(); // Unsubscribe first

pubsub.publish('news', 'More news'); // Only subscriber 2 receives
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Application state management
console.log('\n=== State Management ===');

class Store extends EventEmitter {
  constructor(initialState = {}) {
    super();
    this.state = initialState;
  }
  
  getState() {
    return { ...this.state };
  }
  
  setState(updates) {
    const oldState = this.getState();
    this.state = { ...this.state, ...updates };
    this.emit('stateChange', this.state, oldState);
  }
}

const store = new Store({ count: 0 });

store.on('stateChange', (newState, oldState) => {
  console.log('State changed:', { old: oldState.count, new: newState.count });
});

store.setState({ count: 1 });
store.setState({ count: 2 });

// 2. HTTP Server-like interface
console.log('\n=== Server Interface ===');

class Server extends EventEmitter {
  constructor() {
    super();
    this.running = false;
  }
  
  listen(port) {
    this.running = true;
    this.emit('listening', port);
    
    // Simulate requests
    setTimeout(() => this.emit('request', { url: '/api/users', method: 'GET' }), 100);
  }
  
  close() {
    this.running = false;
    this.emit('close');
  }
}

const server = new Server();

server.on('listening', (port) => {
  console.log(`Server listening on port ${port}`);
});

server.on('request', (req) => {
  console.log(`Request: ${req.method} ${req.url}`);
});

server.on('close', () => {
  console.log('Server closed');
});

server.listen(3000);
setTimeout(() => server.close(), 500);

// 3. Real-time chat
console.log('\n=== Chat System ===');

class ChatRoom extends EventEmitter {
  constructor(name) {
    super();
    this.name = name;
    this.users = [];
  }
  
  join(user) {
    this.users.push(user);
    this.emit('userJoined', user);
  }
  
  leave(user) {
    this.users = this.users.filter(u => u !== user);
    this.emit('userLeft', user);
  }
  
  sendMessage(user, message) {
    this.emit('message', { user, message, timestamp: Date.now() });
  }
}

const room = new ChatRoom('General');

room.on('userJoined', (user) => {
  console.log(`${user} joined the chat`);
});

room.on('message', ({ user, message }) => {
  console.log(`${user}: ${message}`);
});

room.join('Alice');
room.join('Bob');
room.sendMessage('Alice', 'Hello everyone!');
room.sendMessage('Bob', 'Hi Alice!');

// 4. File watcher simulation
console.log('\n=== File Watcher ===');

class FileWatcher extends EventEmitter {
  constructor() {
    super();
    this.watching = new Set();
  }
  
  watch(filename) {
    this.watching.add(filename);
    this.emit('watching', filename);
  }
  
  simulateChange(filename, type = 'change') {
    if (this.watching.has(filename)) {
      this.emit(type, filename);
    }
  }
  
  unwatch(filename) {
    this.watching.delete(filename);
    this.emit('unwatched', filename);
  }
}

const watcher = new FileWatcher();

watcher.on('change', (file) => {
  console.log(`File changed: ${file}`);
});

watcher.on('delete', (file) => {
  console.log(`File deleted: ${file}`);
});

watcher.watch('app.js');
watcher.simulateChange('app.js', 'change');
watcher.simulateChange('app.js', 'delete');

// 5. Task queue with events
console.log('\n=== Task Queue ===');

class TaskQueue extends EventEmitter {
  constructor() {
    super();
    this.queue = [];
    this.processing = false;
  }
  
  add(task) {
    this.queue.push(task);
    this.emit('taskAdded', task);
    this.process();
  }
  
  async process() {
    if (this.processing || this.queue.length === 0) {
      return;
    }
    
    this.processing = true;
    
    while (this.queue.length > 0) {
      const task = this.queue.shift();
      
      this.emit('taskStart', task);
      
      try {
        await task();
        this.emit('taskComplete', task);
      } catch (error) {
        this.emit('taskError', task, error);
      }
    }
    
    this.processing = false;
    this.emit('queueEmpty');
  }
}

const queue = new TaskQueue();

queue.on('taskComplete', () => console.log('Task completed'));
queue.on('queueEmpty', () => console.log('Queue empty'));

queue.add(async () => {
  await new Promise(r => setTimeout(r, 100));
  console.log('Task 1 executed');
});

queue.add(async () => {
  console.log('Task 2 executed');
});
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

const edge = new EventEmitter();

// No listeners
console.log('Emit with no listeners:', edge.emit('nonexistent')); // false

// Multiple off calls
const listener = () => console.log('test');
edge.on('test', listener);
edge.off('test', listener);
edge.off('test', listener); // No error

// Remove all for event
edge.on('test', () => console.log('1'));
edge.on('test', () => console.log('2'));
edge.events.test = [];
edge.emit('test'); // No output

// Emit during emit
edge.on('recursive', function() {
  console.log('Recursive emit');
  if (!this.recursiveCount) this.recursiveCount = 0;
  if (this.recursiveCount++ < 2) {
    edge.emit('recursive');
  }
});

edge.emit('recursive');

// Listener modifies listeners array
edge.on('modify', () => {
  console.log('Modifying during emit');
  edge.off('modify');
});

edge.emit('modify');
edge.emit('modify'); // No output

// Error in listener
edge.on('error', () => {
  throw new Error('Listener error');
});

try {
  edge.emit('error');
} catch (e) {
  console.log('Caught listener error:', e.message);
}
```

### **Performance Considerations**
```javascript
/**
 * Benchmark event emitter
 */
console.log('\n=== Performance ===');

const perfEmitter = new EventEmitter();

// Add many listeners
for (let i = 0; i < 100; i++) {
  perfEmitter.on('test', () => {});
}

console.time('Emit with 100 listeners');
for (let i = 0; i < 1000; i++) {
  perfEmitter.emit('test');
}
console.timeEnd('Emit with 100 listeners');

console.log(`
Performance Notes:
• O(n) time for emit (n = number of listeners)
• Array iteration is fast for small n
• Consider Set for large listener counts
• WeakMap for memory efficiency with objects
• Async listeners add Promise overhead
• Deep event hierarchies slow down wildcards
• Memory leaks if listeners not removed
`);
```

**Interview Tips:**
- Event emitter: pub/sub pattern for decoupled communication
- Core methods: on (subscribe), emit (publish), off (unsubscribe)
- Store listeners in object: { eventName: [listener1, listener2] }
- on(): add listener to array for event name
- emit(): call all listeners for event with provided arguments
- off(): filter out listener from array
- once(): wrapper that removes itself after first call
- Return 'this' for method chaining
- Priority: sort listeners by priority before emit
- Async: use Promise.all or sequential await
- Wildcard: '*' event catches all emissions
- Max listeners: warn when too many (potential memory leak)
- Applications: state management, servers, chat, file watchers, queues
- Node.js EventEmitter: built-in with many features
- Pub/Sub: similar but with topic-based subscriptions
- Edge cases: no listeners, remove during emit, errors in listeners
- Memory leaks: always remove listeners when done
- Performance: O(n) for emit, consider Set for large listener counts
- Clarify: sync or async? priority? wildcard? max listeners? Node.js compatible?
- Follow-ups: add namespaces, implement middleware, add error event, make thread-safe

</details>

---

## **EXTRA HARD LEVEL (96-120)**

### **Complex Data Structures & Algorithms**

96. Implement a Trie (Prefix Tree) for autocomplete

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Trie Implementation**
```javascript
/**
 * Basic Trie (Prefix Tree) for word storage and search
 * Time Complexity: 
 *   - Insert: O(m) where m is word length
 *   - Search: O(m)
 *   - StartsWith: O(p) where p is prefix length
 * Space Complexity: O(n * m) where n is number of words
 */
class TrieNode {
  constructor() {
    this.children = {};
    this.isEndOfWord = false;
  }
}

class Trie {
  constructor() {
    this.root = new TrieNode();
  }
  
  insert(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
    }
    
    node.isEndOfWord = true;
  }
  
  search(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    
    return node.isEndOfWord;
  }
  
  startsWith(prefix) {
    let node = this.root;
    
    for (const char of prefix) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    
    return true;
  }
}

// Test
console.log('=== Basic Trie ===');

const trie = new Trie();

trie.insert('apple');
trie.insert('app');
trie.insert('application');

console.log('Search "apple":', trie.search('apple')); // true
console.log('Search "app":', trie.search('app')); // true
console.log('Search "appl":', trie.search('appl')); // false
console.log('StartsWith "app":', trie.startsWith('app')); // true
console.log('StartsWith "apl":', trie.startsWith('apl')); // false
```

### **Approach 2: Trie with Autocomplete**
```javascript
/**
 * Trie with autocomplete/suggestion functionality
 */
class AutocompleteTrie {
  constructor() {
    this.root = new TrieNode();
  }
  
  insert(word) {
    let node = this.root;
    
    for (const char of word.toLowerCase()) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
    }
    
    node.isEndOfWord = true;
  }
  
  // Get all words with given prefix
  autocomplete(prefix) {
    let node = this.root;
    prefix = prefix.toLowerCase();
    
    // Navigate to prefix node
    for (const char of prefix) {
      if (!node.children[char]) {
        return [];
      }
      node = node.children[char];
    }
    
    // Collect all words from this node
    const results = [];
    this._collectWords(node, prefix, results);
    return results;
  }
  
  _collectWords(node, currentWord, results) {
    if (node.isEndOfWord) {
      results.push(currentWord);
    }
    
    for (const char in node.children) {
      this._collectWords(
        node.children[char],
        currentWord + char,
        results
      );
    }
  }
}

// Test
console.log('\n=== Autocomplete Trie ===');

const autoTrie = new AutocompleteTrie();

const words = ['apple', 'app', 'application', 'apply', 'apricot', 'banana'];
words.forEach(word => autoTrie.insert(word));

console.log('Autocomplete "app":', autoTrie.autocomplete('app'));
// ['app', 'apple', 'application', 'apply']

console.log('Autocomplete "apr":', autoTrie.autocomplete('apr'));
// ['apricot']

console.log('Autocomplete "ban":', autoTrie.autocomplete('ban'));
// ['banana']

console.log('Autocomplete "xyz":', autoTrie.autocomplete('xyz'));
// []
```

### **Approach 3: Trie with Word Frequency**
```javascript
/**
 * Trie that tracks word frequency for ranking suggestions
 */
class TrieNodeWithFreq {
  constructor() {
    this.children = {};
    this.isEndOfWord = false;
    this.frequency = 0;
  }
}

class FrequencyTrie {
  constructor() {
    this.root = new TrieNodeWithFreq();
  }
  
  insert(word) {
    let node = this.root;
    
    for (const char of word.toLowerCase()) {
      if (!node.children[char]) {
        node.children[char] = new TrieNodeWithFreq();
      }
      node = node.children[char];
    }
    
    node.isEndOfWord = true;
    node.frequency++;
  }
  
  autocomplete(prefix, limit = 5) {
    let node = this.root;
    prefix = prefix.toLowerCase();
    
    // Navigate to prefix
    for (const char of prefix) {
      if (!node.children[char]) {
        return [];
      }
      node = node.children[char];
    }
    
    // Collect words with frequencies
    const results = [];
    this._collectWithFreq(node, prefix, results);
    
    // Sort by frequency (descending) and limit results
    return results
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, limit)
      .map(item => item.word);
  }
  
  _collectWithFreq(node, currentWord, results) {
    if (node.isEndOfWord) {
      results.push({ word: currentWord, frequency: node.frequency });
    }
    
    for (const char in node.children) {
      this._collectWithFreq(
        node.children[char],
        currentWord + char,
        results
      );
    }
  }
  
  getFrequency(word) {
    let node = this.root;
    
    for (const char of word.toLowerCase()) {
      if (!node.children[char]) {
        return 0;
      }
      node = node.children[char];
    }
    
    return node.isEndOfWord ? node.frequency : 0;
  }
}

// Test
console.log('\n=== Frequency Trie ===');

const freqTrie = new FrequencyTrie();

// Insert with varying frequencies
freqTrie.insert('apple');
freqTrie.insert('apple');
freqTrie.insert('apple');
freqTrie.insert('app');
freqTrie.insert('app');
freqTrie.insert('application');
freqTrie.insert('apply');

console.log('Frequency of "apple":', freqTrie.getFrequency('apple')); // 3
console.log('Frequency of "app":', freqTrie.getFrequency('app')); // 2

console.log('Top autocomplete "app":', freqTrie.autocomplete('app', 3));
// ['apple', 'app', 'application'] (sorted by frequency)
```

### **Approach 4: Trie with Delete Operation**
```javascript
/**
 * Trie with delete functionality
 */
class DeletableTrie {
  constructor() {
    this.root = new TrieNode();
  }
  
  insert(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
    }
    
    node.isEndOfWord = true;
  }
  
  delete(word) {
    return this._deleteHelper(this.root, word, 0);
  }
  
  _deleteHelper(node, word, index) {
    if (index === word.length) {
      // Reached end of word
      if (!node.isEndOfWord) {
        return false; // Word doesn't exist
      }
      
      node.isEndOfWord = false;
      
      // Delete node if it has no children
      return Object.keys(node.children).length === 0;
    }
    
    const char = word[index];
    const childNode = node.children[char];
    
    if (!childNode) {
      return false; // Word doesn't exist
    }
    
    const shouldDeleteChild = this._deleteHelper(childNode, word, index + 1);
    
    if (shouldDeleteChild) {
      delete node.children[char];
      
      // Delete current node if it has no children and isn't end of word
      return Object.keys(node.children).length === 0 && !node.isEndOfWord;
    }
    
    return false;
  }
  
  search(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    
    return node.isEndOfWord;
  }
}

// Test
console.log('\n=== Deletable Trie ===');

const delTrie = new DeletableTrie();

delTrie.insert('apple');
delTrie.insert('app');
delTrie.insert('application');

console.log('Before delete:');
console.log('  Search "apple":', delTrie.search('apple')); // true
console.log('  Search "app":', delTrie.search('app')); // true

delTrie.delete('apple');

console.log('After delete "apple":');
console.log('  Search "apple":', delTrie.search('apple')); // false
console.log('  Search "app":', delTrie.search('app')); // true (still exists)
```

### **Approach 5: Advanced Trie with Multiple Features**
```javascript
/**
 * Feature-rich Trie implementation
 */
class AdvancedTrieNode {
  constructor() {
    this.children = {};
    this.isEndOfWord = false;
    this.frequency = 0;
    this.data = null; // Store additional data
  }
}

class AdvancedTrie {
  constructor() {
    this.root = new AdvancedTrieNode();
    this.wordCount = 0;
  }
  
  insert(word, data = null) {
    let node = this.root;
    word = word.toLowerCase();
    
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new AdvancedTrieNode();
      }
      node = node.children[char];
    }
    
    if (!node.isEndOfWord) {
      this.wordCount++;
    }
    
    node.isEndOfWord = true;
    node.frequency++;
    node.data = data;
  }
  
  search(word) {
    const node = this._findNode(word.toLowerCase());
    return node ? node.isEndOfWord : false;
  }
  
  startsWith(prefix) {
    return this._findNode(prefix.toLowerCase()) !== null;
  }
  
  autocomplete(prefix, options = {}) {
    const {
      limit = 10,
      sortBy = 'frequency', // 'frequency' or 'alphabetical'
      includeData = false
    } = options;
    
    const node = this._findNode(prefix.toLowerCase());
    if (!node) return [];
    
    const results = [];
    this._collectWords(node, prefix.toLowerCase(), results, includeData);
    
    // Sort results
    if (sortBy === 'frequency') {
      results.sort((a, b) => b.frequency - a.frequency);
    } else {
      results.sort((a, b) => a.word.localeCompare(b.word));
    }
    
    return results.slice(0, limit).map(item => 
      includeData ? item : item.word
    );
  }
  
  delete(word) {
    if (this._deleteHelper(this.root, word.toLowerCase(), 0)) {
      this.wordCount--;
      return true;
    }
    return false;
  }
  
  getAllWords() {
    const results = [];
    this._collectWords(this.root, '', results, false);
    return results.map(item => item.word);
  }
  
  getWordCount() {
    return this.wordCount;
  }
  
  longestCommonPrefix() {
    let prefix = '';
    let node = this.root;
    
    while (Object.keys(node.children).length === 1 && !node.isEndOfWord) {
      const char = Object.keys(node.children)[0];
      prefix += char;
      node = node.children[char];
    }
    
    return prefix;
  }
  
  _findNode(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        return null;
      }
      node = node.children[char];
    }
    
    return node;
  }
  
  _collectWords(node, currentWord, results, includeData) {
    if (node.isEndOfWord) {
      const result = {
        word: currentWord,
        frequency: node.frequency
      };
      
      if (includeData) {
        result.data = node.data;
      }
      
      results.push(result);
    }
    
    for (const char in node.children) {
      this._collectWords(
        node.children[char],
        currentWord + char,
        results,
        includeData
      );
    }
  }
  
  _deleteHelper(node, word, index) {
    if (index === word.length) {
      if (!node.isEndOfWord) return false;
      node.isEndOfWord = false;
      node.frequency = 0;
      node.data = null;
      return Object.keys(node.children).length === 0;
    }
    
    const char = word[index];
    if (!node.children[char]) return false;
    
    const shouldDelete = this._deleteHelper(node.children[char], word, index + 1);
    
    if (shouldDelete) {
      delete node.children[char];
      return Object.keys(node.children).length === 0 && !node.isEndOfWord;
    }
    
    return false;
  }
}

// Test
console.log('\n=== Advanced Trie ===');

const advTrie = new AdvancedTrie();

// Insert with data
advTrie.insert('apple', { price: 1.99, category: 'fruit' });
advTrie.insert('apple'); // Increment frequency
advTrie.insert('application', { type: 'software' });
advTrie.insert('app', { type: 'mobile' });

console.log('Word count:', advTrie.getWordCount());
console.log('All words:', advTrie.getAllWords());

console.log('Autocomplete "app" (by frequency):',
  advTrie.autocomplete('app', { limit: 3, sortBy: 'frequency' }));

console.log('Autocomplete "app" (alphabetical):',
  advTrie.autocomplete('app', { limit: 3, sortBy: 'alphabetical' }));

console.log('Autocomplete with data:',
  advTrie.autocomplete('app', { includeData: true }));
```

### **Bonus: Compressed Trie (PATRICIA Trie)**
```javascript
/**
 * Compressed Trie that stores strings on edges
 * More space-efficient for sparse tries
 */
class CompressedTrieNode {
  constructor() {
    this.children = new Map();
    this.isEndOfWord = false;
  }
}

class CompressedTrie {
  constructor() {
    this.root = new CompressedTrieNode();
  }
  
  insert(word) {
    this._insertHelper(this.root, word, 0);
  }
  
  _insertHelper(node, word, index) {
    if (index === word.length) {
      node.isEndOfWord = true;
      return;
    }
    
    const char = word[index];
    
    // Try to find matching edge
    for (const [edge, child] of node.children) {
      const commonLength = this._getCommonPrefixLength(edge, word.slice(index));
      
      if (commonLength > 0) {
        if (commonLength === edge.length) {
          // Full edge match, continue down
          this._insertHelper(child, word, index + commonLength);
          return;
        } else {
          // Partial match, need to split edge
          const commonPrefix = edge.slice(0, commonLength);
          const oldSuffix = edge.slice(commonLength);
          const newSuffix = word.slice(index + commonLength);
          
          // Create intermediate node
          const intermediateNode = new CompressedTrieNode();
          
          // Move old child
          node.children.delete(edge);
          node.children.set(commonPrefix, intermediateNode);
          intermediateNode.children.set(oldSuffix, child);
          
          // Add new path
          if (newSuffix.length > 0) {
            intermediateNode.children.set(newSuffix, new CompressedTrieNode());
            intermediateNode.children.get(newSuffix).isEndOfWord = true;
          } else {
            intermediateNode.isEndOfWord = true;
          }
          
          return;
        }
      }
    }
    
    // No matching edge, create new
    const newNode = new CompressedTrieNode();
    newNode.isEndOfWord = true;
    node.children.set(word.slice(index), newNode);
  }
  
  search(word) {
    return this._searchHelper(this.root, word, 0);
  }
  
  _searchHelper(node, word, index) {
    if (index === word.length) {
      return node.isEndOfWord;
    }
    
    for (const [edge, child] of node.children) {
      if (word.slice(index).startsWith(edge)) {
        return this._searchHelper(child, word, index + edge.length);
      }
    }
    
    return false;
  }
  
  _getCommonPrefixLength(str1, str2) {
    let i = 0;
    while (i < str1.length && i < str2.length && str1[i] === str2[i]) {
      i++;
    }
    return i;
  }
}

// Test
console.log('\n=== Compressed Trie ===');

const compTrie = new CompressedTrie();

compTrie.insert('romane');
compTrie.insert('romanus');
compTrie.insert('romulus');
compTrie.insert('rubens');
compTrie.insert('ruber');
compTrie.insert('rubicon');
compTrie.insert('rubicundus');

console.log('Search "romane":', compTrie.search('romane')); // true
console.log('Search "roman":', compTrie.search('roman')); // false
console.log('Search "rubicon":', compTrie.search('rubicon')); // true
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of Trie
 */

// 1. Search Engine Autocomplete
console.log('\n=== Search Autocomplete ===');

class SearchEngine {
  constructor() {
    this.trie = new FrequencyTrie();
  }
  
  indexQuery(query) {
    this.trie.insert(query);
  }
  
  suggest(prefix, limit = 5) {
    return this.trie.autocomplete(prefix, limit);
  }
}

const search = new SearchEngine();

// Simulate user searches
['javascript tutorial', 'javascript array', 'javascript array methods',
 'javascript async', 'java programming', 'python basics'].forEach(query => {
  search.indexQuery(query);
});

// Some searches are more popular
search.indexQuery('javascript tutorial');
search.indexQuery('javascript tutorial');

console.log('Suggestions for "java":', search.suggest('java', 3));
console.log('Suggestions for "javascript a":', search.suggest('javascript a', 3));

// 2. Spell Checker
console.log('\n=== Spell Checker ===');

class SpellChecker {
  constructor(dictionary) {
    this.trie = new Trie();
    dictionary.forEach(word => this.trie.insert(word.toLowerCase()));
  }
  
  isCorrect(word) {
    return this.trie.search(word.toLowerCase());
  }
  
  suggest(word) {
    word = word.toLowerCase();
    
    // If correct, no suggestions needed
    if (this.isCorrect(word)) {
      return [];
    }
    
    // Find similar words (simple approach)
    const suggestions = [];
    
    // Try removing each character
    for (let i = 0; i < word.length; i++) {
      const candidate = word.slice(0, i) + word.slice(i + 1);
      if (this.isCorrect(candidate)) {
        suggestions.push(candidate);
      }
    }
    
    // Try replacing each character
    for (let i = 0; i < word.length; i++) {
      for (let c = 97; c <= 122; c++) { // a-z
        const char = String.fromCharCode(c);
        const candidate = word.slice(0, i) + char + word.slice(i + 1);
        if (this.isCorrect(candidate) && !suggestions.includes(candidate)) {
          suggestions.push(candidate);
        }
      }
    }
    
    return suggestions.slice(0, 5);
  }
}

const dictionary = ['apple', 'application', 'apply', 'banana', 'band', 'can'];
const spellChecker = new SpellChecker(dictionary);

console.log('Is "apple" correct?', spellChecker.isCorrect('apple'));
console.log('Is "aple" correct?', spellChecker.isCorrect('aple'));
console.log('Suggestions for "aple":', spellChecker.suggest('aple'));

// 3. IP Routing Table
console.log('\n=== IP Routing ===');

class IPRouter {
  constructor() {
    this.trie = new AdvancedTrie();
  }
  
  addRoute(ipPrefix, gateway) {
    // Convert IP to binary string for trie
    const binaryIP = ipPrefix.split('.')
      .map(octet => parseInt(octet).toString(2).padStart(8, '0'))
      .join('');
    
    this.trie.insert(binaryIP, { gateway, originalIP: ipPrefix });
  }
  
  findRoute(ip) {
    const binaryIP = ip.split('.')
      .map(octet => parseInt(octet).toString(2).padStart(8, '0'))
      .join('');
    
    // Find longest prefix match
    let longestMatch = null;
    let maxLength = 0;
    
    for (let i = 1; i <= binaryIP.length; i++) {
      const prefix = binaryIP.slice(0, i);
      const node = this.trie._findNode(prefix);
      
      if (node && node.isEndOfWord) {
        if (i > maxLength) {
          maxLength = i;
          longestMatch = node.data;
        }
      }
    }
    
    return longestMatch;
  }
}

const router = new IPRouter();
router.addRoute('192.168', 'Gateway A');
router.addRoute('192.168.1', 'Gateway B');
router.addRoute('10', 'Gateway C');

console.log('Route for 192.168.1.100:', router.findRoute('192.168.1.100'));
console.log('Route for 192.168.5.1:', router.findRoute('192.168.5.1'));
console.log('Route for 10.0.0.1:', router.findRoute('10.0.0.1'));

// 4. Contact Search
console.log('\n=== Contact Search ===');

class ContactList {
  constructor() {
    this.trie = new AdvancedTrie();
  }
  
  addContact(name, phone, email) {
    // Index by name
    this.trie.insert(name.toLowerCase(), { name, phone, email });
    
    // Also index by phone
    this.trie.insert(phone, { name, phone, email });
  }
  
  search(query) {
    return this.trie.autocomplete(query.toLowerCase(), {
      limit: 10,
      includeData: true,
      sortBy: 'alphabetical'
    });
  }
}

const contacts = new ContactList();
contacts.addContact('Alice Smith', '555-0100', 'alice@email.com');
contacts.addContact('Alice Johnson', '555-0101', 'alicej@email.com');
contacts.addContact('Bob Wilson', '555-0200', 'bob@email.com');

console.log('Search "alice":', contacts.search('alice'));
console.log('Search "555":', contacts.search('555'));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

const edgeTrie = new Trie();

// Empty string
edgeTrie.insert('');
console.log('Search empty string:', edgeTrie.search('')); // true

// Single character
edgeTrie.insert('a');
console.log('Search "a":', edgeTrie.search('a')); // true

// Long word
const longWord = 'a'.repeat(1000);
edgeTrie.insert(longWord);
console.log('Search long word:', edgeTrie.search(longWord)); // true

// Case sensitivity
const caseTrie = new AutocompleteTrie();
caseTrie.insert('Apple');
caseTrie.insert('APPLE');
console.log('Case insensitive autocomplete:', caseTrie.autocomplete('app'));

// Special characters
const specialTrie = new Trie();
specialTrie.insert('hello-world');
specialTrie.insert('hello_world');
console.log('Search with dash:', specialTrie.search('hello-world')); // true

// Overlapping words
const overlapTrie = new Trie();
overlapTrie.insert('test');
overlapTrie.insert('testing');
overlapTrie.insert('tester');
console.log('Search "test":', overlapTrie.search('test')); // true
console.log('Search "testing":', overlapTrie.search('testing')); // true
```

### **Performance Benchmarks**
```javascript
/**
 * Compare Trie vs Array vs Object
 */
console.log('\n=== Performance Comparison ===');

const words = [];
for (let i = 0; i < 1000; i++) {
  words.push('word' + i);
}

// Trie
const perfTrie = new Trie();
console.time('Trie insert 1000 words');
words.forEach(word => perfTrie.insert(word));
console.timeEnd('Trie insert 1000 words');

console.time('Trie search 1000 words');
words.forEach(word => perfTrie.search(word));
console.timeEnd('Trie search 1000 words');

// Array
console.time('Array insert 1000 words');
const arr = [...words];
console.timeEnd('Array insert 1000 words');

console.time('Array search 1000 words');
words.forEach(word => arr.includes(word));
console.timeEnd('Array search 1000 words');

// Set
console.time('Set insert 1000 words');
const set = new Set(words);
console.timeEnd('Set insert 1000 words');

console.time('Set search 1000 words');
words.forEach(word => set.has(word));
console.timeEnd('Set search 1000 words');

console.log(`
Performance Analysis:
┌──────────────┬────────────┬────────────┬────────────────┐
│ Operation    │ Trie       │ Array      │ Set            │
├──────────────┼────────────┼────────────┼────────────────┤
│ Insert       │ O(m)       │ O(1)       │ O(1)           │
│ Search       │ O(m)       │ O(n)       │ O(1) avg       │
│ Prefix       │ O(p)       │ O(n*m)     │ O(n*m)         │
│ Autocomplete │ O(p+k)     │ O(n*m)     │ O(n*m)         │
│ Space        │ O(n*m)     │ O(n*m)     │ O(n*m)         │
└──────────────┴────────────┴────────────┴────────────────┘

Where:
  m = average word length
  n = number of words
  p = prefix length
  k = number of matching words

Best Use Cases:
• Trie: Prefix search, autocomplete, spell checking
• Array: Small datasets, insertion order matters
• Set: Fast exact match lookup, no prefix operations
`);
```

**Interview Tips:**
- Trie (prefix tree): tree where each node represents a character
- Each path from root to leaf represents a word
- Children stored in map/object: { 'a': node, 'b': node }
- isEndOfWord flag: marks complete words vs prefixes
- Insert: traverse/create nodes for each character, mark last as end
- Search: traverse nodes, check if final node has isEndOfWord=true
- StartsWith: traverse nodes for prefix, return true if path exists
- Autocomplete: navigate to prefix node, collect all words below it
- Time: O(m) for insert/search where m is word length
- Space: O(ALPHABET_SIZE * n * m) worst case, typically O(n * m)
- Advantages: fast prefix operations, memory efficient for common prefixes
- Applications: autocomplete, spell checker, IP routing, T9 predictive text
- Frequency: track insertion count for ranking suggestions
- Delete: recursive removal, clean up unused nodes
- Compressed Trie (PATRICIA): store strings on edges, more space-efficient
- Ternary Search Tree: uses less memory than standard trie
- Edge cases: empty string, single char, case sensitivity, special characters
- Optimization: use arrays instead of objects for fixed alphabet
- Alternative: suffix tree for substring search
- Clarify: case sensitive? special characters? delete needed? frequency ranking?
- Follow-ups: add wildcard search, implement prefix count, optimize memory

</details>

97. Implement a Binary Search Tree with insert, delete, and search

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic BST Implementation**
```javascript
/**
 * Basic Binary Search Tree
 * Time Complexity:
 *   - Insert: O(h) where h is height, O(log n) average, O(n) worst
 *   - Search: O(h)
 *   - Delete: O(h)
 * Space Complexity: O(n) for n nodes
 */
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }
  
  insert(value) {
    const newNode = new TreeNode(value);
    
    if (!this.root) {
      this.root = newNode;
      return this;
    }
    
    let current = this.root;
    
    while (true) {
      if (value === current.value) {
        return this; // Duplicate, ignore
      }
      
      if (value < current.value) {
        if (!current.left) {
          current.left = newNode;
          return this;
        }
        current = current.left;
      } else {
        if (!current.right) {
          current.right = newNode;
          return this;
        }
        current = current.right;
      }
    }
  }
  
  search(value) {
    let current = this.root;
    
    while (current) {
      if (value === current.value) {
        return true;
      }
      
      if (value < current.value) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
    
    return false;
  }
  
  delete(value) {
    this.root = this._deleteNode(this.root, value);
    return this;
  }
  
  _deleteNode(node, value) {
    if (!node) {
      return null;
    }
    
    if (value < node.value) {
      node.left = this._deleteNode(node.left, value);
      return node;
    }
    
    if (value > node.value) {
      node.right = this._deleteNode(node.right, value);
      return node;
    }
    
    // Found node to delete
    
    // Case 1: No children (leaf node)
    if (!node.left && !node.right) {
      return null;
    }
    
    // Case 2: One child
    if (!node.left) {
      return node.right;
    }
    
    if (!node.right) {
      return node.left;
    }
    
    // Case 3: Two children
    // Find in-order successor (smallest in right subtree)
    let successor = node.right;
    while (successor.left) {
      successor = successor.left;
    }
    
    // Replace node value with successor value
    node.value = successor.value;
    
    // Delete successor
    node.right = this._deleteNode(node.right, successor.value);
    
    return node;
  }
}

// Test
console.log('=== Basic BST ===');

const bst = new BinarySearchTree();

// Insert values
[50, 30, 70, 20, 40, 60, 80].forEach(val => bst.insert(val));

console.log('Search 40:', bst.search(40)); // true
console.log('Search 25:', bst.search(25)); // false

bst.delete(20); // Delete leaf
console.log('After delete 20, search 20:', bst.search(20)); // false

bst.delete(30); // Delete node with two children
console.log('After delete 30, search 30:', bst.search(30)); // false
console.log('Search 40:', bst.search(40)); // true (still exists)
```

### **Approach 2: Recursive BST**
```javascript
/**
 * BST with recursive implementations
 */
class RecursiveBST {
  constructor() {
    this.root = null;
  }
  
  insert(value) {
    this.root = this._insertRecursive(this.root, value);
    return this;
  }
  
  _insertRecursive(node, value) {
    if (!node) {
      return new TreeNode(value);
    }
    
    if (value < node.value) {
      node.left = this._insertRecursive(node.left, value);
    } else if (value > node.value) {
      node.right = this._insertRecursive(node.right, value);
    }
    
    return node;
  }
  
  search(value) {
    return this._searchRecursive(this.root, value);
  }
  
  _searchRecursive(node, value) {
    if (!node) {
      return false;
    }
    
    if (value === node.value) {
      return true;
    }
    
    if (value < node.value) {
      return this._searchRecursive(node.left, value);
    }
    
    return this._searchRecursive(node.right, value);
  }
  
  delete(value) {
    this.root = this._deleteRecursive(this.root, value);
    return this;
  }
  
  _deleteRecursive(node, value) {
    if (!node) {
      return null;
    }
    
    if (value < node.value) {
      node.left = this._deleteRecursive(node.left, value);
    } else if (value > node.value) {
      node.right = this._deleteRecursive(node.right, value);
    } else {
      // Node found
      
      if (!node.left && !node.right) {
        return null;
      }
      
      if (!node.left) {
        return node.right;
      }
      
      if (!node.right) {
        return node.left;
      }
      
      // Two children: find min in right subtree
      const minRight = this._findMin(node.right);
      node.value = minRight.value;
      node.right = this._deleteRecursive(node.right, minRight.value);
    }
    
    return node;
  }
  
  _findMin(node) {
    while (node.left) {
      node = node.left;
    }
    return node;
  }
  
  findMin() {
    if (!this.root) return null;
    return this._findMin(this.root).value;
  }
  
  findMax() {
    if (!this.root) return null;
    let current = this.root;
    while (current.right) {
      current = current.right;
    }
    return current.value;
  }
}

// Test
console.log('\n=== Recursive BST ===');

const recBst = new RecursiveBST();

[50, 30, 70, 20, 40, 60, 80].forEach(val => recBst.insert(val));

console.log('Min value:', recBst.findMin()); // 20
console.log('Max value:', recBst.findMax()); // 80
console.log('Search 40:', recBst.search(40)); // true

recBst.delete(50); // Delete root
console.log('After delete 50:', recBst.search(50)); // false
```

### **Approach 3: BST with Traversals**
```javascript
/**
 * BST with different traversal methods
 */
class TraversalBST extends RecursiveBST {
  inOrderTraversal(callback) {
    this._inOrder(this.root, callback);
  }
  
  _inOrder(node, callback) {
    if (!node) return;
    
    this._inOrder(node.left, callback);
    callback(node.value);
    this._inOrder(node.right, callback);
  }
  
  preOrderTraversal(callback) {
    this._preOrder(this.root, callback);
  }
  
  _preOrder(node, callback) {
    if (!node) return;
    
    callback(node.value);
    this._preOrder(node.left, callback);
    this._preOrder(node.right, callback);
  }
  
  postOrderTraversal(callback) {
    this._postOrder(this.root, callback);
  }
  
  _postOrder(node, callback) {
    if (!node) return;
    
    this._postOrder(node.left, callback);
    this._postOrder(node.right, callback);
    callback(node.value);
  }
  
  levelOrderTraversal(callback) {
    if (!this.root) return;
    
    const queue = [this.root];
    
    while (queue.length > 0) {
      const node = queue.shift();
      callback(node.value);
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
  }
  
  toArray(order = 'inorder') {
    const result = [];
    const callback = (val) => result.push(val);
    
    switch (order) {
      case 'inorder':
        this.inOrderTraversal(callback);
        break;
      case 'preorder':
        this.preOrderTraversal(callback);
        break;
      case 'postorder':
        this.postOrderTraversal(callback);
        break;
      case 'levelorder':
        this.levelOrderTraversal(callback);
        break;
    }
    
    return result;
  }
}

// Test
console.log('\n=== BST Traversals ===');

const travBst = new TraversalBST();
[50, 30, 70, 20, 40, 60, 80].forEach(val => travBst.insert(val));

console.log('In-order (sorted):', travBst.toArray('inorder'));
// [20, 30, 40, 50, 60, 70, 80]

console.log('Pre-order:', travBst.toArray('preorder'));
// [50, 30, 20, 40, 70, 60, 80]

console.log('Post-order:', travBst.toArray('postorder'));
// [20, 40, 30, 60, 80, 70, 50]

console.log('Level-order:', travBst.toArray('levelorder'));
// [50, 30, 70, 20, 40, 60, 80]
```

### **Approach 4: BST with Additional Operations**
```javascript
/**
 * Feature-rich BST
 */
class AdvancedBST extends TraversalBST {
  getHeight() {
    return this._getHeightRecursive(this.root);
  }
  
  _getHeightRecursive(node) {
    if (!node) return -1;
    
    return 1 + Math.max(
      this._getHeightRecursive(node.left),
      this._getHeightRecursive(node.right)
    );
  }
  
  isBalanced() {
    return this._checkBalance(this.root) !== -1;
  }
  
  _checkBalance(node) {
    if (!node) return 0;
    
    const leftHeight = this._checkBalance(node.left);
    if (leftHeight === -1) return -1;
    
    const rightHeight = this._checkBalance(node.right);
    if (rightHeight === -1) return -1;
    
    if (Math.abs(leftHeight - rightHeight) > 1) {
      return -1; // Unbalanced
    }
    
    return 1 + Math.max(leftHeight, rightHeight);
  }
  
  countNodes() {
    return this._countNodesRecursive(this.root);
  }
  
  _countNodesRecursive(node) {
    if (!node) return 0;
    
    return 1 + 
           this._countNodesRecursive(node.left) + 
           this._countNodesRecursive(node.right);
  }
  
  findClosest(target) {
    if (!this.root) return null;
    
    let closest = this.root.value;
    let minDiff = Math.abs(target - closest);
    let current = this.root;
    
    while (current) {
      const diff = Math.abs(target - current.value);
      
      if (diff < minDiff) {
        minDiff = diff;
        closest = current.value;
      }
      
      if (target === current.value) {
        return current.value;
      }
      
      current = target < current.value ? current.left : current.right;
    }
    
    return closest;
  }
  
  findKthSmallest(k) {
    const result = { count: 0, value: null };
    
    this._findKthHelper(this.root, k, result);
    
    return result.value;
  }
  
  _findKthHelper(node, k, result) {
    if (!node || result.value !== null) return;
    
    this._findKthHelper(node.left, k, result);
    
    result.count++;
    if (result.count === k) {
      result.value = node.value;
      return;
    }
    
    this._findKthHelper(node.right, k, result);
  }
  
  getRange(min, max) {
    const result = [];
    this._getRangeHelper(this.root, min, max, result);
    return result;
  }
  
  _getRangeHelper(node, min, max, result) {
    if (!node) return;
    
    if (node.value > min) {
      this._getRangeHelper(node.left, min, max, result);
    }
    
    if (node.value >= min && node.value <= max) {
      result.push(node.value);
    }
    
    if (node.value < max) {
      this._getRangeHelper(node.right, min, max, result);
    }
  }
  
  validate() {
    return this._isValidBST(this.root, -Infinity, Infinity);
  }
  
  _isValidBST(node, min, max) {
    if (!node) return true;
    
    if (node.value <= min || node.value >= max) {
      return false;
    }
    
    return this._isValidBST(node.left, min, node.value) &&
           this._isValidBST(node.right, node.value, max);
  }
}

// Test
console.log('\n=== Advanced BST ===');

const advBst = new AdvancedBST();
[50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45].forEach(val => advBst.insert(val));

console.log('Height:', advBst.getHeight()); // 3
console.log('Node count:', advBst.countNodes()); // 11
console.log('Is balanced:', advBst.isBalanced()); // false (unbalanced)
console.log('Is valid BST:', advBst.validate()); // true

console.log('Closest to 33:', advBst.findClosest(33)); // 30 or 35
console.log('3rd smallest:', advBst.findKthSmallest(3)); // 25
console.log('Range [25, 50]:', advBst.getRange(25, 50));
// [25, 30, 35, 40, 45, 50]
```

### **Approach 5: Self-Balancing BST (AVL Tree Basics)**
```javascript
/**
 * Simple AVL tree with rotations
 * (Simplified version for demonstration)
 */
class AVLNode extends TreeNode {
  constructor(value) {
    super(value);
    this.height = 1;
  }
}

class AVLTree {
  constructor() {
    this.root = null;
  }
  
  getHeight(node) {
    return node ? node.height : 0;
  }
  
  getBalance(node) {
    return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;
  }
  
  updateHeight(node) {
    if (node) {
      node.height = 1 + Math.max(
        this.getHeight(node.left),
        this.getHeight(node.right)
      );
    }
  }
  
  rotateRight(y) {
    const x = y.left;
    const T2 = x.right;
    
    x.right = y;
    y.left = T2;
    
    this.updateHeight(y);
    this.updateHeight(x);
    
    return x;
  }
  
  rotateLeft(x) {
    const y = x.right;
    const T2 = y.left;
    
    y.left = x;
    x.right = T2;
    
    this.updateHeight(x);
    this.updateHeight(y);
    
    return y;
  }
  
  insert(value) {
    this.root = this._insertAVL(this.root, value);
    return this;
  }
  
  _insertAVL(node, value) {
    // Standard BST insert
    if (!node) {
      return new AVLNode(value);
    }
    
    if (value < node.value) {
      node.left = this._insertAVL(node.left, value);
    } else if (value > node.value) {
      node.right = this._insertAVL(node.right, value);
    } else {
      return node; // Duplicate
    }
    
    // Update height
    this.updateHeight(node);
    
    // Get balance factor
    const balance = this.getBalance(node);
    
    // Left Left Case
    if (balance > 1 && value < node.left.value) {
      return this.rotateRight(node);
    }
    
    // Right Right Case
    if (balance < -1 && value > node.right.value) {
      return this.rotateLeft(node);
    }
    
    // Left Right Case
    if (balance > 1 && value > node.left.value) {
      node.left = this.rotateLeft(node.left);
      return this.rotateRight(node);
    }
    
    // Right Left Case
    if (balance < -1 && value < node.right.value) {
      node.right = this.rotateRight(node.right);
      return this.rotateLeft(node);
    }
    
    return node;
  }
  
  search(value) {
    let current = this.root;
    
    while (current) {
      if (value === current.value) return true;
      current = value < current.value ? current.left : current.right;
    }
    
    return false;
  }
  
  inOrder() {
    const result = [];
    this._inOrderHelper(this.root, result);
    return result;
  }
  
  _inOrderHelper(node, result) {
    if (!node) return;
    
    this._inOrderHelper(node.left, result);
    result.push(node.value);
    this._inOrderHelper(node.right, result);
  }
}

// Test
console.log('\n=== AVL Tree (Self-Balancing) ===');

const avl = new AVLTree();

// Insert sequence that would create unbalanced BST
[10, 20, 30, 40, 50, 25].forEach(val => avl.insert(val));

console.log('In-order traversal:', avl.inOrder());
console.log('Root value (balanced):', avl.root.value); // Should be 30
console.log('Height:', avl.getHeight(avl.root)); // Much shorter than unbalanced
```

### **Real-World Use Cases**
```javascript
/**
 * Practical BST applications
 */

// 1. Range Query System
console.log('\n=== Range Query ===');

class RangeQueryDB {
  constructor() {
    this.bst = new AdvancedBST();
  }
  
  insert(key, value) {
    // In real system, store key-value pairs
    this.bst.insert(key);
  }
  
  rangeQuery(min, max) {
    return this.bst.getRange(min, max);
  }
}

const db = new RangeQueryDB();
[15, 10, 20, 8, 12, 16, 25].forEach(val => db.insert(val));

console.log('Range query [10, 20]:', db.rangeQuery(10, 20));

// 2. Priority Queue (using BST)
console.log('\n=== Priority Queue ===');

class PriorityQueueBST {
  constructor() {
    this.bst = new RecursiveBST();
  }
  
  enqueue(priority) {
    this.bst.insert(priority);
  }
  
  dequeue() {
    // Remove and return highest priority (max)
    const max = this.bst.findMax();
    if (max !== null) {
      this.bst.delete(max);
    }
    return max;
  }
  
  peek() {
    return this.bst.findMax();
  }
  
  isEmpty() {
    return this.bst.root === null;
  }
}

const pq = new PriorityQueueBST();
[5, 1, 9, 3, 7].forEach(p => pq.enqueue(p));

console.log('Dequeue (highest):', pq.dequeue()); // 9
console.log('Dequeue next:', pq.dequeue()); // 7
console.log('Peek:', pq.peek()); // 5

// 3. Sorted Set
console.log('\n=== Sorted Set ===');

class SortedSet {
  constructor() {
    this.bst = new TraversalBST();
  }
  
  add(value) {
    this.bst.insert(value);
  }
  
  has(value) {
    return this.bst.search(value);
  }
  
  delete(value) {
    this.bst.delete(value);
  }
  
  toArray() {
    return this.bst.toArray('inorder');
  }
  
  min() {
    return this.bst.findMin();
  }
  
  max() {
    return this.bst.findMax();
  }
}

const sortedSet = new SortedSet();
[5, 2, 8, 1, 9].forEach(v => sortedSet.add(v));

console.log('Sorted values:', sortedSet.toArray()); // [1, 2, 5, 8, 9]
console.log('Has 5:', sortedSet.has(5)); // true
console.log('Min:', sortedSet.min()); // 1
console.log('Max:', sortedSet.max()); // 9
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

const edgeBst = new AdvancedBST();

// Empty tree operations
console.log('Search in empty:', edgeBst.search(5)); // false
console.log('Min in empty:', edgeBst.findMin()); // null
console.log('Height of empty:', edgeBst.getHeight()); // -1

// Single node
edgeBst.insert(50);
console.log('Single node height:', edgeBst.getHeight()); // 0

// Duplicate insertions
edgeBst.insert(30);
edgeBst.insert(30); // Should be ignored
console.log('Node count (with duplicate):', edgeBst.countNodes()); // 2

// Delete root
edgeBst.insert(70);
edgeBst.delete(50);
console.log('After delete root:', edgeBst.toArray('inorder'));

// Skewed tree (worst case)
const skewedBst = new AdvancedBST();
[1, 2, 3, 4, 5].forEach(v => skewedBst.insert(v));
console.log('Skewed tree height:', skewedBst.getHeight()); // 4 (O(n))
console.log('Is skewed balanced:', skewedBst.isBalanced()); // false

// Delete non-existent
const testBst = new AdvancedBST();
[5, 3, 7].forEach(v => testBst.insert(v));
testBst.delete(10); // No error
console.log('After delete non-existent:', testBst.toArray('inorder'));
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Time Complexity:
┌──────────────┬─────────────┬─────────────┬─────────────┐
│ Operation    │ BST Average │ BST Worst   │ AVL Tree    │
├──────────────┼─────────────┼─────────────┼─────────────┤
│ Insert       │ O(log n)    │ O(n)        │ O(log n)    │
│ Search       │ O(log n)    │ O(n)        │ O(log n)    │
│ Delete       │ O(log n)    │ O(n)        │ O(log n)    │
│ Min/Max      │ O(log n)    │ O(n)        │ O(log n)    │
│ In-order     │ O(n)        │ O(n)        │ O(n)        │
│ Range Query  │ O(log n + k)│ O(n)        │ O(log n + k)│
└──────────────┴─────────────┴─────────────┴─────────────┘

Space Complexity: O(n) for all

Best Cases:
• Balanced BST: height = log(n), all operations O(log n)
• Skewed BST: height = n, degenerates to linked list O(n)

Advantages:
• Sorted order maintained
• Efficient search, insert, delete
• No rehashing like hash tables
• Range queries efficient

Disadvantages:
• Can become unbalanced (worst case O(n))
• More complex than arrays
• Extra memory for pointers

Solutions:
• AVL Tree: self-balancing, strict balance (height diff ≤ 1)
• Red-Black Tree: self-balancing, relaxed rules, faster insert
• B-Tree: for disk-based databases, multiple keys per node
`);
```

**Interview Tips:**
- BST: binary tree where left < node < right for all nodes
- Insert: traverse tree comparing values, add at appropriate leaf
- Search: traverse left if target < node, right if target > node
- Delete: three cases - leaf (remove), one child (replace), two children (find successor)
- Successor: smallest value in right subtree (leftmost node)
- Predecessor: largest value in left subtree (rightmost node)
- Time: O(h) where h is height, O(log n) average, O(n) worst (skewed)
- Space: O(n) for n nodes, O(h) call stack for recursion
- In-order traversal: yields sorted order (left, node, right)
- Pre-order: node, left, right (useful for copying tree)
- Post-order: left, right, node (useful for deletion)
- Level-order: breadth-first, use queue
- Height: longest path from root to leaf
- Balanced: height difference between subtrees ≤ 1 at every node
- Skewed: all nodes on one side, degenerates to linked list
- Applications: sorted sets, priority queues, range queries, databases
- Alternatives: AVL (strict balance), Red-Black (relaxed balance), B-Tree (databases)
- Edge cases: empty tree, single node, duplicates, delete root, skewed tree
- Optimization: keep height/size in nodes, iterative vs recursive, parent pointers
- Clarify: duplicates allowed? need balancing? additional operations? parent pointers?
- Follow-ups: serialize/deserialize tree, find LCA, convert to balanced BST, add iterator

</details>

98. Implement breadth-first search (BFS) on a graph

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic BFS with Adjacency List**
```javascript
/**
 * Breadth-First Search using queue
 * Time Complexity: O(V + E) where V is vertices, E is edges
 * Space Complexity: O(V) for queue and visited set
 */
class Graph {
  constructor() {
    this.adjacencyList = {};
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }
  
  addEdge(v1, v2) {
    this.adjacencyList[v1].push(v2);
    this.adjacencyList[v2].push(v1); // Undirected graph
  }
  
  bfs(start) {
    const visited = new Set();
    const queue = [start];
    const result = [];
    
    visited.add(start);
    
    while (queue.length > 0) {
      const vertex = queue.shift();
      result.push(vertex);
      
      for (const neighbor of this.adjacencyList[vertex]) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }
    
    return result;
  }
}

// Test
console.log('=== Basic BFS ===');

const graph = new Graph();

// Build graph:
//     A
//    / \
//   B   C
//  / \   \
// D   E   F

['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph.addVertex(v));
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('B', 'D');
graph.addEdge('B', 'E');
graph.addEdge('C', 'F');

console.log('BFS from A:', graph.bfs('A'));
// ['A', 'B', 'C', 'D', 'E', 'F']

console.log('BFS from C:', graph.bfs('C'));
// ['C', 'A', 'F', 'B', 'D', 'E']
```

### **Approach 2: BFS with Level Tracking**
```javascript
/**
 * BFS that tracks levels/distances from start
 */
function bfsWithLevels(graph, start) {
  const visited = new Set();
  const queue = [[start, 0]]; // [vertex, level]
  const levels = {};
  
  visited.add(start);
  levels[start] = 0;
  
  while (queue.length > 0) {
    const [vertex, level] = queue.shift();
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        levels[neighbor] = level + 1;
        queue.push([neighbor, level + 1]);
      }
    }
  }
  
  return levels;
}

// Test
console.log('\n=== BFS with Levels ===');

const graph2 = new Graph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph2.addVertex(v));
graph2.addEdge('A', 'B');
graph2.addEdge('A', 'C');
graph2.addEdge('B', 'D');
graph2.addEdge('B', 'E');
graph2.addEdge('C', 'F');

console.log('Levels from A:', bfsWithLevels(graph2, 'A'));
// { A: 0, B: 1, C: 1, D: 2, E: 2, F: 2 }
```

### **Approach 3: BFS for Shortest Path**
```javascript
/**
 * BFS to find shortest path between two vertices
 */
function bfsShortestPath(graph, start, end) {
  const visited = new Set();
  const queue = [[start, [start]]]; // [vertex, path]
  
  visited.add(start);
  
  while (queue.length > 0) {
    const [vertex, path] = queue.shift();
    
    if (vertex === end) {
      return path;
    }
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push([neighbor, [...path, neighbor]]);
      }
    }
  }
  
  return null; // No path found
}

// Test
console.log('\n=== BFS Shortest Path ===');

const graph3 = new Graph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph3.addVertex(v));
graph3.addEdge('A', 'B');
graph3.addEdge('A', 'C');
graph3.addEdge('B', 'D');
graph3.addEdge('C', 'E');
graph3.addEdge('D', 'F');
graph3.addEdge('E', 'F');

console.log('Shortest path A to F:', bfsShortestPath(graph3, 'A', 'F'));
// ['A', 'B', 'D', 'F'] or ['A', 'C', 'E', 'F']
```

### **Approach 4: BFS for Disconnected Graphs**
```javascript
/**
 * BFS that handles disconnected graphs
 */
function bfsAllComponents(graph) {
  const visited = new Set();
  const components = [];
  
  function bfsComponent(start) {
    const queue = [start];
    const component = [];
    
    visited.add(start);
    
    while (queue.length > 0) {
      const vertex = queue.shift();
      component.push(vertex);
      
      for (const neighbor of graph.adjacencyList[vertex]) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }
    
    return component;
  }
  
  // Visit all vertices
  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      components.push(bfsComponent(vertex));
    }
  }
  
  return components;
}

// Test
console.log('\n=== BFS All Components ===');

const disconnectedGraph = new Graph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => disconnectedGraph.addVertex(v));

// Component 1: A - B - C
disconnectedGraph.addEdge('A', 'B');
disconnectedGraph.addEdge('B', 'C');

// Component 2: D - E
disconnectedGraph.addEdge('D', 'E');

// Component 3: F (isolated)

console.log('All components:', bfsAllComponents(disconnectedGraph));
// [['A', 'B', 'C'], ['D', 'E'], ['F']]
```

### **Approach 5: BFS on Matrix (Grid)**
```javascript
/**
 * BFS on 2D grid (common in problems)
 */
function bfsGrid(grid, startRow, startCol) {
  const rows = grid.length;
  const cols = grid[0].length;
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  const queue = [[startRow, startCol]];
  const result = [];
  
  visited[startRow][startCol] = true;
  
  // Directions: up, right, down, left
  const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
  
  while (queue.length > 0) {
    const [row, col] = queue.shift();
    result.push([row, col]);
    
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      
      if (
        newRow >= 0 && newRow < rows &&
        newCol >= 0 && newCol < cols &&
        !visited[newRow][newCol] &&
        grid[newRow][newCol] !== 0 // 0 represents obstacle
      ) {
        visited[newRow][newCol] = true;
        queue.push([newRow, newCol]);
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== BFS on Grid ===');

const grid = [
  [1, 1, 0, 1],
  [1, 1, 1, 0],
  [0, 1, 1, 1],
  [1, 0, 1, 1]
];

console.log('BFS from (0,0):');
const gridResult = bfsGrid(grid, 0, 0);
gridResult.forEach(([r, c]) => console.log(`  (${r},${c})`));
```

### **Bonus: Multi-Source BFS**
```javascript
/**
 * BFS from multiple starting points simultaneously
 * Useful for: rotten oranges, walls and gates problems
 */
function multiSourceBFS(graph, sources) {
  const visited = new Set();
  const queue = [];
  const distances = {};
  
  // Initialize queue with all sources
  for (const source of sources) {
    queue.push([source, 0]);
    visited.add(source);
    distances[source] = 0;
  }
  
  while (queue.length > 0) {
    const [vertex, distance] = queue.shift();
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        distances[neighbor] = distance + 1;
        queue.push([neighbor, distance + 1]);
      }
    }
  }
  
  return distances;
}

// Test
console.log('\n=== Multi-Source BFS ===');

const graph4 = new Graph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph4.addVertex(v));
graph4.addEdge('A', 'B');
graph4.addEdge('B', 'C');
graph4.addEdge('C', 'D');
graph4.addEdge('D', 'E');
graph4.addEdge('E', 'F');

// Start from both ends
console.log('Distances from [A, F]:', multiSourceBFS(graph4, ['A', 'F']));
// Nearest source to each vertex
```

### **Bonus: Bidirectional BFS**
```javascript
/**
 * Bidirectional BFS for faster pathfinding
 * Search from both start and end simultaneously
 */
function bidirectionalBFS(graph, start, end) {
  if (start === end) return [start];
  
  const visitedStart = new Map([[start, [start]]]);
  const visitedEnd = new Map([[end, [end]]]);
  const queueStart = [start];
  const queueEnd = [end];
  
  while (queueStart.length > 0 || queueEnd.length > 0) {
    // Expand from start
    if (queueStart.length > 0) {
      const vertex = queueStart.shift();
      
      for (const neighbor of graph.adjacencyList[vertex]) {
        if (visitedEnd.has(neighbor)) {
          // Paths met!
          return [
            ...visitedStart.get(vertex),
            ...visitedEnd.get(neighbor).reverse()
          ];
        }
        
        if (!visitedStart.has(neighbor)) {
          visitedStart.set(neighbor, [...visitedStart.get(vertex), neighbor]);
          queueStart.push(neighbor);
        }
      }
    }
    
    // Expand from end
    if (queueEnd.length > 0) {
      const vertex = queueEnd.shift();
      
      for (const neighbor of graph.adjacencyList[vertex]) {
        if (visitedStart.has(neighbor)) {
          // Paths met!
          return [
            ...visitedStart.get(neighbor),
            ...visitedEnd.get(vertex).reverse()
          ];
        }
        
        if (!visitedEnd.has(neighbor)) {
          visitedEnd.set(neighbor, [...visitedEnd.get(vertex), neighbor]);
          queueEnd.push(neighbor);
        }
      }
    }
  }
  
  return null; // No path
}

// Test
console.log('\n=== Bidirectional BFS ===');

const graph5 = new Graph();
for (let i = 0; i < 10; i++) {
  graph5.addVertex(i);
}

// Linear chain: 0-1-2-3-4-5-6-7-8-9
for (let i = 0; i < 9; i++) {
  graph5.addEdge(i, i + 1);
}

console.log('Bidirectional path 0 to 9:', bidirectionalBFS(graph5, 0, 9));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical BFS applications
 */

// 1. Social Network - Degrees of Separation
console.log('\n=== Social Network ===');

class SocialNetwork {
  constructor() {
    this.graph = new Graph();
  }
  
  addUser(user) {
    this.graph.addVertex(user);
  }
  
  addFriendship(user1, user2) {
    this.graph.addEdge(user1, user2);
  }
  
  degreesOfSeparation(user1, user2) {
    const levels = bfsWithLevels(this.graph, user1);
    return levels[user2] !== undefined ? levels[user2] : -1;
  }
  
  findMutualFriends(user1, user2) {
    const friends1 = new Set(this.graph.adjacencyList[user1]);
    const friends2 = new Set(this.graph.adjacencyList[user2]);
    
    return [...friends1].filter(friend => friends2.has(friend));
  }
}

const social = new SocialNetwork();
['Alice', 'Bob', 'Charlie', 'David', 'Eve'].forEach(u => social.addUser(u));
social.addFriendship('Alice', 'Bob');
social.addFriendship('Bob', 'Charlie');
social.addFriendship('Charlie', 'David');
social.addFriendship('Alice', 'Eve');
social.addFriendship('Eve', 'David');

console.log('Degrees Alice to David:', social.degreesOfSeparation('Alice', 'David'));
console.log('Mutual friends Alice & David:', social.findMutualFriends('Alice', 'David'));

// 2. Web Crawler
console.log('\n=== Web Crawler ===');

class WebCrawler {
  constructor(maxDepth = 3) {
    this.maxDepth = maxDepth;
    this.visited = new Set();
  }
  
  crawl(startUrl, links) {
    const queue = [[startUrl, 0]]; // [url, depth]
    const crawled = [];
    
    this.visited.add(startUrl);
    
    while (queue.length > 0) {
      const [url, depth] = queue.shift();
      
      console.log(`  Crawling: ${url} (depth ${depth})`);
      crawled.push(url);
      
      if (depth < this.maxDepth && links[url]) {
        for (const link of links[url]) {
          if (!this.visited.has(link)) {
            this.visited.add(link);
            queue.push([link, depth + 1]);
          }
        }
      }
    }
    
    return crawled;
  }
}

const links = {
  'home': ['about', 'contact', 'blog'],
  'about': ['team', 'careers'],
  'blog': ['post1', 'post2'],
  'team': ['member1', 'member2']
};

const crawler = new WebCrawler(2);
console.log('Crawled pages:', crawler.crawl('home', links));

// 3. Game - Find Shortest Path
console.log('\n=== Game Pathfinding ===');

function findShortestPath(maze, start, end) {
  const [startRow, startCol] = start;
  const [endRow, endCol] = end;
  
  const rows = maze.length;
  const cols = maze[0].length;
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  const queue = [[startRow, startCol, 0, [[startRow, startCol]]]]; // row, col, dist, path
  
  visited[startRow][startCol] = true;
  
  const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
  
  while (queue.length > 0) {
    const [row, col, dist, path] = queue.shift();
    
    if (row === endRow && col === endCol) {
      return { distance: dist, path };
    }
    
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      
      if (
        newRow >= 0 && newRow < rows &&
        newCol >= 0 && newCol < cols &&
        !visited[newRow][newCol] &&
        maze[newRow][newCol] === 0 // 0 = passable
      ) {
        visited[newRow][newCol] = true;
        queue.push([newRow, newCol, dist + 1, [...path, [newRow, newCol]]]);
      }
    }
  }
  
  return null; // No path
}

const maze = [
  [0, 0, 1, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 0, 1],
  [1, 1, 0, 1, 0],
  [0, 0, 0, 0, 0]
];

const pathResult = findShortestPath(maze, [0, 0], [4, 4]);
console.log('Shortest path:', pathResult);

// 4. Network Broadcasting
console.log('\n=== Network Broadcasting ===');

function broadcastTime(network, source) {
  const visited = new Set();
  const queue = [[source, 0]];
  const receiveTimes = {};
  
  visited.add(source);
  receiveTimes[source] = 0;
  
  while (queue.length > 0) {
    const [node, time] = queue.shift();
    
    for (const [neighbor, delay] of network[node] || []) {
      const arrivalTime = time + delay;
      
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        receiveTimes[neighbor] = arrivalTime;
        queue.push([neighbor, arrivalTime]);
      }
    }
  }
  
  return receiveTimes;
}

const network = {
  'A': [['B', 1], ['C', 2]],
  'B': [['D', 3]],
  'C': [['D', 1], ['E', 2]],
  'D': [['E', 1]]
};

console.log('Broadcast from A:', broadcastTime(network, 'A'));

// 5. Flood Fill (Paint Bucket)
console.log('\n=== Flood Fill ===');

function floodFill(image, sr, sc, newColor) {
  const rows = image.length;
  const cols = image[0].length;
  const originalColor = image[sr][sc];
  
  if (originalColor === newColor) return image;
  
  const queue = [[sr, sc]];
  image[sr][sc] = newColor;
  
  const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
  
  while (queue.length > 0) {
    const [row, col] = queue.shift();
    
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      
      if (
        newRow >= 0 && newRow < rows &&
        newCol >= 0 && newCol < cols &&
        image[newRow][newCol] === originalColor
      ) {
        image[newRow][newCol] = newColor;
        queue.push([newRow, newCol]);
      }
    }
  }
  
  return image;
}

const image = [
  [1, 1, 1],
  [1, 1, 0],
  [1, 0, 1]
];

console.log('Original image:', image);
const filled = floodFill(JSON.parse(JSON.stringify(image)), 1, 1, 2);
console.log('After flood fill (1,1) with 2:', filled);
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Single node
const singleGraph = new Graph();
singleGraph.addVertex('A');
console.log('BFS single node:', singleGraph.bfs('A')); // ['A']

// No edges
const isolatedGraph = new Graph();
['A', 'B', 'C'].forEach(v => isolatedGraph.addVertex(v));
console.log('BFS isolated nodes:', isolatedGraph.bfs('A')); // ['A']

// Cyclic graph
const cyclicGraph = new Graph();
['A', 'B', 'C', 'D'].forEach(v => cyclicGraph.addVertex(v));
cyclicGraph.addEdge('A', 'B');
cyclicGraph.addEdge('B', 'C');
cyclicGraph.addEdge('C', 'D');
cyclicGraph.addEdge('D', 'A'); // Creates cycle
console.log('BFS cyclic graph:', cyclicGraph.bfs('A'));

// Self-loop
const selfLoopGraph = new Graph();
selfLoopGraph.addVertex('A');
selfLoopGraph.adjacencyList['A'].push('A'); // Self-loop
console.log('BFS with self-loop:', selfLoopGraph.bfs('A'));

// Non-existent start
const testGraph = new Graph();
testGraph.addVertex('A');
console.log('BFS non-existent start:', testGraph.bfs('Z')); // []
```

### **Performance Analysis**
```javascript
console.log('\n=== Performance ===');

console.log(`
Time Complexity Analysis:
• BFS: O(V + E) where V = vertices, E = edges
  - Each vertex visited once: O(V)
  - Each edge explored once: O(E)
  - Total: O(V + E)

• Space Complexity: O(V)
  - Queue size: O(V) worst case
  - Visited set: O(V)
  - Path storage: O(V) per path

Grid BFS:
• Time: O(rows × cols)
• Space: O(rows × cols)

Optimization Techniques:
1. Use deque instead of array.shift() for O(1) queue operations
2. Bidirectional BFS: reduces time from O(b^d) to O(b^(d/2))
3. Early termination when target found
4. Use visited set, not array search (O(1) vs O(n))
5. Store only indices for grid, not full coordinates

BFS vs DFS:
┌─────────────────┬─────────────┬─────────────┐
│ Aspect          │ BFS         │ DFS         │
├─────────────────┼─────────────┼─────────────┤
│ Data Structure  │ Queue       │ Stack/Recursion│
│ Shortest Path   │ Yes         │ No          │
│ Memory          │ O(V)        │ O(h)        │
│ Complete        │ Yes         │ No (cycles) │
│ Optimal         │ Yes (unweighted)│ No       │
└─────────────────┴─────────────┴─────────────┘

When to use BFS:
• Finding shortest path (unweighted)
• Level-order traversal
• Social network analysis
• Web crawling
• Broadcasting/flooding
• Minimum steps problems
`);
```

**Interview Tips:**
- BFS: explore level by level using queue (FIFO)
- Algorithm: add start to queue, mark visited, dequeue, process, enqueue unvisited neighbors
- Data structures: queue for traversal, Set for visited tracking
- Time: O(V + E) visit each vertex once, explore each edge once
- Space: O(V) for queue and visited set
- Shortest path: BFS finds shortest path in unweighted graph
- Level tracking: store depth/distance with each vertex in queue
- Grid BFS: treat as implicit graph, use 4 or 8 directions
- Applications: shortest path, social networks, web crawling, flood fill, game pathfinding
- Multi-source: start from multiple nodes simultaneously
- Bidirectional: search from both ends, meet in middle, faster for single source-target
- Queue operations: use deque or circular buffer for O(1) enqueue/dequeue (array.shift() is O(n))
- Visited timing: mark as visited when enqueuing, not when dequeuing (prevents duplicates in queue)
- Disconnected graphs: run BFS from each unvisited vertex to find all components
- Edge cases: empty graph, single node, cycles, self-loops, disconnected components
- vs DFS: BFS uses more memory but finds shortest paths, DFS uses less memory but explores deep first
- Optimization: early termination, bidirectional search, efficient queue implementation
- Clarify: directed or undirected? weighted? need path or just reachability? single target or all vertices?
- Follow-ups: implement with adjacency matrix, add edge weights, find all paths, detect bipartite

</details>

99. Implement depth-first search (DFS) on a graph

<details>
<summary><b>Solution</b></summary>

### **Approach 1: DFS with Recursion**
```javascript
/**
 * Depth-First Search using recursion
 * Time Complexity: O(V + E) where V is vertices, E is edges
 * Space Complexity: O(V) for recursion stack and visited set
 */
class Graph {
  constructor() {
    this.adjacencyList = {};
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }
  
  addEdge(v1, v2) {
    this.adjacencyList[v1].push(v2);
    this.adjacencyList[v2].push(v1); // Undirected
  }
  
  dfsRecursive(start) {
    const visited = new Set();
    const result = [];
    
    const dfs = (vertex) => {
      visited.add(vertex);
      result.push(vertex);
      
      for (const neighbor of this.adjacencyList[vertex]) {
        if (!visited.has(neighbor)) {
          dfs(neighbor);
        }
      }
    };
    
    dfs(start);
    return result;
  }
}

// Test
console.log('=== Recursive DFS ===');

const graph = new Graph();

// Build graph:
//     A
//    / \
//   B   C
//  / \   \
// D   E   F

['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph.addVertex(v));
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('B', 'D');
graph.addEdge('B', 'E');
graph.addEdge('C', 'F');

console.log('DFS from A:', graph.dfsRecursive('A'));
// ['A', 'B', 'D', 'E', 'C', 'F'] (depth-first order)
```

### **Approach 2: DFS with Iterative Stack**
```javascript
/**
 * Iterative DFS using explicit stack
 */
class GraphIterative extends Graph {
  dfsIterative(start) {
    const visited = new Set();
    const stack = [start];
    const result = [];
    
    visited.add(start);
    
    while (stack.length > 0) {
      const vertex = stack.pop();
      result.push(vertex);
      
      // Add neighbors to stack (reverse order for same result as recursive)
      const neighbors = [...this.adjacencyList[vertex]].reverse();
      
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          stack.push(neighbor);
        }
      }
    }
    
    return result;
  }
}

// Test
console.log('\n=== Iterative DFS ===');

const graph2 = new GraphIterative();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph2.addVertex(v));
graph2.addEdge('A', 'B');
graph2.addEdge('A', 'C');
graph2.addEdge('B', 'D');
graph2.addEdge('B', 'E');
graph2.addEdge('C', 'F');

console.log('DFS iterative from A:', graph2.dfsIterative('A'));
```

### **Approach 3: DFS with Path Finding**
```javascript
/**
 * DFS to find a path between two vertices
 */
function dfsPath(graph, start, end, visited = new Set(), path = []) {
  visited.add(start);
  path.push(start);
  
  if (start === end) {
    return [...path]; // Found path
  }
  
  for (const neighbor of graph.adjacencyList[start]) {
    if (!visited.has(neighbor)) {
      const result = dfsPath(graph, neighbor, end, visited, path);
      if (result) {
        return result;
      }
    }
  }
  
  path.pop(); // Backtrack
  return null;
}

// Find all paths
function dfsAllPaths(graph, start, end, visited = new Set(), path = [], allPaths = []) {
  visited.add(start);
  path.push(start);
  
  if (start === end) {
    allPaths.push([...path]);
  } else {
    for (const neighbor of graph.adjacencyList[start]) {
      if (!visited.has(neighbor)) {
        dfsAllPaths(graph, neighbor, end, visited, path, allPaths);
      }
    }
  }
  
  path.pop();
  visited.delete(start); // Allow revisiting for other paths
  
  return allPaths;
}

// Test
console.log('\n=== DFS Path Finding ===');

const graph3 = new Graph();
['A', 'B', 'C', 'D', 'E'].forEach(v => graph3.addVertex(v));
graph3.addEdge('A', 'B');
graph3.addEdge('A', 'C');
graph3.addEdge('B', 'D');
graph3.addEdge('C', 'D');
graph3.addEdge('D', 'E');

console.log('One path A to E:', dfsPath(graph3, 'A', 'E'));
console.log('All paths A to E:', dfsAllPaths(graph3, 'A', 'E'));
```

### **Approach 4: DFS for Cycle Detection**
```javascript
/**
 * DFS to detect cycles in undirected graph
 */
function hasCycleUndirected(graph) {
  const visited = new Set();
  
  function dfs(vertex, parent) {
    visited.add(vertex);
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        if (dfs(neighbor, vertex)) {
          return true;
        }
      } else if (neighbor !== parent) {
        // Visited and not parent = cycle
        return true;
      }
    }
    
    return false;
  }
  
  // Check all components
  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      if (dfs(vertex, null)) {
        return true;
      }
    }
  }
  
  return false;
}

// DFS for cycle detection in directed graph
function hasCycleDirected(graph) {
  const visited = new Set();
  const recStack = new Set(); // Recursion stack
  
  function dfs(vertex) {
    visited.add(vertex);
    recStack.add(vertex);
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        if (dfs(neighbor)) {
          return true;
        }
      } else if (recStack.has(neighbor)) {
        // In current path = cycle
        return true;
      }
    }
    
    recStack.delete(vertex);
    return false;
  }
  
  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      if (dfs(vertex)) {
        return true;
      }
    }
  }
  
  return false;
}

// Test
console.log('\n=== Cycle Detection ===');

const cyclicGraph = new Graph();
['A', 'B', 'C', 'D'].forEach(v => cyclicGraph.addVertex(v));
cyclicGraph.addEdge('A', 'B');
cyclicGraph.addEdge('B', 'C');
cyclicGraph.addEdge('C', 'D');
cyclicGraph.addEdge('D', 'A'); // Creates cycle

console.log('Has cycle (undirected):', hasCycleUndirected(cyclicGraph)); // true

const acyclicGraph = new Graph();
['A', 'B', 'C', 'D'].forEach(v => acyclicGraph.addVertex(v));
acyclicGraph.addEdge('A', 'B');
acyclicGraph.addEdge('B', 'C');
acyclicGraph.addEdge('C', 'D');

console.log('Has cycle (acyclic):', hasCycleUndirected(acyclicGraph)); // false
```

### **Approach 5: DFS with Timestamps (Discovery/Finish)**
```javascript
/**
 * DFS with discovery and finish timestamps
 * Useful for topological sorting and finding SCCs
 */
function dfsWithTimestamps(graph) {
  const visited = new Set();
  const discovery = {};
  const finish = {};
  let time = 0;
  
  function dfs(vertex) {
    visited.add(vertex);
    discovery[vertex] = ++time;
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        dfs(neighbor);
      }
    }
    
    finish[vertex] = ++time;
  }
  
  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      dfs(vertex);
    }
  }
  
  return { discovery, finish };
}

// Test
console.log('\n=== DFS with Timestamps ===');

const graph4 = new Graph();
['A', 'B', 'C', 'D'].forEach(v => graph4.addVertex(v));
graph4.addEdge('A', 'B');
graph4.addEdge('B', 'C');
graph4.addEdge('A', 'D');

const timestamps = dfsWithTimestamps(graph4);
console.log('Discovery times:', timestamps.discovery);
console.log('Finish times:', timestamps.finish);
```

### **Bonus: DFS on Grid/Matrix**
```javascript
/**
 * DFS on 2D grid
 */
function dfsGrid(grid, row, col, visited = null) {
  const rows = grid.length;
  const cols = grid[0].length;
  
  if (!visited) {
    visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  }
  
  const result = [];
  
  function dfs(r, c) {
    if (
      r < 0 || r >= rows ||
      c < 0 || c >= cols ||
      visited[r][c] ||
      grid[r][c] === 0 // 0 = obstacle
    ) {
      return;
    }
    
    visited[r][c] = true;
    result.push([r, c]);
    
    // Visit all 4 directions
    dfs(r - 1, c); // Up
    dfs(r, c + 1); // Right
    dfs(r + 1, c); // Down
    dfs(r, c - 1); // Left
  }
  
  dfs(row, col);
  return result;
}

// Count islands problem
function countIslands(grid) {
  const rows = grid.length;
  const cols = grid[0].length;
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  let count = 0;
  
  function dfs(r, c) {
    if (
      r < 0 || r >= rows ||
      c < 0 || c >= cols ||
      visited[r][c] ||
      grid[r][c] === 0
    ) {
      return;
    }
    
    visited[r][c] = true;
    
    dfs(r - 1, c);
    dfs(r, c + 1);
    dfs(r + 1, c);
    dfs(r, c - 1);
  }
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c] === 1 && !visited[r][c]) {
        dfs(r, c);
        count++;
      }
    }
  }
  
  return count;
}

// Test
console.log('\n=== DFS on Grid ===');

const grid = [
  [1, 1, 0, 0],
  [1, 0, 0, 1],
  [0, 0, 1, 1],
  [0, 0, 0, 1]
];

console.log('DFS from (0,0):', dfsGrid(grid, 0, 0));

const islandGrid = [
  [1, 1, 0, 0, 0],
  [1, 1, 0, 0, 1],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 1, 1]
];

console.log('Number of islands:', countIslands(islandGrid)); // 4
```

### **Real-World Use Cases**
```javascript
/**
 * Practical DFS applications
 */

// 1. Maze Solver
console.log('\n=== Maze Solver ===');

function solveMaze(maze, start, end) {
  const [startRow, startCol] = start;
  const [endRow, endCol] = end;
  const rows = maze.length;
  const cols = maze[0].length;
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  
  function dfs(r, c, path) {
    if (r < 0 || r >= rows || c < 0 || c >= cols || visited[r][c] || maze[r][c] === 1) {
      return null;
    }
    
    visited[r][c] = true;
    path.push([r, c]);
    
    if (r === endRow && c === endCol) {
      return path;
    }
    
    // Try all directions
    const result = 
      dfs(r - 1, c, path) ||
      dfs(r, c + 1, path) ||
      dfs(r + 1, c, path) ||
      dfs(r, c - 1, path);
    
    if (result) return result;
    
    path.pop(); // Backtrack
    return null;
  }
  
  return dfs(startRow, startCol, []);
}

const maze = [
  [0, 0, 1, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 0, 1],
  [1, 1, 0, 1, 0],
  [0, 0, 0, 0, 0]
];

console.log('Maze solution:', solveMaze(maze, [0, 0], [4, 4]));

// 2. File System Traversal
console.log('\n=== File System ===');

class FileSystem {
  constructor() {
    this.structure = {
      name: 'root',
      type: 'folder',
      children: []
    };
  }
  
  dfsTraversal(node = this.structure, depth = 0) {
    const indent = '  '.repeat(depth);
    console.log(`${indent}${node.name} (${node.type})`);
    
    if (node.children) {
      for (const child of node.children) {
        this.dfsTraversal(child, depth + 1);
      }
    }
  }
  
  findFile(name, node = this.structure) {
    if (node.name === name) {
      return node;
    }
    
    if (node.children) {
      for (const child of node.children) {
        const result = this.findFile(name, child);
        if (result) return result;
      }
    }
    
    return null;
  }
}

const fs = new FileSystem();
fs.structure.children = [
  {
    name: 'documents',
    type: 'folder',
    children: [
      { name: 'file1.txt', type: 'file' },
      { name: 'file2.txt', type: 'file' }
    ]
  },
  {
    name: 'photos',
    type: 'folder',
    children: [
      { name: 'pic1.jpg', type: 'file' }
    ]
  }
];

console.log('File system structure:');
fs.dfsTraversal();

console.log('\nFind file "pic1.jpg":', fs.findFile('pic1.jpg'));

// 3. Dependency Resolution
console.log('\n=== Dependency Resolution ===');

class DependencyGraph {
  constructor() {
    this.graph = {};
  }
  
  addPackage(pkg, dependencies = []) {
    this.graph[pkg] = dependencies;
  }
  
  getInstallOrder(pkg, visited = new Set(), stack = []) {
    if (visited.has(pkg)) {
      return;
    }
    
    visited.add(pkg);
    
    for (const dep of this.graph[pkg] || []) {
      this.getInstallOrder(dep, visited, stack);
    }
    
    stack.push(pkg);
    return stack;
  }
  
  hasCyclicDependency(pkg, visited = new Set(), recStack = new Set()) {
    visited.add(pkg);
    recStack.add(pkg);
    
    for (const dep of this.graph[pkg] || []) {
      if (!visited.has(dep)) {
        if (this.hasCyclicDependency(dep, visited, recStack)) {
          return true;
        }
      } else if (recStack.has(dep)) {
        return true; // Cycle detected
      }
    }
    
    recStack.delete(pkg);
    return false;
  }
}

const deps = new DependencyGraph();
deps.addPackage('app', ['express', 'mongoose']);
deps.addPackage('express', ['body-parser']);
deps.addPackage('mongoose', ['mongodb']);
deps.addPackage('body-parser', []);
deps.addPackage('mongodb', []);

console.log('Install order for app:', deps.getInstallOrder('app'));
console.log('Has cyclic dependency:', deps.hasCyclicDependency('app'));

// 4. Connected Components
console.log('\n=== Connected Components ===');

function findConnectedComponents(graph) {
  const visited = new Set();
  const components = [];
  
  function dfs(vertex, component) {
    visited.add(vertex);
    component.push(vertex);
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        dfs(neighbor, component);
      }
    }
  }
  
  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      const component = [];
      dfs(vertex, component);
      components.push(component);
    }
  }
  
  return components;
}

const disconnected = new Graph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => disconnected.addVertex(v));
disconnected.addEdge('A', 'B');
disconnected.addEdge('B', 'C');
disconnected.addEdge('D', 'E');

console.log('Connected components:', findConnectedComponents(disconnected));

// 5. Sudoku Solver
console.log('\n=== Sudoku Solver ===');

function solveSudoku(board) {
  function isValid(board, row, col, num) {
    // Check row
    for (let c = 0; c < 9; c++) {
      if (board[row][c] === num) return false;
    }
    
    // Check column
    for (let r = 0; r < 9; r++) {
      if (board[r][col] === num) return false;
    }
    
    // Check 3x3 box
    const boxRow = Math.floor(row / 3) * 3;
    const boxCol = Math.floor(col / 3) * 3;
    for (let r = boxRow; r < boxRow + 3; r++) {
      for (let c = boxCol; c < boxCol + 3; c++) {
        if (board[r][c] === num) return false;
      }
    }
    
    return true;
  }
  
  function solve() {
    for (let row = 0; row < 9; row++) {
      for (let col = 0; col < 9; col++) {
        if (board[row][col] === 0) {
          for (let num = 1; num <= 9; num++) {
            if (isValid(board, row, col, num)) {
              board[row][col] = num;
              
              if (solve()) {
                return true;
              }
              
              board[row][col] = 0; // Backtrack
            }
          }
          return false;
        }
      }
    }
    return true;
  }
  
  solve();
  return board;
}

const sudoku = [
  [5, 3, 0, 0, 7, 0, 0, 0, 0],
  [6, 0, 0, 1, 9, 5, 0, 0, 0],
  [0, 9, 8, 0, 0, 0, 0, 6, 0],
  [8, 0, 0, 0, 6, 0, 0, 0, 3],
  [4, 0, 0, 8, 0, 3, 0, 0, 1],
  [7, 0, 0, 0, 2, 0, 0, 0, 6],
  [0, 6, 0, 0, 0, 0, 2, 8, 0],
  [0, 0, 0, 4, 1, 9, 0, 0, 5],
  [0, 0, 0, 0, 8, 0, 0, 7, 9]
];

console.log('Sudoku solved:', solveSudoku(sudoku)[0].join(' '));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty graph
const emptyGraph = new Graph();
console.log('DFS empty graph:', emptyGraph.dfsRecursive('A')); // []

// Single vertex
const singleGraph = new Graph();
singleGraph.addVertex('A');
console.log('DFS single vertex:', singleGraph.dfsRecursive('A')); // ['A']

// Self-loop
const selfLoop = new Graph();
selfLoop.addVertex('A');
selfLoop.adjacencyList['A'].push('A');
console.log('DFS self-loop:', selfLoop.dfsRecursive('A')); // ['A']

// Dense graph
const denseGraph = new Graph();
for (let i = 0; i < 5; i++) {
  denseGraph.addVertex(i);
  for (let j = 0; j < i; j++) {
    denseGraph.addEdge(i, j);
  }
}
console.log('DFS dense graph:', denseGraph.dfsRecursive(0));

// Stack overflow protection (very deep recursion)
const deepGraph = new Graph();
for (let i = 0; i < 100; i++) {
  deepGraph.addVertex(i);
  if (i > 0) {
    deepGraph.addEdge(i - 1, i);
  }
}
console.log('DFS deep graph (first 5):', deepGraph.dfsRecursive(0).slice(0, 5));
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Time & Space Complexity:
┌──────────────────┬─────────────┬─────────────┐
│ Aspect           │ DFS         │ BFS         │
├──────────────────┼─────────────┼─────────────┤
│ Time             │ O(V + E)    │ O(V + E)    │
│ Space (recursive)│ O(V)        │ O(V)        │
│ Space (iterative)│ O(V)        │ O(V)        │
│ Data Structure   │ Stack/Call  │ Queue       │
│ Shortest Path    │ No          │ Yes         │
│ Memory (worst)   │ O(h) height │ O(w) width  │
└──────────────────┴─────────────┴─────────────┘

When to use DFS:
• Pathfinding (any path, not shortest)
• Cycle detection
• Topological sorting
• Strongly connected components
• Maze solving with backtracking
• Exhaustive search (all solutions)
• Tree traversals (pre/in/post-order)
• Dependency resolution

DFS Advantages:
• Less memory for narrow/tall graphs
• Natural for recursion
• Good for exhaustive search
• Backtracking friendly

DFS Disadvantages:
• Doesn't find shortest path
• Can get stuck in infinite paths (needs cycle detection)
• Stack overflow risk for deep recursion

Optimization:
• Use iterative version for very deep graphs
• Tail recursion optimization
• Early termination when target found
• Path compression for repeated searches
`);
```

**Interview Tips:**
- DFS: explore as deep as possible before backtracking
- Implementation: recursion (implicit stack) or explicit stack (iterative)
- Recursive: simpler code, natural backtracking, risk of stack overflow
- Iterative: explicit stack, more control, no recursion limit
- Time: O(V + E) visit each vertex once, explore each edge once
- Space: O(V) for visited set, O(h) for recursion stack where h is height
- Applications: pathfinding, cycle detection, topological sort, maze solving, dependency resolution
- Backtracking: DFS naturally supports undo operations (pop from path)
- Pre-order: process before children (useful for copying)
- Post-order: process after children (useful for deletion, topological sort)
- Cycle detection: track recursion stack (directed) or parent (undirected)
- All paths: remove from visited on backtrack to allow revisiting
- Grid DFS: check bounds, visited, and obstacles; use recursion for 4/8 directions
- vs BFS: DFS uses less memory for tall graphs, doesn't guarantee shortest path
- Stack overflow: switch to iterative for very deep graphs (>10k depth)
- Edge cases: empty graph, single node, cycles, self-loops, disconnected components
- Mark visited: when entering function, not when adding to stack
- Optimization: iterative for depth, memoization for repeated subproblems
- Clarify: directed or undirected? need all paths or just one? detect cycles? max depth limit?
- Follow-ups: find all paths, detect cycle and return it, add path cost, implement iteratively

</details>

100. Find the shortest path in a graph (Dijkstra's algorithm)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Dijkstra with Array**
```javascript
/**
 * Dijkstra's Algorithm for shortest path in weighted graph
 * Time Complexity: O(V²) with array implementation
 * Space Complexity: O(V)
 */
class WeightedGraph {
  constructor() {
    this.adjacencyList = {};
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }
  
  addEdge(v1, v2, weight) {
    this.adjacencyList[v1].push({ node: v2, weight });
    this.adjacencyList[v2].push({ node: v1, weight }); // Undirected
  }
  
  dijkstra(start, end) {
    const distances = {};
    const previous = {};
    const unvisited = new Set();
    
    // Initialize
    for (const vertex in this.adjacencyList) {
      distances[vertex] = vertex === start ? 0 : Infinity;
      previous[vertex] = null;
      unvisited.add(vertex);
    }
    
    while (unvisited.size > 0) {
      // Find vertex with minimum distance
      let minVertex = null;
      let minDistance = Infinity;
      
      for (const vertex of unvisited) {
        if (distances[vertex] < minDistance) {
          minDistance = distances[vertex];
          minVertex = vertex;
        }
      }
      
      if (minVertex === null || minDistance === Infinity) {
        break; // No path to remaining vertices
      }
      
      unvisited.delete(minVertex);
      
      // Early termination if we reached the end
      if (minVertex === end) {
        break;
      }
      
      // Update distances to neighbors
      for (const neighbor of this.adjacencyList[minVertex]) {
        if (unvisited.has(neighbor.node)) {
          const newDistance = distances[minVertex] + neighbor.weight;
          
          if (newDistance < distances[neighbor.node]) {
            distances[neighbor.node] = newDistance;
            previous[neighbor.node] = minVertex;
          }
        }
      }
    }
    
    // Reconstruct path
    const path = [];
    let current = end;
    
    while (current !== null) {
      path.unshift(current);
      current = previous[current];
    }
    
    return {
      distance: distances[end],
      path: distances[end] === Infinity ? [] : path
    };
  }
}

// Test
console.log('=== Basic Dijkstra ===');

const graph = new WeightedGraph();

//      A
//    /   \
//   4     2
//  /       \
// B----1----C
//  \       /
//   3     5
//    \   /
//      D

['A', 'B', 'C', 'D'].forEach(v => graph.addVertex(v));
graph.addEdge('A', 'B', 4);
graph.addEdge('A', 'C', 2);
graph.addEdge('B', 'C', 1);
graph.addEdge('B', 'D', 3);
graph.addEdge('C', 'D', 5);

console.log('Shortest path A to D:', graph.dijkstra('A', 'D'));
// { distance: 7, path: ['A', 'B', 'D'] }
```

### **Approach 2: Dijkstra with Priority Queue (Min Heap)**
```javascript
/**
 * Optimized Dijkstra using priority queue
 * Time Complexity: O((V + E) log V)
 * Space Complexity: O(V)
 */
class MinHeap {
  constructor() {
    this.heap = [];
  }
  
  push(value, priority) {
    this.heap.push({ value, priority });
    this.bubbleUp(this.heap.length - 1);
  }
  
  pop() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();
    
    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    
    return min;
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      
      if (this.heap[index].priority >= this.heap[parentIndex].priority) {
        break;
      }
      
      [this.heap[index], this.heap[parentIndex]] = 
        [this.heap[parentIndex], this.heap[index]];
      
      index = parentIndex;
    }
  }
  
  bubbleDown(index) {
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let smallest = index;
      
      if (
        leftChild < this.heap.length &&
        this.heap[leftChild].priority < this.heap[smallest].priority
      ) {
        smallest = leftChild;
      }
      
      if (
        rightChild < this.heap.length &&
        this.heap[rightChild].priority < this.heap[smallest].priority
      ) {
        smallest = rightChild;
      }
      
      if (smallest === index) break;
      
      [this.heap[index], this.heap[smallest]] = 
        [this.heap[smallest], this.heap[index]];
      
      index = smallest;
    }
  }
  
  isEmpty() {
    return this.heap.length === 0;
  }
}

class OptimizedWeightedGraph extends WeightedGraph {
  dijkstraOptimized(start, end) {
    const distances = {};
    const previous = {};
    const pq = new MinHeap();
    
    // Initialize
    for (const vertex in this.adjacencyList) {
      distances[vertex] = vertex === start ? 0 : Infinity;
      previous[vertex] = null;
    }
    
    pq.push(start, 0);
    
    while (!pq.isEmpty()) {
      const { value: current, priority: currentDistance } = pq.pop();
      
      // Early termination
      if (current === end) {
        break;
      }
      
      // Skip if we've found a better path already
      if (currentDistance > distances[current]) {
        continue;
      }
      
      // Check neighbors
      for (const neighbor of this.adjacencyList[current]) {
        const newDistance = distances[current] + neighbor.weight;
        
        if (newDistance < distances[neighbor.node]) {
          distances[neighbor.node] = newDistance;
          previous[neighbor.node] = current;
          pq.push(neighbor.node, newDistance);
        }
      }
    }
    
    // Reconstruct path
    const path = [];
    let current = end;
    
    while (current !== null) {
      path.unshift(current);
      current = previous[current];
    }
    
    return {
      distance: distances[end],
      path: distances[end] === Infinity ? [] : path
    };
  }
}

// Test
console.log('\n=== Optimized Dijkstra ===');

const graph2 = new OptimizedWeightedGraph();
['A', 'B', 'C', 'D', 'E'].forEach(v => graph2.addVertex(v));
graph2.addEdge('A', 'B', 4);
graph2.addEdge('A', 'C', 2);
graph2.addEdge('B', 'C', 1);
graph2.addEdge('B', 'D', 5);
graph2.addEdge('C', 'D', 8);
graph2.addEdge('C', 'E', 10);
graph2.addEdge('D', 'E', 2);

console.log('Shortest path A to E:', graph2.dijkstraOptimized('A', 'E'));
// { distance: 11, path: ['A', 'B', 'D', 'E'] }
```

### **Approach 3: Dijkstra with All Paths**
```javascript
/**
 * Find shortest distances to all vertices from source
 */
function dijkstraAll(graph, start) {
  const distances = {};
  const previous = {};
  const visited = new Set();
  const pq = new MinHeap();
  
  // Initialize
  for (const vertex in graph.adjacencyList) {
    distances[vertex] = vertex === start ? 0 : Infinity;
    previous[vertex] = null;
  }
  
  pq.push(start, 0);
  
  while (!pq.isEmpty()) {
    const { value: current } = pq.pop();
    
    if (visited.has(current)) continue;
    visited.add(current);
    
    for (const neighbor of graph.adjacencyList[current]) {
      const newDistance = distances[current] + neighbor.weight;
      
      if (newDistance < distances[neighbor.node]) {
        distances[neighbor.node] = newDistance;
        previous[neighbor.node] = current;
        pq.push(neighbor.node, newDistance);
      }
    }
  }
  
  return { distances, previous };
}

// Helper to reconstruct any path
function reconstructPath(previous, start, end) {
  const path = [];
  let current = end;
  
  while (current !== null) {
    path.unshift(current);
    current = previous[current];
  }
  
  return path[0] === start ? path : [];
}

// Test
console.log('\n=== Dijkstra All Paths ===');

const graph3 = new OptimizedWeightedGraph();
['A', 'B', 'C', 'D', 'E'].forEach(v => graph3.addVertex(v));
graph3.addEdge('A', 'B', 4);
graph3.addEdge('A', 'C', 2);
graph3.addEdge('B', 'D', 5);
graph3.addEdge('C', 'D', 8);
graph3.addEdge('C', 'E', 10);
graph3.addEdge('D', 'E', 2);

const { distances, previous } = dijkstraAll(graph3, 'A');
console.log('Distances from A:', distances);
console.log('Path to E:', reconstructPath(previous, 'A', 'E'));
```

### **Approach 4: Dijkstra on Grid**
```javascript
/**
 * Dijkstra for weighted grid (common in games)
 */
function dijkstraGrid(grid, start, end) {
  const [startRow, startCol] = start;
  const [endRow, endCol] = end;
  const rows = grid.length;
  const cols = grid[0].length;
  
  const distances = Array.from({ length: rows }, () => 
    Array(cols).fill(Infinity)
  );
  
  const previous = Array.from({ length: rows }, () => 
    Array(cols).fill(null)
  );
  
  const pq = new MinHeap();
  
  distances[startRow][startCol] = 0;
  pq.push([startRow, startCol], 0);
  
  const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
  
  while (!pq.isEmpty()) {
    const { value: [row, col], priority: dist } = pq.pop();
    
    if (row === endRow && col === endCol) {
      break;
    }
    
    if (dist > distances[row][col]) {
      continue;
    }
    
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      
      if (
        newRow >= 0 && newRow < rows &&
        newCol >= 0 && newCol < cols &&
        grid[newRow][newCol] !== -1 // -1 = obstacle
      ) {
        const newDistance = distances[row][col] + grid[newRow][newCol];
        
        if (newDistance < distances[newRow][newCol]) {
          distances[newRow][newCol] = newDistance;
          previous[newRow][newCol] = [row, col];
          pq.push([newRow, newCol], newDistance);
        }
      }
    }
  }
  
  // Reconstruct path
  const path = [];
  let current = [endRow, endCol];
  
  while (current !== null) {
    path.unshift(current);
    current = previous[current[0]][current[1]];
  }
  
  return {
    distance: distances[endRow][endCol],
    path: distances[endRow][endCol] === Infinity ? [] : path
  };
}

// Test
console.log('\n=== Dijkstra on Grid ===');

// Grid values represent cost to enter that cell
const weightedGrid = [
  [1, 3, 1, 2],
  [2, 1, 4, 1],
  [1, 2, 1, 3],
  [3, 1, 2, 1]
];

const gridResult = dijkstraGrid(weightedGrid, [0, 0], [3, 3]);
console.log('Shortest path cost:', gridResult.distance);
console.log('Path:', gridResult.path);
```

### **Approach 5: A* Algorithm (Dijkstra with Heuristic)**
```javascript
/**
 * A* algorithm - Dijkstra with heuristic for faster pathfinding
 */
function aStarGrid(grid, start, end) {
  const [startRow, startCol] = start;
  const [endRow, endCol] = end;
  const rows = grid.length;
  const cols = grid[0].length;
  
  // Heuristic: Manhattan distance
  const heuristic = (row, col) => {
    return Math.abs(row - endRow) + Math.abs(col - endCol);
  };
  
  const gScore = Array.from({ length: rows }, () => 
    Array(cols).fill(Infinity)
  );
  
  const fScore = Array.from({ length: rows }, () => 
    Array(cols).fill(Infinity)
  );
  
  const previous = Array.from({ length: rows }, () => 
    Array(cols).fill(null)
  );
  
  gScore[startRow][startCol] = 0;
  fScore[startRow][startCol] = heuristic(startRow, startCol);
  
  const pq = new MinHeap();
  pq.push([startRow, startCol], fScore[startRow][startCol]);
  
  const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
  
  while (!pq.isEmpty()) {
    const { value: [row, col] } = pq.pop();
    
    if (row === endRow && col === endCol) {
      break;
    }
    
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      
      if (
        newRow >= 0 && newRow < rows &&
        newCol >= 0 && newCol < cols &&
        grid[newRow][newCol] !== -1
      ) {
        const tentativeG = gScore[row][col] + grid[newRow][newCol];
        
        if (tentativeG < gScore[newRow][newCol]) {
          previous[newRow][newCol] = [row, col];
          gScore[newRow][newCol] = tentativeG;
          fScore[newRow][newCol] = tentativeG + heuristic(newRow, newCol);
          pq.push([newRow, newCol], fScore[newRow][newCol]);
        }
      }
    }
  }
  
  // Reconstruct path
  const path = [];
  let current = [endRow, endCol];
  
  while (current !== null) {
    path.unshift(current);
    current = previous[current[0]][current[1]];
  }
  
  return {
    distance: gScore[endRow][endCol],
    path: gScore[endRow][endCol] === Infinity ? [] : path
  };
}

// Test
console.log('\n=== A* Algorithm ===');

const astarGrid = [
  [1, 1, 1, 1, 1],
  [1, -1, -1, -1, 1],
  [1, 1, 1, 1, 1],
  [1, -1, -1, -1, 1],
  [1, 1, 1, 1, 1]
];

const astarResult = aStarGrid(astarGrid, [0, 0], [4, 4]);
console.log('A* shortest path:', astarResult.path);
```

### **Real-World Use Cases**
```javascript
/**
 * Practical Dijkstra applications
 */

// 1. GPS Navigation System
console.log('\n=== GPS Navigation ===');

class NavigationSystem {
  constructor() {
    this.map = new OptimizedWeightedGraph();
  }
  
  addLocation(name) {
    this.map.addVertex(name);
  }
  
  addRoute(from, to, distance, traffic = 1) {
    // Weight considers distance and traffic
    const weight = distance * traffic;
    this.map.addEdge(from, to, weight);
  }
  
  findRoute(start, end) {
    const result = this.map.dijkstraOptimized(start, end);
    return {
      ...result,
      estimatedTime: Math.round(result.distance / 60) // Convert to minutes
    };
  }
}

const gps = new NavigationSystem();

['Home', 'Work', 'Store', 'School', 'Park'].forEach(loc => 
  gps.addLocation(loc)
);

gps.addRoute('Home', 'Work', 10, 1.5); // 10km, heavy traffic
gps.addRoute('Home', 'Store', 5, 1);
gps.addRoute('Store', 'Work', 8, 1.2);
gps.addRoute('Store', 'School', 3, 1);
gps.addRoute('School', 'Work', 6, 1);

console.log('Best route Home to Work:', gps.findRoute('Home', 'Work'));

// 2. Network Routing
console.log('\n=== Network Routing ===');

class NetworkRouter {
  constructor() {
    this.network = new OptimizedWeightedGraph();
  }
  
  addNode(node) {
    this.network.addVertex(node);
  }
  
  addConnection(node1, node2, latency) {
    this.network.addEdge(node1, node2, latency);
  }
  
  findFastestRoute(source, destination) {
    return this.network.dijkstraOptimized(source, destination);
  }
}

const router = new NetworkRouter();

['Server-A', 'Server-B', 'Server-C', 'Server-D', 'Client'].forEach(n => 
  router.addNode(n)
);

router.addConnection('Client', 'Server-A', 10);
router.addConnection('Client', 'Server-B', 15);
router.addConnection('Server-A', 'Server-C', 5);
router.addConnection('Server-B', 'Server-C', 8);
router.addConnection('Server-C', 'Server-D', 3);

console.log('Fastest route Client to Server-D:', 
  router.findFastestRoute('Client', 'Server-D')
);

// 3. Flight Booking System
console.log('\n=== Flight Booking ===');

class FlightBooking {
  constructor() {
    this.routes = new OptimizedWeightedGraph();
  }
  
  addAirport(code) {
    this.routes.addVertex(code);
  }
  
  addFlight(from, to, price) {
    this.routes.addEdge(from, to, price);
  }
  
  findCheapestRoute(from, to) {
    const result = this.routes.dijkstraOptimized(from, to);
    return {
      route: result.path,
      totalPrice: result.distance,
      stops: result.path.length - 2
    };
  }
}

const booking = new FlightBooking();

['NYC', 'LAX', 'CHI', 'MIA', 'SEA'].forEach(city => 
  booking.addAirport(city)
);

booking.addFlight('NYC', 'CHI', 200);
booking.addFlight('NYC', 'MIA', 300);
booking.addFlight('CHI', 'LAX', 150);
booking.addFlight('MIA', 'LAX', 250);
booking.addFlight('CHI', 'SEA', 180);
booking.addFlight('SEA', 'LAX', 100);

console.log('Cheapest NYC to LAX:', booking.findCheapestRoute('NYC', 'LAX'));

// 4. Game Pathfinding with Obstacles
console.log('\n=== Game Pathfinding ===');

function findGamePath(map, player, goal) {
  // Convert character positions to grid coordinates
  const rows = map.length;
  const cols = map[0].length;
  
  // Build weighted grid (different terrain costs)
  const grid = map.map(row => 
    row.map(cell => {
      if (cell === '#') return -1; // Wall
      if (cell === 'W') return 5;  // Water (slow)
      if (cell === 'M') return 3;  // Mountain (medium)
      return 1; // Plain
    })
  );
  
  return dijkstraGrid(grid, player, goal);
}

const gameMap = [
  ['.', '.', 'W', '.', '.'],
  ['.', '#', 'W', '#', '.'],
  ['.', '.', '.', '.', '.'],
  ['M', 'M', '.', 'M', 'M'],
  ['.', '.', '.', '.', '.']
];

console.log('Game path (0,0) to (4,4):', 
  findGamePath(gameMap, [0, 0], [4, 4])
);

// 5. Delivery Route Optimization
console.log('\n=== Delivery Routes ===');

class DeliveryRouter {
  constructor() {
    this.cityMap = new OptimizedWeightedGraph();
  }
  
  addLocation(location) {
    this.cityMap.addVertex(location);
  }
  
  addRoad(loc1, loc2, distance) {
    this.cityMap.addEdge(loc1, loc2, distance);
  }
  
  optimizeRoute(warehouse, deliveries) {
    let currentLocation = warehouse;
    let totalDistance = 0;
    const route = [warehouse];
    const remaining = new Set(deliveries);
    
    // Greedy: always go to nearest unvisited delivery
    while (remaining.size > 0) {
      let nearest = null;
      let minDistance = Infinity;
      
      for (const delivery of remaining) {
        const result = this.cityMap.dijkstraOptimized(currentLocation, delivery);
        
        if (result.distance < minDistance) {
          minDistance = result.distance;
          nearest = delivery;
        }
      }
      
      if (nearest) {
        route.push(nearest);
        totalDistance += minDistance;
        currentLocation = nearest;
        remaining.delete(nearest);
      }
    }
    
    // Return to warehouse
    const returnTrip = this.cityMap.dijkstraOptimized(currentLocation, warehouse);
    route.push(warehouse);
    totalDistance += returnTrip.distance;
    
    return { route, totalDistance };
  }
}

const delivery = new DeliveryRouter();

['Warehouse', 'A', 'B', 'C', 'D'].forEach(loc => 
  delivery.addLocation(loc)
);

delivery.addRoad('Warehouse', 'A', 5);
delivery.addRoad('Warehouse', 'B', 10);
delivery.addRoad('A', 'C', 3);
delivery.addRoad('B', 'C', 2);
delivery.addRoad('C', 'D', 4);
delivery.addRoad('B', 'D', 8);

console.log('Optimized delivery route:', 
  delivery.optimizeRoute('Warehouse', ['A', 'C', 'D'])
);
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// No path exists
const disconnected = new OptimizedWeightedGraph();
['A', 'B', 'C', 'D'].forEach(v => disconnected.addVertex(v));
disconnected.addEdge('A', 'B', 1);
disconnected.addEdge('C', 'D', 1);

console.log('No path A to D:', disconnected.dijkstraOptimized('A', 'D'));
// { distance: Infinity, path: [] }

// Single vertex
const single = new OptimizedWeightedGraph();
single.addVertex('A');
console.log('Path to self:', single.dijkstraOptimized('A', 'A'));
// { distance: 0, path: ['A'] }

// Negative weights (Dijkstra doesn't work correctly)
const negative = new OptimizedWeightedGraph();
['A', 'B', 'C'].forEach(v => negative.addVertex(v));
negative.addEdge('A', 'B', 5);
negative.addEdge('B', 'C', -3); // Negative weight!
console.log('With negative weight:', negative.dijkstraOptimized('A', 'C'));
console.log('Note: Dijkstra incorrect with negative weights. Use Bellman-Ford instead.');

// Multiple equal shortest paths
const multiple = new OptimizedWeightedGraph();
['A', 'B', 'C', 'D'].forEach(v => multiple.addVertex(v));
multiple.addEdge('A', 'B', 1);
multiple.addEdge('A', 'C', 1);
multiple.addEdge('B', 'D', 1);
multiple.addEdge('C', 'D', 1);

console.log('Multiple equal paths A to D:', multiple.dijkstraOptimized('A', 'D'));
// Returns one of the equal-cost paths

// Zero weight edges
const zeroWeight = new OptimizedWeightedGraph();
['A', 'B', 'C'].forEach(v => zeroWeight.addVertex(v));
zeroWeight.addEdge('A', 'B', 0);
zeroWeight.addEdge('B', 'C', 5);

console.log('With zero weight:', zeroWeight.dijkstraOptimized('A', 'C'));
```

### **Performance Analysis**
```javascript
console.log('\n=== Performance ===');

console.log(`
Time Complexity:
┌──────────────────────┬─────────────────┬─────────────────┐
│ Implementation       │ Time            │ Space           │
├──────────────────────┼─────────────────┼─────────────────┤
│ Array (naive)        │ O(V²)           │ O(V)            │
│ Min Heap             │ O((V+E) log V)  │ O(V)            │
│ Fibonacci Heap       │ O(E + V log V)  │ O(V)            │
└──────────────────────┴─────────────────┴─────────────────┘

Where:
  V = number of vertices
  E = number of edges

Algorithm Comparison:
┌──────────────────┬─────────────┬─────────────┬─────────────┐
│ Algorithm        │ Time        │ Negative    │ Use Case    │
│                  │             │ Weights     │             │
├──────────────────┼─────────────┼─────────────┼─────────────┤
│ Dijkstra         │ O(E log V)  │ No          │ General     │
│ Bellman-Ford     │ O(VE)       │ Yes         │ Neg weights │
│ Floyd-Warshall   │ O(V³)       │ Yes         │ All pairs   │
│ BFS              │ O(V + E)    │ Unweighted  │ Unweighted  │
│ A*               │ O(E log V)  │ No          │ With heur   │
└──────────────────┴─────────────┴─────────────┴─────────────┘

Optimization Techniques:
1. Use priority queue (min heap) instead of array
2. Early termination when target found
3. Bidirectional search from both ends
4. A* with good heuristic for specific targets
5. Skip already-visited vertices
6. Fibonacci heap for theoretical improvement

Memory Optimization:
• Store only essential data in heap
• Use indices instead of full vertex objects
• Lazy deletion from priority queue
• Compress path reconstruction data
`);
```

**Interview Tips:**
- Dijkstra: finds shortest path in weighted graph with non-negative weights
- Greedy algorithm: always picks vertex with minimum distance
- Data structures: distances array, priority queue (min heap), previous/parent tracking
- Algorithm: initialize distances to infinity except start (0), repeatedly extract min, relax neighbors
- Relaxation: if dist[u] + weight(u,v) < dist[v], update dist[v] and previous[v]
- Time: O(V²) with array, O((V+E) log V) with min heap (better for sparse graphs)
- Space: O(V) for distances and previous arrays
- Early termination: stop when target vertex is dequeued
- Path reconstruction: backtrack through previous pointers from end to start
- Applications: GPS navigation, network routing, game pathfinding, flight booking
- vs BFS: Dijkstra handles weighted graphs, BFS only unweighted
- Limitation: doesn't work with negative weights (use Bellman-Ford instead)
- A* optimization: add heuristic for faster search to specific target
- Priority queue: critical for performance, use min heap not array
- Edge cases: no path (return Infinity), negative weights (undefined behavior), single vertex
- Grid version: treat cells as vertices, neighbors as edges, use 4 or 8 directions
- Bidirectional: search from both ends simultaneously, faster for single target
- All-pairs: run Dijkstra from each vertex or use Floyd-Warshall
- Clarify: negative weights? single path or all? need actual path or just distance? directed/undirected?
- Follow-ups: implement with Fibonacci heap, handle negative weights (Bellman-Ford), find k shortest paths, add turn costs

</details>

101. Implement a Min Heap / Max Heap

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Min Heap**
```javascript
/**
 * Min Heap - parent smaller than children
 * Time Complexity:
 *   - Insert: O(log n)
 *   - Extract Min: O(log n)
 *   - Peek: O(1)
 * Space Complexity: O(n)
 */
class MinHeap {
  constructor() {
    this.heap = [];
  }
  
  getParentIndex(i) {
    return Math.floor((i - 1) / 2);
  }
  
  getLeftChildIndex(i) {
    return 2 * i + 1;
  }
  
  getRightChildIndex(i) {
    return 2 * i + 2;
  }
  
  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
  
  insert(value) {
    this.heap.push(value);
    this.bubbleUp(this.heap.length - 1);
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = this.getParentIndex(index);
      
      if (this.heap[index] >= this.heap[parentIndex]) {
        break;
      }
      
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }
  
  extractMin() {
    if (this.heap.length === 0) {
      return null;
    }
    
    if (this.heap.length === 1) {
      return this.heap.pop();
    }
    
    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    
    return min;
  }
  
  bubbleDown(index) {
    while (true) {
      const leftChild = this.getLeftChildIndex(index);
      const rightChild = this.getRightChildIndex(index);
      let smallest = index;
      
      if (
        leftChild < this.heap.length &&
        this.heap[leftChild] < this.heap[smallest]
      ) {
        smallest = leftChild;
      }
      
      if (
        rightChild < this.heap.length &&
        this.heap[rightChild] < this.heap[smallest]
      ) {
        smallest = rightChild;
      }
      
      if (smallest === index) {
        break;
      }
      
      this.swap(index, smallest);
      index = smallest;
    }
  }
  
  peek() {
    return this.heap.length > 0 ? this.heap[0] : null;
  }
  
  size() {
    return this.heap.length;
  }
  
  isEmpty() {
    return this.heap.length === 0;
  }
}

// Test
console.log('=== Min Heap ===');

const minHeap = new MinHeap();

[5, 3, 7, 1, 4, 6].forEach(val => minHeap.insert(val));

console.log('Min Heap:', minHeap.heap);
console.log('Extract min:', minHeap.extractMin()); // 1
console.log('Extract min:', minHeap.extractMin()); // 3
console.log('Peek:', minHeap.peek()); // 4
console.log('Size:', minHeap.size()); // 4
```

### **Approach 2: Max Heap**
```javascript
/**
 * Max Heap - parent larger than children
 */
class MaxHeap {
  constructor() {
    this.heap = [];
  }
  
  getParentIndex(i) {
    return Math.floor((i - 1) / 2);
  }
  
  getLeftChildIndex(i) {
    return 2 * i + 1;
  }
  
  getRightChildIndex(i) {
    return 2 * i + 2;
  }
  
  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
  
  insert(value) {
    this.heap.push(value);
    this.bubbleUp(this.heap.length - 1);
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = this.getParentIndex(index);
      
      if (this.heap[index] <= this.heap[parentIndex]) {
        break;
      }
      
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }
  
  extractMax() {
    if (this.heap.length === 0) {
      return null;
    }
    
    if (this.heap.length === 1) {
      return this.heap.pop();
    }
    
    const max = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    
    return max;
  }
  
  bubbleDown(index) {
    while (true) {
      const leftChild = this.getLeftChildIndex(index);
      const rightChild = this.getRightChildIndex(index);
      let largest = index;
      
      if (
        leftChild < this.heap.length &&
        this.heap[leftChild] > this.heap[largest]
      ) {
        largest = leftChild;
      }
      
      if (
        rightChild < this.heap.length &&
        this.heap[rightChild] > this.heap[largest]
      ) {
        largest = rightChild;
      }
      
      if (largest === index) {
        break;
      }
      
      this.swap(index, largest);
      index = largest;
    }
  }
  
  peek() {
    return this.heap.length > 0 ? this.heap[0] : null;
  }
  
  size() {
    return this.heap.length;
  }
}

// Test
console.log('\n=== Max Heap ===');

const maxHeap = new MaxHeap();

[5, 3, 7, 1, 4, 6].forEach(val => maxHeap.insert(val));

console.log('Max Heap:', maxHeap.heap);
console.log('Extract max:', maxHeap.extractMax()); // 7
console.log('Extract max:', maxHeap.extractMax()); // 6
console.log('Peek:', maxHeap.peek()); // 5
```

### **Approach 3: Generic Heap with Comparator**
```javascript
/**
 * Generic heap that works as min or max based on comparator
 */
class Heap {
  constructor(compareFn = (a, b) => a - b) {
    this.heap = [];
    this.compare = compareFn;
  }
  
  getParentIndex(i) {
    return Math.floor((i - 1) / 2);
  }
  
  getLeftChildIndex(i) {
    return 2 * i + 1;
  }
  
  getRightChildIndex(i) {
    return 2 * i + 2;
  }
  
  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
  
  insert(value) {
    this.heap.push(value);
    this.bubbleUp(this.heap.length - 1);
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = this.getParentIndex(index);
      
      if (this.compare(this.heap[index], this.heap[parentIndex]) >= 0) {
        break;
      }
      
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }
  
  extract() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();
    
    const root = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    
    return root;
  }
  
  bubbleDown(index) {
    while (true) {
      const leftChild = this.getLeftChildIndex(index);
      const rightChild = this.getRightChildIndex(index);
      let target = index;
      
      if (
        leftChild < this.heap.length &&
        this.compare(this.heap[leftChild], this.heap[target]) < 0
      ) {
        target = leftChild;
      }
      
      if (
        rightChild < this.heap.length &&
        this.compare(this.heap[rightChild], this.heap[target]) < 0
      ) {
        target = rightChild;
      }
      
      if (target === index) break;
      
      this.swap(index, target);
      index = target;
    }
  }
  
  peek() {
    return this.heap.length > 0 ? this.heap[0] : null;
  }
  
  size() {
    return this.heap.length;
  }
  
  isEmpty() {
    return this.heap.length === 0;
  }
  
  toArray() {
    return [...this.heap];
  }
}

// Test
console.log('\n=== Generic Heap ===');

// Min heap for numbers
const minHeap2 = new Heap((a, b) => a - b);
[5, 3, 7, 1].forEach(v => minHeap2.insert(v));
console.log('Min heap:', minHeap2.toArray());

// Max heap for numbers
const maxHeap2 = new Heap((a, b) => b - a);
[5, 3, 7, 1].forEach(v => maxHeap2.insert(v));
console.log('Max heap:', maxHeap2.toArray());

// Custom comparator for objects
const taskHeap = new Heap((a, b) => a.priority - b.priority);
taskHeap.insert({ task: 'Low', priority: 3 });
taskHeap.insert({ task: 'High', priority: 1 });
taskHeap.insert({ task: 'Medium', priority: 2 });

console.log('Next task:', taskHeap.extract());
```

### **Approach 4: Heap with Additional Operations**
```javascript
/**
 * Enhanced heap with more operations
 */
class EnhancedHeap extends Heap {
  constructor(compareFn = (a, b) => a - b) {
    super(compareFn);
    this.indexMap = new Map(); // Track element indices
  }
  
  insert(value) {
    this.heap.push(value);
    const index = this.heap.length - 1;
    this.indexMap.set(value, index);
    this.bubbleUp(index);
  }
  
  extract() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) {
      const value = this.heap.pop();
      this.indexMap.delete(value);
      return value;
    }
    
    const root = this.heap[0];
    this.indexMap.delete(root);
    
    const last = this.heap.pop();
    this.heap[0] = last;
    this.indexMap.set(last, 0);
    this.bubbleDown(0);
    
    return root;
  }
  
  remove(value) {
    const index = this.indexMap.get(value);
    if (index === undefined) return false;
    
    if (index === this.heap.length - 1) {
      this.heap.pop();
      this.indexMap.delete(value);
      return true;
    }
    
    const last = this.heap.pop();
    this.indexMap.delete(value);
    
    this.heap[index] = last;
    this.indexMap.set(last, index);
    
    // May need to bubble up or down
    const parentIndex = this.getParentIndex(index);
    if (index > 0 && this.compare(this.heap[index], this.heap[parentIndex]) < 0) {
      this.bubbleUp(index);
    } else {
      this.bubbleDown(index);
    }
    
    return true;
  }
  
  updatePriority(oldValue, newValue) {
    this.remove(oldValue);
    this.insert(newValue);
  }
  
  contains(value) {
    return this.indexMap.has(value);
  }
  
  clear() {
    this.heap = [];
    this.indexMap.clear();
  }
  
  // Build heap from array in O(n)
  heapify(array) {
    this.heap = [...array];
    this.indexMap.clear();
    
    array.forEach((val, idx) => this.indexMap.set(val, idx));
    
    // Start from last non-leaf node
    for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
      this.bubbleDown(i);
    }
  }
}

// Test
console.log('\n=== Enhanced Heap ===');

const enhanced = new EnhancedHeap((a, b) => a - b);

[5, 3, 7, 1, 4].forEach(v => enhanced.insert(v));
console.log('Contains 3:', enhanced.contains(3)); // true

enhanced.remove(3);
console.log('After remove 3:', enhanced.toArray());

// Heapify
const arr = [9, 5, 6, 2, 3];
enhanced.heapify(arr);
console.log('Heapified:', enhanced.toArray());
```

### **Approach 5: Heap Sort Implementation**
```javascript
/**
 * Heap sort using heap
 */
function heapSort(array) {
  const heap = new MaxHeap();
  
  // Build heap
  array.forEach(val => heap.insert(val));
  
  // Extract all elements
  const sorted = [];
  while (heap.size() > 0) {
    sorted.unshift(heap.extractMax());
  }
  
  return sorted;
}

// In-place heap sort
function heapSortInPlace(array) {
  const n = array.length;
  
  // Build max heap
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapifyDown(array, n, i);
  }
  
  // Extract elements one by one
  for (let i = n - 1; i > 0; i--) {
    [array[0], array[i]] = [array[i], array[0]];
    heapifyDown(array, i, 0);
  }
  
  return array;
}

function heapifyDown(array, heapSize, index) {
  let largest = index;
  const left = 2 * index + 1;
  const right = 2 * index + 2;
  
  if (left < heapSize && array[left] > array[largest]) {
    largest = left;
  }
  
  if (right < heapSize && array[right] > array[largest]) {
    largest = right;
  }
  
  if (largest !== index) {
    [array[index], array[largest]] = [array[largest], array[index]];
    heapifyDown(array, heapSize, largest);
  }
}

// Test
console.log('\n=== Heap Sort ===');

console.log('Sorted:', heapSort([5, 3, 7, 1, 4, 6]));
// [1, 3, 4, 5, 6, 7]

const arr = [5, 3, 7, 1, 4, 6];
heapSortInPlace(arr);
console.log('In-place sorted:', arr);
```

### **Real-World Use Cases**
```javascript
/**
 * Practical heap applications
 */

// 1. Priority Queue for Task Scheduling
console.log('\n=== Task Scheduler ===');

class TaskScheduler {
  constructor() {
    this.tasks = new Heap((a, b) => a.priority - b.priority);
  }
  
  addTask(name, priority) {
    this.tasks.insert({ name, priority, timestamp: Date.now() });
  }
  
  getNextTask() {
    return this.tasks.extract();
  }
  
  peekNextTask() {
    return this.tasks.peek();
  }
  
  isEmpty() {
    return this.tasks.isEmpty();
  }
}

const scheduler = new TaskScheduler();

scheduler.addTask('Send email', 3);
scheduler.addTask('Fix critical bug', 1);
scheduler.addTask('Code review', 2);
scheduler.addTask('Meeting', 2);

console.log('Next task:', scheduler.getNextTask().name); // Fix critical bug
console.log('Next task:', scheduler.getNextTask().name); // Code review

// 2. Find K Largest/Smallest Elements
console.log('\n=== K Largest Elements ===');

function findKLargest(array, k) {
  const minHeap = new MinHeap();
  
  for (const num of array) {
    minHeap.insert(num);
    
    if (minHeap.size() > k) {
      minHeap.extractMin();
    }
  }
  
  return minHeap.heap.sort((a, b) => b - a);
}

console.log('3 largest in [3,1,5,12,2,11]:', findKLargest([3, 1, 5, 12, 2, 11], 3));
// [12, 11, 5]

// 3. Merge K Sorted Arrays
console.log('\n=== Merge K Sorted Arrays ===');

function mergeKSortedArrays(arrays) {
  const heap = new Heap((a, b) => a.value - b.value);
  const result = [];
  
  // Initialize heap with first element from each array
  arrays.forEach((arr, arrayIndex) => {
    if (arr.length > 0) {
      heap.insert({ value: arr[0], arrayIndex, elementIndex: 0 });
    }
  });
  
  while (!heap.isEmpty()) {
    const { value, arrayIndex, elementIndex } = heap.extract();
    result.push(value);
    
    // Add next element from same array
    const nextIndex = elementIndex + 1;
    if (nextIndex < arrays[arrayIndex].length) {
      heap.insert({
        value: arrays[arrayIndex][nextIndex],
        arrayIndex,
        elementIndex: nextIndex
      });
    }
  }
  
  return result;
}

const sortedArrays = [
  [1, 4, 7],
  [2, 5, 8],
  [3, 6, 9]
];

console.log('Merged:', mergeKSortedArrays(sortedArrays));
// [1, 2, 3, 4, 5, 6, 7, 8, 9]

// 4. Running Median
console.log('\n=== Running Median ===');

class MedianFinder {
  constructor() {
    this.maxHeap = new Heap((a, b) => b - a); // Lower half
    this.minHeap = new Heap((a, b) => a - b); // Upper half
  }
  
  addNum(num) {
    // Add to max heap first
    this.maxHeap.insert(num);
    
    // Balance: move largest from maxHeap to minHeap
    this.minHeap.insert(this.maxHeap.extract());
    
    // Ensure maxHeap has equal or one more element
    if (this.maxHeap.size() < this.minHeap.size()) {
      this.maxHeap.insert(this.minHeap.extract());
    }
  }
  
  findMedian() {
    if (this.maxHeap.size() > this.minHeap.size()) {
      return this.maxHeap.peek();
    }
    
    return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
  }
}

const medianFinder = new MedianFinder();

[1, 2, 3, 4, 5].forEach(num => {
  medianFinder.addNum(num);
  console.log(`After adding ${num}, median:`, medianFinder.findMedian());
});

// 5. CPU Task Scheduling with Cooldown
console.log('\n=== CPU Scheduler ===');

function leastInterval(tasks, cooldown) {
  const freq = {};
  
  // Count frequencies
  for (const task of tasks) {
    freq[task] = (freq[task] || 0) + 1;
  }
  
  // Max heap by frequency
  const heap = new Heap((a, b) => b - a);
  Object.values(freq).forEach(f => heap.insert(f));
  
  let time = 0;
  const queue = []; // [frequency, availableTime]
  
  while (!heap.isEmpty() || queue.length > 0) {
    time++;
    
    if (!heap.isEmpty()) {
      const freq = heap.extract() - 1;
      
      if (freq > 0) {
        queue.push([freq, time + cooldown]);
      }
    }
    
    if (queue.length > 0 && queue[0][1] === time) {
      heap.insert(queue.shift()[0]);
    }
  }
  
  return time;
}

console.log('Min intervals for [A,A,A,B,B,B] with cooldown 2:', 
  leastInterval(['A','A','A','B','B','B'], 2)
);
// 8 (A->B->idle->A->B->idle->A->B)
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty heap
const empty = new MinHeap();
console.log('Extract from empty:', empty.extractMin()); // null
console.log('Peek empty:', empty.peek()); // null

// Single element
const single = new MinHeap();
single.insert(5);
console.log('Single element:', single.extractMin()); // 5
console.log('After extract:', single.isEmpty()); // true

// Duplicate values
const duplicates = new MinHeap();
[5, 3, 5, 1, 3].forEach(v => duplicates.insert(v));
console.log('With duplicates:', duplicates.toArray());

// All same values
const same = new MinHeap();
[5, 5, 5, 5].forEach(v => same.insert(v));
console.log('All same:', same.toArray());

// Large heap
const large = new MinHeap();
for (let i = 1000; i > 0; i--) {
  large.insert(i);
}
console.log('Large heap min:', large.peek()); // 1
console.log('Large heap size:', large.size()); // 1000
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Time Complexity:
┌──────────────────┬─────────────┬─────────────┐
│ Operation        │ Time        │ Note        │
├──────────────────┼─────────────┼─────────────┤
│ Insert           │ O(log n)    │ Bubble up   │
│ Extract Min/Max  │ O(log n)    │ Bubble down │
│ Peek             │ O(1)        │ Access root │
│ Remove arbitrary │ O(log n)    │ Find + fix  │
│ Build heap       │ O(n)        │ Heapify     │
│ Heap sort        │ O(n log n)  │ n extracts  │
└──────────────────┴─────────────┴─────────────┘

Space Complexity: O(n)

Heap vs Other Structures:
┌────────────────┬──────────┬──────────┬──────────┐
│ Operation      │ Heap     │ Array    │ BST      │
├────────────────┼──────────┼──────────┼──────────┤
│ Find min/max   │ O(1)     │ O(n)     │ O(log n) │
│ Insert         │ O(log n) │ O(1)     │ O(log n) │
│ Delete min/max │ O(log n) │ O(n)     │ O(log n) │
│ Search         │ O(n)     │ O(n)     │ O(log n) │
└────────────────┴──────────┴──────────┴──────────┘

Use Cases:
• Priority Queue: task scheduling, event handling
• Heap Sort: O(n log n) sorting, in-place possible
• K largest/smallest: maintain heap of size k
• Median finding: two heaps (max + min)
• Graph algorithms: Dijkstra, Prim's MST
• Merge K sorted: heap of size k
`);
```

**Interview Tips:**
- Heap: complete binary tree stored as array
- Min heap: parent ≤ children, root is minimum
- Max heap: parent ≥ children, root is maximum
- Array representation: parent at i, children at 2i+1 and 2i+2
- Insert: add to end, bubble up to maintain heap property
- Extract: remove root, move last to root, bubble down
- Bubble up: swap with parent while violating heap property
- Bubble down: swap with smaller/larger child while violating property
- Time: O(log n) for insert/extract, O(1) for peek
- Space: O(n) for storing n elements
- Heapify: build heap from array in O(n) time (bottom-up)
- Applications: priority queue, heap sort, k largest/smallest, running median
- Priority queue: heap is ideal implementation
- Heap sort: O(n log n) time, O(1) extra space (in-place)
- K largest: use min heap of size k, keep removing smallest if size > k
- Running median: use two heaps, max heap for lower half, min heap for upper half
- Generic heap: use comparator function for flexibility
- Edge cases: empty heap, single element, duplicates, all same
- Complete tree: all levels full except last, filled left to right
- Not for searching: heaps don't maintain full sorted order, only heap property
- vs BST: heap faster for min/max, BST faster for search
- Clarify: min or max heap? need to remove arbitrary elements? custom comparison?
- Follow-ups: implement decrease-key operation, merge two heaps, make it persistent

</details>

102. Detect cycle in a directed graph

<details>
<summary><b>Solution</b></summary>

### **Approach 1: DFS with Recursion Stack**
```javascript
/**
 * Cycle detection using DFS with recursion stack
 * Time Complexity: O(V + E)
 * Space Complexity: O(V)
 */
class DirectedGraph {
  constructor() {
    this.adjacencyList = {};
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }
  
  addEdge(from, to) {
    this.adjacencyList[from].push(to); // Directed edge
  }
  
  hasCycle() {
    const visited = new Set();
    const recStack = new Set(); // Recursion stack
    
    const dfs = (vertex) => {
      visited.add(vertex);
      recStack.add(vertex);
      
      for (const neighbor of this.adjacencyList[vertex]) {
        if (!visited.has(neighbor)) {
          if (dfs(neighbor)) {
            return true;
          }
        } else if (recStack.has(neighbor)) {
          // Found back edge to vertex in current path
          return true;
        }
      }
      
      recStack.delete(vertex);
      return false;
    };
    
    // Check all vertices (for disconnected components)
    for (const vertex in this.adjacencyList) {
      if (!visited.has(vertex)) {
        if (dfs(vertex)) {
          return true;
        }
      }
    }
    
    return false;
  }
}

// Test
console.log('=== Cycle Detection (DFS) ===');

const graph1 = new DirectedGraph();
['A', 'B', 'C', 'D'].forEach(v => graph1.addVertex(v));
graph1.addEdge('A', 'B');
graph1.addEdge('B', 'C');
graph1.addEdge('C', 'D');

console.log('Has cycle (no):', graph1.hasCycle()); // false

graph1.addEdge('D', 'A'); // Create cycle
console.log('Has cycle (yes):', graph1.hasCycle()); // true
```

### **Approach 2: DFS with Three Colors**
```javascript
/**
 * Three-color DFS: white (unvisited), gray (processing), black (done)
 */
class ColoredGraph extends DirectedGraph {
  hasCycleWithColors() {
    const WHITE = 0; // Unvisited
    const GRAY = 1;  // In progress
    const BLACK = 2; // Completed
    
    const colors = {};
    
    // Initialize all vertices as white
    for (const vertex in this.adjacencyList) {
      colors[vertex] = WHITE;
    }
    
    const dfs = (vertex) => {
      colors[vertex] = GRAY;
      
      for (const neighbor of this.adjacencyList[vertex]) {
        if (colors[neighbor] === GRAY) {
          return true; // Back edge to gray node = cycle
        }
        
        if (colors[neighbor] === WHITE) {
          if (dfs(neighbor)) {
            return true;
          }
        }
      }
      
      colors[vertex] = BLACK;
      return false;
    };
    
    for (const vertex in this.adjacencyList) {
      if (colors[vertex] === WHITE) {
        if (dfs(vertex)) {
          return true;
        }
      }
    }
    
    return false;
  }
}

// Test
console.log('\n=== Three-Color DFS ===');

const graph2 = new ColoredGraph();
['A', 'B', 'C', 'D'].forEach(v => graph2.addVertex(v));
graph2.addEdge('A', 'B');
graph2.addEdge('B', 'C');
graph2.addEdge('C', 'A'); // Cycle

console.log('Has cycle:', graph2.hasCycleWithColors()); // true
```

### **Approach 3: Find Cycle and Return Path**
```javascript
/**
 * Detect cycle and return the actual cycle path
 */
function findCycle(graph) {
  const visited = new Set();
  const recStack = new Set();
  const parent = {};
  let cycleStart = null;
  let cycleEnd = null;
  
  function dfs(vertex) {
    visited.add(vertex);
    recStack.add(vertex);
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        parent[neighbor] = vertex;
        
        if (dfs(neighbor)) {
          return true;
        }
      } else if (recStack.has(neighbor)) {
        cycleStart = neighbor;
        cycleEnd = vertex;
        return true;
      }
    }
    
    recStack.delete(vertex);
    return false;
  }
  
  // Find cycle
  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      if (dfs(vertex)) {
        break;
      }
    }
  }
  
  if (!cycleStart) {
    return null; // No cycle
  }
  
  // Reconstruct cycle path
  const cycle = [cycleStart];
  let current = cycleEnd;
  
  while (current !== cycleStart) {
    cycle.push(current);
    current = parent[current];
  }
  
  cycle.push(cycleStart); // Complete the cycle
  cycle.reverse();
  
  return cycle;
}

// Test
console.log('\n=== Find Cycle Path ===');

const graph3 = new DirectedGraph();
['A', 'B', 'C', 'D', 'E'].forEach(v => graph3.addVertex(v));
graph3.addEdge('A', 'B');
graph3.addEdge('B', 'C');
graph3.addEdge('C', 'D');
graph3.addEdge('D', 'B'); // Cycle: B -> C -> D -> B
graph3.addEdge('D', 'E');

const cycle = findCycle(graph3);
console.log('Cycle found:', cycle); // ['B', 'C', 'D', 'B']
```

### **Approach 4: Kahn's Algorithm (Topological Sort)**
```javascript
/**
 * Detect cycle using Kahn's algorithm (topological sort)
 * If topological sort completes, no cycle exists
 */
function hasCycleKahn(graph) {
  const inDegree = {};
  const queue = [];
  let processedCount = 0;
  
  // Initialize in-degrees
  for (const vertex in graph.adjacencyList) {
    inDegree[vertex] = 0;
  }
  
  // Calculate in-degrees
  for (const vertex in graph.adjacencyList) {
    for (const neighbor of graph.adjacencyList[vertex]) {
      inDegree[neighbor]++;
    }
  }
  
  // Add vertices with in-degree 0 to queue
  for (const vertex in inDegree) {
    if (inDegree[vertex] === 0) {
      queue.push(vertex);
    }
  }
  
  // Process vertices
  while (queue.length > 0) {
    const vertex = queue.shift();
    processedCount++;
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      inDegree[neighbor]--;
      
      if (inDegree[neighbor] === 0) {
        queue.push(neighbor);
      }
    }
  }
  
  // If not all vertices processed, cycle exists
  const totalVertices = Object.keys(graph.adjacencyList).length;
  return processedCount !== totalVertices;
}

// Test
console.log('\n=== Kahn\'s Algorithm ===');

const graph4 = new DirectedGraph();
['A', 'B', 'C', 'D'].forEach(v => graph4.addVertex(v));
graph4.addEdge('A', 'B');
graph4.addEdge('B', 'C');
graph4.addEdge('C', 'D');

console.log('Has cycle (no):', hasCycleKahn(graph4)); // false

graph4.addEdge('D', 'A'); // Create cycle
console.log('Has cycle (yes):', hasCycleKahn(graph4)); // true
```

### **Approach 5: Union-Find for DAG Verification**
```javascript
/**
 * Union-Find to detect cycles (works for adding edges one by one)
 */
class UnionFind {
  constructor(vertices) {
    this.parent = {};
    this.rank = {};
    
    for (const v of vertices) {
      this.parent[v] = v;
      this.rank[v] = 0;
    }
  }
  
  find(x) {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]); // Path compression
    }
    return this.parent[x];
  }
  
  union(x, y) {
    const rootX = this.find(x);
    const rootY = this.find(y);
    
    if (rootX === rootY) {
      return false; // Already in same set
    }
    
    // Union by rank
    if (this.rank[rootX] < this.rank[rootY]) {
      this.parent[rootX] = rootY;
    } else if (this.rank[rootX] > this.rank[rootY]) {
      this.parent[rootY] = rootX;
    } else {
      this.parent[rootY] = rootX;
      this.rank[rootX]++;
    }
    
    return true;
  }
}

// Note: Union-Find only works for undirected graphs or
// directed acyclic graphs being built incrementally
function canAddEdgeWithoutCycle(vertices, edges, newEdge) {
  const uf = new UnionFind(vertices);
  
  // Process existing edges
  for (const [from, to] of edges) {
    uf.union(from, to);
  }
  
  // Check if new edge creates cycle
  const [from, to] = newEdge;
  return uf.find(from) !== uf.find(to);
}

// Test
console.log('\n=== Union-Find ===');

const vertices = ['A', 'B', 'C', 'D'];
const edges = [['A', 'B'], ['B', 'C']];

console.log('Can add A->D:', canAddEdgeWithoutCycle(vertices, edges, ['A', 'D'])); // true
console.log('Can add C->A:', canAddEdgeWithoutCycle(vertices, edges, ['C', 'A'])); // false (creates cycle)
```

### **Bonus: All Cycles Detection**
```javascript
/**
 * Find all cycles in directed graph
 */
function findAllCycles(graph) {
  const visited = new Set();
  const recStack = new Set();
  const path = [];
  const allCycles = [];
  
  function dfs(vertex) {
    visited.add(vertex);
    recStack.add(vertex);
    path.push(vertex);
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        dfs(neighbor);
      } else if (recStack.has(neighbor)) {
        // Found cycle
        const cycleStart = path.indexOf(neighbor);
        const cycle = path.slice(cycleStart);
        cycle.push(neighbor); // Complete the cycle
        allCycles.push([...cycle]);
      }
    }
    
    path.pop();
    recStack.delete(vertex);
  }
  
  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      dfs(vertex);
    }
  }
  
  return allCycles;
}

// Test
console.log('\n=== All Cycles ===');

const graph5 = new DirectedGraph();
['A', 'B', 'C', 'D', 'E'].forEach(v => graph5.addVertex(v));
graph5.addEdge('A', 'B');
graph5.addEdge('B', 'C');
graph5.addEdge('C', 'A'); // Cycle 1: A->B->C->A
graph5.addEdge('C', 'D');
graph5.addEdge('D', 'E');
graph5.addEdge('E', 'C'); // Cycle 2: C->D->E->C

console.log('All cycles:', findAllCycles(graph5));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical cycle detection applications
 */

// 1. Dependency Resolution
console.log('\n=== Dependency Resolution ===');

class DependencyManager {
  constructor() {
    this.graph = new DirectedGraph();
  }
  
  addPackage(pkg) {
    this.graph.addVertex(pkg);
  }
  
  addDependency(pkg, dependency) {
    this.graph.addEdge(pkg, dependency);
  }
  
  hasCircularDependency() {
    return this.graph.hasCycle();
  }
  
  findCircularDependency() {
    return findCycle(this.graph);
  }
}

const deps = new DependencyManager();

['app', 'db', 'auth', 'logger'].forEach(pkg => deps.addPackage(pkg));
deps.addDependency('app', 'db');
deps.addDependency('app', 'auth');
deps.addDependency('auth', 'logger');
deps.addDependency('db', 'logger');

console.log('Has circular dependency:', deps.hasCircularDependency()); // false

deps.addDependency('logger', 'auth'); // Creates cycle
console.log('After adding logger->auth:', deps.hasCircularDependency()); // true
console.log('Circular dependency:', deps.findCircularDependency());

// 2. Deadlock Detection
console.log('\n=== Deadlock Detection ===');

class DeadlockDetector {
  constructor() {
    this.waitGraph = new DirectedGraph();
  }
  
  addProcess(process) {
    this.waitGraph.addVertex(process);
  }
  
  processWaitsFor(process1, process2) {
    this.waitGraph.addEdge(process1, process2);
  }
  
  detectDeadlock() {
    return this.waitGraph.hasCycle();
  }
  
  getDeadlockedProcesses() {
    return findCycle(this.waitGraph);
  }
}

const detector = new DeadlockDetector();

['P1', 'P2', 'P3'].forEach(p => detector.addProcess(p));
detector.processWaitsFor('P1', 'P2'); // P1 waits for P2's resource
detector.processWaitsFor('P2', 'P3'); // P2 waits for P3's resource

console.log('Deadlock:', detector.detectDeadlock()); // false

detector.processWaitsFor('P3', 'P1'); // P3 waits for P1's resource - deadlock!
console.log('After P3->P1:', detector.detectDeadlock()); // true
console.log('Deadlocked processes:', detector.getDeadlockedProcesses());

// 3. Build System
console.log('\n=== Build System ===');

class BuildSystem {
  constructor() {
    this.targets = new DirectedGraph();
  }
  
  addTarget(target) {
    this.targets.addVertex(target);
  }
  
  addDependency(target, dependency) {
    this.targets.addEdge(target, dependency);
  }
  
  canBuild() {
    if (this.targets.hasCycle()) {
      return { success: false, error: 'Circular dependency detected' };
    }
    return { success: true };
  }
}

const build = new BuildSystem();

['main.o', 'utils.o', 'lib.a'].forEach(t => build.addTarget(t));
build.addDependency('main.o', 'utils.o');
build.addDependency('utils.o', 'lib.a');

console.log('Can build:', build.canBuild());

build.addDependency('lib.a', 'main.o'); // Circular dependency
console.log('After circular dep:', build.canBuild());

// 4. Course Prerequisites
console.log('\n=== Course Prerequisites ===');

class CourseScheduler {
  constructor() {
    this.prerequisites = new DirectedGraph();
  }
  
  addCourse(course) {
    this.prerequisites.addVertex(course);
  }
  
  addPrerequisite(course, prerequisite) {
    this.prerequisites.addEdge(course, prerequisite);
  }
  
  canFinishAllCourses() {
    return !this.prerequisites.hasCycle();
  }
  
  findProblematicCourses() {
    if (!this.canFinishAllCourses()) {
      return findCycle(this.prerequisites);
    }
    return null;
  }
}

const scheduler = new CourseScheduler();

['CS101', 'CS201', 'CS301', 'MATH101'].forEach(c => scheduler.addCourse(c));
scheduler.addPrerequisite('CS201', 'CS101');
scheduler.addPrerequisite('CS301', 'CS201');
scheduler.addPrerequisite('CS301', 'MATH101');

console.log('Can finish all courses:', scheduler.canFinishAllCourses()); // true

scheduler.addPrerequisite('CS101', 'CS301'); // Creates impossible situation
console.log('After impossible prereq:', scheduler.canFinishAllCourses()); // false
console.log('Problematic courses:', scheduler.findProblematicCourses());

// 5. Workflow Validation
console.log('\n=== Workflow Validation ===');

class WorkflowValidator {
  constructor() {
    this.workflow = new DirectedGraph();
  }
  
  addTask(task) {
    this.workflow.addVertex(task);
  }
  
  addTransition(from, to) {
    this.workflow.addEdge(from, to);
  }
  
  validateWorkflow() {
    if (this.workflow.hasCycle()) {
      return {
        valid: false,
        error: 'Workflow contains infinite loop',
        cycle: findCycle(this.workflow)
      };
    }
    
    return { valid: true };
  }
}

const workflow = new WorkflowValidator();

['Start', 'Review', 'Approve', 'Deploy', 'End'].forEach(t => workflow.addTask(t));
workflow.addTransition('Start', 'Review');
workflow.addTransition('Review', 'Approve');
workflow.addTransition('Approve', 'Deploy');
workflow.addTransition('Deploy', 'End');

console.log('Workflow valid:', workflow.validateWorkflow());

workflow.addTransition('Deploy', 'Review'); // Can retry after deploy
console.log('After retry loop:', workflow.validateWorkflow());
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Single vertex with self-loop
const selfLoop = new DirectedGraph();
selfLoop.addVertex('A');
selfLoop.addEdge('A', 'A');
console.log('Self-loop:', selfLoop.hasCycle()); // true

// Two vertices with mutual edges
const mutual = new DirectedGraph();
['A', 'B'].forEach(v => mutual.addVertex(v));
mutual.addEdge('A', 'B');
mutual.addEdge('B', 'A');
console.log('Mutual edges:', mutual.hasCycle()); // true

// Disconnected components with one cycle
const disconnected = new DirectedGraph();
['A', 'B', 'C', 'D', 'E'].forEach(v => disconnected.addVertex(v));
disconnected.addEdge('A', 'B');
disconnected.addEdge('B', 'A'); // Cycle in component 1
disconnected.addEdge('C', 'D'); // Component 2, no cycle
console.log('Disconnected with cycle:', disconnected.hasCycle()); // true

// Empty graph
const empty = new DirectedGraph();
console.log('Empty graph:', empty.hasCycle()); // false

// Single vertex, no edges
const singleVertex = new DirectedGraph();
singleVertex.addVertex('A');
console.log('Single vertex:', singleVertex.hasCycle()); // false

// Long chain (no cycle)
const chain = new DirectedGraph();
for (let i = 0; i < 100; i++) {
  chain.addVertex(i);
  if (i > 0) {
    chain.addEdge(i - 1, i);
  }
}
console.log('Long chain (no cycle):', chain.hasCycle()); // false

// Complex graph with multiple paths
const complex = new DirectedGraph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => complex.addVertex(v));
complex.addEdge('A', 'B');
complex.addEdge('A', 'C');
complex.addEdge('B', 'D');
complex.addEdge('C', 'D');
complex.addEdge('D', 'E');
complex.addEdge('E', 'F');
console.log('Complex DAG:', complex.hasCycle()); // false

complex.addEdge('F', 'A'); // Add cycle
console.log('Complex with cycle:', complex.hasCycle()); // true
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Algorithm Comparison:
┌──────────────────────┬─────────────┬─────────────┬────────────┐
│ Algorithm            │ Time        │ Space       │ Best For   │
├──────────────────────┼─────────────┼─────────────┼────────────┤
│ DFS (recursion)      │ O(V + E)    │ O(V)        │ General    │
│ DFS (iterative)      │ O(V + E)    │ O(V)        │ Deep graphs│
│ Three-color DFS      │ O(V + E)    │ O(V)        │ Cleaner    │
│ Kahn's algorithm     │ O(V + E)    │ O(V)        │ Topo sort  │
│ Union-Find           │ O(E α(V))   │ O(V)        │ Incremental│
└──────────────────────┴─────────────┴─────────────┴────────────┘

Where:
  V = number of vertices
  E = number of edges
  α(V) = inverse Ackermann (nearly constant)

Key Differences:
• DFS with recursion stack: Most common, intuitive
• Three-color: Cleaner state tracking
• Kahn's: Bonus of topological order if no cycle
• Union-Find: Good for dynamic graph construction

Optimization:
• Early termination when cycle found
• Track visited to avoid redundant work
• Path compression in Union-Find
• Iterative DFS for very deep graphs (avoid stack overflow)

Space Optimization:
• Reuse visited set across components
• In-place color marking if vertices are numbered
• Bit vectors for large graphs
`);
```

**Interview Tips:**
- Directed graph cycle: use DFS with recursion stack tracking
- Key insight: back edge to vertex in current recursion path = cycle
- Recursion stack: tracks current DFS path, different from visited
- Algorithm: DFS, mark vertex as "in progress", check neighbors, unmark when done
- If neighbor is "in progress" (in recursion stack), cycle found
- Time: O(V + E) visit each vertex once, check each edge once
- Space: O(V) for visited and recursion stack sets
- Three colors: white (unvisited), gray (processing), black (done)
- Gray vertex: currently in DFS path (recursion stack)
- Black vertex: fully explored, no cycle through it
- Applications: dependency resolution, deadlock detection, build systems, prerequisites
- vs undirected: undirected uses parent tracking, directed uses recursion stack
- Kahn's algorithm: alternative using topological sort, if all vertices processed then DAG
- Return cycle: track parent pointers, reconstruct path when cycle found
- All cycles: continue DFS after finding each cycle, collect all
- Edge cases: self-loop (cycle), mutual edges, disconnected components, empty graph
- Disconnected: check all components by iterating unvisited vertices
- Union-Find: works for incremental edge addition in undirected/DAG scenarios
- Optimization: early termination, avoid processing same vertices multiple times
- Clarify: need cycle path or just detection? all cycles or first? graph properties?
- Follow-ups: find shortest cycle, count cycles, remove minimum edges to break cycles

</details>

103. Implement topological sort

<details>
<summary><b>Solution</b></summary>

### **Approach 1: DFS with Post-Order**
```javascript
/**
 * Topological sort using DFS
 * Time Complexity: O(V + E)
 * Space Complexity: O(V)
 */
class DirectedGraph {
  constructor() {
    this.adjacencyList = {};
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }
  
  addEdge(from, to) {
    this.adjacencyList[from].push(to);
  }
  
  topologicalSort() {
    const visited = new Set();
    const stack = [];
    
    const dfs = (vertex) => {
      visited.add(vertex);
      
      for (const neighbor of this.adjacencyList[vertex]) {
        if (!visited.has(neighbor)) {
          dfs(neighbor);
        }
      }
      
      // Add to result after visiting all descendants
      stack.push(vertex);
    };
    
    // Visit all vertices
    for (const vertex in this.adjacencyList) {
      if (!visited.has(vertex)) {
        dfs(vertex);
      }
    }
    
    // Reverse to get correct order
    return stack.reverse();
  }
}

// Test
console.log('=== Topological Sort (DFS) ===');

const graph = new DirectedGraph();

// Example: course prerequisites
// CS301 -> CS201 -> CS101
// CS301 -> MATH101
['CS101', 'CS201', 'CS301', 'MATH101'].forEach(v => graph.addVertex(v));
graph.addEdge('CS301', 'CS201');
graph.addEdge('CS201', 'CS101');
graph.addEdge('CS301', 'MATH101');

console.log('Topological order:', graph.topologicalSort());
// ['CS101', 'MATH101', 'CS201', 'CS301'] or ['MATH101', 'CS101', 'CS201', 'CS301']
```

### **Approach 2: Kahn's Algorithm (BFS)**
```javascript
/**
 * Kahn's algorithm using BFS and in-degrees
 */
class KahnGraph extends DirectedGraph {
  topologicalSortKahn() {
    const inDegree = {};
    const result = [];
    const queue = [];
    
    // Initialize in-degrees
    for (const vertex in this.adjacencyList) {
      inDegree[vertex] = 0;
    }
    
    // Calculate in-degrees
    for (const vertex in this.adjacencyList) {
      for (const neighbor of this.adjacencyList[vertex]) {
        inDegree[neighbor] = (inDegree[neighbor] || 0) + 1;
      }
    }
    
    // Add vertices with in-degree 0 to queue
    for (const vertex in inDegree) {
      if (inDegree[vertex] === 0) {
        queue.push(vertex);
      }
    }
    
    // Process vertices
    while (queue.length > 0) {
      const vertex = queue.shift();
      result.push(vertex);
      
      // Reduce in-degree for neighbors
      for (const neighbor of this.adjacencyList[vertex]) {
        inDegree[neighbor]--;
        
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      }
    }
    
    // Check for cycle
    if (result.length !== Object.keys(this.adjacencyList).length) {
      throw new Error('Graph contains a cycle - topological sort not possible');
    }
    
    return result;
  }
}

// Test
console.log('\n=== Kahn\'s Algorithm ===');

const graph2 = new KahnGraph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph2.addVertex(v));
graph2.addEdge('A', 'C');
graph2.addEdge('A', 'D');
graph2.addEdge('B', 'D');
graph2.addEdge('B', 'E');
graph2.addEdge('C', 'F');
graph2.addEdge('D', 'F');
graph2.addEdge('E', 'F');

console.log('Kahn\'s topological order:', graph2.topologicalSortKahn());
```

### **Approach 3: All Possible Topological Orders**
```javascript
/**
 * Find all valid topological orderings
 */
function allTopologicalSorts(graph) {
  const inDegree = {};
  const allOrders = [];
  
  // Calculate in-degrees
  for (const vertex in graph.adjacencyList) {
    inDegree[vertex] = 0;
  }
  
  for (const vertex in graph.adjacencyList) {
    for (const neighbor of graph.adjacencyList[vertex]) {
      inDegree[neighbor] = (inDegree[neighbor] || 0) + 1;
    }
  }
  
  function backtrack(current, remaining) {
    if (remaining === 0) {
      allOrders.push([...current]);
      return;
    }
    
    // Try all vertices with in-degree 0
    for (const vertex in inDegree) {
      if (inDegree[vertex] === 0) {
        // Choose vertex
        current.push(vertex);
        
        // Temporarily reduce in-degrees
        const neighbors = graph.adjacencyList[vertex];
        for (const neighbor of neighbors) {
          inDegree[neighbor]--;
        }
        
        inDegree[vertex] = -1; // Mark as used
        
        // Recurse
        backtrack(current, remaining - 1);
        
        // Backtrack
        inDegree[vertex] = 0;
        for (const neighbor of neighbors) {
          inDegree[neighbor]++;
        }
        current.pop();
      }
    }
  }
  
  const vertexCount = Object.keys(graph.adjacencyList).length;
  backtrack([], vertexCount);
  
  return allOrders;
}

// Test
console.log('\n=== All Topological Orders ===');

const graph3 = new DirectedGraph();
['A', 'B', 'C', 'D'].forEach(v => graph3.addVertex(v));
graph3.addEdge('A', 'C');
graph3.addEdge('B', 'C');
graph3.addEdge('C', 'D');

console.log('All valid orders:', allTopologicalSorts(graph3));
// [['A', 'B', 'C', 'D'], ['B', 'A', 'C', 'D']]
```

### **Approach 4: Topological Sort with Levels**
```javascript
/**
 * Topological sort grouped by levels (parallel processing)
 */
function topologicalSortWithLevels(graph) {
  const inDegree = {};
  const levels = [];
  
  // Initialize in-degrees
  for (const vertex in graph.adjacencyList) {
    inDegree[vertex] = 0;
  }
  
  for (const vertex in graph.adjacencyList) {
    for (const neighbor of graph.adjacencyList[vertex]) {
      inDegree[neighbor] = (inDegree[neighbor] || 0) + 1;
    }
  }
  
  let currentLevel = [];
  
  // Find vertices with in-degree 0
  for (const vertex in inDegree) {
    if (inDegree[vertex] === 0) {
      currentLevel.push(vertex);
    }
  }
  
  while (currentLevel.length > 0) {
    levels.push([...currentLevel]);
    const nextLevel = [];
    
    for (const vertex of currentLevel) {
      for (const neighbor of graph.adjacencyList[vertex]) {
        inDegree[neighbor]--;
        
        if (inDegree[neighbor] === 0) {
          nextLevel.push(neighbor);
        }
      }
    }
    
    currentLevel = nextLevel;
  }
  
  return levels;
}

// Test
console.log('\n=== Topological Sort with Levels ===');

const graph4 = new DirectedGraph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph4.addVertex(v));
graph4.addEdge('A', 'C');
graph4.addEdge('A', 'D');
graph4.addEdge('B', 'D');
graph4.addEdge('C', 'E');
graph4.addEdge('D', 'E');
graph4.addEdge('D', 'F');
graph4.addEdge('E', 'F');

const levels = topologicalSortWithLevels(graph4);
console.log('Levels:', levels);
// [[A, B], [C, D], [E], [F]]
// Level 0: A, B can run in parallel
// Level 1: C, D can run after A, B
// etc.
```

### **Approach 5: Lexicographically Smallest Topological Sort**
```javascript
/**
 * Find lexicographically smallest topological order
 * Uses priority queue (min heap) instead of regular queue
 */
class MinHeap {
  constructor(compareFn = (a, b) => a.localeCompare(b)) {
    this.heap = [];
    this.compare = compareFn;
  }
  
  push(val) {
    this.heap.push(val);
    this.bubbleUp(this.heap.length - 1);
  }
  
  pop() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();
    
    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    return min;
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parent = Math.floor((index - 1) / 2);
      if (this.compare(this.heap[index], this.heap[parent]) >= 0) break;
      [this.heap[index], this.heap[parent]] = [this.heap[parent], this.heap[index]];
      index = parent;
    }
  }
  
  bubbleDown(index) {
    while (true) {
      let smallest = index;
      const left = 2 * index + 1;
      const right = 2 * index + 2;
      
      if (left < this.heap.length && this.compare(this.heap[left], this.heap[smallest]) < 0) {
        smallest = left;
      }
      
      if (right < this.heap.length && this.compare(this.heap[right], this.heap[smallest]) < 0) {
        smallest = right;
      }
      
      if (smallest === index) break;
      
      [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
      index = smallest;
    }
  }
  
  isEmpty() {
    return this.heap.length === 0;
  }
}

function lexicographicalTopologicalSort(graph) {
  const inDegree = {};
  const result = [];
  const pq = new MinHeap();
  
  // Initialize and calculate in-degrees
  for (const vertex in graph.adjacencyList) {
    inDegree[vertex] = 0;
  }
  
  for (const vertex in graph.adjacencyList) {
    for (const neighbor of graph.adjacencyList[vertex]) {
      inDegree[neighbor] = (inDegree[neighbor] || 0) + 1;
    }
  }
  
  // Add vertices with in-degree 0
  for (const vertex in inDegree) {
    if (inDegree[vertex] === 0) {
      pq.push(vertex);
    }
  }
  
  while (!pq.isEmpty()) {
    const vertex = pq.pop();
    result.push(vertex);
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      inDegree[neighbor]--;
      
      if (inDegree[neighbor] === 0) {
        pq.push(neighbor);
      }
    }
  }
  
  return result;
}

// Test
console.log('\n=== Lexicographical Sort ===');

const graph5 = new DirectedGraph();
['C', 'A', 'B', 'D'].forEach(v => graph5.addVertex(v));
graph5.addEdge('C', 'D');
graph5.addEdge('A', 'D');
graph5.addEdge('B', 'D');

console.log('Lexicographical order:', lexicographicalTopologicalSort(graph5));
// ['A', 'B', 'C', 'D'] (alphabetically smallest)
```

### **Real-World Use Cases**
```javascript
/**
 * Practical topological sort applications
 */

// 1. Course Scheduling
console.log('\n=== Course Scheduling ===');

class CourseScheduler {
  constructor() {
    this.graph = new KahnGraph();
  }
  
  addCourse(course) {
    this.graph.addVertex(course);
  }
  
  addPrerequisite(course, prerequisite) {
    // prerequisite must be taken before course
    this.graph.addEdge(prerequisite, course);
  }
  
  getCourseOrder() {
    try {
      return this.graph.topologicalSortKahn();
    } catch (error) {
      return { error: 'Circular prerequisites detected' };
    }
  }
  
  getCourseScheduleByLevel() {
    return topologicalSortWithLevels(this.graph);
  }
}

const courses = new CourseScheduler();

['CS101', 'CS201', 'CS301', 'MATH101', 'MATH201'].forEach(c => 
  courses.addCourse(c)
);

courses.addPrerequisite('CS201', 'CS101');
courses.addPrerequisite('CS301', 'CS201');
courses.addPrerequisite('MATH201', 'MATH101');
courses.addPrerequisite('CS301', 'MATH201');

console.log('Course order:', courses.getCourseOrder());
console.log('Semester plan:', courses.getCourseScheduleByLevel());

// 2. Build System
console.log('\n=== Build System ===');

class BuildSystem {
  constructor() {
    this.targets = new DirectedGraph();
  }
  
  addTarget(target) {
    this.targets.addVertex(target);
  }
  
  addDependency(target, dependency) {
    // dependency must be built before target
    this.targets.addEdge(dependency, target);
  }
  
  getBuildOrder() {
    return this.targets.topologicalSort();
  }
  
  getParallelBuildStages() {
    return topologicalSortWithLevels(this.targets);
  }
}

const build = new BuildSystem();

['main.o', 'utils.o', 'lib.a', 'app'].forEach(t => build.addTarget(t));
build.addDependency('main.o', 'utils.o');
build.addDependency('main.o', 'lib.a');
build.addDependency('app', 'main.o');

console.log('Build order:', build.getBuildOrder());
console.log('Parallel stages:', build.getParallelBuildStages());

// 3. Task Scheduling
console.log('\n=== Task Scheduling ===');

class TaskScheduler {
  constructor() {
    this.tasks = new DirectedGraph();
    this.durations = {};
  }
  
  addTask(task, duration = 1) {
    this.tasks.addVertex(task);
    this.durations[task] = duration;
  }
  
  addDependency(task, dependency) {
    this.tasks.addEdge(dependency, task);
  }
  
  getExecutionOrder() {
    return this.tasks.topologicalSort();
  }
  
  getCriticalPath() {
    const order = this.tasks.topologicalSort();
    const earliestStart = {};
    const latestStart = {};
    
    // Forward pass: earliest start times
    for (const task of order) {
      let maxPredecessorEnd = 0;
      
      // Find max end time of dependencies
      for (const vertex in this.tasks.adjacencyList) {
        if (this.tasks.adjacencyList[vertex].includes(task)) {
          const predEnd = earliestStart[vertex] + this.durations[vertex];
          maxPredecessorEnd = Math.max(maxPredecessorEnd, predEnd);
        }
      }
      
      earliestStart[task] = maxPredecessorEnd;
    }
    
    // Project duration
    const projectDuration = Math.max(
      ...order.map(task => earliestStart[task] + this.durations[task])
    );
    
    console.log('Project duration:', projectDuration);
    console.log('Earliest start times:', earliestStart);
    
    return { earliestStart, projectDuration };
  }
}

const scheduler = new TaskScheduler();

scheduler.addTask('Design', 3);
scheduler.addTask('Code', 5);
scheduler.addTask('Test', 2);
scheduler.addTask('Deploy', 1);

scheduler.addDependency('Code', 'Design');
scheduler.addDependency('Test', 'Code');
scheduler.addDependency('Deploy', 'Test');

console.log('Execution order:', scheduler.getExecutionOrder());
scheduler.getCriticalPath();

// 4. Package Manager
console.log('\n=== Package Manager ===');

class PackageManager {
  constructor() {
    this.packages = new DirectedGraph();
  }
  
  addPackage(pkg) {
    this.packages.addVertex(pkg);
  }
  
  addDependency(pkg, dependency) {
    this.packages.addEdge(dependency, pkg);
  }
  
  getInstallOrder(targetPackage) {
    // Get all reachable packages using DFS
    const reachable = new Set();
    
    const dfs = (vertex) => {
      if (reachable.has(vertex)) return;
      reachable.add(vertex);
      
      for (const dep of this.packages.adjacencyList[vertex]) {
        dfs(dep);
      }
    };
    
    // Reverse edges for DFS
    const reversed = {};
    for (const vertex in this.packages.adjacencyList) {
      reversed[vertex] = [];
    }
    
    for (const vertex in this.packages.adjacencyList) {
      for (const neighbor of this.packages.adjacencyList[vertex]) {
        reversed[neighbor].push(vertex);
      }
    }
    
    // DFS from target
    const dfsFromTarget = (vertex) => {
      if (reachable.has(vertex)) return;
      reachable.add(vertex);
      
      for (const dep of reversed[vertex]) {
        dfsFromTarget(dep);
      }
    };
    
    dfsFromTarget(targetPackage);
    
    // Get topological order of reachable packages
    const fullOrder = this.packages.topologicalSort();
    return fullOrder.filter(pkg => reachable.has(pkg));
  }
}

const pm = new PackageManager();

['express', 'body-parser', 'cookie-parser', 'morgan'].forEach(p => 
  pm.addPackage(p)
);

pm.addDependency('express', 'body-parser');
pm.addDependency('express', 'cookie-parser');

console.log('Install order for express:', pm.getInstallOrder('express'));

// 5. Data Pipeline
console.log('\n=== Data Pipeline ===');

class DataPipeline {
  constructor() {
    this.stages = new DirectedGraph();
  }
  
  addStage(stage) {
    this.stages.addVertex(stage);
  }
  
  addDataFlow(from, to) {
    this.stages.addEdge(from, to);
  }
  
  getExecutionPlan() {
    return topologicalSortWithLevels(this.stages);
  }
}

const pipeline = new DataPipeline();

['Extract', 'Transform1', 'Transform2', 'Validate', 'Load'].forEach(s => 
  pipeline.addStage(s)
);

pipeline.addDataFlow('Extract', 'Transform1');
pipeline.addDataFlow('Extract', 'Transform2');
pipeline.addDataFlow('Transform1', 'Validate');
pipeline.addDataFlow('Transform2', 'Validate');
pipeline.addDataFlow('Validate', 'Load');

console.log('Pipeline stages (parallel):', pipeline.getExecutionPlan());
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty graph
const empty = new DirectedGraph();
console.log('Empty graph:', empty.topologicalSort()); // []

// Single vertex
const single = new DirectedGraph();
single.addVertex('A');
console.log('Single vertex:', single.topologicalSort()); // ['A']

// Linear chain
const chain = new DirectedGraph();
['A', 'B', 'C', 'D'].forEach(v => chain.addVertex(v));
chain.addEdge('A', 'B');
chain.addEdge('B', 'C');
chain.addEdge('C', 'D');
console.log('Linear chain:', chain.topologicalSort()); // ['A', 'B', 'C', 'D']

// Complete DAG (all possible edges)
const complete = new DirectedGraph();
['A', 'B', 'C'].forEach(v => complete.addVertex(v));
complete.addEdge('A', 'B');
complete.addEdge('A', 'C');
complete.addEdge('B', 'C');
console.log('Complete DAG:', complete.topologicalSort()); // ['A', 'B', 'C']

// Disconnected components
const disconnected = new DirectedGraph();
['A', 'B', 'C', 'D'].forEach(v => disconnected.addVertex(v));
disconnected.addEdge('A', 'B');
disconnected.addEdge('C', 'D');
console.log('Disconnected:', disconnected.topologicalSort());
// Multiple valid orders

// Graph with cycle (should fail with Kahn's)
const cyclic = new KahnGraph();
['A', 'B', 'C'].forEach(v => cyclic.addVertex(v));
cyclic.addEdge('A', 'B');
cyclic.addEdge('B', 'C');
cyclic.addEdge('C', 'A');

try {
  cyclic.topologicalSortKahn();
} catch (error) {
  console.log('Cyclic graph error:', error.message);
}
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Algorithm Comparison:
┌──────────────────┬─────────────┬─────────────┬────────────────┐
│ Algorithm        │ Time        │ Space       │ Advantages     │
├──────────────────┼─────────────┼─────────────┼────────────────┤
│ DFS              │ O(V + E)    │ O(V)        │ Simple, one    │
│                  │             │             │ valid order    │
├──────────────────┼─────────────┼─────────────┼────────────────┤
│ Kahn's (BFS)     │ O(V + E)    │ O(V)        │ Detects cycles,│
│                  │             │             │ level tracking │
├──────────────────┼─────────────┼─────────────┼────────────────┤
│ All orders       │ O(V! × E)   │ O(V)        │ Find all valid │
│                  │             │             │ orderings      │
├──────────────────┼─────────────┼─────────────┼────────────────┤
│ Lexicographical  │ O((V+E)logV)│ O(V)        │ Smallest order │
└──────────────────┴─────────────┴─────────────┴────────────────┘

When to use:
• DFS: Default choice, simple and efficient
• Kahn's: Need cycle detection or level grouping
• All orders: Count valid schedules, enumerate options
• Lexicographical: Specific ordering requirement

Applications:
• Course scheduling: plan semester, detect prereq cycles
• Build systems: compilation order, parallel builds
• Task scheduling: project management, critical path
• Package managers: installation order, dependency resolution
• Data pipelines: ETL stages, parallel processing
`);
```

**Interview Tips:**
- Topological sort: linear ordering of vertices where u comes before v for every edge u→v
- Only possible for DAG (Directed Acyclic Graph)
- Two main algorithms: DFS (post-order) and Kahn's (BFS with in-degrees)
- DFS approach: run DFS, add vertex to result after visiting all descendants, reverse result
- Kahn's approach: repeatedly remove vertices with in-degree 0, reduce neighbors' in-degrees
- Time: O(V + E) for both approaches
- Space: O(V) for auxiliary data structures
- Post-order: in DFS, add vertex after processing all children (finish time order)
- In-degree: number of incoming edges to a vertex
- Applications: course prerequisites, build order, task scheduling, dependency resolution
- Cycle detection: Kahn's algorithm naturally detects cycles (not all vertices processed)
- Multiple valid orders: most DAGs have multiple topological orderings
- Levels: vertices at same level have no dependencies between them (can run in parallel)
- Critical path: in project scheduling, longest path determines minimum project duration
- Lexicographical: use priority queue instead of regular queue in Kahn's algorithm
- All orders: backtracking to enumerate all valid topological sorts
- Edge cases: empty graph, single vertex, disconnected components, cycles
- DFS vs Kahn's: DFS simpler, Kahn's better for cycle detection and level tracking
- Optimization: early termination if only one valid order needed
- Clarify: need one order or all? detect cycles? level grouping? lexicographical order?
- Follow-ups: find all valid orders, minimum time with parallel execution, longest path

</details>

104. Find all strongly connected components in a graph

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Kosaraju's Algorithm (Two DFS)**
```javascript
/**
 * Find SCCs using Kosaraju's algorithm
 * Time Complexity: O(V + E)
 * Space Complexity: O(V)
 */
class DirectedGraph {
  constructor() {
    this.adjacencyList = {};
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }
  
  addEdge(from, to) {
    this.adjacencyList[from].push(to);
  }
  
  // Kosaraju's Algorithm
  findStronglyConnectedComponents() {
    const visited = new Set();
    const stack = [];
    
    // Step 1: Fill stack with vertices in order of finish time (DFS)
    const dfs1 = (vertex) => {
      visited.add(vertex);
      
      for (const neighbor of this.adjacencyList[vertex]) {
        if (!visited.has(neighbor)) {
          dfs1(neighbor);
        }
      }
      
      stack.push(vertex); // Add after visiting all descendants
    };
    
    // Run DFS on all unvisited vertices
    for (const vertex in this.adjacencyList) {
      if (!visited.has(vertex)) {
        dfs1(vertex);
      }
    }
    
    // Step 2: Create transpose (reverse) graph
    const transpose = {};
    for (const vertex in this.adjacencyList) {
      transpose[vertex] = [];
    }
    
    for (const vertex in this.adjacencyList) {
      for (const neighbor of this.adjacencyList[vertex]) {
        transpose[neighbor].push(vertex);
      }
    }
    
    // Step 3: DFS on transpose in order from stack
    visited.clear();
    const sccs = [];
    
    const dfs2 = (vertex, component) => {
      visited.add(vertex);
      component.push(vertex);
      
      for (const neighbor of transpose[vertex]) {
        if (!visited.has(neighbor)) {
          dfs2(neighbor, component);
        }
      }
    };
    
    while (stack.length > 0) {
      const vertex = stack.pop();
      
      if (!visited.has(vertex)) {
        const component = [];
        dfs2(vertex, component);
        sccs.push(component);
      }
    }
    
    return sccs;
  }
}

// Test
console.log('=== Kosaraju\'s Algorithm ===');

const graph = new DirectedGraph();
['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'].forEach(v => graph.addVertex(v));

// Create SCCs: {A, B, C}, {D, E}, {F, G}, {H}
graph.addEdge('A', 'B');
graph.addEdge('B', 'C');
graph.addEdge('C', 'A'); // SCC 1

graph.addEdge('B', 'D');
graph.addEdge('D', 'E');
graph.addEdge('E', 'D'); // SCC 2

graph.addEdge('C', 'F');
graph.addEdge('F', 'G');
graph.addEdge('G', 'F'); // SCC 3

graph.addEdge('E', 'H'); // SCC 4 (single node)

const sccs = graph.findStronglyConnectedComponents();
console.log('SCCs:', sccs);
```

### **Approach 2: Tarjan's Algorithm (Single DFS)**
```javascript
/**
 * Find SCCs using Tarjan's algorithm with single DFS
 * More efficient as it only does one DFS pass
 */
class TarjanGraph extends DirectedGraph {
  findSCCsTarjan() {
    let index = 0;
    const indices = {};
    const lowLinks = {};
    const onStack = new Set();
    const stack = [];
    const sccs = [];
    
    const strongConnect = (vertex) => {
      // Set the depth index for this vertex
      indices[vertex] = index;
      lowLinks[vertex] = index;
      index++;
      
      stack.push(vertex);
      onStack.add(vertex);
      
      // Consider successors
      for (const neighbor of this.adjacencyList[vertex]) {
        if (indices[neighbor] === undefined) {
          // Successor not yet visited; recurse
          strongConnect(neighbor);
          lowLinks[vertex] = Math.min(lowLinks[vertex], lowLinks[neighbor]);
        } else if (onStack.has(neighbor)) {
          // Successor is on stack (part of current SCC)
          lowLinks[vertex] = Math.min(lowLinks[vertex], indices[neighbor]);
        }
      }
      
      // If vertex is a root node, pop the stack to find SCC
      if (lowLinks[vertex] === indices[vertex]) {
        const scc = [];
        let w;
        
        do {
          w = stack.pop();
          onStack.delete(w);
          scc.push(w);
        } while (w !== vertex);
        
        sccs.push(scc);
      }
    };
    
    // Run for all unvisited vertices
    for (const vertex in this.adjacencyList) {
      if (indices[vertex] === undefined) {
        strongConnect(vertex);
      }
    }
    
    return sccs;
  }
}

// Test
console.log('\n=== Tarjan\'s Algorithm ===');

const graph2 = new TarjanGraph();
['0', '1', '2', '3', '4', '5', '6', '7'].forEach(v => graph2.addVertex(v));

graph2.addEdge('0', '1');
graph2.addEdge('1', '2');
graph2.addEdge('2', '0'); // SCC: 0, 1, 2

graph2.addEdge('1', '3');
graph2.addEdge('3', '4');
graph2.addEdge('4', '5');
graph2.addEdge('5', '3'); // SCC: 3, 4, 5

graph2.addEdge('4', '6');
graph2.addEdge('6', '7'); // SCC: 6, SCC: 7

const sccs2 = graph2.findSCCsTarjan();
console.log('SCCs (Tarjan):', sccs2);
```

### **Approach 3: Path-Based Algorithm**
```javascript
/**
 * Path-based strong component algorithm
 * Alternative to Tarjan's with two stacks
 */
function findSCCsPathBased(graph) {
  let preorderCounter = 0;
  const preorder = {};
  const assigned = {};
  const stack = [];
  const boundaryStack = [];
  const sccs = [];
  
  function dfs(vertex) {
    preorder[vertex] = preorderCounter++;
    stack.push(vertex);
    boundaryStack.push(vertex);
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (preorder[neighbor] === undefined) {
        dfs(neighbor);
      } else if (assigned[neighbor] === undefined) {
        // Remove vertices with higher preorder than neighbor
        while (preorder[boundaryStack[boundaryStack.length - 1]] > preorder[neighbor]) {
          boundaryStack.pop();
        }
      }
    }
    
    // Check if vertex is boundary
    if (boundaryStack[boundaryStack.length - 1] === vertex) {
      boundaryStack.pop();
      const scc = [];
      let w;
      
      do {
        w = stack.pop();
        assigned[w] = true;
        scc.push(w);
      } while (w !== vertex);
      
      sccs.push(scc);
    }
  }
  
  for (const vertex in graph.adjacencyList) {
    if (preorder[vertex] === undefined) {
      dfs(vertex);
    }
  }
  
  return sccs;
}

// Test
console.log('\n=== Path-Based Algorithm ===');

const graph3 = new DirectedGraph();
['A', 'B', 'C', 'D', 'E'].forEach(v => graph3.addVertex(v));

graph3.addEdge('A', 'B');
graph3.addEdge('B', 'C');
graph3.addEdge('C', 'A'); // SCC: A, B, C

graph3.addEdge('B', 'D');
graph3.addEdge('D', 'E');
graph3.addEdge('E', 'D'); // SCC: D, E

console.log('SCCs (Path-based):', findSCCsPathBased(graph3));
```

### **Approach 4: SCC Condensation Graph**
```javascript
/**
 * Create condensation graph (DAG of SCCs)
 */
function createCondensationGraph(graph) {
  const sccs = graph.findStronglyConnectedComponents();
  
  // Map each vertex to its SCC index
  const vertexToSCC = {};
  sccs.forEach((scc, index) => {
    scc.forEach(vertex => {
      vertexToSCC[vertex] = index;
    });
  });
  
  // Build condensation graph
  const condensation = new DirectedGraph();
  
  // Add vertices (SCC indices)
  for (let i = 0; i < sccs.length; i++) {
    condensation.addVertex(i);
  }
  
  // Add edges between different SCCs
  const addedEdges = new Set();
  
  for (const vertex in graph.adjacencyList) {
    const fromSCC = vertexToSCC[vertex];
    
    for (const neighbor of graph.adjacencyList[vertex]) {
      const toSCC = vertexToSCC[neighbor];
      
      if (fromSCC !== toSCC) {
        const edgeKey = `${fromSCC}->${toSCC}`;
        if (!addedEdges.has(edgeKey)) {
          condensation.addEdge(fromSCC, toSCC);
          addedEdges.add(edgeKey);
        }
      }
    }
  }
  
  return { sccs, condensation, vertexToSCC };
}

// Test
console.log('\n=== Condensation Graph ===');

const graph4 = new DirectedGraph();
['A', 'B', 'C', 'D', 'E', 'F'].forEach(v => graph4.addVertex(v));

graph4.addEdge('A', 'B');
graph4.addEdge('B', 'A'); // SCC 0: A, B

graph4.addEdge('B', 'C');
graph4.addEdge('C', 'D');
graph4.addEdge('D', 'C'); // SCC 1: C, D

graph4.addEdge('D', 'E');
graph4.addEdge('E', 'F');
graph4.addEdge('F', 'E'); // SCC 2: E, F

const { sccs: sccs4, condensation, vertexToSCC } = createCondensationGraph(graph4);
console.log('SCCs:', sccs4);
console.log('Vertex to SCC mapping:', vertexToSCC);
console.log('Condensation edges:', condensation.adjacencyList);
```

### **Approach 5: Finding Bridges and Articulation Points**
```javascript
/**
 * Related: Find bridges (edges whose removal disconnects graph)
 * and articulation points (vertices whose removal disconnects)
 */
class BridgeArticulationFinder {
  constructor(graph) {
    this.graph = graph;
    this.time = 0;
  }
  
  findBridges() {
    const visited = new Set();
    const disc = {}; // Discovery time
    const low = {}; // Lowest reachable
    const parent = {};
    const bridges = [];
    
    const dfs = (u) => {
      visited.add(u);
      disc[u] = low[u] = this.time++;
      
      for (const v of this.graph.adjacencyList[u]) {
        if (!visited.has(v)) {
          parent[v] = u;
          dfs(v);
          
          low[u] = Math.min(low[u], low[v]);
          
          // If lowest reachable from v is greater than discovery of u
          if (low[v] > disc[u]) {
            bridges.push([u, v]);
          }
        } else if (v !== parent[u]) {
          low[u] = Math.min(low[u], disc[v]);
        }
      }
    };
    
    for (const vertex in this.graph.adjacencyList) {
      if (!visited.has(vertex)) {
        dfs(vertex);
      }
    }
    
    return bridges;
  }
  
  findArticulationPoints() {
    const visited = new Set();
    const disc = {};
    const low = {};
    const parent = {};
    const ap = new Set();
    
    const dfs = (u) => {
      let children = 0;
      visited.add(u);
      disc[u] = low[u] = this.time++;
      
      for (const v of this.graph.adjacencyList[u]) {
        if (!visited.has(v)) {
          children++;
          parent[v] = u;
          dfs(v);
          
          low[u] = Math.min(low[u], low[v]);
          
          // u is root with multiple children OR
          // u is not root and low[v] >= disc[u]
          if (parent[u] === undefined && children > 1) {
            ap.add(u);
          }
          
          if (parent[u] !== undefined && low[v] >= disc[u]) {
            ap.add(u);
          }
        } else if (v !== parent[u]) {
          low[u] = Math.min(low[u], disc[v]);
        }
      }
    };
    
    for (const vertex in this.graph.adjacencyList) {
      if (!visited.has(vertex)) {
        dfs(vertex);
      }
    }
    
    return Array.from(ap);
  }
}

// Test
console.log('\n=== Bridges and Articulation Points ===');

const graph5 = new DirectedGraph();
['0', '1', '2', '3', '4'].forEach(v => graph5.addVertex(v));

graph5.addEdge('0', '1');
graph5.addEdge('1', '0');
graph5.addEdge('1', '2');
graph5.addEdge('2', '1');
graph5.addEdge('1', '3');
graph5.addEdge('3', '1');
graph5.addEdge('3', '4');
graph5.addEdge('4', '3');

const finder = new BridgeArticulationFinder(graph5);
console.log('Bridges:', finder.findBridges());
console.log('Articulation points:', finder.findArticulationPoints());
```

### **Real-World Use Cases**
```javascript
/**
 * Practical SCC applications
 */

// 1. Social Network Analysis
console.log('\n=== Social Network Analysis ===');

class SocialNetwork {
  constructor() {
    this.follows = new DirectedGraph();
  }
  
  addUser(user) {
    this.follows.addVertex(user);
  }
  
  follow(follower, followee) {
    this.follows.addEdge(follower, followee);
  }
  
  findCommunities() {
    // Communities are SCCs - groups where everyone can reach everyone
    return this.follows.findStronglyConnectedComponents();
  }
  
  findInfluencers() {
    const { sccs, condensation, vertexToSCC } = createCondensationGraph(this.follows);
    
    // Calculate in-degree for each SCC in condensation
    const inDegree = {};
    for (const scc in condensation.adjacencyList) {
      inDegree[scc] = 0;
    }
    
    for (const scc in condensation.adjacencyList) {
      for (const neighbor of condensation.adjacencyList[scc]) {
        inDegree[neighbor]++;
      }
    }
    
    // Find SCCs with high in-degree (many communities follow them)
    const influencers = [];
    for (const scc in inDegree) {
      if (inDegree[scc] >= 2) {
        influencers.push({ scc: parseInt(scc), users: sccs[scc], influence: inDegree[scc] });
      }
    }
    
    return influencers;
  }
}

const network = new SocialNetwork();

['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank'].forEach(u => network.addUser(u));

// Community 1: Alice, Bob, Charlie (mutual follows)
network.follow('Alice', 'Bob');
network.follow('Bob', 'Charlie');
network.follow('Charlie', 'Alice');

// Community 2: David, Eve (mutual follows)
network.follow('David', 'Eve');
network.follow('Eve', 'David');

// Frank follows both communities
network.follow('Frank', 'Alice');
network.follow('Frank', 'David');

// Communities follow Frank back
network.follow('Charlie', 'Frank');
network.follow('Eve', 'Frank');

console.log('Communities:', network.findCommunities());
console.log('Influencers:', network.findInfluencers());

// 2. Web Page Ranking
console.log('\n=== Web Page Ranking ===');

class WebGraph {
  constructor() {
    this.links = new DirectedGraph();
  }
  
  addPage(page) {
    this.links.addVertex(page);
  }
  
  addLink(from, to) {
    this.links.addEdge(from, to);
  }
  
  findStronglyLinkedGroups() {
    // Pages that link to each other form strong groups
    return this.links.findStronglyConnectedComponents();
  }
  
  identifyLinkFarms() {
    const sccs = this.links.findStronglyConnectedComponents();
    
    // Link farms are large SCCs with high internal linking
    return sccs.filter(scc => {
      if (scc.length < 3) return false;
      
      // Count internal links
      let internalLinks = 0;
      for (const page of scc) {
        for (const link of this.links.adjacencyList[page]) {
          if (scc.includes(link)) {
            internalLinks++;
          }
        }
      }
      
      // High internal link density suggests link farm
      const maxPossibleLinks = scc.length * (scc.length - 1);
      return internalLinks / maxPossibleLinks > 0.5;
    });
  }
}

const web = new WebGraph();

['pageA', 'pageB', 'pageC', 'pageD', 'pageE'].forEach(p => web.addPage(p));

// Legitimate group
web.addLink('pageA', 'pageB');
web.addLink('pageB', 'pageA');

// Link farm (suspicious)
web.addLink('pageC', 'pageD');
web.addLink('pageD', 'pageE');
web.addLink('pageE', 'pageC');
web.addLink('pageC', 'pageE');

console.log('Strongly linked groups:', web.findStronglyLinkedGroups());
console.log('Potential link farms:', web.identifyLinkFarms());

// 3. Code Dependency Analysis
console.log('\n=== Code Dependency Analysis ===');

class CodeAnalyzer {
  constructor() {
    this.dependencies = new DirectedGraph();
  }
  
  addModule(module) {
    this.dependencies.addVertex(module);
  }
  
  addImport(importer, imported) {
    this.dependencies.addEdge(importer, imported);
  }
  
  findCircularDependencies() {
    const sccs = this.dependencies.findStronglyConnectedComponents();
    
    // Circular dependencies are SCCs with more than one module
    return sccs.filter(scc => scc.length > 1);
  }
  
  suggestRefactoring() {
    const circular = this.findCircularDependencies();
    
    return circular.map(cycle => ({
      modules: cycle,
      suggestion: `Consider extracting common code from ${cycle.join(', ')} into a new module`,
      severity: cycle.length > 3 ? 'high' : 'medium'
    }));
  }
}

const analyzer = new CodeAnalyzer();

['auth', 'user', 'profile', 'settings', 'utils'].forEach(m => analyzer.addModule(m));

// Good dependencies
analyzer.addImport('auth', 'utils');
analyzer.addImport('user', 'utils');

// Circular dependency
analyzer.addImport('profile', 'user');
analyzer.addImport('user', 'settings');
analyzer.addImport('settings', 'profile'); // Creates cycle

console.log('Circular dependencies:', analyzer.findCircularDependencies());
console.log('Refactoring suggestions:', analyzer.suggestRefactoring());

// 4. Database Referential Integrity
console.log('\n=== Database Referential Integrity ===');

class DatabaseAnalyzer {
  constructor() {
    this.foreignKeys = new DirectedGraph();
  }
  
  addTable(table) {
    this.foreignKeys.addVertex(table);
  }
  
  addForeignKey(fromTable, toTable) {
    this.foreignKeys.addEdge(fromTable, toTable);
  }
  
  findMutualDependencies() {
    const sccs = this.foreignKeys.findStronglyConnectedComponents();
    return sccs.filter(scc => scc.length > 1);
  }
  
  getDeletionOrder() {
    // For tables without circular references, find safe deletion order
    const sccs = this.foreignKeys.findStronglyConnectedComponents();
    
    // Build condensation and find topological order
    const { condensation } = createCondensationGraph(this.foreignKeys);
    
    // Reverse topological sort gives deletion order
    const visited = new Set();
    const order = [];
    
    const dfs = (vertex) => {
      visited.add(vertex);
      for (const neighbor of condensation.adjacencyList[vertex]) {
        if (!visited.has(neighbor)) {
          dfs(neighbor);
        }
      }
      order.push(sccs[vertex]);
    };
    
    for (const vertex in condensation.adjacencyList) {
      if (!visited.has(vertex)) {
        dfs(parseInt(vertex));
      }
    }
    
    return order;
  }
}

const db = new DatabaseAnalyzer();

['users', 'orders', 'products', 'reviews', 'categories'].forEach(t => db.addTable(t));

db.addForeignKey('orders', 'users');
db.addForeignKey('orders', 'products');
db.addForeignKey('reviews', 'users');
db.addForeignKey('reviews', 'products');
db.addForeignKey('products', 'categories');

console.log('Mutual dependencies:', db.findMutualDependencies());
console.log('Safe deletion order:', db.getDeletionOrder());

// 5. Compiler Optimization
console.log('\n=== Compiler Optimization ===');

class ControlFlowAnalyzer {
  constructor() {
    this.cfg = new TarjanGraph(); // Control Flow Graph
  }
  
  addBasicBlock(block) {
    this.cfg.addVertex(block);
  }
  
  addJump(from, to) {
    this.cfg.addEdge(from, to);
  }
  
  findLoops() {
    // Loops are SCCs in control flow graph
    const sccs = this.cfg.findSCCsTarjan();
    return sccs.filter(scc => scc.length > 1 || this.hasSelfLoop(scc[0]));
  }
  
  hasSelfLoop(block) {
    return this.cfg.adjacencyList[block].includes(block);
  }
  
  identifyHotPaths() {
    const loops = this.findLoops();
    
    return loops.map(loop => ({
      blocks: loop,
      optimization: 'Loop unrolling, inlining, or hoisting candidates',
      complexity: loop.length
    }));
  }
}

const compiler = new ControlFlowAnalyzer();

['entry', 'cond1', 'loop_body', 'cond2', 'exit'].forEach(b => compiler.addBasicBlock(b));

compiler.addJump('entry', 'cond1');
compiler.addJump('cond1', 'loop_body');
compiler.addJump('loop_body', 'cond2');
compiler.addJump('cond2', 'loop_body'); // Loop back
compiler.addJump('cond2', 'exit');
compiler.addJump('cond1', 'exit');

console.log('Detected loops:', compiler.findLoops());
console.log('Hot paths for optimization:', compiler.identifyHotPaths());
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Single vertex (SCC of size 1)
const single = new DirectedGraph();
single.addVertex('A');
console.log('Single vertex:', single.findStronglyConnectedComponents()); // [['A']]

// Self-loop
const selfLoop = new DirectedGraph();
selfLoop.addVertex('A');
selfLoop.addEdge('A', 'A');
console.log('Self-loop:', selfLoop.findStronglyConnectedComponents()); // [['A']]

// Two vertices with bidirectional edges
const bidirectional = new DirectedGraph();
['A', 'B'].forEach(v => bidirectional.addVertex(v));
bidirectional.addEdge('A', 'B');
bidirectional.addEdge('B', 'A');
console.log('Bidirectional:', bidirectional.findStronglyConnectedComponents()); // [['A', 'B']]

// Complete graph (all vertices mutually reachable)
const complete = new DirectedGraph();
['A', 'B', 'C'].forEach(v => complete.addVertex(v));
complete.addEdge('A', 'B');
complete.addEdge('B', 'C');
complete.addEdge('C', 'A');
complete.addEdge('A', 'C');
complete.addEdge('C', 'B');
complete.addEdge('B', 'A');
console.log('Complete graph:', complete.findStronglyConnectedComponents()); // [['A', 'B', 'C']]

// DAG (each vertex is its own SCC)
const dag = new DirectedGraph();
['A', 'B', 'C', 'D'].forEach(v => dag.addVertex(v));
dag.addEdge('A', 'B');
dag.addEdge('B', 'C');
dag.addEdge('A', 'D');
dag.addEdge('D', 'C');
console.log('DAG:', dag.findStronglyConnectedComponents());
// Each vertex is separate SCC

// Disconnected components
const disconnected = new DirectedGraph();
['A', 'B', 'C', 'D'].forEach(v => disconnected.addVertex(v));
disconnected.addEdge('A', 'B');
disconnected.addEdge('B', 'A');
disconnected.addEdge('C', 'D');
disconnected.addEdge('D', 'C');
console.log('Disconnected:', disconnected.findStronglyConnectedComponents());
// [['A', 'B'], ['C', 'D']]

// Empty graph
const empty = new DirectedGraph();
console.log('Empty graph:', empty.findStronglyConnectedComponents()); // []

// Large single SCC
const largeSCC = new DirectedGraph();
for (let i = 0; i < 10; i++) {
  largeSCC.addVertex(i);
}
for (let i = 0; i < 10; i++) {
  largeSCC.addEdge(i, (i + 1) % 10); // Circular
}
console.log('Large single SCC:', largeSCC.findStronglyConnectedComponents());
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Algorithm Comparison:
┌────────────────────┬─────────────┬─────────────┬────────────────┐
│ Algorithm          │ Time        │ Space       │ Advantages     │
├────────────────────┼─────────────┼─────────────┼────────────────┤
│ Kosaraju's         │ O(V + E)    │ O(V)        │ Easy to        │
│                    │             │             │ understand     │
├────────────────────┼─────────────┼─────────────┼────────────────┤
│ Tarjan's           │ O(V + E)    │ O(V)        │ Single DFS,    │
│                    │             │             │ more efficient │
├────────────────────┼─────────────┼─────────────┼────────────────┤
│ Path-Based         │ O(V + E)    │ O(V)        │ Alternative    │
│                    │             │             │ single-pass    │
└────────────────────┴─────────────┴─────────────┴────────────────┘

Kosaraju's Algorithm:
• Two DFS passes (original graph, then transpose)
• Easy to implement and understand
• Good for teaching
• Creates transpose graph explicitly

Tarjan's Algorithm:
• Single DFS pass
• More efficient in practice (no transpose needed)
• Uses discovery time and low-link values
• Stack-based approach
• Preferred for production use

Applications:
• Social networks: community detection
• Web analysis: page ranking, link farms
• Code analysis: circular dependencies
• Database: referential integrity, deletion order
• Compilers: loop detection, optimization
• Security: vulnerability chains

Condensation Graph:
• DAG of SCCs
• Useful for meta-analysis
• Enables hierarchical processing
• Reveals high-level structure

Related Algorithms:
• Bridges: edges whose removal disconnects graph
• Articulation points: vertices whose removal disconnects
• Both use similar DFS with low-link values
`);
```

**Interview Tips:**
- SCC: maximal set of vertices where every vertex is reachable from every other
- Two main algorithms: Kosaraju's (two DFS) and Tarjan's (one DFS)
- Kosaraju's: DFS to get finish times, transpose graph, DFS in reverse finish order
- Tarjan's: single DFS with discovery time and low-link values, stack for current path
- Time: O(V + E) for both algorithms
- Space: O(V) for auxiliary structures
- Condensation graph: DAG where each node is an SCC, edges between SCCs
- Applications: social network communities, web page ranking, circular dependency detection
- Low-link value: lowest vertex reachable from subtree in DFS
- Discovery time: when vertex is first visited in DFS
- SCC root: vertex where low-link equals discovery time
- Transpose: reverse all edges in directed graph
- Finish time: when DFS completes processing a vertex (post-order)
- Why transpose: allows finding vertices that can reach a given vertex
- Stack in Tarjan's: maintains vertices in current SCC being explored
- Single vertex: can be SCC (trivial SCC)
- DAG: each vertex is its own SCC
- Complete graph: all vertices form single SCC
- Bridges and articulation points: related concepts for connectivity
- Edge cases: empty graph, single vertex, self-loops, disconnected components
- Kosaraju vs Tarjan: Kosaraju easier to understand, Tarjan more efficient
- Follow-ups: count SCCs, largest SCC, condensation graph, bridges/articulation points
- Clarify: need SCC members? condensation graph? just count? specific vertex's SCC?

</details>

105. Implement an LRU (Least Recently Used) Cache

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Hash Map + Doubly Linked List**
```javascript
/**
 * LRU Cache with O(1) operations
 * Time Complexity: O(1) for get and put
 * Space Complexity: O(capacity)
 */
class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}

class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
    
    // Dummy head and tail for easier operations
    this.head = new Node(0, 0);
    this.tail = new Node(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    const node = this.cache.get(key);
    
    // Move to front (most recently used)
    this.remove(node);
    this.addToFront(node);
    
    return node.value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      // Update existing
      const node = this.cache.get(key);
      node.value = value;
      this.remove(node);
      this.addToFront(node);
    } else {
      // Add new
      if (this.cache.size >= this.capacity) {
        // Remove least recently used (from tail)
        const lru = this.tail.prev;
        this.remove(lru);
        this.cache.delete(lru.key);
      }
      
      const newNode = new Node(key, value);
      this.cache.set(key, newNode);
      this.addToFront(newNode);
    }
  }
  
  remove(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }
  
  addToFront(node) {
    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;
  }
}

// Test
console.log('=== LRU Cache ===');

const cache = new LRUCache(3);

cache.put(1, 'one');
cache.put(2, 'two');
cache.put(3, 'three');

console.log('Get 1:', cache.get(1)); // 'one' - moves to front
console.log('Get 2:', cache.get(2)); // 'two' - moves to front

cache.put(4, 'four'); // Evicts key 3 (LRU)

console.log('Get 3:', cache.get(3)); // -1 (evicted)
console.log('Get 4:', cache.get(4)); // 'four'
console.log('Get 1:', cache.get(1)); // 'one'
console.log('Get 2:', cache.get(2)); // 'two'
```

### **Approach 2: Using Map (Built-in Ordering)**
```javascript
/**
 * LRU Cache using JavaScript Map's insertion order
 * Map maintains insertion order, delete+set moves to end
 */
class LRUCacheMap {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    const value = this.cache.get(key);
    
    // Move to end (most recent)
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // Remove first entry (oldest)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
  
  keys() {
    return Array.from(this.cache.keys());
  }
}

// Test
console.log('\n=== LRU Cache (Map) ===');

const cache2 = new LRUCacheMap(3);

cache2.put(1, 'a');
cache2.put(2, 'b');
cache2.put(3, 'c');

console.log('Keys:', cache2.keys()); // [1, 2, 3]

cache2.get(1); // Access 1
console.log('After get(1):', cache2.keys()); // [2, 3, 1]

cache2.put(4, 'd'); // Evicts 2
console.log('After put(4, d):', cache2.keys()); // [3, 1, 4]
```

### **Approach 3: LRU with Expiration Time**
```javascript
/**
 * LRU Cache with TTL (Time To Live)
 */
class LRUCacheWithTTL extends LRUCache {
  constructor(capacity, ttl = Infinity) {
    super(capacity);
    this.ttl = ttl; // milliseconds
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    const node = this.cache.get(key);
    
    // Check expiration
    if (Date.now() - node.timestamp > this.ttl) {
      this.remove(node);
      this.cache.delete(key);
      return -1;
    }
    
    // Update timestamp and move to front
    node.timestamp = Date.now();
    this.remove(node);
    this.addToFront(node);
    
    return node.value;
  }
  
  put(key, value) {
    const timestamp = Date.now();
    
    if (this.cache.has(key)) {
      const node = this.cache.get(key);
      node.value = value;
      node.timestamp = timestamp;
      this.remove(node);
      this.addToFront(node);
    } else {
      if (this.cache.size >= this.capacity) {
        const lru = this.tail.prev;
        this.remove(lru);
        this.cache.delete(lru.key);
      }
      
      const newNode = new Node(key, value);
      newNode.timestamp = timestamp;
      this.cache.set(key, newNode);
      this.addToFront(newNode);
    }
  }
}

// Test
console.log('\n=== LRU Cache with TTL ===');

const cache3 = new LRUCacheWithTTL(3, 1000); // 1 second TTL

cache3.put('temp', 'value');
console.log('Immediate get:', cache3.get('temp')); // 'value'

setTimeout(() => {
  console.log('After 1.5s:', cache3.get('temp')); // -1 (expired)
}, 1500);
```

### **Approach 4: LRU with Frequency Tracking (LFU-LRU Hybrid)**
```javascript
/**
 * LRU Cache that also tracks frequency
 * Evicts least frequently used, then least recently used
 */
class LFULRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map(); // key -> {value, freq, timestamp}
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    const entry = this.cache.get(key);
    entry.freq++;
    entry.timestamp = Date.now();
    
    return entry.value;
  }
  
  put(key, value) {
    if (this.capacity === 0) return;
    
    if (this.cache.has(key)) {
      const entry = this.cache.get(key);
      entry.value = value;
      entry.freq++;
      entry.timestamp = Date.now();
    } else {
      if (this.cache.size >= this.capacity) {
        // Find LFU, then LRU
        let minFreq = Infinity;
        let minTime = Infinity;
        let lruKey = null;
        
        for (const [k, v] of this.cache) {
          if (v.freq < minFreq || (v.freq === minFreq && v.timestamp < minTime)) {
            minFreq = v.freq;
            minTime = v.timestamp;
            lruKey = k;
          }
        }
        
        this.cache.delete(lruKey);
      }
      
      this.cache.set(key, {
        value,
        freq: 1,
        timestamp: Date.now()
      });
    }
  }
}

// Test
console.log('\n=== LFU-LRU Hybrid ===');

const cache4 = new LFULRUCache(3);

cache4.put(1, 'one');
cache4.put(2, 'two');
cache4.put(3, 'three');

cache4.get(1); // freq = 2
cache4.get(1); // freq = 3
cache4.get(2); // freq = 2

cache4.put(4, 'four'); // Evicts 3 (freq = 1, least frequent)

console.log('Get 3:', cache4.get(3)); // -1 (evicted)
console.log('Get 1:', cache4.get(1)); // 'one'
```

### **Approach 5: Thread-Safe LRU Cache**
```javascript
/**
 * Thread-safe LRU Cache (for Node.js with async operations)
 * Uses locks to prevent race conditions
 */
class ThreadSafeLRUCache extends LRUCache {
  constructor(capacity) {
    super(capacity);
    this.locks = new Map();
  }
  
  async acquireLock(key) {
    while (this.locks.has(key)) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    this.locks.set(key, true);
  }
  
  releaseLock(key) {
    this.locks.delete(key);
  }
  
  async getAsync(key) {
    await this.acquireLock(key);
    
    try {
      return this.get(key);
    } finally {
      this.releaseLock(key);
    }
  }
  
  async putAsync(key, value) {
    await this.acquireLock(key);
    
    try {
      this.put(key, value);
    } finally {
      this.releaseLock(key);
    }
  }
}

// Test
console.log('\n=== Thread-Safe LRU Cache ===');

const cache5 = new ThreadSafeLRUCache(3);

(async () => {
  await cache5.putAsync(1, 'one');
  await cache5.putAsync(2, 'two');
  
  const value = await cache5.getAsync(1);
  console.log('Async get:', value); // 'one'
})();
```

### **Real-World Use Cases**
```javascript
/**
 * Practical LRU Cache applications
 */

// 1. Web Browser Cache
console.log('\n=== Web Browser Cache ===');

class BrowserCache {
  constructor(maxPages = 50) {
    this.cache = new LRUCache(maxPages);
  }
  
  visitPage(url, content) {
    console.log(`Caching page: ${url}`);
    this.cache.put(url, content);
  }
  
  getPage(url) {
    const content = this.cache.get(url);
    
    if (content === -1) {
      console.log(`Cache miss for ${url} - fetching from server`);
      return null;
    }
    
    console.log(`Cache hit for ${url}`);
    return content;
  }
}

const browser = new BrowserCache(3);

browser.visitPage('page1.html', '<html>Page 1</html>');
browser.visitPage('page2.html', '<html>Page 2</html>');
browser.visitPage('page3.html', '<html>Page 3</html>');

browser.getPage('page1.html'); // Cache hit

browser.visitPage('page4.html', '<html>Page 4</html>'); // Evicts page2

browser.getPage('page2.html'); // Cache miss

// 2. Database Query Cache
console.log('\n=== Database Query Cache ===');

class QueryCache {
  constructor(maxQueries = 100) {
    this.cache = new LRUCacheMap(maxQueries);
    this.hits = 0;
    this.misses = 0;
  }
  
  async executeQuery(sql, params = []) {
    const cacheKey = JSON.stringify({ sql, params });
    const cached = this.cache.get(cacheKey);
    
    if (cached !== -1) {
      this.hits++;
      console.log(`Cache hit for query: ${sql.substring(0, 50)}...`);
      return cached;
    }
    
    this.misses++;
    console.log(`Cache miss - executing query: ${sql.substring(0, 50)}...`);
    
    // Simulate database query
    const result = await this.simulateDBQuery(sql, params);
    
    this.cache.put(cacheKey, result);
    return result;
  }
  
  async simulateDBQuery(sql, params) {
    // Simulate delay
    await new Promise(resolve => setTimeout(resolve, 100));
    return { rows: [], count: 0 };
  }
  
  getStats() {
    const total = this.hits + this.misses;
    const hitRate = total > 0 ? (this.hits / total * 100).toFixed(2) : 0;
    
    return {
      hits: this.hits,
      misses: this.misses,
      hitRate: `${hitRate}%`
    };
  }
}

const queryCache = new QueryCache(5);

(async () => {
  await queryCache.executeQuery('SELECT * FROM users WHERE id = ?', [1]);
  await queryCache.executeQuery('SELECT * FROM users WHERE id = ?', [1]); // Cache hit
  await queryCache.executeQuery('SELECT * FROM orders WHERE user_id = ?', [1]);
  
  console.log('Cache stats:', queryCache.getStats());
})();

// 3. API Response Cache
console.log('\n=== API Response Cache ===');

class APICache {
  constructor(maxEndpoints = 20, ttl = 60000) {
    this.cache = new LRUCacheWithTTL(maxEndpoints, ttl);
  }
  
  async fetch(endpoint, options = {}) {
    const cacheKey = JSON.stringify({ endpoint, options });
    const cached = this.cache.get(cacheKey);
    
    if (cached !== -1) {
      console.log(`Using cached response for ${endpoint}`);
      return cached;
    }
    
    console.log(`Fetching from API: ${endpoint}`);
    
    // Simulate API call
    const response = await this.simulateAPICall(endpoint, options);
    
    this.cache.put(cacheKey, response);
    return response;
  }
  
  async simulateAPICall(endpoint, options) {
    await new Promise(resolve => setTimeout(resolve, 200));
    return { data: `Response from ${endpoint}`, timestamp: Date.now() };
  }
}

const apiCache = new APICache(10, 5000); // 5 second TTL

(async () => {
  await apiCache.fetch('/api/users/1');
  await apiCache.fetch('/api/users/1'); // Cache hit
  
  setTimeout(async () => {
    await apiCache.fetch('/api/users/1'); // Cache miss after expiration
  }, 6000);
})();

// 4. Memoization Cache
console.log('\n=== Memoization Cache ===');

class MemoCache {
  constructor(fn, maxSize = 100) {
    this.fn = fn;
    this.cache = new LRUCacheMap(maxSize);
  }
  
  call(...args) {
    const key = JSON.stringify(args);
    const cached = this.cache.get(key);
    
    if (cached !== -1) {
      return cached;
    }
    
    const result = this.fn(...args);
    this.cache.put(key, result);
    
    return result;
  }
}

// Expensive Fibonacci calculation
function fibonacci(n) {
  console.log(`Calculating fib(${n})`);
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoFib = new MemoCache(fibonacci, 50);

console.log('First call fib(10):', memoFib.call(10)); // Calculates
console.log('Second call fib(10):', memoFib.call(10)); // Cached

// 5. CDN Edge Cache
console.log('\n=== CDN Edge Cache ===');

class EdgeCache {
  constructor(maxAssets = 1000) {
    this.cache = new LRUCache(maxAssets);
    this.bandwidth = 0;
  }
  
  serve(assetPath) {
    const cached = this.cache.get(assetPath);
    
    if (cached !== -1) {
      console.log(`✓ Edge cache hit: ${assetPath}`);
      return cached;
    }
    
    console.log(`✗ Edge cache miss: ${assetPath} - fetching from origin`);
    
    // Simulate fetching from origin server
    const asset = this.fetchFromOrigin(assetPath);
    this.cache.put(assetPath, asset);
    this.bandwidth += asset.size;
    
    return asset;
  }
  
  fetchFromOrigin(path) {
    return {
      path,
      content: `Binary content of ${path}`,
      size: Math.random() * 1000 + 100, // KB
      timestamp: Date.now()
    };
  }
  
  getStats() {
    return {
      bandwidthUsed: `${this.bandwidth.toFixed(2)} KB`,
      cachedAssets: this.cache.cache.size
    };
  }
}

const cdn = new EdgeCache(5);

cdn.serve('/img/logo.png');
cdn.serve('/css/style.css');
cdn.serve('/img/logo.png'); // Cache hit
cdn.serve('/js/app.js');

console.log('CDN stats:', cdn.getStats());
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Capacity 1
const tiny = new LRUCache(1);
tiny.put(1, 'one');
tiny.put(2, 'two'); // Evicts 1
console.log('Capacity 1, get(1):', tiny.get(1)); // -1
console.log('Capacity 1, get(2):', tiny.get(2)); // 'two'

// Capacity 0 (edge case)
const zero = new LRUCache(0);
zero.put(1, 'one'); // No-op
console.log('Capacity 0:', zero.get(1)); // -1

// Update existing key
const update = new LRUCache(2);
update.put(1, 'one');
update.put(1, 'ONE'); // Update
console.log('Update:', update.get(1)); // 'ONE'

// Multiple operations
const multi = new LRUCache(2);
multi.put(1, 1);
multi.put(2, 2);
console.log('Get 1:', multi.get(1)); // 1 - moves to front
multi.put(3, 3); // Evicts 2
console.log('Get 2:', multi.get(2)); // -1 (evicted)
console.log('Get 3:', multi.get(3)); // 3

// Access pattern
const pattern = new LRUCache(3);
pattern.put('a', 1);
pattern.put('b', 2);
pattern.put('c', 3);
pattern.get('a'); // Access 'a'
pattern.get('b'); // Access 'b'
pattern.put('d', 4); // Evicts 'c' (least recently used)
console.log('Get c:', pattern.get('c')); // -1
```

### **Performance Analysis**
```javascript
console.log('\n=== Performance ===');

console.log(`
LRU Cache Comparison:
┌──────────────────────┬─────────┬─────────┬─────────────────┐
│ Implementation       │ Get     │ Put     │ Advantages      │
├──────────────────────┼─────────┼─────────┼─────────────────┤
│ HashMap + DLL        │ O(1)    │ O(1)    │ True O(1),      │
│                      │         │         │ predictable     │
├──────────────────────┼─────────┼─────────┼─────────────────┤
│ Map (JS)             │ O(1)*   │ O(1)*   │ Simpler code,   │
│                      │         │         │ uses built-in   │
├──────────────────────┼─────────┼─────────┼─────────────────┤
│ With TTL             │ O(1)    │ O(1)    │ Auto-expiration │
├──────────────────────┼─────────┼─────────┼─────────────────┤
│ LFU-LRU Hybrid       │ O(1)    │ O(n)**  │ Better eviction │
└──────────────────────┴─────────┴─────────┴─────────────────┘

* Amortized O(1) but may have overhead from delete+set
** O(n) to find LFU item, can be O(1) with more complex structure

Space Complexity: O(capacity) for all implementations

Applications:
• Browser cache: recently visited pages
• Database query cache: reduce DB load
• API response cache: reduce external API calls
• CDN edge cache: serve static assets quickly
• Memoization: cache expensive function results

Key Design Decisions:
• Doubly linked list: O(1) removal and insertion
• HashMap: O(1) lookup by key
• Dummy head/tail: simplify edge cases
• Move on access: maintain LRU order

Variations:
• LFU (Least Frequently Used): evict least accessed
• MRU (Most Recently Used): evict most recent
• FIFO: evict oldest insertion
• Random: evict random entry
• TTL: time-based expiration
`);
```

**Interview Tips:**
- LRU cache: evicts least recently used item when full
- Two data structures: hash map for O(1) lookup, doubly linked list for O(1) removal
- Get operation: return value and move to front (most recent)
- Put operation: add/update, move to front, evict from tail if full
- Doubly linked list: need prev and next pointers for O(1) removal
- Dummy head/tail nodes: simplify edge cases (no null checks)
- Time: O(1) for both get and put operations
- Space: O(capacity) to store at most capacity items
- Why doubly linked: need to remove from middle efficiently
- Hash map: stores key → node mapping for fast lookup
- Most recent: at head, least recent: at tail
- On access: remove from current position, add to head
- On eviction: remove from tail (least recently used)
- JavaScript Map: maintains insertion order, can use for simpler LRU
- Map.delete() + Map.set(): moves entry to end (most recent)
- Applications: browser cache, database query cache, CDN, memoization
- Variations: LFU (frequency-based), TTL (time-based), LRU-K (k-distance)
- Thread safety: add locks for concurrent access
- Edge cases: capacity 0 or 1, update existing key, empty cache
- Optimization: could use built-in Map but less educational
- Real-world: combine with TTL for time-based expiration
- Follow-ups: implement LFU, add TTL, thread-safe version, statistics/monitoring
- Clarify: capacity limit? what to return on miss? need statistics? thread-safe?

</details>

### **Advanced Problem Solving**

106. Solve the "Longest Palindromic Substring" problem

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Expand Around Center**
```javascript
/**
 * Longest palindromic substring by expanding around each center
 * Time Complexity: O(n²)
 * Space Complexity: O(1)
 */
function longestPalindrome(s) {
  if (!s || s.length < 1) return '';
  
  let start = 0;
  let end = 0;
  
  function expandAroundCenter(left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      left--;
      right++;
    }
    // Return length of palindrome
    return right - left - 1;
  }
  
  for (let i = 0; i < s.length; i++) {
    // Odd length palindrome (center is single character)
    const len1 = expandAroundCenter(i, i);
    
    // Even length palindrome (center is between two characters)
    const len2 = expandAroundCenter(i, i + 1);
    
    const len = Math.max(len1, len2);
    
    if (len > end - start) {
      start = i - Math.floor((len - 1) / 2);
      end = i + Math.floor(len / 2);
    }
  }
  
  return s.substring(start, end + 1);
}

// Test
console.log('=== Expand Around Center ===');

console.log(longestPalindrome('babad')); // 'bab' or 'aba'
console.log(longestPalindrome('cbbd')); // 'bb'
console.log(longestPalindrome('racecar')); // 'racecar'
console.log(longestPalindrome('a')); // 'a'
console.log(longestPalindrome('ac')); // 'a' or 'c'
```

### **Approach 2: Dynamic Programming**
```javascript
/**
 * DP approach: dp[i][j] = true if substring s[i...j] is palindrome
 * Time Complexity: O(n²)
 * Space Complexity: O(n²)
 */
function longestPalindromeDP(s) {
  const n = s.length;
  if (n < 2) return s;
  
  // dp[i][j] = true if s[i...j] is palindrome
  const dp = Array(n).fill(null).map(() => Array(n).fill(false));
  
  let start = 0;
  let maxLen = 1;
  
  // Every single character is a palindrome
  for (let i = 0; i < n; i++) {
    dp[i][i] = true;
  }
  
  // Check for length 2
  for (let i = 0; i < n - 1; i++) {
    if (s[i] === s[i + 1]) {
      dp[i][i + 1] = true;
      start = i;
      maxLen = 2;
    }
  }
  
  // Check for lengths greater than 2
  for (let len = 3; len <= n; len++) {
    for (let i = 0; i < n - len + 1; i++) {
      const j = i + len - 1; // Ending index
      
      // Check if s[i...j] is palindrome
      if (s[i] === s[j] && dp[i + 1][j - 1]) {
        dp[i][j] = true;
        
        if (len > maxLen) {
          start = i;
          maxLen = len;
        }
      }
    }
  }
  
  return s.substring(start, start + maxLen);
}

// Test
console.log('\n=== Dynamic Programming ===');

console.log(longestPalindromeDP('babad')); // 'bab' or 'aba'
console.log(longestPalindromeDP('cbbd')); // 'bb'
console.log(longestPalindromeDP('noon')); // 'noon'
console.log(longestPalindromeDP('abcdefg')); // any single char
```

### **Approach 3: Manacher's Algorithm (Optimal)**
```javascript
/**
 * Manacher's algorithm - linear time
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function longestPalindromeManacher(s) {
  if (!s || s.length === 0) return '';
  
  // Transform string to handle even/odd palindromes uniformly
  // "abc" -> "^#a#b#c#$"
  let T = '^';
  for (let i = 0; i < s.length; i++) {
    T += '#' + s[i];
  }
  T += '#$';
  
  const n = T.length;
  const P = new Array(n).fill(0); // P[i] = radius of palindrome centered at i
  let center = 0;
  let right = 0;
  
  for (let i = 1; i < n - 1; i++) {
    // Mirror of i with respect to center
    const mirror = 2 * center - i;
    
    if (i < right) {
      P[i] = Math.min(right - i, P[mirror]);
    }
    
    // Expand around i
    try {
      while (T[i + 1 + P[i]] === T[i - 1 - P[i]]) {
        P[i]++;
      }
    } catch (e) {
      // Out of bounds
    }
    
    // Update center and right if palindrome extends past right
    if (i + P[i] > right) {
      center = i;
      right = i + P[i];
    }
  }
  
  // Find longest palindrome
  let maxLen = 0;
  let centerIndex = 0;
  
  for (let i = 1; i < n - 1; i++) {
    if (P[i] > maxLen) {
      maxLen = P[i];
      centerIndex = i;
    }
  }
  
  // Extract palindrome from original string
  const start = Math.floor((centerIndex - maxLen) / 2);
  return s.substring(start, start + maxLen);
}

// Test
console.log('\n=== Manacher\'s Algorithm ===');

console.log(longestPalindromeManacher('babad')); // 'bab' or 'aba'
console.log(longestPalindromeManacher('cbbd')); // 'bb'
console.log(longestPalindromeManacher('racecar')); // 'racecar'
console.log(longestPalindromeManacher('abcde')); // any single char
```

### **Approach 4: Find All Palindromic Substrings**
```javascript
/**
 * Find all palindromic substrings and return longest
 */
function findAllPalindromes(s) {
  const palindromes = [];
  
  function expandAroundCenter(left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      palindromes.push(s.substring(left, right + 1));
      left--;
      right++;
    }
  }
  
  for (let i = 0; i < s.length; i++) {
    expandAroundCenter(i, i); // Odd length
    expandAroundCenter(i, i + 1); // Even length
  }
  
  // Return longest
  return palindromes.reduce((longest, current) => 
    current.length > longest.length ? current : longest
  , '');
}

// Test
console.log('\n=== All Palindromes ===');

const allPalindromes = [];

function getAllPalindromes(s) {
  const result = [];
  
  function expandAroundCenter(left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      result.push(s.substring(left, right + 1));
      left--;
      right++;
    }
  }
  
  for (let i = 0; i < s.length; i++) {
    expandAroundCenter(i, i);
    expandAroundCenter(i, i + 1);
  }
  
  return result;
}

console.log('All palindromes in "abba":', getAllPalindromes('abba'));
console.log('Longest:', findAllPalindromes('abba'));
```

### **Approach 5: Count Palindromic Substrings**
```javascript
/**
 * Count total number of palindromic substrings
 */
function countPalindromicSubstrings(s) {
  let count = 0;
  
  function expandAroundCenter(left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      count++;
      left--;
      right++;
    }
  }
  
  for (let i = 0; i < s.length; i++) {
    expandAroundCenter(i, i); // Odd length
    expandAroundCenter(i, i + 1); // Even length
  }
  
  return count;
}

// Test
console.log('\n=== Count Palindromes ===');

console.log('Count in "abc":', countPalindromicSubstrings('abc')); // 3 (a, b, c)
console.log('Count in "aaa":', countPalindromicSubstrings('aaa')); // 6 (a, a, a, aa, aa, aaa)
console.log('Count in "noon":', countPalindromicSubstrings('noon')); // 6
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of palindrome detection
 */

// 1. DNA Sequence Analysis
console.log('\n=== DNA Sequence Analysis ===');

class DNAAnalyzer {
  constructor(sequence) {
    this.sequence = sequence;
  }
  
  findPalindromicSites() {
    // Palindromic sequences are important in genetics (restriction sites)
    const palindromes = [];
    
    function expandAroundCenter(s, left, right) {
      const found = [];
      while (left >= 0 && right < s.length && s[left] === s[right]) {
        if (right - left + 1 >= 4) { // Minimum length for restriction sites
          found.push({
            sequence: s.substring(left, right + 1),
            start: left,
            end: right,
            length: right - left + 1
          });
        }
        left--;
        right++;
      }
      return found;
    }
    
    for (let i = 0; i < this.sequence.length; i++) {
      palindromes.push(...expandAroundCenter(this.sequence, i, i));
      palindromes.push(...expandAroundCenter(this.sequence, i, i + 1));
    }
    
    // Sort by length descending
    return palindromes.sort((a, b) => b.length - a.length);
  }
  
  getLongestPalindrome() {
    return longestPalindrome(this.sequence);
  }
}

const dna = new DNAAnalyzer('GAATTCGAATTC');
console.log('Longest palindrome:', dna.getLongestPalindrome());
console.log('Palindromic sites:', dna.findPalindromicSites().slice(0, 3));

// 2. Text Processing - Detecting Symmetrical Patterns
console.log('\n=== Symmetrical Pattern Detection ===');

class TextAnalyzer {
  constructor(text) {
    this.text = text.toLowerCase().replace(/[^a-z0-9]/g, '');
  }
  
  findSymmetricalPhrases(minLength = 3) {
    const phrases = [];
    const text = this.text;
    
    function expandAroundCenter(left, right) {
      while (left >= 0 && right < text.length && text[left] === text[right]) {
        if (right - left + 1 >= minLength) {
          phrases.push({
            text: text.substring(left, right + 1),
            start: left,
            length: right - left + 1
          });
        }
        left--;
        right++;
      }
    }
    
    for (let i = 0; i < text.length; i++) {
      expandAroundCenter(i, i);
      expandAroundCenter(i, i + 1);
    }
    
    // Deduplicate and sort
    const unique = Array.from(
      new Map(phrases.map(p => [p.text, p])).values()
    );
    
    return unique.sort((a, b) => b.length - a.length);
  }
}

const analyzer = new TextAnalyzer('A man, a plan, a canal: Panama');
console.log('Symmetrical patterns:', analyzer.findSymmetricalPhrases().slice(0, 5));

// 3. Password Strength Validator
console.log('\n=== Password Strength ===');

class PasswordValidator {
  checkPalindromes(password) {
    const longest = longestPalindrome(password);
    
    // Penalize long palindromes (predictable patterns)
    return {
      longestPalindrome: longest,
      length: longest.length,
      warning: longest.length > 3 ? 
        'Contains palindromic pattern - less secure' : 
        'No significant palindromic patterns',
      strength: longest.length <= 3 ? 'Good' : 'Weak'
    };
  }
}

const validator = new PasswordValidator();

console.log(validator.checkPalindromes('abccba123')); // Weak
console.log(validator.checkPalindromes('x9k2!mQ7')); // Good

// 4. Compression Algorithm
console.log('\n=== String Compression ===');

class PalindromeCompressor {
  compress(s) {
    // Find longest palindrome to potentially compress
    const longest = longestPalindrome(s);
    const index = s.indexOf(longest);
    
    if (longest.length < 3) {
      return { compressed: s, ratio: 1.0 };
    }
    
    // Represent palindrome as center + radius notation
    const center = Math.floor(longest.length / 2);
    const compressed = 
      s.substring(0, index) + 
      `[PAL:${longest[center]}:${Math.floor(longest.length / 2)}]` +
      s.substring(index + longest.length);
    
    return {
      original: s,
      compressed,
      saved: s.length - compressed.length,
      ratio: (compressed.length / s.length).toFixed(2)
    };
  }
}

const compressor = new PalindromeCompressor();
console.log(compressor.compress('xyzracecarpqr'));
console.log(compressor.compress('abc123321xyz'));

// 5. Code Review - Detect Redundant Patterns
console.log('\n=== Code Pattern Detection ===');

class CodeAnalyzer {
  detectRedundantPatterns(code) {
    // Simplify code for analysis
    const simplified = code.replace(/\s+/g, '').toLowerCase();
    
    const palindromes = [];
    
    function expandAroundCenter(s, left, right) {
      while (left >= 0 && right < s.length && s[left] === s[right]) {
        if (right - left + 1 >= 5) { // Minimum pattern size
          palindromes.push({
            pattern: s.substring(left, right + 1),
            position: left,
            length: right - left + 1
          });
        }
        left--;
        right++;
      }
    }
    
    for (let i = 0; i < simplified.length; i++) {
      expandAroundCenter(simplified, i, i);
      expandAroundCenter(simplified, i, i + 1);
    }
    
    return palindromes.length > 0 ? {
      found: true,
      patterns: palindromes.slice(0, 3),
      suggestion: 'Consider refactoring repetitive code'
    } : {
      found: false,
      message: 'No obvious redundant patterns'
    };
  }
}

const codeAnalyzer = new CodeAnalyzer();
const code = 'if (x) { y = z; z = y; } else { y = z; z = y; }';
console.log(codeAnalyzer.detectRedundantPatterns(code));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty string
console.log('Empty string:', longestPalindrome('')); // ''

// Single character
console.log('Single char:', longestPalindrome('a')); // 'a'

// No palindrome (all different characters)
console.log('All different:', longestPalindrome('abcdef')); // Any single char

// Entire string is palindrome
console.log('Full palindrome:', longestPalindrome('racecar')); // 'racecar'

// Multiple same-length palindromes
console.log('Multiple:', longestPalindrome('abacabad')); // 'aba' or 'aca' or 'abad'

// Even length palindrome
console.log('Even length:', longestPalindrome('abba')); // 'abba'

// Odd length palindrome
console.log('Odd length:', longestPalindrome('aba')); // 'aba'

// Long string with small palindrome
const longStr = 'a'.repeat(1000) + 'racecar' + 'b'.repeat(1000);
console.log('Long string result length:', longestPalindrome(longStr).length); // 1000

// All same characters
console.log('All same:', longestPalindrome('aaaa')); // 'aaaa'

// Palindrome at start
console.log('At start:', longestPalindrome('abbaxy')); // 'abba'

// Palindrome at end
console.log('At end:', longestPalindrome('xyabba')); // 'abba'

// Nested palindromes
console.log('Nested:', longestPalindrome('abacabad')); // 'abacaba'
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

function benchmark(fn, name, input) {
  const start = performance.now();
  const result = fn(input);
  const end = performance.now();
  
  console.log(`${name}: ${result} (${(end - start).toFixed(3)}ms)`);
}

const testStr = 'forgeeksskeegfor';

benchmark(longestPalindrome, 'Expand Center', testStr);
benchmark(longestPalindromeDP, 'Dynamic Programming', testStr);
benchmark(longestPalindromeManacher, 'Manacher', testStr);

console.log(`
Algorithm Comparison:
┌────────────────────┬─────────────┬─────────────┬──────────────┐
│ Algorithm          │ Time        │ Space       │ Best For     │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Expand Center      │ O(n²)       │ O(1)        │ Simple,      │
│                    │             │             │ space-optimal│
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Dynamic Programming│ O(n²)       │ O(n²)       │ All substrings│
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Manacher's         │ O(n)        │ O(n)        │ Optimal,     │
│                    │             │             │ large inputs │
└────────────────────┴─────────────┴─────────────┴──────────────┘

Key Insights:
• Expand around center: most intuitive, good for interviews
• Consider both odd and even length palindromes
• DP: builds table of all substrings
• Manacher's: linear time but complex to implement
• For practical use: expand around center is usually sufficient

Optimization Tips:
• Early termination if max possible length exceeded
• Precompute character frequencies
• Skip positions that can't improve answer
• Use Manacher's for very long strings (10k+ chars)
`);
```

**Interview Tips:**
- Palindrome: reads same forwards and backwards
- Expand around center: most common interview approach, O(n²) time, O(1) space
- Key insight: every palindrome has a center (1 char for odd, 2 chars for even)
- For each position, expand left and right while characters match
- Time: O(n²) - n centers, each expansion O(n) worst case
- Space: O(1) - only tracking start/end indices
- DP approach: dp[i][j] = true if s[i..j] is palindrome
- DP recurrence: dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]
- DP time: O(n²), space: O(n²) for table
- Manacher's: optimal O(n) time but complex, rarely required in interviews
- Manacher's transforms string with delimiters to handle odd/even uniformly
- Two cases: odd length (center is char) and even length (center is between chars)
- Track longest palindrome: update start/end indices when found longer
- Applications: DNA analysis (restriction sites), text patterns, password validation
- Edge cases: empty string, single char, no palindrome, entire string, all same chars
- Multiple palindromes: problem usually asks for any longest, not all
- Optimization: can stop early if remaining string can't beat current max
- Common mistake: forgetting even-length palindromes
- Follow-ups: count all palindromes, longest palindromic subsequence (different!), check if palindrome
- Substring vs subsequence: substring is contiguous, subsequence allows gaps
- Clarify: return one or all longest? indices or string? ignore spaces/punctuation?

</details>

107. Implement a function to solve Sudoku

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Backtracking (Classic)**
```javascript
/**
 * Solve Sudoku using backtracking
 * Time Complexity: O(9^m) where m is number of empty cells
 * Space Complexity: O(1) if modifying in place
 */
function solveSudoku(board) {
  function isValid(board, row, col, num) {
    // Check row
    for (let x = 0; x < 9; x++) {
      if (board[row][x] === num) {
        return false;
      }
    }
    
    // Check column
    for (let x = 0; x < 9; x++) {
      if (board[x][col] === num) {
        return false;
      }
    }
    
    // Check 3x3 box
    const boxRow = Math.floor(row / 3) * 3;
    const boxCol = Math.floor(col / 3) * 3;
    
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if (board[boxRow + i][boxCol + j] === num) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  function solve(board) {
    for (let row = 0; row < 9; row++) {
      for (let col = 0; col < 9; col++) {
        if (board[row][col] === '.') {
          for (let num = 1; num <= 9; num++) {
            const char = num.toString();
            
            if (isValid(board, row, col, char)) {
              board[row][col] = char;
              
              if (solve(board)) {
                return true;
              }
              
              // Backtrack
              board[row][col] = '.';
            }
          }
          
          return false; // No valid number found
        }
      }
    }
    
    return true; // All cells filled
  }
  
  solve(board);
  return board;
}

// Test
console.log('=== Sudoku Solver (Backtracking) ===');

const puzzle = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
];

console.log('Original:');
puzzle.forEach(row => console.log(row.join(' ')));

solveSudoku(puzzle);

console.log('\nSolved:');
puzzle.forEach(row => console.log(row.join(' ')));
```

### **Approach 2: Backtracking with Optimization**
```javascript
/**
 * Optimized with constraint tracking
 */
class SudokuSolver {
  constructor(board) {
    this.board = board;
    this.rows = Array(9).fill(0).map(() => new Set());
    this.cols = Array(9).fill(0).map(() => new Set());
    this.boxes = Array(9).fill(0).map(() => new Set());
    
    // Initialize constraints
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (board[i][j] !== '.') {
          const num = board[i][j];
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
          
          this.rows[i].add(num);
          this.cols[j].add(num);
          this.boxes[boxIndex].add(num);
        }
      }
    }
  }
  
  isValid(row, col, num) {
    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
    
    return !this.rows[row].has(num) && 
           !this.cols[col].has(num) && 
           !this.boxes[boxIndex].has(num);
  }
  
  placeNumber(row, col, num) {
    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
    
    this.board[row][col] = num;
    this.rows[row].add(num);
    this.cols[col].add(num);
    this.boxes[boxIndex].add(num);
  }
  
  removeNumber(row, col, num) {
    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
    
    this.board[row][col] = '.';
    this.rows[row].delete(num);
    this.cols[col].delete(num);
    this.boxes[boxIndex].delete(num);
  }
  
  solve() {
    // Find next empty cell
    for (let row = 0; row < 9; row++) {
      for (let col = 0; col < 9; col++) {
        if (this.board[row][col] === '.') {
          // Try each number
          for (let num = 1; num <= 9; num++) {
            const char = num.toString();
            
            if (this.isValid(row, col, char)) {
              this.placeNumber(row, col, char);
              
              if (this.solve()) {
                return true;
              }
              
              this.removeNumber(row, col, char);
            }
          }
          
          return false;
        }
      }
    }
    
    return true;
  }
}

// Test
console.log('\n=== Optimized Solver ===');

const puzzle2 = [
  [".",".","9","7","4","8",".",".","."],
  ["7",".",".",".",".",".",".",".","."],
  [".","2",".","1",".","9",".",".","."],
  [".",".","7",".",".",".","2","4","."],
  [".","6","4",".","1",".","5","9","."],
  [".","9","8",".",".",".","3",".","."],
  [".",".",".","8",".","3",".","2","."],
  [".",".",".",".",".",".",".",".","6"],
  [".",".",".","2","7","5","9",".","."]
];

const solver = new SudokuSolver(puzzle2);
solver.solve();

console.log('Solved:');
solver.board.forEach(row => console.log(row.join(' ')));
```

### **Approach 3: Find All Solutions**
```javascript
/**
 * Find all possible solutions (some puzzles have multiple)
 */
function findAllSudokuSolutions(board) {
  const solutions = [];
  
  function isValid(board, row, col, num) {
    // Check row
    for (let x = 0; x < 9; x++) {
      if (board[row][x] === num) return false;
    }
    
    // Check column
    for (let x = 0; x < 9; x++) {
      if (board[x][col] === num) return false;
    }
    
    // Check box
    const boxRow = Math.floor(row / 3) * 3;
    const boxCol = Math.floor(col / 3) * 3;
    
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if (board[boxRow + i][boxCol + j] === num) return false;
      }
    }
    
    return true;
  }
  
  function solve(board) {
    for (let row = 0; row < 9; row++) {
      for (let col = 0; col < 9; col++) {
        if (board[row][col] === '.') {
          for (let num = 1; num <= 9; num++) {
            const char = num.toString();
            
            if (isValid(board, row, col, char)) {
              board[row][col] = char;
              solve(board);
              board[row][col] = '.';
            }
          }
          
          return;
        }
      }
    }
    
    // Found complete solution
    solutions.push(board.map(row => [...row]));
  }
  
  solve(board);
  return solutions;
}

// Test
console.log('\n=== Find All Solutions ===');

const simplePuzzle = [
  [".",".",".",".",".",".",".",".","1"],
  [".",".",".",".",".",".",".",".","2"],
  [".",".",".",".",".",".",".",".","3"],
  [".",".",".",".",".",".",".",".","4"],
  [".",".",".",".",".",".",".",".","5"],
  [".",".",".",".",".",".",".",".","6"],
  [".",".",".",".",".",".",".",".","7"],
  [".",".",".",".",".",".",".",".","8"],
  ["1","2","3","4","5","6","7","8","."]
];

const allSolutions = findAllSudokuSolutions(simplePuzzle);
console.log(`Found ${allSolutions.length} solution(s)`);
```

### **Approach 4: Validate Sudoku Board**
```javascript
/**
 * Validate if a Sudoku board is valid (not necessarily complete)
 */
function isValidSudoku(board) {
  // Check rows
  for (let row = 0; row < 9; row++) {
    const seen = new Set();
    for (let col = 0; col < 9; col++) {
      const num = board[row][col];
      if (num !== '.') {
        if (seen.has(num)) return false;
        seen.add(num);
      }
    }
  }
  
  // Check columns
  for (let col = 0; col < 9; col++) {
    const seen = new Set();
    for (let row = 0; row < 9; row++) {
      const num = board[row][col];
      if (num !== '.') {
        if (seen.has(num)) return false;
        seen.add(num);
      }
    }
  }
  
  // Check 3x3 boxes
  for (let box = 0; box < 9; box++) {
    const seen = new Set();
    const boxRow = Math.floor(box / 3) * 3;
    const boxCol = (box % 3) * 3;
    
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        const num = board[boxRow + i][boxCol + j];
        if (num !== '.') {
          if (seen.has(num)) return false;
          seen.add(num);
        }
      }
    }
  }
  
  return true;
}

// Test
console.log('\n=== Validate Sudoku ===');

const validBoard = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
];

const invalidBoard = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  ["5",".",".",".","8",".",".","7","9"] // Duplicate 5 in column 0
];

console.log('Valid board:', isValidSudoku(validBoard)); // true
console.log('Invalid board:', isValidSudoku(invalidBoard)); // false
```

### **Approach 5: Generate Sudoku Puzzle**
```javascript
/**
 * Generate a random valid Sudoku puzzle
 */
class SudokuGenerator {
  generateSolution() {
    const board = Array(9).fill(null).map(() => Array(9).fill('.'));
    this.fillBoard(board);
    return board;
  }
  
  fillBoard(board) {
    for (let row = 0; row < 9; row++) {
      for (let col = 0; col < 9; col++) {
        if (board[row][col] === '.') {
          const numbers = this.shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
          
          for (const num of numbers) {
            if (this.isValid(board, row, col, num.toString())) {
              board[row][col] = num.toString();
              
              if (this.fillBoard(board)) {
                return true;
              }
              
              board[row][col] = '.';
            }
          }
          
          return false;
        }
      }
    }
    
    return true;
  }
  
  isValid(board, row, col, num) {
    // Check row
    for (let x = 0; x < 9; x++) {
      if (board[row][x] === num) return false;
    }
    
    // Check column
    for (let x = 0; x < 9; x++) {
      if (board[x][col] === num) return false;
    }
    
    // Check box
    const boxRow = Math.floor(row / 3) * 3;
    const boxCol = Math.floor(col / 3) * 3;
    
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if (board[boxRow + i][boxCol + j] === num) return false;
      }
    }
    
    return true;
  }
  
  generatePuzzle(difficulty = 'medium') {
    const solution = this.generateSolution();
    const puzzle = solution.map(row => [...row]);
    
    // Remove cells based on difficulty
    const cellsToRemove = {
      easy: 30,
      medium: 40,
      hard: 50,
      expert: 55
    }[difficulty] || 40;
    
    let removed = 0;
    const cells = [];
    
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        cells.push([i, j]);
      }
    }
    
    this.shuffleArray(cells);
    
    for (const [row, col] of cells) {
      if (removed >= cellsToRemove) break;
      
      puzzle[row][col] = '.';
      removed++;
    }
    
    return { puzzle, solution };
  }
  
  shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
}

// Test
console.log('\n=== Generate Sudoku ===');

const generator = new SudokuGenerator();
const { puzzle: newPuzzle, solution } = generator.generatePuzzle('medium');

console.log('Generated puzzle:');
newPuzzle.forEach(row => console.log(row.join(' ')));

console.log('\nSolution:');
solution.forEach(row => console.log(row.join(' ')));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications beyond puzzles
 */

// 1. Constraint Satisfaction Problem Solver
console.log('\n=== CSP Solver ===');

class ConstraintSolver {
  constructor(variables, domains, constraints) {
    this.variables = variables;
    this.domains = domains;
    this.constraints = constraints;
  }
  
  solve(assignment = {}) {
    if (Object.keys(assignment).length === this.variables.length) {
      return assignment;
    }
    
    const variable = this.selectUnassignedVariable(assignment);
    
    for (const value of this.domains[variable]) {
      if (this.isConsistent(variable, value, assignment)) {
        assignment[variable] = value;
        
        const result = this.solve(assignment);
        if (result) return result;
        
        delete assignment[variable];
      }
    }
    
    return null;
  }
  
  selectUnassignedVariable(assignment) {
    for (const variable of this.variables) {
      if (!(variable in assignment)) {
        return variable;
      }
    }
  }
  
  isConsistent(variable, value, assignment) {
    for (const constraint of this.constraints) {
      if (!constraint(variable, value, assignment)) {
        return false;
      }
    }
    return true;
  }
}

// Example: Map coloring
const countries = ['A', 'B', 'C', 'D'];
const colors = { A: ['red', 'green', 'blue'], B: ['red', 'green', 'blue'], 
                 C: ['red', 'green', 'blue'], D: ['red', 'green', 'blue'] };
const adjacency = { A: ['B', 'C'], B: ['A', 'C', 'D'], C: ['A', 'B', 'D'], D: ['B', 'C'] };

const constraint = (var1, val1, assignment) => {
  for (const neighbor of adjacency[var1] || []) {
    if (neighbor in assignment && assignment[neighbor] === val1) {
      return false;
    }
  }
  return true;
};

const csp = new ConstraintSolver(countries, colors, [constraint]);
console.log('Map coloring solution:', csp.solve());

// 2. Schedule Generator
console.log('\n=== Schedule Generator ===');

class ScheduleGenerator {
  constructor(tasks, resources, constraints) {
    this.tasks = tasks;
    this.resources = resources;
    this.constraints = constraints;
  }
  
  generateSchedule() {
    const schedule = {};
    return this.backtrack(schedule, 0);
  }
  
  backtrack(schedule, taskIndex) {
    if (taskIndex === this.tasks.length) {
      return { ...schedule };
    }
    
    const task = this.tasks[taskIndex];
    
    for (const resource of this.resources) {
      for (const timeSlot of resource.availableSlots) {
        if (this.canSchedule(task, resource, timeSlot, schedule)) {
          schedule[task.id] = { resource: resource.id, time: timeSlot };
          
          const result = this.backtrack(schedule, taskIndex + 1);
          if (result) return result;
          
          delete schedule[task.id];
        }
      }
    }
    
    return null;
  }
  
  canSchedule(task, resource, timeSlot, schedule) {
    // Check resource capacity
    if (!resource.canHandle(task)) return false;
    
    // Check time conflicts
    for (const [taskId, assignment] of Object.entries(schedule)) {
      if (assignment.resource === resource.id && assignment.time === timeSlot) {
        return false;
      }
    }
    
    return true;
  }
}

// Example usage
const tasks = [
  { id: 'T1', duration: 2 },
  { id: 'T2', duration: 1 },
  { id: 'T3', duration: 3 }
];

const resources = [
  { id: 'R1', availableSlots: [9, 10, 11, 12], canHandle: (task) => true },
  { id: 'R2', availableSlots: [9, 10, 11, 12], canHandle: (task) => true }
];

const scheduler = new ScheduleGenerator(tasks, resources, []);
console.log('Schedule:', scheduler.generateSchedule());

// 3. Puzzle Game Engine
console.log('\n=== Puzzle Game Engine ===');

class PuzzleGame {
  constructor() {
    this.generator = new SudokuGenerator();
  }
  
  startGame(difficulty = 'medium') {
    const { puzzle, solution } = this.generator.generatePuzzle(difficulty);
    
    return {
      puzzle,
      solution,
      moves: [],
      hints: 3,
      startTime: Date.now()
    };
  }
  
  makeMove(game, row, col, value) {
    if (game.puzzle[row][col] !== '.') {
      return { success: false, error: 'Cell is fixed' };
    }
    
    game.puzzle[row][col] = value;
    game.moves.push({ row, col, value, time: Date.now() });
    
    const isCorrect = value === game.solution[row][col];
    
    return { 
      success: true, 
      correct: isCorrect,
      complete: this.isComplete(game.puzzle)
    };
  }
  
  getHint(game) {
    if (game.hints <= 0) {
      return { success: false, error: 'No hints remaining' };
    }
    
    // Find empty cell
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (game.puzzle[i][j] === '.') {
          game.hints--;
          return {
            success: true,
            hint: { row: i, col: j, value: game.solution[i][j] },
            hintsRemaining: game.hints
          };
        }
      }
    }
    
    return { success: false, error: 'Puzzle already complete' };
  }
  
  isComplete(puzzle) {
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (puzzle[i][j] === '.') return false;
      }
    }
    return true;
  }
}

const gameEngine = new PuzzleGame();
const game = gameEngine.startGame('easy');
console.log('Game started with', game.hints, 'hints available');

const hint = gameEngine.getHint(game);
console.log('Hint:', hint);
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty board (should fill entire board)
const emptyBoard = Array(9).fill(null).map(() => Array(9).fill('.'));
console.log('Can solve empty board:', solveSudoku(emptyBoard) !== null);

// Invalid board (no solution)
const invalidPuzzle = [
  ["5","5",".",".","7",".",".",".","."], // Two 5s in first row
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
];

console.log('Invalid board validation:', isValidSudoku(invalidPuzzle)); // false

// Almost complete board (one cell empty)
const almostComplete = [
  ["5","3","4","6","7","8","9","1","2"],
  ["6","7","2","1","9","5","3","4","8"],
  ["1","9","8","3","4","2","5","6","7"],
  ["8","5","9","7","6","1","4","2","3"],
  ["4","2","6","8","5","3","7","9","1"],
  ["7","1","3","9","2","4","8","5","6"],
  ["9","6","1","5","3","7","2","8","4"],
  ["2","8","7","4","1","9","6","3","5"],
  ["3","4","5",".","8","6","1","7","9"] // Only last cell empty
];

console.log('Almost complete:');
solveSudoku(almostComplete);
console.log(almostComplete[8][3]); // Should be '2'
```

### **Performance Analysis**
```javascript
console.log('\n=== Performance ===');

console.log(`
Sudoku Solver Complexity:
┌──────────────────────┬─────────────┬─────────────┐
│ Operation            │ Time        │ Space       │
├──────────────────────┼─────────────┼─────────────┤
│ Backtracking         │ O(9^m)      │ O(m)        │
│ Validation           │ O(1)        │ O(1)        │
│ With constraints     │ O(9^m)*     │ O(81)       │
│ Generate puzzle      │ O(9^81)     │ O(81)       │
└──────────────────────┴─────────────┴─────────────┘

Where m = number of empty cells
* Constraint tracking provides constant-time validation

Optimizations:
• Maintain sets for rows/cols/boxes (O(1) validation)
• Choose cell with fewest candidates (MRV heuristic)
• Constraint propagation (naked singles, hidden singles)
• Dancing Links (Algorithm X) for advanced cases
• Bit manipulation for faster set operations

Heuristics:
• MRV: Choose variable with minimum remaining values
• Degree: Choose variable involved in most constraints
• LCV: Try least constraining value first

Applications:
• Constraint satisfaction problems
• Resource allocation
• Scheduling
• Graph coloring
• N-Queens problem
• Puzzle games
`);
```

**Interview Tips:**
- Sudoku: 9×9 grid, fill with 1-9, each row/col/box has unique numbers
- Backtracking: classic approach, try each number, recurse, backtrack if invalid
- Three constraints: row (no duplicates), column (no duplicates), 3×3 box (no duplicates)
- Algorithm: find empty cell, try 1-9, check validity, recurse, backtrack on failure
- Time: O(9^m) where m is empty cells, worst case 9^81
- Space: O(m) for recursion stack
- Validation: check row, column, and 3×3 box for duplicates
- Box calculation: boxRow = (row/3)*3, boxCol = (col/3)*3
- Optimization: track constraints in sets for O(1) validation vs O(27) checking
- Box index: floor(row/3)*3 + floor(col/3)
- Base case: no empty cells left = solution found
- Backtrack: if no valid number works, return false and undo
- In-place vs copy: can modify board in place or create copy
- Early termination: return immediately when solution found
- Applications: CSP solver, scheduling, resource allocation, game engine
- Validation: separate function to check if board state is valid
- Generation: fill board randomly with backtracking, then remove cells
- Difficulty: more cells removed = harder puzzle
- MRV heuristic: choose cell with minimum remaining valid values
- Edge cases: no solution, multiple solutions, invalid input
- Optimization: naked singles (only one possibility), hidden singles
- Follow-ups: count solutions, validate board, generate puzzle, solve variants (16×16, irregular)
- Clarify: modify in place? multiple solutions? validate only? generate puzzle?

</details>

108. Solve the "Word Ladder" problem

<details>
<summary><b>Solution</b></summary>

### **Approach 1: BFS (Shortest Path)**
```javascript
/**
 * Word Ladder using BFS to find shortest transformation
 * Time Complexity: O(M² × N) where M is word length, N is word list size
 * Space Complexity: O(N)
 */
function ladderLength(beginWord, endWord, wordList) {
  const wordSet = new Set(wordList);
  
  if (!wordSet.has(endWord)) {
    return 0; // No transformation possible
  }
  
  const queue = [[beginWord, 1]]; // [word, level]
  const visited = new Set([beginWord]);
  
  while (queue.length > 0) {
    const [word, level] = queue.shift();
    
    if (word === endWord) {
      return level;
    }
    
    // Try changing each character
    for (let i = 0; i < word.length; i++) {
      for (let c = 97; c <= 122; c++) { // a-z
        const char = String.fromCharCode(c);
        const newWord = word.slice(0, i) + char + word.slice(i + 1);
        
        if (wordSet.has(newWord) && !visited.has(newWord)) {
          queue.push([newWord, level + 1]);
          visited.add(newWord);
        }
      }
    }
  }
  
  return 0; // No transformation found
}

// Test
console.log('=== Word Ladder (BFS) ===');

console.log(ladderLength('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog'])); // 5
// hit -> hot -> dot -> dog -> cog

console.log(ladderLength('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log'])); // 0
// endWord not in list

console.log(ladderLength('a', 'c', ['a', 'b', 'c'])); // 2
// a -> c
```

### **Approach 2: Bidirectional BFS (Optimized)**
```javascript
/**
 * Bidirectional BFS - search from both ends
 * More efficient for long paths
 */
function ladderLengthBidirectional(beginWord, endWord, wordList) {
  const wordSet = new Set(wordList);
  
  if (!wordSet.has(endWord)) {
    return 0;
  }
  
  let beginSet = new Set([beginWord]);
  let endSet = new Set([endWord]);
  const visited = new Set();
  let level = 1;
  
  while (beginSet.size > 0 && endSet.size > 0) {
    // Always expand smaller set
    if (beginSet.size > endSet.size) {
      [beginSet, endSet] = [endSet, beginSet];
    }
    
    const nextSet = new Set();
    
    for (const word of beginSet) {
      for (let i = 0; i < word.length; i++) {
        for (let c = 97; c <= 122; c++) {
          const char = String.fromCharCode(c);
          const newWord = word.slice(0, i) + char + word.slice(i + 1);
          
          if (endSet.has(newWord)) {
            return level + 1; // Found connection
          }
          
          if (wordSet.has(newWord) && !visited.has(newWord)) {
            nextSet.add(newWord);
            visited.add(newWord);
          }
        }
      }
    }
    
    beginSet = nextSet;
    level++;
  }
  
  return 0;
}

// Test
console.log('\n=== Bidirectional BFS ===');

console.log(ladderLengthBidirectional('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog'])); // 5
console.log(ladderLengthBidirectional('red', 'tax', ['ted', 'tex', 'red', 'tax', 'tad', 'den', 'rex', 'pee'])); // 4
```

### **Approach 3: Find All Shortest Paths**
```javascript
/**
 * Find all shortest transformation sequences
 */
function findLadders(beginWord, endWord, wordList) {
  const wordSet = new Set(wordList);
  
  if (!wordSet.has(endWord)) {
    return [];
  }
  
  // BFS to build parent map
  const parents = new Map();
  const queue = [beginWord];
  const visited = new Set([beginWord]);
  let found = false;
  
  while (queue.length > 0 && !found) {
    const levelSize = queue.length;
    const levelVisited = new Set();
    
    for (let i = 0; i < levelSize; i++) {
      const word = queue.shift();
      
      // Generate neighbors
      for (let j = 0; j < word.length; j++) {
        for (let c = 97; c <= 122; c++) {
          const char = String.fromCharCode(c);
          const newWord = word.slice(0, j) + char + word.slice(j + 1);
          
          if (newWord === endWord) {
            found = true;
          }
          
          if (wordSet.has(newWord) && !visited.has(newWord)) {
            if (!parents.has(newWord)) {
              parents.set(newWord, []);
            }
            parents.get(newWord).push(word);
            
            if (!levelVisited.has(newWord)) {
              queue.push(newWord);
              levelVisited.add(newWord);
            }
          }
        }
      }
    }
    
    // Mark all level words as visited after processing level
    for (const word of levelVisited) {
      visited.add(word);
    }
  }
  
  if (!found) {
    return [];
  }
  
  // Backtrack to build all paths
  const result = [];
  
  function backtrack(word, path) {
    if (word === beginWord) {
      result.push([...path].reverse());
      return;
    }
    
    if (parents.has(word)) {
      for (const parent of parents.get(word)) {
        path.push(parent);
        backtrack(parent, path);
        path.pop();
      }
    }
  }
  
  backtrack(endWord, [endWord]);
  return result;
}

// Test
console.log('\n=== All Shortest Paths ===');

const paths = findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']);
console.log('All shortest paths:');
paths.forEach(path => console.log(path.join(' -> ')));
```

### **Approach 4: Word Ladder with Pre-computed Patterns**
```javascript
/**
 * Pre-compute generic patterns for faster neighbor lookup
 * Pattern: "h*t" matches "hit", "hot", "hat", etc.
 */
function ladderLengthWithPatterns(beginWord, endWord, wordList) {
  if (!wordList.includes(endWord)) {
    return 0;
  }
  
  // Build pattern map
  const patterns = new Map();
  const allWords = [beginWord, ...wordList];
  
  for (const word of allWords) {
    for (let i = 0; i < word.length; i++) {
      const pattern = word.slice(0, i) + '*' + word.slice(i + 1);
      
      if (!patterns.has(pattern)) {
        patterns.set(pattern, []);
      }
      patterns.get(pattern).push(word);
    }
  }
  
  // BFS with pattern lookup
  const queue = [[beginWord, 1]];
  const visited = new Set([beginWord]);
  
  while (queue.length > 0) {
    const [word, level] = queue.shift();
    
    if (word === endWord) {
      return level;
    }
    
    // Get all neighbors via patterns
    for (let i = 0; i < word.length; i++) {
      const pattern = word.slice(0, i) + '*' + word.slice(i + 1);
      
      if (patterns.has(pattern)) {
        for (const neighbor of patterns.get(pattern)) {
          if (!visited.has(neighbor)) {
            queue.push([neighbor, level + 1]);
            visited.add(neighbor);
          }
        }
      }
    }
  }
  
  return 0;
}

// Test
console.log('\n=== Pattern-Based BFS ===');

console.log(ladderLengthWithPatterns('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog'])); // 5
```

### **Approach 5: Build Word Graph**
```javascript
/**
 * Build explicit graph of word connections
 */
class WordGraph {
  constructor(wordList) {
    this.graph = new Map();
    this.buildGraph(wordList);
  }
  
  buildGraph(wordList) {
    // Initialize graph
    for (const word of wordList) {
      this.graph.set(word, []);
    }
    
    // Add edges between words that differ by one character
    for (let i = 0; i < wordList.length; i++) {
      for (let j = i + 1; j < wordList.length; j++) {
        if (this.differByOne(wordList[i], wordList[j])) {
          this.graph.get(wordList[i]).push(wordList[j]);
          this.graph.get(wordList[j]).push(wordList[i]);
        }
      }
    }
  }
  
  differByOne(word1, word2) {
    if (word1.length !== word2.length) {
      return false;
    }
    
    let diffs = 0;
    for (let i = 0; i < word1.length; i++) {
      if (word1[i] !== word2[i]) {
        diffs++;
        if (diffs > 1) return false;
      }
    }
    
    return diffs === 1;
  }
  
  shortestPath(start, end) {
    if (!this.graph.has(start) || !this.graph.has(end)) {
      return 0;
    }
    
    const queue = [[start, 1]];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
      const [word, dist] = queue.shift();
      
      if (word === end) {
        return dist;
      }
      
      for (const neighbor of this.graph.get(word)) {
        if (!visited.has(neighbor)) {
          queue.push([neighbor, dist + 1]);
          visited.add(neighbor);
        }
      }
    }
    
    return 0;
  }
}

// Test
console.log('\n=== Word Graph ===');

const wordGraph = new WordGraph(['hot', 'dot', 'dog', 'lot', 'log', 'cog']);
wordGraph.graph.set('hit', ['hot']);

console.log('Shortest path (graph):', wordGraph.shortestPath('hit', 'cog'));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of word transformation
 */

// 1. Spell Checker - Suggest Similar Words
console.log('\n=== Spell Checker ===');

class SpellChecker {
  constructor(dictionary) {
    this.dictionary = new Set(dictionary);
  }
  
  suggestCorrections(misspelled, maxDistance = 2) {
    const suggestions = [];
    
    // BFS to find words within edit distance
    const queue = [[misspelled, 0]];
    const visited = new Set([misspelled]);
    
    while (queue.length > 0) {
      const [word, dist] = queue.shift();
      
      if (dist > maxDistance) continue;
      
      if (this.dictionary.has(word) && word !== misspelled) {
        suggestions.push({ word, distance: dist });
      }
      
      // Generate one-edit neighbors
      for (let i = 0; i < word.length; i++) {
        for (let c = 97; c <= 122; c++) {
          const char = String.fromCharCode(c);
          const newWord = word.slice(0, i) + char + word.slice(i + 1);
          
          if (!visited.has(newWord)) {
            queue.push([newWord, dist + 1]);
            visited.add(newWord);
          }
        }
      }
    }
    
    return suggestions.sort((a, b) => a.distance - b.distance);
  }
}

const spellChecker = new SpellChecker(['cat', 'bat', 'hat', 'mat', 'rat', 'fat', 'sat']);
console.log('Suggestions for "cot":', spellChecker.suggestCorrections('cot'));

// 2. Text Transformation Chain
console.log('\n=== Text Transformation ===');

class TextTransformer {
  constructor(validWords) {
    this.validWords = new Set(validWords);
  }
  
  findTransformationChain(source, target) {
    if (!this.validWords.has(target)) {
      return null;
    }
    
    const queue = [[source, [source]]];
    const visited = new Set([source]);
    
    while (queue.length > 0) {
      const [word, path] = queue.shift();
      
      if (word === target) {
        return path;
      }
      
      for (let i = 0; i < word.length; i++) {
        for (let c = 97; c <= 122; c++) {
          const char = String.fromCharCode(c);
          const newWord = word.slice(0, i) + char + word.slice(i + 1);
          
          if (this.validWords.has(newWord) && !visited.has(newWord)) {
            queue.push([newWord, [...path, newWord]]);
            visited.add(newWord);
          }
        }
      }
    }
    
    return null;
  }
}

const transformer = new TextTransformer(['code', 'cede', 'core', 'care', 'cape', 'tape']);
const chain = transformer.findTransformationChain('code', 'tape');
console.log('Transformation chain:', chain ? chain.join(' -> ') : 'No path found');

// 3. Word Game Solver
console.log('\n=== Word Game Solver ===');

class WordGameSolver {
  constructor(dictionary) {
    this.dictionary = dictionary;
  }
  
  solveWordChain(start, end, maxMoves) {
    const wordSet = new Set(this.dictionary);
    
    if (!wordSet.has(end)) {
      return { possible: false };
    }
    
    const queue = [[start, 1, [start]]];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
      const [word, moves, path] = queue.shift();
      
      if (moves > maxMoves) {
        continue;
      }
      
      if (word === end) {
        return {
          possible: true,
          moves: moves,
          path: path,
          score: this.calculateScore(path)
        };
      }
      
      for (let i = 0; i < word.length; i++) {
        for (let c = 97; c <= 122; c++) {
          const char = String.fromCharCode(c);
          const newWord = word.slice(0, i) + char + word.slice(i + 1);
          
          if (wordSet.has(newWord) && !visited.has(newWord)) {
            queue.push([newWord, moves + 1, [...path, newWord]]);
            visited.add(newWord);
          }
        }
      }
    }
    
    return { possible: false };
  }
  
  calculateScore(path) {
    // Score based on word rarity (length in this example)
    return path.reduce((sum, word) => sum + word.length, 0);
  }
}

const gameSolver = new WordGameSolver(['hit', 'hot', 'dot', 'dog', 'cog']);
const solution = gameSolver.solveWordChain('hit', 'cog', 5);
console.log('Game solution:', solution);

// 4. Password Strength Analyzer
console.log('\n=== Password Strength ===');

class PasswordAnalyzer {
  constructor(commonWords) {
    this.commonWords = new Set(commonWords);
  }
  
  analyzeStrength(password) {
    const strength = {
      score: 100,
      warnings: []
    };
    
    // Check proximity to common words
    const minDistance = this.minDistanceToCommon(password);
    
    if (minDistance <= 2) {
      strength.score -= 30;
      strength.warnings.push('Too similar to common words');
    }
    
    return strength;
  }
  
  minDistanceToCommon(password) {
    let minDist = Infinity;
    
    for (const word of this.commonWords) {
      if (word.length !== password.length) continue;
      
      const dist = this.hammingDistance(password, word);
      minDist = Math.min(minDist, dist);
    }
    
    return minDist;
  }
  
  hammingDistance(s1, s2) {
    let dist = 0;
    for (let i = 0; i < s1.length; i++) {
      if (s1[i] !== s2[i]) dist++;
    }
    return dist;
  }
}

const pwdAnalyzer = new PasswordAnalyzer(['password', 'qwerty', 'admin']);
console.log(pwdAnalyzer.analyzeStrength('passwprd')); // Too similar
console.log(pwdAnalyzer.analyzeStrength('x9k2mQ7!')); // Strong

// 5. Gene Mutation Tracker
console.log('\n=== Gene Mutation ===');

class GeneMutationTracker {
  constructor(validGenes) {
    this.validGenes = new Set(validGenes);
  }
  
  findMutationPath(startGene, endGene) {
    if (!this.validGenes.has(endGene)) {
      return null;
    }
    
    const queue = [[startGene, [startGene]]];
    const visited = new Set([startGene]);
    
    // Valid gene bases: A, C, G, T
    const bases = ['A', 'C', 'G', 'T'];
    
    while (queue.length > 0) {
      const [gene, path] = queue.shift();
      
      if (gene === endGene) {
        return {
          mutations: path.length - 1,
          path: path,
          steps: path.map((g, i) => ({
            step: i,
            gene: g,
            mutation: i > 0 ? this.getMutation(path[i-1], g) : null
          }))
        };
      }
      
      // Try single base mutations
      for (let i = 0; i < gene.length; i++) {
        for (const base of bases) {
          const mutated = gene.slice(0, i) + base + gene.slice(i + 1);
          
          if (this.validGenes.has(mutated) && !visited.has(mutated)) {
            queue.push([mutated, [...path, mutated]]);
            visited.add(mutated);
          }
        }
      }
    }
    
    return null;
  }
  
  getMutation(from, to) {
    for (let i = 0; i < from.length; i++) {
      if (from[i] !== to[i]) {
        return { position: i, from: from[i], to: to[i] };
      }
    }
    return null;
  }
}

const geneTracker = new GeneMutationTracker(['AAAT', 'AACT', 'ACCT', 'CCCT', 'CCCC']);
const mutationPath = geneTracker.findMutationPath('AAAT', 'CCCC');
console.log('Mutation path:', mutationPath);
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Same start and end
console.log('Same word:', ladderLength('hit', 'hit', ['hit'])); // 1

// No valid path
console.log('No path:', ladderLength('hit', 'cog', ['hot', 'dot', 'lot'])); // 0

// EndWord not in list
console.log('End not in list:', ladderLength('hit', 'cog', ['hot', 'dot'])); // 0

// Direct transformation (one step)
console.log('One step:', ladderLength('hit', 'hot', ['hot'])); // 2

// Empty word list
console.log('Empty list:', ladderLength('a', 'b', [])); // 0

// Single character words
console.log('Single char:', ladderLength('a', 'c', ['a', 'b', 'c'])); // 2

// Long words
const longWords = ['abcde', 'abcdf', 'abcef', 'abdef', 'abeef'];
console.log('Long words:', ladderLength('abcde', 'abeef', longWords)); // 3

// Large word list
const largeList = [];
for (let i = 0; i < 100; i++) {
  largeList.push('w' + i.toString().padStart(3, '0'));
}
console.log('Large list:', ladderLength('w000', 'w099', largeList)); // 0 (no connections)

// All words differ by one
const connected = ['aaa', 'aab', 'abb', 'bbb'];
console.log('Connected:', ladderLength('aaa', 'bbb', connected)); // 4
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Word Ladder Algorithms:
┌──────────────────────┬─────────────────┬─────────────┬────────────┐
│ Approach             │ Time            │ Space       │ Best For   │
├──────────────────────┼─────────────────┼─────────────┼────────────┤
│ BFS                  │ O(M² × N)       │ O(N)        │ Standard   │
│ Bidirectional BFS    │ O(M² × N/2)     │ O(N)        │ Long paths │
│ Pattern-based        │ O(M × N)        │ O(M × N)    │ Preprocessing│
│ Word Graph           │ O(N² × M)       │ O(N²)       │ Multiple   │
│                      │ build + O(E)    │             │ queries    │
└──────────────────────┴─────────────────┴─────────────┴────────────┘

Where:
  M = word length
  N = number of words in list
  E = edges in graph

Key Optimizations:
• Bidirectional BFS: expand from both ends
• Pattern matching: pre-compute generic patterns (*ot, h*t, ho*)
• Early termination: stop at first solution in BFS
• Use Set for O(1) word lookup
• Visited tracking to avoid cycles

Trade-offs:
• BFS: simple, finds shortest path
• Bidirectional: faster for long paths
• Graph: overhead to build but fast queries
• Pattern-based: faster neighbor generation

Applications:
• Spell checking and autocorrection
• Text transformation chains
• Word games (Wordle, Word Ladder)
• Gene sequence mutation analysis
• Password strength analysis
`);
```

**Interview Tips:**
- Word ladder: transform one word to another, changing one letter at a time
- Each intermediate word must exist in dictionary
- Goal: find shortest transformation sequence (BFS problem)
- BFS guarantees shortest path in unweighted graph
- Time: O(M² × N) - M for word comparison, M for generating neighbors, N words
- Space: O(N) for queue and visited set
- Key insight: treat as graph problem, words are nodes, edges between one-letter differences
- Generate neighbors: try replacing each position with a-z
- Use Set for O(1) dictionary lookup
- Track visited to avoid cycles
- Queue stores [word, level] or [word, path]
- Level/distance tracking: increment when dequeuing
- Bidirectional BFS: expand from both start and end, faster for long paths
- Always expand smaller frontier in bidirectional BFS
- Pattern approach: "h*t" matches all words differing at position 1
- Pre-computing patterns: O(M × N) space but faster neighbor lookup
- All shortest paths: use parent tracking during BFS, backtrack at end
- Edge cases: start equals end, no path, endWord not in list, empty list
- Common mistake: forgetting to check if endWord is in dictionary
- Return 0 if no path (vs -1 or null), check problem statement
- Applications: spell checker, text games, gene mutations, password analysis
- Follow-ups: find all shortest paths, count paths, with word costs, different alphabet
- Optimization: use bidirectional BFS for better performance
- Clarify: shortest path or any path? count transformations or return sequence?

</details>

109. Implement a regular expression matcher (basic)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Recursive Matching**
```javascript
/**
 * Basic regex matcher with . (any char) and * (zero or more)
 * Time Complexity: O(2^(m+n)) worst case
 * Space Complexity: O(m+n) for recursion
 */
function isMatch(text, pattern) {
  // Base case: empty pattern
  if (pattern.length === 0) {
    return text.length === 0;
  }
  
  // Check if first character matches
  const firstMatch = text.length > 0 && 
                     (pattern[0] === text[0] || pattern[0] === '.');
  
  // Handle * (zero or more of preceding character)
  if (pattern.length >= 2 && pattern[1] === '*') {
    // Try zero occurrence OR one+ occurrence
    return isMatch(text, pattern.slice(2)) || // zero
           (firstMatch && isMatch(text.slice(1), pattern)); // one or more
  } else {
    // Regular character or . (any single char)
    return firstMatch && isMatch(text.slice(1), pattern.slice(1));
  }
}

// Test
console.log('=== Recursive Matcher ===');

console.log(isMatch('aa', 'a')); // false
console.log(isMatch('aa', 'a*')); // true
console.log(isMatch('ab', '.*')); // true
console.log(isMatch('aab', 'c*a*b')); // true
console.log(isMatch('mississippi', 'mis*is*p*.')); // false
console.log(isMatch('abc', '.*c')); // true
```

### **Approach 2: Dynamic Programming**
```javascript
/**
 * DP approach for regex matching
 * dp[i][j] = true if text[0...i-1] matches pattern[0...j-1]
 */
function isMatchDP(text, pattern) {
  const m = text.length;
  const n = pattern.length;
  
  // dp[i][j] = does text[0..i-1] match pattern[0..j-1]
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(false));
  
  // Empty text and empty pattern match
  dp[0][0] = true;
  
  // Handle patterns like a*, a*b*, etc. that can match empty string
  for (let j = 2; j <= n; j++) {
    if (pattern[j - 1] === '*') {
      dp[0][j] = dp[0][j - 2];
    }
  }
  
  // Fill the table
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const textChar = text[i - 1];
      const patternChar = pattern[j - 1];
      
      if (patternChar === '*') {
        // Star can match zero or more of preceding character
        const prevPatternChar = pattern[j - 2];
        
        // Zero occurrence: ignore pattern[j-2] and pattern[j-1]
        dp[i][j] = dp[i][j - 2];
        
        // One or more occurrence: if chars match
        if (prevPatternChar === textChar || prevPatternChar === '.') {
          dp[i][j] = dp[i][j] || dp[i - 1][j];
        }
      } else if (patternChar === '.' || patternChar === textChar) {
        // Single character match
        dp[i][j] = dp[i - 1][j - 1];
      }
    }
  }
  
  return dp[m][n];
}

// Test
console.log('\n=== DP Matcher ===');

console.log(isMatchDP('aa', 'a')); // false
console.log(isMatchDP('aa', 'a*')); // true
console.log(isMatchDP('ab', '.*')); // true
console.log(isMatchDP('aab', 'c*a*b')); // true
console.log(isMatchDP('mississippi', 'mis*is*p*.')); // false
```

### **Approach 3: With Memoization**
```javascript
/**
 * Recursive with memoization for better performance
 */
function isMatchMemo(text, pattern) {
  const memo = new Map();
  
  function dp(i, j) {
    const key = `${i},${j}`;
    
    if (memo.has(key)) {
      return memo.get(key);
    }
    
    let result;
    
    if (j === pattern.length) {
      result = i === text.length;
    } else {
      const firstMatch = i < text.length && 
                        (pattern[j] === text[i] || pattern[j] === '.');
      
      if (j + 1 < pattern.length && pattern[j + 1] === '*') {
        result = dp(i, j + 2) || (firstMatch && dp(i + 1, j));
      } else {
        result = firstMatch && dp(i + 1, j + 1);
      }
    }
    
    memo.set(key, result);
    return result;
  }
  
  return dp(0, 0);
}

// Test
console.log('\n=== Memoized Matcher ===');

console.log(isMatchMemo('aa', 'a')); // false
console.log(isMatchMemo('aa', 'a*')); // true
console.log(isMatchMemo('aaaaaa', 'a*')); // true
console.log(isMatchMemo('ab', '.*')); // true
```

### **Approach 4: Extended Regex (+ operator)**
```javascript
/**
 * Extended matcher with + (one or more)
 */
function isMatchExtended(text, pattern) {
  // Convert + to equivalent pattern
  // a+ becomes aa*
  pattern = pattern.replace(/(.)\+/g, '$1$1*');
  
  return isMatchDP(text, pattern);
}

// Alternative: handle + directly
function isMatchWithPlus(text, pattern) {
  const memo = new Map();
  
  function dp(i, j) {
    const key = `${i},${j}`;
    if (memo.has(key)) return memo.get(key);
    
    let result;
    
    if (j === pattern.length) {
      result = i === text.length;
    } else {
      const firstMatch = i < text.length && 
                        (pattern[j] === text[i] || pattern[j] === '.');
      
      if (j + 1 < pattern.length) {
        const nextChar = pattern[j + 1];
        
        if (nextChar === '*') {
          // Zero or more
          result = dp(i, j + 2) || (firstMatch && dp(i + 1, j));
        } else if (nextChar === '+') {
          // One or more
          result = firstMatch && (dp(i + 1, j + 2) || dp(i + 1, j));
        } else {
          result = firstMatch && dp(i + 1, j + 1);
        }
      } else {
        result = firstMatch && dp(i + 1, j + 1);
      }
    }
    
    memo.set(key, result);
    return result;
  }
  
  return dp(0, 0);
}

// Test
console.log('\n=== Extended Matcher (+ operator) ===');

console.log(isMatchExtended('a', 'a+')); // true
console.log(isMatchExtended('aa', 'a+')); // true
console.log(isMatchExtended('', 'a+')); // false
console.log(isMatchExtended('ab', 'a+b')); // true
```

### **Approach 5: Full Regex Engine (?, [], ^, $)**
```javascript
/**
 * More complete regex engine
 */
class RegexEngine {
  constructor(pattern) {
    this.pattern = pattern;
  }
  
  match(text) {
    return this.matchRecursive(text, 0, this.pattern, 0);
  }
  
  matchRecursive(text, ti, pattern, pi) {
    // End of pattern
    if (pi === pattern.length) {
      return ti === text.length;
    }
    
    // Get current pattern character and next
    const pChar = pattern[pi];
    const nextChar = pi + 1 < pattern.length ? pattern[pi + 1] : null;
    
    // Handle quantifiers
    if (nextChar === '*') {
      // Zero occurrences
      if (this.matchRecursive(text, ti, pattern, pi + 2)) {
        return true;
      }
      
      // One or more occurrences
      let i = ti;
      while (i < text.length && this.matchChar(text[i], pChar)) {
        if (this.matchRecursive(text, i + 1, pattern, pi + 2)) {
          return true;
        }
        i++;
      }
      
      return false;
    } else if (nextChar === '?') {
      // Zero or one occurrence
      return this.matchRecursive(text, ti, pattern, pi + 2) ||
             (ti < text.length && this.matchChar(text[ti], pChar) &&
              this.matchRecursive(text, ti + 1, pattern, pi + 2));
    } else if (nextChar === '+') {
      // One or more occurrences
      if (ti >= text.length || !this.matchChar(text[ti], pChar)) {
        return false;
      }
      
      let i = ti + 1;
      while (i < text.length && this.matchChar(text[i], pChar)) {
        if (this.matchRecursive(text, i + 1, pattern, pi + 2)) {
          return true;
        }
        i++;
      }
      
      return this.matchRecursive(text, i, pattern, pi + 2);
    }
    
    // Regular character match
    if (ti < text.length && this.matchChar(text[ti], pChar)) {
      return this.matchRecursive(text, ti + 1, pattern, pi + 1);
    }
    
    return false;
  }
  
  matchChar(textChar, patternChar) {
    return patternChar === '.' || patternChar === textChar;
  }
}

// Test
console.log('\n=== Full Regex Engine ===');

const engine1 = new RegexEngine('a*b');
console.log(engine1.match('b')); // true
console.log(engine1.match('aab')); // true

const engine2 = new RegexEngine('a?b');
console.log(engine2.match('b')); // true
console.log(engine2.match('ab')); // true
console.log(engine2.match('aab')); // false

const engine3 = new RegexEngine('a+b');
console.log(engine3.match('ab')); // true
console.log(engine3.match('aab')); // true
console.log(engine3.match('b')); // false
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of pattern matching
 */

// 1. Input Validation
console.log('\n=== Input Validation ===');

class InputValidator {
  validateEmail(email) {
    // Simplified email pattern
    const pattern = '.*@.*\\..*';
    return isMatchDP(email, pattern);
  }
  
  validatePhone(phone) {
    // Pattern: XXX-XXX-XXXX
    const pattern = '[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]';
    return this.matchBracket(phone, pattern);
  }
  
  matchBracket(text, pattern) {
    // Simple bracket matching [0-9] means any digit
    let expandedPattern = pattern;
    expandedPattern = expandedPattern.replace(/\[0-9\]/g, '[0123456789]');
    
    // Convert [abc] to (a|b|c) conceptually
    const matches = expandedPattern.match(/\[([^\]]+)\]/g);
    
    if (!matches) {
      return isMatchDP(text, expandedPattern);
    }
    
    // For simplicity, just check digit patterns
    for (let i = 0; i < text.length && i < pattern.length; i++) {
      if (pattern[i] === '[') {
        const closeIdx = pattern.indexOf(']', i);
        const chars = pattern.slice(i + 1, closeIdx);
        
        if (chars === '0-9' && !/\d/.test(text[i])) {
          return false;
        }
        
        i = closeIdx;
      } else if (pattern[i] !== text[i]) {
        return false;
      }
    }
    
    return true;
  }
}

const validator = new InputValidator();
console.log('Email valid:', validator.validateEmail('user@example.com')); // true
console.log('Email invalid:', validator.validateEmail('userexample.com')); // false

// 2. Search and Replace
console.log('\n=== Search and Replace ===');

class PatternReplacer {
  replace(text, pattern, replacement) {
    // Find all matches and replace
    const matches = this.findAll(text, pattern);
    
    let result = text;
    let offset = 0;
    
    for (const match of matches) {
      const before = result.slice(0, match.start + offset);
      const after = result.slice(match.end + offset);
      result = before + replacement + after;
      offset += replacement.length - (match.end - match.start);
    }
    
    return result;
  }
  
  findAll(text, pattern) {
    const matches = [];
    
    for (let i = 0; i < text.length; i++) {
      for (let j = i + 1; j <= text.length; j++) {
        const substring = text.slice(i, j);
        
        if (isMatchDP(substring, pattern)) {
          matches.push({ start: i, end: j, text: substring });
          break; // Take first match at this position
        }
      }
    }
    
    return matches;
  }
}

const replacer = new PatternReplacer();
console.log(replacer.replace('hello world', 'w.*d', 'universe'));

// 3. Log Parser
console.log('\n=== Log Parser ===');

class LogParser {
  parseLogLine(line) {
    // Pattern: [LEVEL] message
    const levelPattern = '\\[.*\\]';
    
    // Extract level
    const levelMatch = line.match(/\[([^\]]+)\]/);
    const level = levelMatch ? levelMatch[1] : 'UNKNOWN';
    
    // Extract message (everything after "]")
    const messageStart = line.indexOf(']') + 1;
    const message = line.slice(messageStart).trim();
    
    return { level, message };
  }
  
  filterByLevel(logs, levelPattern) {
    return logs.filter(log => {
      const parsed = this.parseLogLine(log);
      return isMatchDP(parsed.level, levelPattern);
    });
  }
}

const parser = new LogParser();
const logs = [
  '[INFO] Application started',
  '[ERROR] Connection failed',
  '[WARN] Deprecated API used',
  '[INFO] User logged in'
];

console.log('ERROR logs:', parser.filterByLevel(logs, 'ERROR'));
console.log('INFO logs:', parser.filterByLevel(logs, 'INFO'));

// 4. URL Router
console.log('\n=== URL Router ===');

class URLRouter {
  constructor() {
    this.routes = [];
  }
  
  addRoute(pattern, handler) {
    this.routes.push({ pattern, handler });
  }
  
  route(url) {
    for (const route of this.routes) {
      if (this.matchRoute(url, route.pattern)) {
        return route.handler(url);
      }
    }
    
    return 'Not Found';
  }
  
  matchRoute(url, pattern) {
    // Simple pattern matching
    // /user/:id becomes /user/.*
    let regexPattern = pattern.replace(/:[\w]+/g, '.*');
    
    return isMatchDP(url, regexPattern);
  }
}

const router = new URLRouter();
router.addRoute('/user/.*', (url) => `User page: ${url}`);
router.addRoute('/post/.*', (url) => `Post page: ${url}`);
router.addRoute('/about', (url) => 'About page');

console.log(router.route('/user/123')); // User page
console.log(router.route('/post/abc')); // Post page
console.log(router.route('/about')); // About page

// 5. Command Parser
console.log('\n=== Command Parser ===');

class CommandParser {
  parseCommand(input) {
    const commands = {
      'git add .*': { action: 'add', pattern: 'git add .*' },
      'git commit .*': { action: 'commit', pattern: 'git commit .*' },
      'npm install .*': { action: 'install', pattern: 'npm install .*' }
    };
    
    for (const [pattern, command] of Object.entries(commands)) {
      if (isMatchDP(input, pattern)) {
        return {
          valid: true,
          action: command.action,
          args: input.split(' ').slice(2)
        };
      }
    }
    
    return { valid: false };
  }
}

const cmdParser = new CommandParser();
console.log(cmdParser.parseCommand('git add file.txt'));
console.log(cmdParser.parseCommand('npm install react'));
console.log(cmdParser.parseCommand('invalid command'));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty strings
console.log('Empty text and pattern:', isMatch('', '')); // true
console.log('Empty text:', isMatch('', 'a*')); // true
console.log('Empty pattern:', isMatch('a', '')); // false

// Only wildcards
console.log('Only .*:', isMatch('anything', '.*')); // true
console.log('Only a*:', isMatch('', 'a*')); // true
console.log('Only a*:', isMatch('aaa', 'a*')); // true

// Complex patterns
console.log('Complex:', isMatch('aab', 'c*a*b')); // true (c* matches '', a* matches 'aa')
console.log('Complex:', isMatch('ab', '.*c')); // false

// Single characters
console.log('Single char:', isMatch('a', '.')); // true
console.log('Single char:', isMatch('a', 'a')); // true
console.log('Single char:', isMatch('a', 'b')); // false

// Multiple stars
console.log('Multiple *:', isMatch('aaa', 'a*a*a*')); // true
console.log('Multiple *:', isMatch('ab', 'a*b*')); // true

// Star at beginning
console.log('Star at start:', isMatch('aab', 'a*aab')); // true

// Long strings
const longText = 'a'.repeat(20);
console.log('Long string:', isMatch(longText, 'a*')); // true

// No match cases
console.log('No match:', isMatch('ab', 'a')); // false
console.log('No match:', isMatch('a', 'ab')); // false
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Regex Matcher Comparison:
┌────────────────────┬─────────────────┬─────────────┬─────────────┐
│ Approach           │ Time            │ Space       │ Best For    │
├────────────────────┼─────────────────┼─────────────┼─────────────┤
│ Recursive          │ O(2^(m+n))      │ O(m+n)      │ Simple cases│
│ DP (bottom-up)     │ O(m × n)        │ O(m × n)    │ General     │
│ Memoized           │ O(m × n)        │ O(m × n)    │ Many queries│
└────────────────────┴─────────────────┴─────────────┴─────────────┘

Where m = text length, n = pattern length

Supported Operations:
• . (dot): matches any single character
• * (star): matches zero or more of preceding element
• + (plus): matches one or more (extension)
• ? (question): matches zero or one (extension)

Key Insights:
• Star requires looking ahead in pattern
• Two choices with star: use it zero times or one+ times
• DP builds table of all subproblems
• Memoization avoids recomputing same states

Real-World Patterns:
• Email: .*@.*\\..*
• Phone: [0-9]{3}-[0-9]{3}-[0-9]{4}
• URL: http.*://.*
• Date: [0-9]{4}-[0-9]{2}-[0-9]{2}

Full Regex Engines:
• NFA (Non-deterministic Finite Automaton)
• DFA (Deterministic Finite Automaton)
• Backtracking with optimization
• Thompson's construction
`);
```

**Interview Tips:**
- Regex matching: pattern with . (any char) and * (zero or more of preceding)
- Classic problem: requires recursion or DP
- Key insight: * applies to preceding character, not following
- Two cases for *: match zero times (skip pattern[0:2]) or one+ times (consume text[0])
- First character match: text[0] == pattern[0] or pattern[0] == '.'
- Recursive: check first char match, then recursively match rest
- Base case: empty pattern → check if text is also empty
- Time: O(2^(m+n)) for pure recursion due to branching
- DP optimization: dp[i][j] = text[0..i-1] matches pattern[0..j-1]
- DP time: O(m × n), space: O(m × n)
- Empty pattern with *: "a*b*c*" can match empty text
- Handle * by checking pattern[j-2] (character before *)
- Memoization: cache results by (textIndex, patternIndex) pair
- Common mistake: forgetting * matches zero or MORE (not just zero or one)
- Extension: + (one or more), ? (zero or one), [] (character class)
- Applications: input validation, search/replace, log parsing, URL routing
- Edge cases: empty strings, only wildcards, multiple stars, no match
- Real implementation: use NFA/DFA for production regex engines
- Clarify: which operators supported? case sensitive? multiline?
- Follow-ups: add +, ?, [], ^, $, full regex engine, optimize with NFA

</details>

110. Solve the "Trapping Rain Water" problem

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Two Pointers**
```javascript
/**
 * Trap rain water using two pointers
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
function trap(height) {
  if (height.length === 0) return 0;
  
  let left = 0;
  let right = height.length - 1;
  let leftMax = 0;
  let rightMax = 0;
  let water = 0;
  
  while (left < right) {
    if (height[left] < height[right]) {
      if (height[left] >= leftMax) {
        leftMax = height[left];
      } else {
        water += leftMax - height[left];
      }
      left++;
    } else {
      if (height[right] >= rightMax) {
        rightMax = height[right];
      } else {
        water += rightMax - height[right];
      }
      right--;
    }
  }
  
  return water;
}

// Test
console.log('=== Two Pointers ===');

console.log(trap([0,1,0,2,1,0,1,3,2,1,2,1])); // 6
console.log(trap([4,2,0,3,2,5])); // 9
console.log(trap([3,0,2,0,4])); // 7
console.log(trap([5,4,1,2])); // 1
```

### **Approach 2: Dynamic Programming**
```javascript
/**
 * Pre-compute max heights on left and right
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function trapDP(height) {
  const n = height.length;
  if (n === 0) return 0;
  
  // leftMax[i] = max height from 0 to i
  const leftMax = new Array(n);
  leftMax[0] = height[0];
  
  for (let i = 1; i < n; i++) {
    leftMax[i] = Math.max(leftMax[i - 1], height[i]);
  }
  
  // rightMax[i] = max height from i to n-1
  const rightMax = new Array(n);
  rightMax[n - 1] = height[n - 1];
  
  for (let i = n - 2; i >= 0; i--) {
    rightMax[i] = Math.max(rightMax[i + 1], height[i]);
  }
  
  // Calculate water at each position
  let water = 0;
  for (let i = 0; i < n; i++) {
    const waterLevel = Math.min(leftMax[i], rightMax[i]);
    water += waterLevel - height[i];
  }
  
  return water;
}

// Test
console.log('\n=== Dynamic Programming ===');

console.log(trapDP([0,1,0,2,1,0,1,3,2,1,2,1])); // 6
console.log(trapDP([4,2,0,3,2,5])); // 9
console.log(trapDP([3,0,2,0,4])); // 7
```

### **Approach 3: Stack-Based**
```javascript
/**
 * Use stack to track potential water containers
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
function trapStack(height) {
  const stack = [];
  let water = 0;
  
  for (let i = 0; i < height.length; i++) {
    while (stack.length > 0 && height[i] > height[stack[stack.length - 1]]) {
      const top = stack.pop();
      
      if (stack.length === 0) {
        break;
      }
      
      const distance = i - stack[stack.length - 1] - 1;
      const boundedHeight = Math.min(height[i], height[stack[stack.length - 1]]) - height[top];
      
      water += distance * boundedHeight;
    }
    
    stack.push(i);
  }
  
  return water;
}

// Test
console.log('\n=== Stack-Based ===');

console.log(trapStack([0,1,0,2,1,0,1,3,2,1,2,1])); // 6
console.log(trapStack([4,2,0,3,2,5])); // 9
console.log(trapStack([3,0,2,0,4])); // 7
```

### **Approach 4: Visualize Water Levels**
```javascript
/**
 * Visualize the trapped water
 */
function trapVisualize(height) {
  const n = height.length;
  if (n === 0) return { water: 0, visualization: [] };
  
  // Calculate water at each position using DP
  const leftMax = new Array(n);
  leftMax[0] = height[0];
  for (let i = 1; i < n; i++) {
    leftMax[i] = Math.max(leftMax[i - 1], height[i]);
  }
  
  const rightMax = new Array(n);
  rightMax[n - 1] = height[n - 1];
  for (let i = n - 2; i >= 0; i--) {
    rightMax[i] = Math.max(rightMax[i + 1], height[i]);
  }
  
  // Build visualization
  const maxHeight = Math.max(...height, ...leftMax, ...rightMax);
  const visualization = [];
  let totalWater = 0;
  
  for (let level = maxHeight; level > 0; level--) {
    let row = '';
    for (let i = 0; i < n; i++) {
      const waterLevel = Math.min(leftMax[i], rightMax[i]);
      
      if (height[i] >= level) {
        row += '█'; // Block
      } else if (waterLevel >= level) {
        row += '≈'; // Water
        if (level === Math.ceil((waterLevel + height[i]) / 2)) {
          totalWater += waterLevel - height[i];
        }
      } else {
        row += ' '; // Air
      }
    }
    visualization.push(row);
  }
  
  return {
    water: totalWater,
    visualization: visualization
  };
}

// Test
console.log('\n=== Visualization ===');

const result = trapVisualize([0,1,0,2,1,0,1,3,2,1,2,1]);
console.log('Water trapped:', result.water);
console.log('Visualization:');
result.visualization.forEach(row => console.log(row));
```

### **Approach 5: 2D Rain Water Trapping**
```javascript
/**
 * Extended to 2D grid (harder version)
 * Given heightMap[i][j], find total water trapped
 */
function trapRainWater2D(heightMap) {
  if (!heightMap || heightMap.length === 0) return 0;
  
  const m = heightMap.length;
  const n = heightMap[0].length;
  
  // Priority queue (min heap)
  const pq = [];
  const visited = Array(m).fill(null).map(() => Array(n).fill(false));
  
  // Add boundary cells to priority queue
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (i === 0 || i === m - 1 || j === 0 || j === n - 1) {
        pq.push({ height: heightMap[i][j], row: i, col: j });
        visited[i][j] = true;
      }
    }
  }
  
  // Sort by height (min heap behavior)
  pq.sort((a, b) => a.height - b.height);
  
  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
  let water = 0;
  
  while (pq.length > 0) {
    const cell = pq.shift();
    
    // Check neighbors
    for (const [dr, dc] of directions) {
      const newRow = cell.row + dr;
      const newCol = cell.col + dc;
      
      if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {
        visited[newRow][newCol] = true;
        
        // Water can be trapped if current max height > cell height
        water += Math.max(0, cell.height - heightMap[newRow][newCol]);
        
        // Add to queue with max height seen so far
        pq.push({
          height: Math.max(cell.height, heightMap[newRow][newCol]),
          row: newRow,
          col: newCol
        });
        
        // Re-sort (in real implementation, use proper min heap)
        pq.sort((a, b) => a.height - b.height);
      }
    }
  }
  
  return water;
}

// Test
console.log('\n=== 2D Rain Water ===');

const heightMap = [
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
];

console.log('2D water trapped:', trapRainWater2D(heightMap)); // 4
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of trapping rain water logic
 */

// 1. Rainfall Simulation
console.log('\n=== Rainfall Simulation ===');

class RainfallSimulator {
  constructor(terrain) {
    this.terrain = terrain;
  }
  
  simulateRainfall(rainfall) {
    const n = this.terrain.length;
    const leftMax = new Array(n);
    const rightMax = new Array(n);
    
    leftMax[0] = this.terrain[0];
    for (let i = 1; i < n; i++) {
      leftMax[i] = Math.max(leftMax[i - 1], this.terrain[i]);
    }
    
    rightMax[n - 1] = this.terrain[n - 1];
    for (let i = n - 2; i >= 0; i--) {
      rightMax[i] = Math.max(rightMax[i + 1], this.terrain[i]);
    }
    
    const waterLevels = [];
    let totalWater = 0;
    
    for (let i = 0; i < n; i++) {
      const waterLevel = Math.min(leftMax[i], rightMax[i]);
      const waterDepth = Math.max(0, waterLevel - this.terrain[i]);
      waterLevels.push(waterDepth);
      totalWater += waterDepth;
    }
    
    return {
      totalVolume: totalWater,
      waterLevels,
      capacity: totalWater,
      utilizationRate: totalWater / (n * Math.max(...this.terrain))
    };
  }
}

const simulator = new RainfallSimulator([3,0,2,0,4]);
console.log('Simulation:', simulator.simulateRainfall(1));

// 2. Flood Risk Assessment
console.log('\n=== Flood Risk Assessment ===');

class FloodRiskAnalyzer {
  constructor(elevationProfile) {
    this.elevationProfile = elevationProfile;
  }
  
  assessRisk() {
    const trapped = trap(this.elevationProfile);
    const avgElevation = this.elevationProfile.reduce((a, b) => a + b, 0) / this.elevationProfile.length;
    const maxElevation = Math.max(...this.elevationProfile);
    const minElevation = Math.min(...this.elevationProfile);
    
    // Find low-lying areas
    const vulnerableAreas = [];
    for (let i = 0; i < this.elevationProfile.length; i++) {
      if (this.elevationProfile[i] < avgElevation * 0.7) {
        vulnerableAreas.push({
          index: i,
          elevation: this.elevationProfile[i],
          risk: ((avgElevation - this.elevationProfile[i]) / avgElevation * 100).toFixed(1) + '%'
        });
      }
    }
    
    return {
      waterTrappingCapacity: trapped,
      averageElevation: avgElevation.toFixed(2),
      elevationRange: maxElevation - minElevation,
      vulnerableAreas,
      overallRisk: trapped > avgElevation ? 'HIGH' : trapped > avgElevation * 0.5 ? 'MEDIUM' : 'LOW'
    };
  }
}

const floodAnalyzer = new FloodRiskAnalyzer([5,3,1,2,4,3,2,4,5]);
console.log('Flood risk:', floodAnalyzer.assessRisk());

// 3. Water Storage Optimization
console.log('\n=== Water Storage Optimization ===');

class WaterStorageOptimizer {
  constructor(containers) {
    this.containers = containers;
  }
  
  optimizeStorage() {
    const currentCapacity = trap(this.containers);
    
    // Find best position to add height
    const improvements = [];
    
    for (let i = 0; i < this.containers.length; i++) {
      const modified = [...this.containers];
      modified[i] += 1;
      
      const newCapacity = trap(modified);
      const gain = newCapacity - currentCapacity;
      
      if (gain > 0) {
        improvements.push({
          position: i,
          currentHeight: this.containers[i],
          newHeight: modified[i],
          capacityGain: gain,
          roi: gain / 1 // cost of 1 unit height
        });
      }
    }
    
    improvements.sort((a, b) => b.roi - a.roi);
    
    return {
      currentCapacity,
      recommendations: improvements.slice(0, 3),
      maxPotentialCapacity: currentCapacity + (improvements[0]?.capacityGain || 0)
    };
  }
}

const optimizer = new WaterStorageOptimizer([3,0,2,0,4]);
console.log('Optimization:', optimizer.optimizeStorage());

// 4. Terrain Analysis
console.log('\n=== Terrain Analysis ===');

class TerrainAnalyzer {
  constructor(elevation) {
    this.elevation = elevation;
  }
  
  analyzeWaterflow() {
    const n = this.elevation.length;
    const leftMax = new Array(n);
    const rightMax = new Array(n);
    
    leftMax[0] = this.elevation[0];
    for (let i = 1; i < n; i++) {
      leftMax[i] = Math.max(leftMax[i - 1], this.elevation[i]);
    }
    
    rightMax[n - 1] = this.elevation[n - 1];
    for (let i = n - 2; i >= 0; i--) {
      rightMax[i] = Math.max(rightMax[i + 1], this.elevation[i]);
    }
    
    // Identify pools
    const pools = [];
    let currentPool = null;
    
    for (let i = 0; i < n; i++) {
      const waterLevel = Math.min(leftMax[i], rightMax[i]);
      const waterDepth = waterLevel - this.elevation[i];
      
      if (waterDepth > 0) {
        if (!currentPool) {
          currentPool = { start: i, end: i, depth: waterDepth, volume: waterDepth };
        } else {
          currentPool.end = i;
          currentPool.depth = Math.max(currentPool.depth, waterDepth);
          currentPool.volume += waterDepth;
        }
      } else if (currentPool) {
        pools.push(currentPool);
        currentPool = null;
      }
    }
    
    if (currentPool) {
      pools.push(currentPool);
    }
    
    return {
      numberOfPools: pools.length,
      pools,
      totalVolume: pools.reduce((sum, p) => sum + p.volume, 0),
      largestPool: pools.reduce((max, p) => p.volume > max.volume ? p : max, { volume: 0 })
    };
  }
}

const terrainAnalyzer = new TerrainAnalyzer([0,1,0,2,1,0,1,3,2,1,2,1]);
console.log('Terrain analysis:', terrainAnalyzer.analyzeWaterflow());

// 5. Building Foundation Planning
console.log('\n=== Foundation Planning ===');

class FoundationPlanner {
  constructor(groundProfile) {
    this.groundProfile = groundProfile;
  }
  
  planFoundation() {
    const n = this.groundProfile.length;
    const waterProblems = [];
    
    // Check each position for water accumulation risk
    for (let i = 1; i < n - 1; i++) {
      const leftMax = Math.max(...this.groundProfile.slice(0, i));
      const rightMax = Math.max(...this.groundProfile.slice(i + 1));
      
      const waterLevel = Math.min(leftMax, rightMax);
      const waterDepth = Math.max(0, waterLevel - this.groundProfile[i]);
      
      if (waterDepth > 0) {
        waterProblems.push({
          position: i,
          elevation: this.groundProfile[i],
          waterDepth,
          recommendation: waterDepth > 2 ? 'Install drainage system' : 'Minor grading needed'
        });
      }
    }
    
    return {
      waterAccumulationRisks: waterProblems.length,
      criticalAreas: waterProblems.filter(p => p.waterDepth > 2),
      recommendations: waterProblems,
      estimatedCost: waterProblems.reduce((sum, p) => sum + p.waterDepth * 100, 0)
    };
  }
}

const foundationPlanner = new FoundationPlanner([4,2,0,3,2,5]);
console.log('Foundation plan:', foundationPlanner.planFoundation());
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty array
console.log('Empty:', trap([])); // 0

// Single element
console.log('Single element:', trap([5])); // 0

// Two elements
console.log('Two elements:', trap([3, 5])); // 0

// All same height
console.log('All same:', trap([3,3,3,3])); // 0

// Ascending
console.log('Ascending:', trap([1,2,3,4,5])); // 0

// Descending
console.log('Descending:', trap([5,4,3,2,1])); // 0

// Valley
console.log('Valley:', trap([5,1,5])); // 4

// Multiple valleys
console.log('Multiple valleys:', trap([4,1,4,1,4])); // 6

// Peak in middle
console.log('Peak in middle:', trap([1,3,1])); // 0

// Complex terrain
console.log('Complex:', trap([5,2,1,2,1,5])); // 14

// Large numbers
console.log('Large numbers:', trap([100,50,100])); // 50

// Zero heights
console.log('With zeros:', trap([0,0,5,0,0])); // 0
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

function benchmark(fn, name, input) {
  const start = performance.now();
  const result = fn(input);
  const end = performance.now();
  console.log(`${name}: ${result} (${(end - start).toFixed(3)}ms)`);
}

const testArray = [0,1,0,2,1,0,1,3,2,1,2,1];

benchmark(trap, 'Two Pointers', testArray);
benchmark(trapDP, 'Dynamic Programming', testArray);
benchmark(trapStack, 'Stack-Based', testArray);

console.log(`
Algorithm Comparison:
┌────────────────────┬─────────────┬─────────────┬──────────────┐
│ Algorithm          │ Time        │ Space       │ Best For     │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Two Pointers       │ O(n)        │ O(1)        │ Optimal,     │
│                    │             │             │ space-efficient│
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Dynamic Programming│ O(n)        │ O(n)        │ Intuitive,   │
│                    │             │             │ easier to    │
│                    │             │             │ understand   │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Stack-Based        │ O(n)        │ O(n)        │ Layer-by-layer│
│                    │             │             │ calculation  │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ 2D Version         │ O(m×n×log k)│ O(m×n)      │ Grid problems│
│                    │             │             │ (harder)     │
└────────────────────┴─────────────┴─────────────┴──────────────┘

Key Insights:
• Water level at position i = min(leftMax[i], rightMax[i])
• Water trapped at i = waterLevel - height[i]
• Two pointers: most efficient, O(1) space
• DP: pre-compute left/right max arrays
• Stack: process layer by layer (horizontal layers)

Real-World Applications:
• Rainfall simulation and modeling
• Flood risk assessment
• Water storage optimization
• Terrain analysis for construction
• Foundation planning and drainage design

Optimization Tips:
• Two pointers eliminates need for extra arrays
• Process from both ends simultaneously
• Track max heights seen so far
• Water can only be trapped between two higher bars
`);
```

**Interview Tips:**
- Trapping rain water: calculate water trapped between elevation bars
- Key insight: water level at position = min(max_left, max_right)
- Water trapped = water_level - current_height (if positive)
- Three main approaches: two pointers (best), DP, stack
- Two pointers: O(n) time, O(1) space - optimal solution
- Track leftMax and rightMax while moving pointers inward
- Move pointer with smaller height (water limited by smaller side)
- DP approach: pre-compute leftMax and rightMax arrays, then iterate
- DP time: O(n), space: O(n) - easier to understand but uses extra space
- Stack approach: calculate water layer by layer horizontally
- Stack tracks indices of bars, pop when finding higher bar
- Applications: rainfall simulation, flood risk, water storage, terrain analysis
- Edge cases: empty array, single element, all same height, ascending/descending
- Visualization: water fills valleys between peaks
- 2D version: harder problem using priority queue (min heap)
- Common mistake: forgetting that water needs walls on both sides
- Optimization: two pointers preferred in interviews for O(1) space
- Follow-ups: 2D version, container with most water (different problem), visualize
- Clarify: 1D or 2D? return volume or visualization? constraints on height values?

</details>

111. Find the median of two sorted arrays

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Merge and Find Median**
```javascript
/**
 * Merge two sorted arrays and find median
 * Time Complexity: O(m + n)
 * Space Complexity: O(m + n)
 */
function findMedianSortedArrays(nums1, nums2) {
  const merged = [];
  let i = 0, j = 0;
  
  // Merge arrays
  while (i < nums1.length && j < nums2.length) {
    if (nums1[i] < nums2[j]) {
      merged.push(nums1[i++]);
    } else {
      merged.push(nums2[j++]);
    }
  }
  
  // Add remaining elements
  while (i < nums1.length) {
    merged.push(nums1[i++]);
  }
  
  while (j < nums2.length) {
    merged.push(nums2[j++]);
  }
  
  // Find median
  const len = merged.length;
  if (len % 2 === 0) {
    return (merged[len / 2 - 1] + merged[len / 2]) / 2;
  } else {
    return merged[Math.floor(len / 2)];
  }
}

// Test
console.log('=== Merge Approach ===');

console.log(findMedianSortedArrays([1,3], [2])); // 2
console.log(findMedianSortedArrays([1,2], [3,4])); // 2.5
console.log(findMedianSortedArrays([0,0], [0,0])); // 0
console.log(findMedianSortedArrays([], [1])); // 1
console.log(findMedianSortedArrays([2], [])); // 2
```

### **Approach 2: Binary Search (Optimal)**
```javascript
/**
 * Binary search on smaller array
 * Time Complexity: O(log(min(m,n)))
 * Space Complexity: O(1)
 */
function findMedianSortedArraysBinarySearch(nums1, nums2) {
  // Ensure nums1 is smaller array
  if (nums1.length > nums2.length) {
    [nums1, nums2] = [nums2, nums1];
  }
  
  const m = nums1.length;
  const n = nums2.length;
  let left = 0;
  let right = m;
  
  while (left <= right) {
    const partition1 = Math.floor((left + right) / 2);
    const partition2 = Math.floor((m + n + 1) / 2) - partition1;
    
    const maxLeft1 = partition1 === 0 ? -Infinity : nums1[partition1 - 1];
    const minRight1 = partition1 === m ? Infinity : nums1[partition1];
    
    const maxLeft2 = partition2 === 0 ? -Infinity : nums2[partition2 - 1];
    const minRight2 = partition2 === n ? Infinity : nums2[partition2];
    
    if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
      // Found correct partition
      if ((m + n) % 2 === 0) {
        return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;
      } else {
        return Math.max(maxLeft1, maxLeft2);
      }
    } else if (maxLeft1 > minRight2) {
      // Too far right in nums1
      right = partition1 - 1;
    } else {
      // Too far left in nums1
      left = partition1 + 1;
    }
  }
  
  throw new Error('Input arrays are not sorted');
}

// Test
console.log('\n=== Binary Search ===');

console.log(findMedianSortedArraysBinarySearch([1,3], [2])); // 2
console.log(findMedianSortedArraysBinarySearch([1,2], [3,4])); // 2.5
console.log(findMedianSortedArraysBinarySearch([0,0], [0,0])); // 0
console.log(findMedianSortedArraysBinarySearch([], [1])); // 1
console.log(findMedianSortedArraysBinarySearch([2], [])); // 2
```

### **Approach 3: K-th Element (Generalized)**
```javascript
/**
 * Find k-th smallest element in two sorted arrays
 * Can be used to find median
 */
function findKthElement(nums1, nums2, k) {
  function helper(arr1, start1, arr2, start2, k) {
    // Base cases
    if (start1 >= arr1.length) {
      return arr2[start2 + k - 1];
    }
    if (start2 >= arr2.length) {
      return arr1[start1 + k - 1];
    }
    if (k === 1) {
      return Math.min(arr1[start1], arr2[start2]);
    }
    
    // Compare k/2-th elements
    const mid = Math.floor(k / 2);
    const val1 = start1 + mid - 1 < arr1.length ? arr1[start1 + mid - 1] : Infinity;
    const val2 = start2 + mid - 1 < arr2.length ? arr2[start2 + mid - 1] : Infinity;
    
    if (val1 < val2) {
      return helper(arr1, start1 + mid, arr2, start2, k - mid);
    } else {
      return helper(arr1, start1, arr2, start2 + mid, k - mid);
    }
  }
  
  return helper(nums1, 0, nums2, 0, k);
}

function findMedianKth(nums1, nums2) {
  const total = nums1.length + nums2.length;
  
  if (total % 2 === 1) {
    return findKthElement(nums1, nums2, Math.floor(total / 2) + 1);
  } else {
    const mid1 = findKthElement(nums1, nums2, total / 2);
    const mid2 = findKthElement(nums1, nums2, total / 2 + 1);
    return (mid1 + mid2) / 2;
  }
}

// Test
console.log('\n=== K-th Element ===');

console.log(findMedianKth([1,3], [2])); // 2
console.log(findMedianKth([1,2], [3,4])); // 2.5
console.log(findKthElement([1,3,5,7], [2,4,6,8], 4)); // 4 (4th smallest)
```

### **Approach 4: Without Extra Space (Merge in Place)**
```javascript
/**
 * Find median without merging into new array
 */
function findMedianNoExtraSpace(nums1, nums2) {
  const total = nums1.length + nums2.length;
  const mid = Math.floor(total / 2);
  
  let i = 0, j = 0, count = 0;
  let prev = 0, curr = 0;
  
  while (count <= mid) {
    prev = curr;
    
    if (i < nums1.length && (j >= nums2.length || nums1[i] <= nums2[j])) {
      curr = nums1[i++];
    } else {
      curr = nums2[j++];
    }
    
    count++;
  }
  
  if (total % 2 === 0) {
    return (prev + curr) / 2;
  } else {
    return curr;
  }
}

// Test
console.log('\n=== No Extra Space ===');

console.log(findMedianNoExtraSpace([1,3], [2])); // 2
console.log(findMedianNoExtraSpace([1,2], [3,4])); // 2.5
```

### **Approach 5: Multiple Arrays Median**
```javascript
/**
 * Find median of multiple sorted arrays
 */
function findMedianMultipleArrays(arrays) {
  // Merge all arrays using min heap approach
  const merged = [];
  const pointers = new Array(arrays.length).fill(0);
  
  while (true) {
    let minVal = Infinity;
    let minIdx = -1;
    
    // Find minimum across all arrays
    for (let i = 0; i < arrays.length; i++) {
      if (pointers[i] < arrays[i].length && arrays[i][pointers[i]] < minVal) {
        minVal = arrays[i][pointers[i]];
        minIdx = i;
      }
    }
    
    if (minIdx === -1) break; // All arrays exhausted
    
    merged.push(minVal);
    pointers[minIdx]++;
  }
  
  // Find median
  const len = merged.length;
  if (len % 2 === 0) {
    return (merged[len / 2 - 1] + merged[len / 2]) / 2;
  } else {
    return merged[Math.floor(len / 2)];
  }
}

// Test
console.log('\n=== Multiple Arrays ===');

console.log(findMedianMultipleArrays([[1,3], [2,4], [5,6]])); // 3.5
console.log(findMedianMultipleArrays([[1], [2], [3]])); // 2
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Data Stream Median
console.log('\n=== Data Stream Median ===');

class MedianFinder {
  constructor() {
    this.small = []; // Max heap (simulate with negative values)
    this.large = []; // Min heap
  }
  
  addNum(num) {
    // Add to max heap (small)
    this.small.push(-num);
    this.small.sort((a, b) => a - b);
    
    // Balance: move largest from small to large
    if (this.small.length > 0) {
      this.large.push(-this.small.shift());
      this.large.sort((a, b) => a - b);
    }
    
    // Rebalance if large has too many
    if (this.large.length > this.small.length + 1) {
      this.small.push(-this.large.shift());
      this.small.sort((a, b) => a - b);
    }
  }
  
  findMedian() {
    if (this.large.length > this.small.length) {
      return this.large[0];
    } else {
      return (-this.small[0] + this.large[0]) / 2;
    }
  }
}

const medianFinder = new MedianFinder();
medianFinder.addNum(1);
medianFinder.addNum(2);
console.log('Median:', medianFinder.findMedian()); // 1.5
medianFinder.addNum(3);
console.log('Median:', medianFinder.findMedian()); // 2

// 2. Merge Performance Metrics
console.log('\n=== Performance Metrics ===');

class PerformanceAnalyzer {
  constructor() {
    this.serverALatencies = [];
    this.serverBLatencies = [];
  }
  
  recordLatency(server, latency) {
    if (server === 'A') {
      this.serverALatencies.push(latency);
      this.serverALatencies.sort((a, b) => a - b);
    } else {
      this.serverBLatencies.push(latency);
      this.serverBLatencies.sort((a, b) => a - b);
    }
  }
  
  getMedianLatency() {
    return findMedianSortedArraysBinarySearch(
      this.serverALatencies,
      this.serverBLatencies
    );
  }
  
  getStats() {
    const median = this.getMedianLatency();
    const total = this.serverALatencies.length + this.serverBLatencies.length;
    
    return {
      median,
      totalSamples: total,
      serverA: this.serverALatencies.length,
      serverB: this.serverBLatencies.length
    };
  }
}

const perfAnalyzer = new PerformanceAnalyzer();
perfAnalyzer.recordLatency('A', 10);
perfAnalyzer.recordLatency('A', 20);
perfAnalyzer.recordLatency('B', 15);
perfAnalyzer.recordLatency('B', 25);
console.log('Stats:', perfAnalyzer.getStats());

// 3. Salary Analysis
console.log('\n=== Salary Analysis ===');

class SalaryAnalyzer {
  analyzeDepartments(dept1Salaries, dept2Salaries) {
    const combinedMedian = findMedianSortedArraysBinarySearch(
      dept1Salaries.sort((a, b) => a - b),
      dept2Salaries.sort((a, b) => a - b)
    );
    
    const dept1Median = this.getMedian(dept1Salaries);
    const dept2Median = this.getMedian(dept2Salaries);
    
    return {
      combinedMedian,
      dept1Median,
      dept2Median,
      difference: Math.abs(dept1Median - dept2Median),
      recommendation: Math.abs(dept1Median - dept2Median) > 10000 ?
        'Consider salary adjustment' : 'Salaries are balanced'
    };
  }
  
  getMedian(arr) {
    const len = arr.length;
    if (len % 2 === 0) {
      return (arr[len / 2 - 1] + arr[len / 2]) / 2;
    } else {
      return arr[Math.floor(len / 2)];
    }
  }
}

const salaryAnalyzer = new SalaryAnalyzer();
console.log(salaryAnalyzer.analyzeDepartments(
  [50000, 60000, 70000],
  [55000, 65000, 75000]
));

// 4. Time Series Merge
console.log('\n=== Time Series Merge ===');

class TimeSeriesMerger {
  mergeTimeSeries(series1, series2) {
    // Each series: [{time, value}, ...]
    const times1 = series1.map(s => s.time).sort((a, b) => a - b);
    const times2 = series2.map(s => s.time).sort((a, b) => a - b);
    
    const medianTime = findMedianSortedArraysBinarySearch(times1, times2);
    
    return {
      medianTime,
      totalDataPoints: times1.length + times2.length,
      timeRange: {
        start: Math.min(times1[0], times2[0]),
        end: Math.max(times1[times1.length - 1], times2[times2.length - 1])
      }
    };
  }
}

const tsMerger = new TimeSeriesMerger();
const series1 = [{time: 1, value: 10}, {time: 3, value: 30}, {time: 5, value: 50}];
const series2 = [{time: 2, value: 20}, {time: 4, value: 40}, {time: 6, value: 60}];
console.log(tsMerger.mergeTimeSeries(series1, series2));

// 5. Load Balancing
console.log('\n=== Load Balancing ===');

class LoadBalancer {
  constructor() {
    this.server1Loads = [];
    this.server2Loads = [];
  }
  
  recordLoad(server, load) {
    if (server === 1) {
      this.server1Loads.push(load);
      this.server1Loads.sort((a, b) => a - b);
    } else {
      this.server2Loads.push(load);
      this.server2Loads.sort((a, b) => a - b);
    }
  }
  
  shouldRebalance() {
    if (this.server1Loads.length === 0 || this.server2Loads.length === 0) {
      return false;
    }
    
    const median1 = this.getMedian(this.server1Loads);
    const median2 = this.getMedian(this.server2Loads);
    
    const threshold = 20; // 20% difference
    const diff = Math.abs(median1 - median2);
    const avg = (median1 + median2) / 2;
    
    return (diff / avg * 100) > threshold;
  }
  
  getMedian(arr) {
    const len = arr.length;
    if (len % 2 === 0) {
      return (arr[len / 2 - 1] + arr[len / 2]) / 2;
    }
    return arr[Math.floor(len / 2)];
  }
}

const balancer = new LoadBalancer();
balancer.recordLoad(1, 50);
balancer.recordLoad(1, 60);
balancer.recordLoad(2, 80);
balancer.recordLoad(2, 90);
console.log('Should rebalance:', balancer.shouldRebalance());
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty arrays
console.log('Both empty:', findMedianSortedArraysBinarySearch([], [])); // Should handle
console.log('One empty:', findMedianSortedArraysBinarySearch([], [1,2,3])); // 2

// Single element
console.log('Single in each:', findMedianSortedArraysBinarySearch([1], [2])); // 1.5

// Different lengths
console.log('Different lengths:', findMedianSortedArraysBinarySearch([1], [2,3,4,5])); // 3

// All same values
console.log('All same:', findMedianSortedArraysBinarySearch([1,1,1], [1,1,1])); // 1

// Negative numbers
console.log('Negatives:', findMedianSortedArraysBinarySearch([-5,-3,-1], [-4,-2,0])); // -2.5

// Large numbers
console.log('Large:', findMedianSortedArraysBinarySearch([1000000], [1000001])); // 1000000.5

// No overlap
console.log('No overlap:', findMedianSortedArraysBinarySearch([1,2], [10,11])); // 6

// Complete overlap
console.log('Overlap:', findMedianSortedArraysBinarySearch([1,3,5], [2,4,6])); // 3.5
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Algorithm Comparison:
┌────────────────────┬─────────────────┬─────────────┬──────────────┐
│ Algorithm          │ Time            │ Space       │ Best For     │
├────────────────────┼─────────────────┼─────────────┼──────────────┤
│ Merge              │ O(m + n)        │ O(m + n)    │ Simple,      │
│                    │                 │             │ intuitive    │
├────────────────────┼─────────────────┼─────────────┼──────────────┤
│ Binary Search      │ O(log(min(m,n)))│ O(1)        │ Optimal,     │
│                    │                 │             │ most efficient│
├────────────────────┼─────────────────┼─────────────┼──────────────┤
│ K-th Element       │ O(log(m + n))   │ O(log(m+n)) │ Generalized  │
├────────────────────┼─────────────────┼─────────────┼──────────────┤
│ No Extra Space     │ O(m + n)        │ O(1)        │ Space-       │
│                    │                 │             │ constrained  │
└────────────────────┴─────────────────┴─────────────┴──────────────┘

Key Insights:
• Binary search on smaller array for O(log(min(m,n)))
• Partition both arrays so left half < right half
• Handle edge cases: empty arrays, single elements
• Median: middle element (odd) or average of two middle (even)

Partition Logic:
• partition1 + partition2 = (m + n + 1) / 2
• maxLeft1 <= minRight2 && maxLeft2 <= minRight1
• If partition valid: median = max(maxLeft1, maxLeft2) for odd
•                     or avg of max(left) and min(right) for even

Applications:
• Data stream median (two heaps)
• Performance metrics merging
• Salary/statistics analysis
• Time series data merging
• Load balancing decisions

Optimization:
• Always search on smaller array
• Use infinity for boundary conditions
• Binary search more efficient than merge for large arrays
`);
```

**Interview Tips:**
- Find median of two sorted arrays: combine and find middle element(s)
- Naive: merge O(m+n), optimal: binary search O(log(min(m,n)))
- Binary search approach: partition arrays so all left < all right
- Key insight: find correct partition point using binary search
- Partition: divide arrays such that left half has (m+n+1)/2 elements
- Valid partition: maxLeft1 ≤ minRight2 AND maxLeft2 ≤ minRight1
- Median calculation: max of left halves (odd) or average with min of right halves (even)
- Always binary search on smaller array for better complexity
- Handle edge cases: use -Infinity and Infinity for boundaries
- Time: O(log(min(m,n))), space: O(1) - optimal solution
- Alternative: merge arrays O(m+n) - simpler but not optimal
- K-th element approach: generalized solution for any k
- Applications: streaming median, performance metrics, statistical analysis
- Two heaps pattern: maintain max heap for lower half, min heap for upper half
- Edge cases: empty arrays, single elements, no overlap, all same values
- Common mistake: not handling boundary conditions with infinities
- Clarify: both arrays sorted? allow duplicates? integer or float values?
- Follow-ups: k-th element, median of k sorted arrays, streaming median
- Optimization: binary search preferred, demonstrate O(log n) understanding

</details>

112. Implement a function to serialize and deserialize a binary tree

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Pre-order Traversal with Null Markers**
```javascript
/**
 * Serialize and deserialize binary tree using pre-order
 * Time Complexity: O(n) for both operations
 * Space Complexity: O(n)
 */
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

class Codec {
  // Serialize tree to string
  serialize(root) {
    const result = [];
    
    function preorder(node) {
      if (node === null) {
        result.push('null');
        return;
      }
      
      result.push(node.val);
      preorder(node.left);
      preorder(node.right);
    }
    
    preorder(root);
    return result.join(',');
  }
  
  // Deserialize string to tree
  deserialize(data) {
    const values = data.split(',');
    let index = 0;
    
    function buildTree() {
      if (index >= values.length || values[index] === 'null') {
        index++;
        return null;
      }
      
      const node = new TreeNode(parseInt(values[index]));
      index++;
      
      node.left = buildTree();
      node.right = buildTree();
      
      return node;
    }
    
    return buildTree();
  }
}

// Test
console.log('=== Pre-order Serialization ===');

const codec1 = new Codec();
const tree1 = new TreeNode(1,
  new TreeNode(2),
  new TreeNode(3,
    new TreeNode(4),
    new TreeNode(5)
  )
);

const serialized1 = codec1.serialize(tree1);
console.log('Serialized:', serialized1); // "1,2,null,null,3,4,null,null,5,null,null"

const deserialized1 = codec1.deserialize(serialized1);
console.log('Deserialized:', codec1.serialize(deserialized1));
```

### **Approach 2: Level-order Traversal (BFS)**
```javascript
/**
 * Serialize using level-order (breadth-first)
 * More readable format
 */
class CodecBFS {
  serialize(root) {
    if (!root) return '';
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
      const node = queue.shift();
      
      if (node === null) {
        result.push('null');
        continue;
      }
      
      result.push(node.val);
      queue.push(node.left);
      queue.push(node.right);
    }
    
    // Remove trailing nulls
    while (result[result.length - 1] === 'null') {
      result.pop();
    }
    
    return result.join(',');
  }
  
  deserialize(data) {
    if (!data) return null;
    
    const values = data.split(',');
    const root = new TreeNode(parseInt(values[0]));
    const queue = [root];
    let i = 1;
    
    while (queue.length > 0 && i < values.length) {
      const node = queue.shift();
      
      // Left child
      if (i < values.length && values[i] !== 'null') {
        node.left = new TreeNode(parseInt(values[i]));
        queue.push(node.left);
      }
      i++;
      
      // Right child
      if (i < values.length && values[i] !== 'null') {
        node.right = new TreeNode(parseInt(values[i]));
        queue.push(node.right);
      }
      i++;
    }
    
    return root;
  }
}

// Test
console.log('\n=== BFS Serialization ===');

const codec2 = new CodecBFS();
const tree2 = new TreeNode(1,
  new TreeNode(2),
  new TreeNode(3,
    new TreeNode(4),
    new TreeNode(5)
  )
);

const serialized2 = codec2.serialize(tree2);
console.log('Serialized:', serialized2); // "1,2,3,null,null,4,5"

const deserialized2 = codec2.deserialize(serialized2);
console.log('Deserialized:', codec2.serialize(deserialized2));
```

### **Approach 3: JSON Format**
```javascript
/**
 * Serialize to JSON format (human-readable)
 */
class CodecJSON {
  serialize(root) {
    if (!root) return JSON.stringify(null);
    
    const obj = {
      val: root.val,
      left: root.left ? JSON.parse(this.serialize(root.left)) : null,
      right: root.right ? JSON.parse(this.serialize(root.right)) : null
    };
    
    return JSON.stringify(obj);
  }
  
  deserialize(data) {
    const obj = JSON.parse(data);
    
    if (obj === null) return null;
    
    const node = new TreeNode(obj.val);
    node.left = this.deserialize(JSON.stringify(obj.left));
    node.right = this.deserialize(JSON.stringify(obj.right));
    
    return node;
  }
  
  // Pretty print
  prettyPrint(root, indent = 0) {
    if (!root) return;
    
    console.log(' '.repeat(indent) + root.val);
    this.prettyPrint(root.left, indent + 2);
    this.prettyPrint(root.right, indent + 2);
  }
}

// Test
console.log('\n=== JSON Serialization ===');

const codec3 = new CodecJSON();
const tree3 = new TreeNode(1,
  new TreeNode(2),
  new TreeNode(3,
    new TreeNode(4),
    new TreeNode(5)
  )
);

const serialized3 = codec3.serialize(tree3);
console.log('Serialized:', serialized3);
console.log('\nPretty print:');
codec3.prettyPrint(tree3);
```

### **Approach 4: Compact Binary Format**
```javascript
/**
 * Space-efficient binary encoding
 */
class CodecBinary {
  serialize(root) {
    const result = [];
    
    function encode(node) {
      if (!node) {
        result.push('0');
        return;
      }
      
      result.push('1');
      result.push(node.val.toString());
      result.push('|');
      
      encode(node.left);
      encode(node.right);
    }
    
    encode(root);
    return result.join('');
  }
  
  deserialize(data) {
    let index = 0;
    
    function decode() {
      if (index >= data.length || data[index] === '0') {
        index++;
        return null;
      }
      
      index++; // Skip '1'
      
      let val = '';
      while (index < data.length && data[index] !== '|') {
        val += data[index];
        index++;
      }
      index++; // Skip '|'
      
      const node = new TreeNode(parseInt(val));
      node.left = decode();
      node.right = decode();
      
      return node;
    }
    
    return decode();
  }
  
  getSize(data) {
    return new Blob([data]).size;
  }
}

// Test
console.log('\n=== Binary Format ===');

const codec4 = new CodecBinary();
const tree4 = new TreeNode(1,
  new TreeNode(2),
  new TreeNode(3,
    new TreeNode(4),
    new TreeNode(5)
  )
);

const serialized4 = codec4.serialize(tree4);
console.log('Serialized:', serialized4);
console.log('Size:', codec4.getSize(serialized4), 'bytes');
```

### **Approach 5: With Metadata and Validation**
```javascript
/**
 * Include metadata and validation
 */
class CodecAdvanced {
  serialize(root, includeMetadata = true) {
    const timestamp = new Date().toISOString();
    const treeData = [];
    let nodeCount = 0;
    let nullCount = 0;
    let height = 0;
    
    function preorder(node, level = 0) {
      height = Math.max(height, level);
      
      if (node === null) {
        treeData.push('null');
        nullCount++;
        return;
      }
      
      nodeCount++;
      treeData.push(node.val);
      preorder(node.left, level + 1);
      preorder(node.right, level + 1);
    }
    
    preorder(root);
    
    if (includeMetadata) {
      return JSON.stringify({
        version: '1.0',
        timestamp,
        metadata: {
          nodeCount,
          nullCount,
          height,
          totalElements: treeData.length
        },
        data: treeData.join(',')
      });
    }
    
    return treeData.join(',');
  }
  
  deserialize(data) {
    let values;
    let metadata = null;
    
    try {
      const parsed = JSON.parse(data);
      if (parsed.data) {
        values = parsed.data.split(',');
        metadata = parsed.metadata;
      } else {
        values = data.split(',');
      }
    } catch {
      values = data.split(',');
    }
    
    let index = 0;
    
    function buildTree() {
      if (index >= values.length || values[index] === 'null') {
        index++;
        return null;
      }
      
      const node = new TreeNode(parseInt(values[index]));
      index++;
      
      node.left = buildTree();
      node.right = buildTree();
      
      return node;
    }
    
    const tree = buildTree();
    
    // Validate if metadata present
    if (metadata) {
      console.log('Validation:');
      console.log('  Expected nodes:', metadata.nodeCount);
      console.log('  Tree height:', metadata.height);
      console.log('  Timestamp:', metadata.timestamp);
    }
    
    return tree;
  }
  
  // Calculate tree metrics
  getMetrics(root) {
    let nodeCount = 0;
    let height = 0;
    let leafCount = 0;
    
    function traverse(node, level = 0) {
      if (!node) return;
      
      nodeCount++;
      height = Math.max(height, level);
      
      if (!node.left && !node.right) {
        leafCount++;
      }
      
      traverse(node.left, level + 1);
      traverse(node.right, level + 1);
    }
    
    traverse(root);
    
    return { nodeCount, height, leafCount };
  }
}

// Test
console.log('\n=== Advanced Codec ===');

const codec5 = new CodecAdvanced();
const tree5 = new TreeNode(1,
  new TreeNode(2),
  new TreeNode(3,
    new TreeNode(4),
    new TreeNode(5)
  )
);

const serialized5 = codec5.serialize(tree5, true);
console.log('Serialized with metadata:');
console.log(JSON.parse(serialized5));

const deserialized5 = codec5.deserialize(serialized5);
console.log('\nMetrics:', codec5.getMetrics(deserialized5));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. File System Serialization
console.log('\n=== File System Serialization ===');

class FileNode {
  constructor(name, isDirectory = false) {
    this.name = name;
    this.isDirectory = isDirectory;
    this.children = [];
    this.size = 0;
  }
}

class FileSystemCodec {
  serialize(root) {
    const result = [];
    
    function encode(node) {
      if (!node) {
        result.push('null');
        return;
      }
      
      result.push(JSON.stringify({
        name: node.name,
        isDirectory: node.isDirectory,
        size: node.size
      }));
      
      result.push('[');
      for (const child of node.children) {
        encode(child);
      }
      result.push(']');
    }
    
    encode(root);
    return result.join('|');
  }
  
  visualize(root, indent = 0) {
    if (!root) return;
    
    const prefix = ' '.repeat(indent);
    const icon = root.isDirectory ? '📁' : '📄';
    console.log(`${prefix}${icon} ${root.name} ${!root.isDirectory ? `(${root.size}KB)` : ''}`);
    
    for (const child of root.children) {
      this.visualize(child, indent + 2);
    }
  }
}

const fsRoot = new FileNode('root', true);
fsRoot.children.push(new FileNode('document.txt', false));
fsRoot.children[0].size = 10;

const subDir = new FileNode('images', true);
subDir.children.push(new FileNode('photo.jpg', false));
subDir.children[0].size = 500;
fsRoot.children.push(subDir);

const fsCodec = new FileSystemCodec();
console.log('File system:');
fsCodec.visualize(fsRoot);

// 2. Expression Tree Serialization
console.log('\n=== Expression Tree ===');

class ExpressionCodec {
  serialize(root) {
    if (!root) return '';
    
    if (!root.left && !root.right) {
      return root.val.toString();
    }
    
    return `(${this.serialize(root.left)}${root.val}${this.serialize(root.right)})`;
  }
  
  deserialize(expr) {
    // Simple parser for mathematical expressions
    const tokens = expr.match(/\d+|[+\-*/()]/g);
    let index = 0;
    
    const parse = () => {
      if (index >= tokens.length) return null;
      
      const token = tokens[index++];
      
      if (token === '(') {
        const left = parse();
        const op = tokens[index++];
        const right = parse();
        index++; // skip ')'
        
        const node = new TreeNode(op);
        node.left = left;
        node.right = right;
        return node;
      }
      
      return new TreeNode(parseInt(token));
    };
    
    return parse();
  }
  
  evaluate(root) {
    if (!root) return 0;
    
    if (!root.left && !root.right) {
      return parseInt(root.val);
    }
    
    const left = this.evaluate(root.left);
    const right = this.evaluate(root.right);
    
    switch (root.val) {
      case '+': return left + right;
      case '-': return left - right;
      case '*': return left * right;
      case '/': return left / right;
      default: return 0;
    }
  }
}

const exprCodec = new ExpressionCodec();
const exprTree = new TreeNode('+',
  new TreeNode('*',
    new TreeNode(2),
    new TreeNode(3)
  ),
  new TreeNode(4)
);

console.log('Expression:', exprCodec.serialize(exprTree)); // "(2*3)+4"
console.log('Result:', exprCodec.evaluate(exprTree)); // 10

// 3. DOM Tree Serialization
console.log('\n=== DOM Tree Serialization ===');

class DOMNode {
  constructor(tag, attributes = {}) {
    this.tag = tag;
    this.attributes = attributes;
    this.children = [];
    this.text = '';
  }
}

class DOMCodec {
  serialize(root) {
    if (!root) return '';
    
    let html = `<${root.tag}`;
    
    for (const [key, value] of Object.entries(root.attributes)) {
      html += ` ${key}="${value}"`;
    }
    
    html += '>';
    
    if (root.text) {
      html += root.text;
    }
    
    for (const child of root.children) {
      html += this.serialize(child);
    }
    
    html += `</${root.tag}>`;
    
    return html;
  }
  
  deserialize(html) {
    // Simplified HTML parser
    const tagRegex = /<(\w+)([^>]*)>(.*?)<\/\1>/s;
    const match = html.match(tagRegex);
    
    if (!match) return null;
    
    const tag = match[1];
    const attrsStr = match[2];
    const content = match[3];
    
    const node = new DOMNode(tag);
    
    // Parse attributes
    const attrRegex = /(\w+)="([^"]*)"/g;
    let attrMatch;
    while ((attrMatch = attrRegex.exec(attrsStr)) !== null) {
      node.attributes[attrMatch[1]] = attrMatch[2];
    }
    
    // Check if content is text or child nodes
    if (!content.includes('<')) {
      node.text = content;
    }
    
    return node;
  }
}

const domRoot = new DOMNode('div', { class: 'container' });
domRoot.text = 'Hello';

const domCodec = new DOMCodec();
console.log('HTML:', domCodec.serialize(domRoot));

// 4. Decision Tree Serialization
console.log('\n=== Decision Tree ===');

class DecisionNode {
  constructor(question, yesNode = null, noNode = null) {
    this.question = question;
    this.yesNode = yesNode;
    this.noNode = noNode;
  }
}

class DecisionTreeCodec {
  serialize(root) {
    if (!root) return 'null';
    
    return JSON.stringify({
      q: root.question,
      y: JSON.parse(this.serialize(root.yesNode)),
      n: JSON.parse(this.serialize(root.noNode))
    });
  }
  
  deserialize(data) {
    const obj = JSON.parse(data);
    if (obj === 'null') return null;
    
    const node = new DecisionNode(obj.q);
    node.yesNode = this.deserialize(JSON.stringify(obj.y));
    node.noNode = this.deserialize(JSON.stringify(obj.n));
    
    return node;
  }
  
  evaluate(root, answers) {
    if (!root) return null;
    
    if (!root.yesNode && !root.noNode) {
      return root.question; // Leaf node (answer)
    }
    
    const response = answers[root.question];
    
    if (response === true) {
      return this.evaluate(root.yesNode, answers);
    } else {
      return this.evaluate(root.noNode, answers);
    }
  }
}

const decisionTree = new DecisionNode(
  'Is it alive?',
  new DecisionNode(
    'Can it fly?',
    new DecisionNode('Bird'),
    new DecisionNode('Mammal')
  ),
  new DecisionNode('Rock')
);

const dtCodec = new DecisionTreeCodec();
console.log('Decision tree:', dtCodec.serialize(decisionTree));

const answers = { 'Is it alive?': true, 'Can it fly?': false };
console.log('Classification:', dtCodec.evaluate(decisionTree, answers)); // Mammal

// 5. State Machine Serialization
console.log('\n=== State Machine ===');

class StateNode {
  constructor(name, transitions = {}) {
    this.name = name;
    this.transitions = transitions; // { event: nextState }
    this.onEnter = null;
    this.onExit = null;
  }
}

class StateMachineCodec {
  serialize(states) {
    return JSON.stringify(
      Object.entries(states).map(([name, state]) => ({
        name,
        transitions: state.transitions
      }))
    );
  }
  
  deserialize(data) {
    const statesData = JSON.parse(data);
    const states = {};
    
    for (const stateData of statesData) {
      states[stateData.name] = new StateNode(stateData.name, stateData.transitions);
    }
    
    return states;
  }
  
  visualize(states) {
    console.log('State Machine:');
    for (const [name, state] of Object.entries(states)) {
      console.log(`  ${name}:`);
      for (const [event, nextState] of Object.entries(state.transitions)) {
        console.log(`    ${event} -> ${nextState}`);
      }
    }
  }
}

const states = {
  idle: new StateNode('idle', { start: 'running' }),
  running: new StateNode('running', { pause: 'paused', stop: 'idle' }),
  paused: new StateNode('paused', { resume: 'running', stop: 'idle' })
};

const smCodec = new StateMachineCodec();
const serializedSM = smCodec.serialize(states);
console.log('Serialized:', serializedSM);

const deserializedSM = smCodec.deserialize(serializedSM);
smCodec.visualize(deserializedSM);
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

const codecTest = new Codec();

// Empty tree
console.log('Empty:', codecTest.serialize(null)); // "null"

// Single node
const single = new TreeNode(1);
console.log('Single node:', codecTest.serialize(single)); // "1,null,null"

// Left-skewed tree
const leftSkewed = new TreeNode(1, new TreeNode(2, new TreeNode(3)));
console.log('Left-skewed:', codecTest.serialize(leftSkewed));

// Right-skewed tree
const rightSkewed = new TreeNode(1, null, new TreeNode(2, null, new TreeNode(3)));
console.log('Right-skewed:', codecTest.serialize(rightSkewed));

// Complete binary tree
const complete = new TreeNode(1,
  new TreeNode(2, new TreeNode(4), new TreeNode(5)),
  new TreeNode(3, new TreeNode(6), new TreeNode(7))
);
console.log('Complete:', codecTest.serialize(complete));

// Tree with negative values
const negative = new TreeNode(-1, new TreeNode(-2), new TreeNode(-3));
console.log('Negative values:', codecTest.serialize(negative));

// Large values
const large = new TreeNode(1000000, new TreeNode(999999));
console.log('Large values:', codecTest.serialize(large));

// Deep tree
let deepRoot = new TreeNode(1);
let current = deepRoot;
for (let i = 2; i <= 5; i++) {
  current.left = new TreeNode(i);
  current = current.left;
}
console.log('Deep tree:', codecTest.serialize(deepRoot));
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance Comparison ===');

const testTree = new TreeNode(1,
  new TreeNode(2, new TreeNode(4), new TreeNode(5)),
  new TreeNode(3, new TreeNode(6), new TreeNode(7))
);

// Size comparison
const c1 = new Codec();
const c2 = new CodecBFS();
const c3 = new CodecJSON();
const c4 = new CodecBinary();

const s1 = c1.serialize(testTree);
const s2 = c2.serialize(testTree);
const s3 = c3.serialize(testTree);
const s4 = c4.serialize(testTree);

console.log('Pre-order:', s1, `(${s1.length} chars)`);
console.log('BFS:', s2, `(${s2.length} chars)`);
console.log('JSON:', s3, `(${s3.length} chars)`);
console.log('Binary:', s4, `(${s4.length} chars)`);

console.log(`
Algorithm Comparison:
┌──────────────────┬─────────────┬─────────────┬──────────────────┐
│ Method           │ Time        │ Space       │ Best For         │
├──────────────────┼─────────────┼─────────────┼──────────────────┤
│ Pre-order        │ O(n)        │ O(n)        │ Compact,         │
│                  │             │             │ fast rebuild     │
├──────────────────┼─────────────┼─────────────┼──────────────────┤
│ Level-order (BFS)│ O(n)        │ O(n)        │ Readable,        │
│                  │             │             │ layer by layer   │
├──────────────────┼─────────────┼─────────────┼──────────────────┤
│ JSON             │ O(n)        │ O(n)        │ Human-readable,  │
│                  │             │             │ debugging        │
├──────────────────┼─────────────┼─────────────┼──────────────────┤
│ Binary           │ O(n)        │ O(n)        │ Space-efficient, │
│                  │             │             │ production       │
├──────────────────┼─────────────┼─────────────┼──────────────────┤
│ With Metadata    │ O(n)        │ O(n)        │ Validation,      │
│                  │             │             │ versioning       │
└──────────────────┴─────────────┴─────────────┴──────────────────┘

Key Insights:
• Pre-order: serialize root, then left subtree, then right subtree
• Need null markers to reconstruct structure unambiguously
• BFS: level-by-level, can omit trailing nulls
• Deserialization reverses the serialization process
• Must handle edge cases: empty tree, single node, skewed trees

Serialization Formats:
• String: "1,2,null,null,3,4,null,null,5,null,null"
• Array: [1,2,3,null,null,4,5]
• JSON: {"val":1,"left":{"val":2},"right":{"val":3}}
• Binary: "1|1|2|0|0|1|3|..."

Applications:
• File system backup/restore
• Expression tree evaluation
• DOM/HTML parsing and rendering
• Decision tree persistence
• State machine configuration
• Network transmission of tree structures
• Database tree storage

Optimization Tips:
• Use BFS for better readability
• Add metadata for validation and versioning
• Compress with gzip for network transmission
• Use binary format for space efficiency
• Include checksums for data integrity
`);
```

**Interview Tips:**
- Serialization: convert tree structure to string/bytes for storage/transmission
- Deserialization: reconstruct tree from serialized format
- Pre-order traversal: most common, serialize root → left → right with null markers
- Must include null markers to uniquely identify tree structure
- BFS (level-order): more readable, serialize layer by layer
- Deserialization reverses the process using same traversal order
- Pre-order: use recursion with index pointer to track position
- BFS: use queue for both serialization and deserialization
- Time: O(n) for both operations (visit each node once)
- Space: O(n) for storing serialized data and recursion stack
- Edge cases: empty tree (return "null"), single node, skewed trees
- Applications: save/load trees, network transmission, deep copy, persistence
- JSON format: human-readable but verbose, good for debugging
- Binary format: space-efficient for production use
- Consider adding metadata: version, timestamp, node count for validation
- Common mistakes: forgetting null markers, wrong traversal order for deserialize
- Follow-ups: serialize N-ary tree, with parent pointers, generic tree, graph
- Optimization: compress data, use delimiter efficiently, handle special characters
- Clarify: format (string/binary), traversal method, handle duplicates?, size constraints?

</details>

113. Solve the "N-Queens" problem

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Backtracking with Array**
```javascript
/**
 * Classic N-Queens backtracking solution
 * Time Complexity: O(n!)
 * Space Complexity: O(n^2)
 */
function solveNQueens(n) {
  const result = [];
  const board = Array(n).fill(null).map(() => Array(n).fill('.'));
  
  function isValid(row, col) {
    // Check column
    for (let i = 0; i < row; i++) {
      if (board[i][col] === 'Q') return false;
    }
    
    // Check upper-left diagonal
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (board[i][j] === 'Q') return false;
    }
    
    // Check upper-right diagonal
    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
      if (board[i][j] === 'Q') return false;
    }
    
    return true;
  }
  
  function backtrack(row) {
    if (row === n) {
      result.push(board.map(r => r.join('')));
      return;
    }
    
    for (let col = 0; col < n; col++) {
      if (isValid(row, col)) {
        board[row][col] = 'Q';
        backtrack(row + 1);
        board[row][col] = '.';
      }
    }
  }
  
  backtrack(0);
  return result;
}

// Test
console.log('=== N-Queens Backtracking ===');

const solutions4 = solveNQueens(4);
console.log(`4-Queens (${solutions4.length} solutions):`);
solutions4.forEach((solution, idx) => {
  console.log(`\nSolution ${idx + 1}:`);
  solution.forEach(row => console.log(row));
});

const solutions8 = solveNQueens(8);
console.log(`\n8-Queens: ${solutions8.length} solutions`);
```

### **Approach 2: Optimized with Sets**
```javascript
/**
 * Use sets to track attacked positions - O(1) validation
 * Time Complexity: O(n!)
 * Space Complexity: O(n)
 */
function solveNQueensOptimized(n) {
  const result = [];
  const cols = new Set();
  const diag1 = new Set(); // row - col
  const diag2 = new Set(); // row + col
  const board = Array(n).fill(null).map(() => Array(n).fill('.'));
  
  function backtrack(row) {
    if (row === n) {
      result.push(board.map(r => r.join('')));
      return;
    }
    
    for (let col = 0; col < n; col++) {
      const d1 = row - col;
      const d2 = row + col;
      
      if (cols.has(col) || diag1.has(d1) || diag2.has(d2)) {
        continue;
      }
      
      // Place queen
      board[row][col] = 'Q';
      cols.add(col);
      diag1.add(d1);
      diag2.add(d2);
      
      backtrack(row + 1);
      
      // Remove queen
      board[row][col] = '.';
      cols.delete(col);
      diag1.delete(d1);
      diag2.delete(d2);
    }
  }
  
  backtrack(0);
  return result;
}

// Test
console.log('\n=== Optimized with Sets ===');

const start = performance.now();
const optimized = solveNQueensOptimized(8);
const end = performance.now();

console.log(`8-Queens: ${optimized.length} solutions`);
console.log(`Time: ${(end - start).toFixed(2)}ms`);
```

### **Approach 3: Count Solutions Only**
```javascript
/**
 * Count total number of solutions without storing them
 * More memory efficient
 */
function totalNQueens(n) {
  let count = 0;
  const cols = new Set();
  const diag1 = new Set();
  const diag2 = new Set();
  
  function backtrack(row) {
    if (row === n) {
      count++;
      return;
    }
    
    for (let col = 0; col < n; col++) {
      const d1 = row - col;
      const d2 = row + col;
      
      if (!cols.has(col) && !diag1.has(d1) && !diag2.has(d2)) {
        cols.add(col);
        diag1.add(d1);
        diag2.add(d2);
        
        backtrack(row + 1);
        
        cols.delete(col);
        diag1.delete(d1);
        diag2.delete(d2);
      }
    }
  }
  
  backtrack(0);
  return count;
}

// Test
console.log('\n=== Count Solutions ===');

for (let n = 1; n <= 10; n++) {
  const count = totalNQueens(n);
  console.log(`${n}-Queens: ${count} solutions`);
}
```

### **Approach 4: Bit Manipulation**
```javascript
/**
 * Use bits to represent attacked positions
 * Most efficient representation
 */
function solveNQueensBits(n) {
  let count = 0;
  const allOnes = (1 << n) - 1; // All n bits set to 1
  
  function backtrack(cols, diag1, diag2) {
    if (cols === allOnes) {
      count++;
      return;
    }
    
    // Available positions = positions not attacked
    let available = allOnes & ~(cols | diag1 | diag2);
    
    while (available) {
      // Get rightmost bit (lowest available position)
      const position = available & -available;
      
      // Clear this bit
      available -= position;
      
      backtrack(
        cols | position,
        (diag1 | position) << 1,
        (diag2 | position) >> 1
      );
    }
  }
  
  backtrack(0, 0, 0);
  return count;
}

// Test
console.log('\n=== Bit Manipulation ===');

const startBit = performance.now();
const countBit = solveNQueensBits(12);
const endBit = performance.now();

console.log(`12-Queens: ${countBit} solutions`);
console.log(`Time: ${(endBit - startBit).toFixed(2)}ms`);
```

### **Approach 5: Visualize and Animate**
```javascript
/**
 * Visualize N-Queens solution with animations
 */
class NQueensVisualizer {
  constructor(n) {
    this.n = n;
    this.solutions = [];
    this.steps = [];
  }
  
  solve() {
    const board = Array(this.n).fill(null).map(() => Array(this.n).fill('.'));
    const cols = new Set();
    const diag1 = new Set();
    const diag2 = new Set();
    
    const backtrack = (row) => {
      if (row === this.n) {
        this.solutions.push(board.map(r => [...r]));
        this.steps.push({ type: 'solution', board: board.map(r => [...r]) });
        return;
      }
      
      for (let col = 0; col < this.n; col++) {
        const d1 = row - col;
        const d2 = row + col;
        
        if (!cols.has(col) && !diag1.has(d1) && !diag2.has(d2)) {
          // Try placing queen
          board[row][col] = 'Q';
          this.steps.push({ type: 'place', row, col, board: board.map(r => [...r]) });
          
          cols.add(col);
          diag1.add(d1);
          diag2.add(d2);
          
          backtrack(row + 1);
          
          // Backtrack
          board[row][col] = '.';
          this.steps.push({ type: 'remove', row, col, board: board.map(r => [...r]) });
          
          cols.delete(col);
          diag1.delete(d1);
          diag2.delete(d2);
        }
      }
    };
    
    backtrack(0);
    return this.solutions;
  }
  
  printBoard(board) {
    console.log('┌' + '─'.repeat(this.n * 2 + 1) + '┐');
    board.forEach(row => {
      console.log('│ ' + row.join(' ') + ' │');
    });
    console.log('└' + '─'.repeat(this.n * 2 + 1) + '┘');
  }
  
  printSolution(index) {
    if (index >= 0 && index < this.solutions.length) {
      console.log(`\nSolution ${index + 1}:`);
      this.printBoard(this.solutions[index]);
    }
  }
  
  getAllSolutions() {
    return this.solutions;
  }
  
  getStepCount() {
    return this.steps.length;
  }
  
  isValid(board, row, col) {
    // Check if placing queen at (row, col) is valid
    for (let i = 0; i < row; i++) {
      if (board[i][col] === 'Q') return false;
    }
    
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (board[i][j] === 'Q') return false;
    }
    
    for (let i = row - 1, j = col + 1; i >= 0 && j < this.n; i--, j++) {
      if (board[i][j] === 'Q') return false;
    }
    
    return true;
  }
}

// Test
console.log('\n=== Visualizer ===');

const viz = new NQueensVisualizer(4);
viz.solve();

console.log(`Total solutions: ${viz.getAllSolutions().length}`);
console.log(`Total steps: ${viz.getStepCount()}`);

viz.printSolution(0);
viz.printSolution(1);
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications of N-Queens logic
 */

// 1. Task Scheduling with Conflicts
console.log('\n=== Task Scheduling ===');

class TaskScheduler {
  constructor(tasks, conflicts) {
    this.tasks = tasks;
    this.conflicts = conflicts; // [[task1, task2], ...] cannot be together
    this.n = tasks.length;
  }
  
  findSchedules(slots) {
    const result = [];
    const schedule = Array(slots).fill(null);
    const used = new Set();
    
    const hasConflict = (taskId, slot) => {
      for (let i = 0; i < slot; i++) {
        if (schedule[i] !== null) {
          const conflict = this.conflicts.find(
            ([a, b]) => 
              (a === taskId && b === schedule[i]) ||
              (b === taskId && a === schedule[i])
          );
          if (conflict) return true;
        }
      }
      return false;
    };
    
    const backtrack = (slot) => {
      if (slot === slots) {
        result.push([...schedule]);
        return;
      }
      
      for (let taskId = 0; taskId < this.n; taskId++) {
        if (!used.has(taskId) && !hasConflict(taskId, slot)) {
          schedule[slot] = taskId;
          used.add(taskId);
          
          backtrack(slot + 1);
          
          schedule[slot] = null;
          used.delete(taskId);
        }
      }
    };
    
    backtrack(0);
    return result;
  }
}

const tasks = ['Task A', 'Task B', 'Task C', 'Task D'];
const conflicts = [[0, 1], [1, 2]]; // A conflicts with B, B conflicts with C

const scheduler = new TaskScheduler(tasks, conflicts);
const schedules = scheduler.findSchedules(4);

console.log(`Valid schedules: ${schedules.length}`);
schedules.slice(0, 2).forEach((schedule, idx) => {
  console.log(`Schedule ${idx + 1}:`, schedule.map(i => tasks[i]).join(' → '));
});

// 2. Seating Arrangement
console.log('\n=== Seating Arrangement ===');

class SeatingArranger {
  constructor(people, incompatibilities) {
    this.people = people;
    this.incompatibilities = incompatibilities; // Set of [person1, person2]
    this.n = people.length;
  }
  
  findArrangements(tables) {
    const result = [];
    const seating = Array(tables).fill(null);
    const seated = new Set();
    
    const canSitTogether = (person, table) => {
      for (let i = 0; i < table; i++) {
        if (seating[i] !== null) {
          const incompatible = this.incompatibilities.some(
            ([p1, p2]) =>
              (p1 === person && p2 === seating[i]) ||
              (p2 === person && p1 === seating[i])
          );
          if (incompatible) return false;
        }
      }
      return true;
    };
    
    const backtrack = (table) => {
      if (table === tables) {
        result.push([...seating]);
        return;
      }
      
      for (let person = 0; person < this.n; person++) {
        if (!seated.has(person) && canSitTogether(person, table)) {
          seating[table] = person;
          seated.add(person);
          
          backtrack(table + 1);
          
          seating[table] = null;
          seated.delete(person);
        }
      }
    };
    
    backtrack(0);
    return result;
  }
}

const people = ['Alice', 'Bob', 'Charlie', 'Diana'];
const incompatibilities = [[0, 1], [2, 3]]; // Alice-Bob, Charlie-Diana

const seater = new SeatingArranger(people, incompatibilities);
const arrangements = seater.findArrangements(4);

console.log(`Valid arrangements: ${arrangements.length}`);
arrangements.slice(0, 2).forEach((arr, idx) => {
  console.log(`Arrangement ${idx + 1}:`, arr.map(i => people[i]).join(', '));
});

// 3. Resource Allocation
console.log('\n=== Resource Allocation ===');

class ResourceAllocator {
  constructor(resources, projects) {
    this.resources = resources;
    this.projects = projects;
    this.n = resources.length;
  }
  
  allocate(requirements) {
    // requirements[project] = [required resource types]
    const allocation = {};
    const used = new Set();
    
    const backtrack = (projectIdx) => {
      if (projectIdx === this.projects.length) {
        return true; // Found valid allocation
      }
      
      const project = this.projects[projectIdx];
      const required = requirements[project];
      
      for (let resIdx = 0; resIdx < this.n; resIdx++) {
        if (!used.has(resIdx) && required.includes(this.resources[resIdx])) {
          allocation[project] = this.resources[resIdx];
          used.add(resIdx);
          
          if (backtrack(projectIdx + 1)) {
            return true;
          }
          
          delete allocation[project];
          used.delete(resIdx);
        }
      }
      
      return false;
    };
    
    return backtrack(0) ? allocation : null;
  }
}

const resources = ['Dev1', 'Dev2', 'Designer1', 'Designer2'];
const projects = ['ProjectA', 'ProjectB'];
const requirements = {
  'ProjectA': ['Dev1', 'Dev2'],
  'ProjectB': ['Designer1', 'Designer2']
};

const allocator = new ResourceAllocator(resources, projects);
const allocation = allocator.allocate(requirements);

console.log('Allocation:', allocation);

// 4. Exam Scheduling
console.log('\n=== Exam Scheduling ===');

class ExamScheduler {
  constructor(courses, studentEnrollments) {
    this.courses = courses;
    this.studentEnrollments = studentEnrollments; // { student: [courses] }
    this.n = courses.length;
  }
  
  scheduleExams(timeSlots) {
    const schedule = Array(timeSlots).fill(null);
    const used = new Set();
    
    const hasConflict = (course, slot) => {
      // Check if any student enrolled in this course
      // is also enrolled in already scheduled courses in this slot
      for (let i = 0; i < slot; i++) {
        if (schedule[i] !== null) {
          const scheduled = schedule[i];
          
          for (const [student, courses] of Object.entries(this.studentEnrollments)) {
            if (courses.includes(course) && courses.includes(scheduled)) {
              return true; // Same student in both courses
            }
          }
        }
      }
      return false;
    };
    
    const backtrack = (slot) => {
      if (slot === timeSlots || used.size === this.n) {
        return used.size === this.n;
      }
      
      for (let courseIdx = 0; courseIdx < this.n; courseIdx++) {
        if (!used.has(courseIdx) && !hasConflict(this.courses[courseIdx], slot)) {
          schedule[slot] = this.courses[courseIdx];
          used.add(courseIdx);
          
          if (backtrack(slot + 1)) {
            return true;
          }
          
          schedule[slot] = null;
          used.delete(courseIdx);
        }
      }
      
      return false;
    };
    
    return backtrack(0) ? schedule.filter(s => s !== null) : null;
  }
}

const courses = ['Math', 'Physics', 'Chemistry', 'Biology'];
const enrollments = {
  'Student1': ['Math', 'Physics'],
  'Student2': ['Physics', 'Chemistry'],
  'Student3': ['Math', 'Biology']
};

const examScheduler = new ExamScheduler(courses, enrollments);
const examSchedule = examScheduler.scheduleExams(4);

console.log('Exam schedule:', examSchedule);

// 5. Graph Coloring (Sudoku-like)
console.log('\n=== Graph Coloring ===');

class GraphColoring {
  constructor(graph) {
    this.graph = graph; // adjacency list
    this.n = Object.keys(graph).length;
  }
  
  color(numColors) {
    const colors = {};
    
    const isValidColor = (node, color) => {
      for (const neighbor of this.graph[node]) {
        if (colors[neighbor] === color) {
          return false;
        }
      }
      return true;
    };
    
    const backtrack = (nodeIdx) => {
      const nodes = Object.keys(this.graph);
      
      if (nodeIdx === nodes.length) {
        return true;
      }
      
      const node = nodes[nodeIdx];
      
      for (let color = 0; color < numColors; color++) {
        if (isValidColor(node, color)) {
          colors[node] = color;
          
          if (backtrack(nodeIdx + 1)) {
            return true;
          }
          
          delete colors[node];
        }
      }
      
      return false;
    };
    
    return backtrack(0) ? colors : null;
  }
}

const graph = {
  'A': ['B', 'C'],
  'B': ['A', 'C', 'D'],
  'C': ['A', 'B', 'D'],
  'D': ['B', 'C']
};

const coloring = new GraphColoring(graph);
const result = coloring.color(3);

console.log('Graph coloring:', result);
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// N = 1 (trivial)
console.log('1-Queen:', totalNQueens(1)); // 1

// N = 2 (no solution)
console.log('2-Queens:', totalNQueens(2)); // 0

// N = 3 (no solution)
console.log('3-Queens:', totalNQueens(3)); // 0

// N = 4 (2 solutions)
const sol4 = solveNQueens(4);
console.log('4-Queens:', sol4.length, 'solutions');

// Large N
const sol10 = totalNQueens(10);
console.log('10-Queens:', sol10, 'solutions');

// Verify solution validity
function isValidSolution(board) {
  const n = board.length;
  
  for (let row = 0; row < n; row++) {
    for (let col = 0; col < n; col++) {
      if (board[row][col] === 'Q') {
        // Check column
        for (let i = row + 1; i < n; i++) {
          if (board[i][col] === 'Q') return false;
        }
        
        // Check diagonals
        for (let i = row + 1, j = col + 1; i < n && j < n; i++, j++) {
          if (board[i][j] === 'Q') return false;
        }
        
        for (let i = row + 1, j = col - 1; i < n && j >= 0; i++, j--) {
          if (board[i][j] === 'Q') return false;
        }
      }
    }
  }
  
  return true;
}

const testSol = solveNQueens(8);
console.log('All 8-Queens solutions valid:', testSol.every(s => isValidSolution(s.map(row => row.split('')))));
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Algorithm Comparison:
┌──────────────────────┬─────────────┬─────────────┬──────────────┐
│ Algorithm            │ Time        │ Space       │ Best For     │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Backtracking (array) │ O(n!)       │ O(n²)       │ Store all    │
│                      │             │             │ solutions    │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Optimized (sets)     │ O(n!)       │ O(n)        │ Faster,      │
│                      │             │             │ O(1) checks  │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Count only           │ O(n!)       │ O(n)        │ Memory       │
│                      │             │             │ efficient    │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Bit manipulation     │ O(n!)       │ O(n)        │ Fastest,     │
│                      │             │             │ large N      │
└──────────────────────┴─────────────┴─────────────┴──────────────┘

Known Solutions Count:
┌─────┬───────────┐
│ N   │ Solutions │
├─────┼───────────┤
│ 1   │ 1         │
│ 2   │ 0         │
│ 3   │ 0         │
│ 4   │ 2         │
│ 5   │ 10        │
│ 6   │ 4         │
│ 7   │ 40        │
│ 8   │ 92        │
│ 9   │ 352       │
│ 10  │ 724       │
│ 11  │ 2,680     │
│ 12  │ 14,200    │
└─────┴───────────┘

Key Insights:
• Classic backtracking problem with constraint satisfaction
• Place queens row by row, trying each column
• Check three constraints: column, two diagonals
• Diagonal identification: row-col (negative diagonal), row+col (positive)
• Use sets for O(1) constraint checking instead of O(n)
• Bit manipulation: fastest for counting solutions only

Optimization Techniques:
• Sets for O(1) validation vs O(n) array checking
• Track columns and diagonals with sets
• Bit manipulation for ultimate speed
• Prune early: skip invalid positions immediately
• Symmetry: can reduce by 2x (mirror solutions)

Applications:
• Task scheduling with conflicts
• Seating arrangements with incompatibilities
• Resource allocation with constraints
• Exam scheduling avoiding conflicts
• Graph coloring problems
• Constraint satisfaction problems (CSP)

Tips:
• Always place one queen per row (reduces search space)
• Diagonal formula: main diagonal (row-col), anti-diagonal (row+col)
• Base case: all rows filled = solution found
• No solution for N=2 and N=3
• Exponential growth in solution count
`);
```

**Interview Tips:**
- N-Queens: place N queens on N×N chessboard so no two queens attack each other
- Queens attack: same row, column, or diagonal
- Classic backtracking: place queens row by row, try each column
- Constraint checking: column, negative diagonal (row-col), positive diagonal (row+col)
- Three sets optimization: track occupied columns, both diagonals for O(1) validation
- Time: O(n!) in worst case due to trying all permutations with pruning
- Space: O(n²) for board or O(n) with sets optimization
- Place one queen per row: reduces search space significantly
- Diagonal formula: row-col gives diagonal index, row+col gives anti-diagonal
- Base case: when row == n, found valid solution
- Backtracking: place queen, recurse, remove queen if no solution
- Edge cases: n=1 (trivial, 1 solution), n=2,3 (no solutions), n=4 (2 solutions)
- Bit manipulation: most efficient for large N, represent positions as bits
- Applications: scheduling, seating, resource allocation, CSP problems
- Common mistakes: checking only rows/columns, forgetting one diagonal, wrong diagonal formula
- Optimization: use sets instead of arrays for O(1) lookups, bit manipulation for speed
- Follow-ups: count solutions only, find first solution, generalized to M×N board
- Clarify: return all solutions or count? just one solution? optimize for speed or readability?
- Interview: explain backtracking clearly, show constraint checking, discuss optimizations

</details>

114. Implement a function for "Edit Distance" (Levenshtein distance)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Dynamic Programming (2D Table)**
```javascript
/**
 * Edit distance using DP table
 * Time Complexity: O(m * n)
 * Space Complexity: O(m * n)
 */
function minDistance(word1, word2) {
  const m = word1.length;
  const n = word2.length;
  
  // dp[i][j] = min operations to convert word1[0..i-1] to word2[0..j-1]
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  
  // Base cases: empty string conversions
  for (let i = 0; i <= m; i++) {
    dp[i][0] = i; // Delete all characters from word1
  }
  
  for (let j = 0; j <= n; j++) {
    dp[0][j] = j; // Insert all characters to form word2
  }
  
  // Fill the DP table
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        // Characters match, no operation needed
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        // Min of: replace, delete, insert
        dp[i][j] = 1 + Math.min(
          dp[i - 1][j - 1], // Replace
          dp[i - 1][j],     // Delete from word1
          dp[i][j - 1]      // Insert into word1
        );
      }
    }
  }
  
  return dp[m][n];
}

// Test
console.log('=== Edit Distance DP ===');

console.log(minDistance('horse', 'ros')); // 3 (horse -> rorse -> rose -> ros)
console.log(minDistance('intention', 'execution')); // 5
console.log(minDistance('kitten', 'sitting')); // 3
console.log(minDistance('', 'abc')); // 3
console.log(minDistance('abc', '')); // 3
console.log(minDistance('abc', 'abc')); // 0
```

### **Approach 2: Space-Optimized DP (1D Array)**
```javascript
/**
 * Optimize space to O(n) using single array
 * Time Complexity: O(m * n)
 * Space Complexity: O(n)
 */
function minDistanceOptimized(word1, word2) {
  const m = word1.length;
  const n = word2.length;
  
  // Use only one row at a time
  let prev = Array(n + 1).fill(0);
  
  // Initialize first row
  for (let j = 0; j <= n; j++) {
    prev[j] = j;
  }
  
  for (let i = 1; i <= m; i++) {
    const curr = Array(n + 1).fill(0);
    curr[0] = i;
    
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        curr[j] = prev[j - 1];
      } else {
        curr[j] = 1 + Math.min(
          prev[j - 1], // Replace
          prev[j],     // Delete
          curr[j - 1]  // Insert
        );
      }
    }
    
    prev = curr;
  }
  
  return prev[n];
}

// Test
console.log('\n=== Space-Optimized ===');

console.log(minDistanceOptimized('horse', 'ros')); // 3
console.log(minDistanceOptimized('intention', 'execution')); // 5
console.log(minDistanceOptimized('kitten', 'sitting')); // 3
```

### **Approach 3: With Operation Tracking**
```javascript
/**
 * Track the actual operations performed
 */
function minDistanceWithOps(word1, word2) {
  const m = word1.length;
  const n = word2.length;
  
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  const ops = Array(m + 1).fill(null).map(() => Array(n + 1).fill(null));
  
  // Base cases
  for (let i = 0; i <= m; i++) {
    dp[i][0] = i;
    ops[i][0] = i > 0 ? 'delete' : 'none';
  }
  
  for (let j = 0; j <= n; j++) {
    dp[0][j] = j;
    ops[0][j] = j > 0 ? 'insert' : 'none';
  }
  
  // Fill DP table
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
        ops[i][j] = 'match';
      } else {
        const replace = dp[i - 1][j - 1];
        const deleteOp = dp[i - 1][j];
        const insert = dp[i][j - 1];
        
        const minCost = Math.min(replace, deleteOp, insert);
        dp[i][j] = 1 + minCost;
        
        if (minCost === replace) {
          ops[i][j] = 'replace';
        } else if (minCost === deleteOp) {
          ops[i][j] = 'delete';
        } else {
          ops[i][j] = 'insert';
        }
      }
    }
  }
  
  // Reconstruct operations
  const operations = [];
  let i = m, j = n;
  
  while (i > 0 || j > 0) {
    const op = ops[i][j];
    
    if (op === 'match') {
      i--;
      j--;
    } else if (op === 'replace') {
      operations.unshift(`Replace '${word1[i - 1]}' with '${word2[j - 1]}' at position ${i - 1}`);
      i--;
      j--;
    } else if (op === 'delete') {
      operations.unshift(`Delete '${word1[i - 1]}' at position ${i - 1}`);
      i--;
    } else if (op === 'insert') {
      operations.unshift(`Insert '${word2[j - 1]}' at position ${i}`);
      j--;
    } else {
      break;
    }
  }
  
  return {
    distance: dp[m][n],
    operations
  };
}

// Test
console.log('\n=== With Operations ===');

const result1 = minDistanceWithOps('horse', 'ros');
console.log(`Distance: ${result1.distance}`);
console.log('Operations:');
result1.operations.forEach(op => console.log(`  ${op}`));

console.log();

const result2 = minDistanceWithOps('kitten', 'sitting');
console.log(`Distance: ${result2.distance}`);
console.log('Operations:');
result2.operations.forEach(op => console.log(`  ${op}`));
```

### **Approach 4: Recursive with Memoization**
```javascript
/**
 * Top-down approach with memoization
 * Time Complexity: O(m * n)
 * Space Complexity: O(m * n)
 */
function minDistanceMemo(word1, word2) {
  const memo = new Map();
  
  function helper(i, j) {
    // Base cases
    if (i === 0) return j; // Insert all remaining chars from word2
    if (j === 0) return i; // Delete all remaining chars from word1
    
    const key = `${i},${j}`;
    if (memo.has(key)) return memo.get(key);
    
    let result;
    
    if (word1[i - 1] === word2[j - 1]) {
      // Characters match
      result = helper(i - 1, j - 1);
    } else {
      // Try all three operations
      result = 1 + Math.min(
        helper(i - 1, j - 1), // Replace
        helper(i - 1, j),     // Delete
        helper(i, j - 1)      // Insert
      );
    }
    
    memo.set(key, result);
    return result;
  }
  
  return helper(word1.length, word2.length);
}

// Test
console.log('\n=== Recursive with Memoization ===');

console.log(minDistanceMemo('horse', 'ros')); // 3
console.log(minDistanceMemo('intention', 'execution')); // 5
console.log(minDistanceMemo('kitten', 'sitting')); // 3
```

### **Approach 5: With Cost Customization**
```javascript
/**
 * Allow custom costs for different operations
 */
class EditDistanceCalculator {
  constructor(insertCost = 1, deleteCost = 1, replaceCost = 1) {
    this.insertCost = insertCost;
    this.deleteCost = deleteCost;
    this.replaceCost = replaceCost;
  }
  
  calculate(word1, word2) {
    const m = word1.length;
    const n = word2.length;
    
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    
    // Base cases with custom costs
    for (let i = 0; i <= m; i++) {
      dp[i][0] = i * this.deleteCost;
    }
    
    for (let j = 0; j <= n; j++) {
      dp[0][j] = j * this.insertCost;
    }
    
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (word1[i - 1] === word2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1];
        } else {
          dp[i][j] = Math.min(
            dp[i - 1][j - 1] + this.replaceCost,
            dp[i - 1][j] + this.deleteCost,
            dp[i][j - 1] + this.insertCost
          );
        }
      }
    }
    
    return dp[m][n];
  }
  
  // Calculate similarity percentage
  similarity(word1, word2) {
    const distance = this.calculate(word1, word2);
    const maxLen = Math.max(word1.length, word2.length);
    
    if (maxLen === 0) return 100;
    
    return ((1 - distance / maxLen) * 100).toFixed(2);
  }
}

// Test
console.log('\n=== Custom Costs ===');

const calc1 = new EditDistanceCalculator(1, 1, 1);
console.log('Equal costs:', calc1.calculate('horse', 'ros')); // 3

const calc2 = new EditDistanceCalculator(1, 2, 1);
console.log('Delete costs 2x:', calc2.calculate('horse', 'ros')); // Different

console.log('\nSimilarity:');
const calc3 = new EditDistanceCalculator();
console.log('horse vs ros:', calc3.similarity('horse', 'ros') + '%');
console.log('kitten vs sitting:', calc3.similarity('kitten', 'sitting') + '%');
console.log('hello vs hello:', calc3.similarity('hello', 'hello') + '%');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Spell Checker
console.log('\n=== Spell Checker ===');

class SpellChecker {
  constructor(dictionary) {
    this.dictionary = dictionary;
  }
  
  suggest(word, maxDistance = 2, maxSuggestions = 5) {
    const suggestions = [];
    
    for (const dictWord of this.dictionary) {
      const distance = minDistance(word, dictWord);
      
      if (distance <= maxDistance) {
        suggestions.push({ word: dictWord, distance });
      }
    }
    
    // Sort by distance
    suggestions.sort((a, b) => a.distance - b.distance);
    
    return suggestions.slice(0, maxSuggestions);
  }
  
  correct(text) {
    const words = text.split(' ');
    const corrected = [];
    
    for (const word of words) {
      if (this.dictionary.includes(word.toLowerCase())) {
        corrected.push(word);
      } else {
        const suggestions = this.suggest(word.toLowerCase(), 2, 1);
        corrected.push(suggestions.length > 0 ? suggestions[0].word : word);
      }
    }
    
    return corrected.join(' ');
  }
}

const dictionary = ['hello', 'world', 'cat', 'dog', 'house', 'mouse'];
const spellChecker = new SpellChecker(dictionary);

console.log('Suggestions for "helo":', spellChecker.suggest('helo'));
console.log('Suggestions for "wrld":', spellChecker.suggest('wrld'));
console.log('Auto-correct:', spellChecker.correct('helo wrld'));

// 2. DNA Sequence Alignment
console.log('\n=== DNA Sequence Alignment ===');

class DNAAligner {
  constructor() {
    this.matchScore = 0;
    this.mismatchPenalty = 1;
    this.gapPenalty = 2;
  }
  
  align(seq1, seq2) {
    const m = seq1.length;
    const n = seq2.length;
    
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    
    // Initialize with gap penalties
    for (let i = 0; i <= m; i++) {
      dp[i][0] = i * this.gapPenalty;
    }
    
    for (let j = 0; j <= n; j++) {
      dp[0][j] = j * this.gapPenalty;
    }
    
    // Fill DP table
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        const match = seq1[i - 1] === seq2[j - 1];
        
        dp[i][j] = Math.min(
          dp[i - 1][j - 1] + (match ? this.matchScore : this.mismatchPenalty),
          dp[i - 1][j] + this.gapPenalty,
          dp[i][j - 1] + this.gapPenalty
        );
      }
    }
    
    return {
      alignmentScore: dp[m][n],
      similarity: ((1 - dp[m][n] / Math.max(m, n)) * 100).toFixed(2) + '%'
    };
  }
  
  findSimilarSequences(query, database, threshold = 0.7) {
    const results = [];
    
    for (const [id, sequence] of Object.entries(database)) {
      const alignment = this.align(query, sequence);
      const similarity = parseFloat(alignment.similarity) / 100;
      
      if (similarity >= threshold) {
        results.push({ id, sequence, similarity: alignment.similarity });
      }
    }
    
    return results.sort((a, b) => parseFloat(b.similarity) - parseFloat(a.similarity));
  }
}

const aligner = new DNAAligner();
console.log('Alignment:', aligner.align('ACGT', 'AGCT'));

const database = {
  'seq1': 'ACGTACGT',
  'seq2': 'ACGTACGG',
  'seq3': 'TGCATGCA'
};

console.log('Similar sequences:', aligner.findSimilarSequences('ACGTACGT', database, 0.8));

// 3. Fuzzy String Matching
console.log('\n=== Fuzzy Search ===');

class FuzzySearch {
  constructor(items) {
    this.items = items;
  }
  
  search(query, threshold = 0.5) {
    const results = [];
    
    for (const item of this.items) {
      const distance = minDistance(query.toLowerCase(), item.toLowerCase());
      const maxLen = Math.max(query.length, item.length);
      const similarity = 1 - distance / maxLen;
      
      if (similarity >= threshold) {
        results.push({
          item,
          similarity: (similarity * 100).toFixed(2) + '%',
          distance
        });
      }
    }
    
    return results.sort((a, b) => parseFloat(b.similarity) - parseFloat(a.similarity));
  }
  
  findClosest(query, count = 3) {
    const allResults = this.items.map(item => {
      const distance = minDistance(query.toLowerCase(), item.toLowerCase());
      return { item, distance };
    });
    
    allResults.sort((a, b) => a.distance - b.distance);
    return allResults.slice(0, count);
  }
}

const items = ['JavaScript', 'Python', 'Java', 'TypeScript', 'Ruby', 'Go'];
const fuzzy = new FuzzySearch(items);

console.log('Fuzzy search for "javscript":', fuzzy.search('javscript', 0.7));
console.log('Closest to "pythn":', fuzzy.findClosest('pythn', 2));

// 4. Plagiarism Detection
console.log('\n=== Plagiarism Detection ===');

class PlagiarismDetector {
  constructor(threshold = 0.8) {
    this.threshold = threshold;
  }
  
  compare(text1, text2) {
    // Split into sentences
    const sentences1 = text1.split(/[.!?]+/).filter(s => s.trim());
    const sentences2 = text2.split(/[.!?]+/).filter(s => s.trim());
    
    let totalSimilarity = 0;
    let matches = 0;
    
    for (const sent1 of sentences1) {
      for (const sent2 of sentences2) {
        const distance = minDistance(sent1.trim(), sent2.trim());
        const maxLen = Math.max(sent1.length, sent2.length);
        const similarity = 1 - distance / maxLen;
        
        if (similarity >= this.threshold) {
          matches++;
          totalSimilarity += similarity;
        }
      }
    }
    
    return {
      matches,
      averageSimilarity: matches > 0 ? (totalSimilarity / matches * 100).toFixed(2) + '%' : '0%',
      isPlagiarized: matches > 0
    };
  }
  
  detect(document, corpus) {
    const results = [];
    
    for (const [id, text] of Object.entries(corpus)) {
      const comparison = this.compare(document, text);
      
      if (comparison.isPlagiarized) {
        results.push({ id, ...comparison });
      }
    }
    
    return results;
  }
}

const detector = new PlagiarismDetector(0.8);
const doc = 'The quick brown fox jumps. Over the lazy dog.';
const corpus = {
  'doc1': 'The quick brown fox jumps. Over a lazy dog.',
  'doc2': 'A completely different text here.'
};

console.log('Plagiarism check:', detector.detect(doc, corpus));

// 5. Version Control Diff
console.log('\n=== Version Control Diff ===');

class TextDiffer {
  diff(oldText, newText) {
    const oldLines = oldText.split('\n');
    const newLines = newText.split('\n');
    
    const m = oldLines.length;
    const n = newLines.length;
    
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    const ops = Array(m + 1).fill(null).map(() => Array(n + 1).fill(null));
    
    // Base cases
    for (let i = 0; i <= m; i++) {
      dp[i][0] = i;
      ops[i][0] = 'delete';
    }
    
    for (let j = 0; j <= n; j++) {
      dp[0][j] = j;
      ops[0][j] = 'insert';
    }
    
    // Fill DP
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (oldLines[i - 1] === newLines[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1];
          ops[i][j] = 'match';
        } else {
          const costs = [
            dp[i - 1][j - 1],
            dp[i - 1][j],
            dp[i][j - 1]
          ];
          
          const minCost = Math.min(...costs);
          dp[i][j] = 1 + minCost;
          
          if (minCost === costs[0]) ops[i][j] = 'replace';
          else if (minCost === costs[1]) ops[i][j] = 'delete';
          else ops[i][j] = 'insert';
        }
      }
    }
    
    // Reconstruct diff
    const diff = [];
    let i = m, j = n;
    
    while (i > 0 || j > 0) {
      const op = ops[i][j];
      
      if (op === 'match') {
        diff.unshift({ type: ' ', line: oldLines[i - 1] });
        i--;
        j--;
      } else if (op === 'replace') {
        diff.unshift({ type: '-', line: oldLines[i - 1] });
        diff.unshift({ type: '+', line: newLines[j - 1] });
        i--;
        j--;
      } else if (op === 'delete') {
        diff.unshift({ type: '-', line: oldLines[i - 1] });
        i--;
      } else if (op === 'insert') {
        diff.unshift({ type: '+', line: newLines[j - 1] });
        j--;
      } else {
        break;
      }
    }
    
    return diff;
  }
  
  printDiff(diff) {
    diff.forEach(({ type, line }) => {
      console.log(`${type} ${line}`);
    });
  }
}

const differ = new TextDiffer();
const oldText = 'Hello World\nThis is a test\nGoodbye';
const newText = 'Hello World\nThis is modified\nGoodbye';

const diff = differ.diff(oldText, newText);
console.log('Diff:');
differ.printDiff(diff);

// 6. Autocomplete with Typo Tolerance
console.log('\n=== Autocomplete ===');

class Autocomplete {
  constructor(dictionary) {
    this.dictionary = dictionary;
  }
  
  suggest(prefix, maxDistance = 1, maxResults = 5) {
    const suggestions = [];
    
    for (const word of this.dictionary) {
      // Check if word starts with prefix (with tolerance)
      if (word.startsWith(prefix)) {
        suggestions.push({ word, distance: 0, exact: true });
      } else {
        // Calculate distance for prefix match with typos
        const prefixDistance = minDistance(prefix, word.substring(0, prefix.length));
        
        if (prefixDistance <= maxDistance) {
          suggestions.push({ word, distance: prefixDistance, exact: false });
        }
      }
    }
    
    // Sort: exact matches first, then by distance
    suggestions.sort((a, b) => {
      if (a.exact !== b.exact) return a.exact ? -1 : 1;
      return a.distance - b.distance;
    });
    
    return suggestions.slice(0, maxResults).map(s => s.word);
  }
}

const autoDict = ['javascript', 'java', 'python', 'typescript', 'ruby'];
const autocomplete = new Autocomplete(autoDict);

console.log('Autocomplete "jav":', autocomplete.suggest('jav'));
console.log('Autocomplete "pyt" (with typo tolerance):', autocomplete.suggest('pyt', 1));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Empty strings
console.log('Empty to "abc":', minDistance('', 'abc')); // 3
console.log('"abc" to empty:', minDistance('abc', '')); // 3
console.log('Both empty:', minDistance('', '')); // 0

// Same strings
console.log('Same strings:', minDistance('hello', 'hello')); // 0

// Single character
console.log('Single char:', minDistance('a', 'b')); // 1
console.log('Single char same:', minDistance('a', 'a')); // 0

// One character off
console.log('Insert one:', minDistance('abc', 'abcd')); // 1
console.log('Delete one:', minDistance('abcd', 'abc')); // 1
console.log('Replace one:', minDistance('abc', 'abd')); // 1

// Completely different
console.log('Completely different:', minDistance('abc', 'xyz')); // 3

// Long strings
console.log('Long strings:', minDistance('abcdefghij', 'jihgfedcba')); // 10

// Special characters
console.log('Special chars:', minDistance('hello!', 'hello?')); // 1

// Case sensitivity
console.log('Case sensitive:', minDistance('Hello', 'hello')); // 1

// Reversed
console.log('Reversed:', minDistance('abc', 'cba')); // 2
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

function benchmark(fn, name, word1, word2) {
  const start = performance.now();
  const result = fn(word1, word2);
  const end = performance.now();
  console.log(`${name}: ${result} (${(end - start).toFixed(3)}ms)`);
}

const w1 = 'algorithm';
const w2 = 'altruistic';

benchmark(minDistance, '2D DP', w1, w2);
benchmark(minDistanceOptimized, '1D DP', w1, w2);
benchmark(minDistanceMemo, 'Memoization', w1, w2);

console.log(`
Algorithm Comparison:
┌────────────────────┬─────────────┬─────────────┬──────────────┐
│ Algorithm          │ Time        │ Space       │ Best For     │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ 2D DP              │ O(m×n)      │ O(m×n)      │ Tracking ops,│
│                    │             │             │ clarity      │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ 1D DP (optimized)  │ O(m×n)      │ O(n)        │ Space-       │
│                    │             │             │ efficient    │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Recursive + Memo   │ O(m×n)      │ O(m×n)      │ Top-down,    │
│                    │             │             │ intuitive    │
├────────────────────┼─────────────┼─────────────┼──────────────┤
│ Custom Costs       │ O(m×n)      │ O(m×n)      │ Weighted ops │
└────────────────────┴─────────────┴─────────────┴──────────────┘

Key Insights:
• Edit distance (Levenshtein): minimum operations to transform string A to B
• Three operations: insert, delete, replace (all cost 1)
• DP formula: 
  - If chars match: dp[i][j] = dp[i-1][j-1]
  - Else: dp[i][j] = 1 + min(replace, delete, insert)
• Base cases: dp[i][0] = i (delete all), dp[0][j] = j (insert all)
• Can optimize space from O(m×n) to O(n) using rolling array

Recurrence Relation:
dp[i][j] = {
  dp[i-1][j-1]                      if word1[i-1] == word2[j-1]
  1 + min(
    dp[i-1][j-1],  // Replace word1[i-1] with word2[j-1]
    dp[i-1][j],    // Delete word1[i-1]
    dp[i][j-1]     // Insert word2[j-1]
  )                                 otherwise
}

Real-World Applications:
• Spell checker and auto-correction
• DNA/protein sequence alignment
• Fuzzy string matching and search
• Plagiarism detection
• Version control (diff/patch)
• Autocomplete with typo tolerance
• Similar text recommendation
• Data deduplication

Optimization Tips:
• Use 1D array to save space (only need previous row)
• Early termination if distance exceeds threshold
• For large alphabets, consider preprocessing
• Can weight operations differently (custom costs)
• Parallel processing for multiple comparisons
`);
```

**Interview Tips:**
- Edit distance (Levenshtein): minimum operations to convert string A to B
- Three operations: insert character, delete character, replace character
- Classic DP problem: dp[i][j] = min operations for word1[0..i-1] → word2[0..j-1]
- Base cases: empty string conversions (dp[i][0]=i, dp[0][j]=j)
- If characters match: no operation needed, dp[i][j] = dp[i-1][j-1]
- If different: 1 + min(replace, delete from word1, insert into word1)
- Replace: dp[i-1][j-1], Delete: dp[i-1][j], Insert: dp[i][j-1]
- Time: O(m×n), Space: O(m×n) for 2D table, O(n) with optimization
- Space optimization: only need current and previous row, use rolling array
- Can track operations by storing which operation was used at each step
- Applications: spell checker, DNA alignment, fuzzy search, plagiarism, diff tools
- Variations: weighted costs, different operations, similarity percentage
- Edge cases: empty strings, same strings, single character, completely different
- Common mistakes: wrong base cases, incorrect recurrence, off-by-one indexing
- Follow-ups: find actual operations, custom costs, substring distance, multiple strings
- Optimization: early termination if threshold exceeded, parallel processing
- Similarity: (1 - distance/maxLength) × 100%
- Clarify: case-sensitive? allow which operations? return distance or operations?

</details>

115. Solve the "Maximum Subarray Sum" problem (Kadane's algorithm)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Kadane's Algorithm (Optimal)**
```javascript
/**
 * Find maximum sum of contiguous subarray
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
function maxSubArray(nums) {
  let maxSum = nums[0];
  let currentSum = nums[0];
  
  for (let i = 1; i < nums.length; i++) {
    // Either extend existing subarray or start new one
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
  }
  
  return maxSum;
}

// Test
console.log('=== Kadane\'s Algorithm ===');

console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])); // 6 ([4,-1,2,1])
console.log(maxSubArray([1])); // 1
console.log(maxSubArray([5,4,-1,7,8])); // 23 (entire array)
console.log(maxSubArray([-1])); // -1
console.log(maxSubArray([-2,-1])); // -1
```

### **Approach 2: With Subarray Indices**
```javascript
/**
 * Track the start and end indices of maximum subarray
 */
function maxSubArrayWithIndices(nums) {
  let maxSum = nums[0];
  let currentSum = nums[0];
  let start = 0;
  let end = 0;
  let tempStart = 0;
  
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] > currentSum + nums[i]) {
      currentSum = nums[i];
      tempStart = i;
    } else {
      currentSum += nums[i];
    }
    
    if (currentSum > maxSum) {
      maxSum = currentSum;
      start = tempStart;
      end = i;
    }
  }
  
  return {
    maxSum,
    subarray: nums.slice(start, end + 1),
    indices: { start, end }
  };
}

// Test
console.log('\n=== With Indices ===');

const result1 = maxSubArrayWithIndices([-2,1,-3,4,-1,2,1,-5,4]);
console.log('Max sum:', result1.maxSum);
console.log('Subarray:', result1.subarray);
console.log('Indices:', result1.indices);

const result2 = maxSubArrayWithIndices([5,4,-1,7,8]);
console.log('\nMax sum:', result2.maxSum);
console.log('Subarray:', result2.subarray);
```

### **Approach 3: Divide and Conquer**
```javascript
/**
 * Divide and conquer approach
 * Time Complexity: O(n log n)
 * Space Complexity: O(log n) for recursion stack
 */
function maxSubArrayDC(nums) {
  function maxCrossingSum(nums, left, mid, right) {
    // Include elements on left of mid
    let leftSum = -Infinity;
    let sum = 0;
    
    for (let i = mid; i >= left; i--) {
      sum += nums[i];
      leftSum = Math.max(leftSum, sum);
    }
    
    // Include elements on right of mid
    let rightSum = -Infinity;
    sum = 0;
    
    for (let i = mid + 1; i <= right; i++) {
      sum += nums[i];
      rightSum = Math.max(rightSum, sum);
    }
    
    return leftSum + rightSum;
  }
  
  function helper(nums, left, right) {
    if (left === right) {
      return nums[left];
    }
    
    const mid = Math.floor((left + right) / 2);
    
    const leftMax = helper(nums, left, mid);
    const rightMax = helper(nums, mid + 1, right);
    const crossMax = maxCrossingSum(nums, left, mid, right);
    
    return Math.max(leftMax, rightMax, crossMax);
  }
  
  return helper(nums, 0, nums.length - 1);
}

// Test
console.log('\n=== Divide and Conquer ===');

console.log(maxSubArrayDC([-2,1,-3,4,-1,2,1,-5,4])); // 6
console.log(maxSubArrayDC([5,4,-1,7,8])); // 23
```

### **Approach 4: Dynamic Programming (Explicit)**
```javascript
/**
 * Explicit DP array showing all subproblem solutions
 */
function maxSubArrayDP(nums) {
  const n = nums.length;
  const dp = new Array(n);
  
  // dp[i] = maximum sum ending at index i
  dp[0] = nums[0];
  let maxSum = dp[0];
  
  for (let i = 1; i < n; i++) {
    dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
    maxSum = Math.max(maxSum, dp[i]);
  }
  
  return {
    maxSum,
    dp // Shows max sum ending at each position
  };
}

// Test
console.log('\n=== Explicit DP ===');

const dpResult = maxSubArrayDP([-2,1,-3,4,-1,2,1,-5,4]);
console.log('Max sum:', dpResult.maxSum);
console.log('DP array:', dpResult.dp);
```

### **Approach 5: All Subarrays (Brute Force)**
```javascript
/**
 * Generate all possible subarrays and find maximum
 * Time Complexity: O(n^2)
 * Space Complexity: O(1)
 * Educational purpose only - not optimal
 */
function maxSubArrayBruteForce(nums) {
  let maxSum = -Infinity;
  let bestSubarray = [];
  
  for (let i = 0; i < nums.length; i++) {
    let currentSum = 0;
    
    for (let j = i; j < nums.length; j++) {
      currentSum += nums[j];
      
      if (currentSum > maxSum) {
        maxSum = currentSum;
        bestSubarray = nums.slice(i, j + 1);
      }
    }
  }
  
  return {
    maxSum,
    subarray: bestSubarray
  };
}

// Test
console.log('\n=== Brute Force ===');

const bruteResult = maxSubArrayBruteForce([-2,1,-3,4,-1,2,1,-5,4]);
console.log('Max sum:', bruteResult.maxSum);
console.log('Subarray:', bruteResult.subarray);
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Stock Trading - Best Time to Buy and Sell
console.log('\n=== Stock Trading ===');

class StockAnalyzer {
  maxProfit(prices) {
    if (prices.length < 2) return 0;
    
    // Convert to price differences
    const changes = [];
    for (let i = 1; i < prices.length; i++) {
      changes.push(prices[i] - prices[i - 1]);
    }
    
    // Find maximum subarray sum in changes
    let maxProfit = 0;
    let currentProfit = 0;
    let buyDay = 0;
    let sellDay = 0;
    let tempBuy = 0;
    
    for (let i = 0; i < changes.length; i++) {
      if (currentProfit + changes[i] < 0) {
        currentProfit = 0;
        tempBuy = i + 1;
      } else {
        currentProfit += changes[i];
      }
      
      if (currentProfit > maxProfit) {
        maxProfit = currentProfit;
        buyDay = tempBuy;
        sellDay = i + 1;
      }
    }
    
    return {
      maxProfit,
      buyDay,
      sellDay,
      buyPrice: prices[buyDay],
      sellPrice: prices[sellDay]
    };
  }
  
  findTradingWindow(prices) {
    const analysis = this.maxProfit(prices);
    
    return {
      ...analysis,
      recommendation: analysis.maxProfit > 0 ? 
        `Buy on day ${analysis.buyDay} at $${analysis.buyPrice}, sell on day ${analysis.sellDay} at $${analysis.sellPrice}` :
        'Hold - no profitable trading opportunity'
    };
  }
}

const analyzer = new StockAnalyzer();
const prices = [7, 1, 5, 3, 6, 4];
console.log('Stock analysis:', analyzer.findTradingWindow(prices));

// 2. Sensor Data Analysis
console.log('\n=== Sensor Data Analysis ===');

class SensorAnalyzer {
  findMaxAnomalyPeriod(readings) {
    // Normalize readings (subtract average)
    const avg = readings.reduce((a, b) => a + b, 0) / readings.length;
    const normalized = readings.map(r => r - avg);
    
    // Find period with maximum deviation
    const result = maxSubArrayWithIndices(normalized);
    
    return {
      period: result.indices,
      totalDeviation: result.maxSum.toFixed(2),
      readings: result.subarray.map((v, i) => ({
        index: result.indices.start + i,
        deviation: v.toFixed(2),
        actual: readings[result.indices.start + i]
      }))
    };
  }
}

const sensorReadings = [20, 22, 19, 25, 30, 35, 28, 21, 20];
const sensorAnalyzer = new SensorAnalyzer();
console.log('Max anomaly period:', sensorAnalyzer.findMaxAnomalyPeriod(sensorReadings));

// 3. Gaming - Maximum Score Streak
console.log('\n=== Gaming Score Streak ===');

class GameAnalyzer {
  findBestStreak(scoreChanges) {
    // scoreChanges: positive for wins, negative for losses
    const result = maxSubArrayWithIndices(scoreChanges);
    
    const totalGames = result.subarray.length;
    const wins = result.subarray.filter(s => s > 0).length;
    const losses = totalGames - wins;
    
    return {
      maxPoints: result.maxSum,
      streakPeriod: result.indices,
      totalGames,
      wins,
      losses,
      winRate: ((wins / totalGames) * 100).toFixed(1) + '%'
    };
  }
}

const scoreChanges = [10, -5, 20, -3, 15, 8, -10, -20, 25, 30];
const gameAnalyzer = new GameAnalyzer();
console.log('Best streak:', gameAnalyzer.findBestStreak(scoreChanges));

// 4. Network Traffic Analysis
console.log('\n=== Network Traffic ===');

class NetworkAnalyzer {
  findPeakTrafficPeriod(traffic) {
    // traffic: array of throughput changes (positive = increase, negative = decrease)
    const result = maxSubArrayWithIndices(traffic);
    
    return {
      peakIncrease: result.maxSum.toFixed(2) + ' Mbps',
      startTime: result.indices.start,
      endTime: result.indices.end,
      duration: result.indices.end - result.indices.start + 1,
      pattern: result.subarray
    };
  }
  
  identifyBottleneck(traffic, threshold) {
    const avgTraffic = traffic.reduce((a, b) => a + b, 0) / traffic.length;
    
    // Find periods exceeding threshold
    const exceedances = traffic.map(t => t > threshold ? t - threshold : 0);
    const result = maxSubArrayWithIndices(exceedances);
    
    if (result.maxSum === 0) {
      return { bottleneck: false, message: 'No bottleneck detected' };
    }
    
    return {
      bottleneck: true,
      severity: result.maxSum.toFixed(2),
      period: result.indices,
      recommendation: 'Consider scaling up during this period'
    };
  }
}

const trafficChanges = [5, -2, 10, 15, -5, 8, -3, 20];
const networkAnalyzer = new NetworkAnalyzer();
console.log('Peak traffic:', networkAnalyzer.findPeakTrafficPeriod(trafficChanges));

// 5. Financial Analysis - Cash Flow
console.log('\n=== Cash Flow Analysis ===');

class CashFlowAnalyzer {
  analyzeCashFlow(transactions) {
    // transactions: positive = income, negative = expenses
    const result = maxSubArrayWithIndices(transactions);
    
    const period = result.subarray;
    const income = period.filter(t => t > 0).reduce((a, b) => a + b, 0);
    const expenses = Math.abs(period.filter(t => t < 0).reduce((a, b) => a + b, 0));
    
    return {
      maxCashFlow: result.maxSum,
      period: result.indices,
      months: result.indices.end - result.indices.start + 1,
      income: income.toFixed(2),
      expenses: expenses.toFixed(2),
      netFlow: result.maxSum.toFixed(2)
    };
  }
  
  findBestInvestmentWindow(cashFlows, minWindow = 3) {
    let bestSum = -Infinity;
    let bestWindow = null;
    
    for (let windowSize = minWindow; windowSize <= cashFlows.length; windowSize++) {
      for (let i = 0; i <= cashFlows.length - windowSize; i++) {
        const windowSum = cashFlows.slice(i, i + windowSize).reduce((a, b) => a + b, 0);
        
        if (windowSum > bestSum) {
          bestSum = windowSum;
          bestWindow = { start: i, end: i + windowSize - 1 };
        }
      }
    }
    
    return {
      maxReturn: bestSum,
      window: bestWindow,
      duration: bestWindow.end - bestWindow.start + 1
    };
  }
}

const cashFlows = [1000, -200, 500, -100, 800, -300, 600];
const cashAnalyzer = new CashFlowAnalyzer();
console.log('Cash flow analysis:', cashAnalyzer.analyzeCashFlow(cashFlows));

// 6. Fitness Tracker - Best Performance Period
console.log('\n=== Fitness Tracker ===');

class FitnessAnalyzer {
  findBestPerformancePeriod(workoutScores) {
    const result = maxSubArrayWithIndices(workoutScores);
    
    const avgScore = result.subarray.reduce((a, b) => a + b, 0) / result.subarray.length;
    
    return {
      totalScore: result.maxSum,
      period: result.indices,
      workouts: result.subarray.length,
      averageScore: avgScore.toFixed(2),
      improvement: ((result.subarray[result.subarray.length - 1] - result.subarray[0]) / result.subarray[0] * 100).toFixed(1) + '%'
    };
  }
}

const workoutScores = [50, 55, -10, 60, 65, 70, -20, 55, 80];
const fitnessAnalyzer = new FitnessAnalyzer();
console.log('Best performance:', fitnessAnalyzer.findBestPerformancePeriod(workoutScores));
```

### **Edge Cases and Testing**
```javascript
console.log('\n=== Edge Cases ===');

// Single element
console.log('Single positive:', maxSubArray([5])); // 5
console.log('Single negative:', maxSubArray([-5])); // -5

// All positive
console.log('All positive:', maxSubArray([1, 2, 3, 4])); // 10

// All negative
console.log('All negative:', maxSubArray([-1, -2, -3, -4])); // -1

// Mixed with zeros
console.log('With zeros:', maxSubArray([0, -1, 0, 2, 0])); // 2

// Large numbers
console.log('Large numbers:', maxSubArray([1000000, -1, 1000000])); // 1999999

// Alternating
console.log('Alternating:', maxSubArray([1, -1, 1, -1, 1])); // 1

// Two elements
console.log('Two positive:', maxSubArray([1, 2])); // 3
console.log('Two negative:', maxSubArray([-1, -2])); // -1
console.log('Mixed two:', maxSubArray([5, -3])); // 5

// Empty (if allowed)
// console.log('Empty:', maxSubArray([])); // Handle based on requirements
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

const testArray = Array.from({ length: 1000 }, () => Math.floor(Math.random() * 200) - 100);

function benchmark(fn, name) {
  const start = performance.now();
  const result = fn(testArray);
  const end = performance.now();
  console.log(`${name}: ${result} (${(end - start).toFixed(3)}ms)`);
}

benchmark(maxSubArray, 'Kadane');
benchmark(maxSubArrayDC, 'Divide & Conquer');
benchmark((arr) => maxSubArrayBruteForce(arr).maxSum, 'Brute Force');

console.log(`
Algorithm Comparison:
┌──────────────────────┬─────────────┬─────────────┬──────────────┐
│ Algorithm            │ Time        │ Space       │ Best For     │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Kadane's Algorithm   │ O(n)        │ O(1)        │ Optimal      │
│                      │             │             │ solution     │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Divide & Conquer     │ O(n log n)  │ O(log n)    │ Educational, │
│                      │             │             │ parallel     │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Dynamic Programming  │ O(n)        │ O(n)        │ Show all     │
│ (explicit)           │             │             │ subproblems  │
├──────────────────────┼─────────────┼─────────────┼──────────────┤
│ Brute Force          │ O(n²)       │ O(1)        │ Small arrays │
│                      │             │             │ only         │
└──────────────────────┴─────────────┴─────────────┴──────────────┘

Kadane's Algorithm Explained:
1. Maintain two variables:
   - currentSum: max sum ending at current position
   - maxSum: overall maximum sum seen so far

2. For each element:
   - Either extend current subarray: currentSum + nums[i]
   - Or start new subarray: nums[i]
   - Choose whichever is larger

3. Update maxSum if currentSum is greater

Key Insight:
At each position, decide: extend previous subarray or start fresh?
If currentSum < 0, starting fresh is always better!

Recurrence:
currentSum = max(nums[i], currentSum + nums[i])
maxSum = max(maxSum, currentSum)

Applications:
• Stock trading (best buy/sell window)
• Sensor data anomaly detection
• Gaming score optimization
• Network traffic peak analysis
• Financial cash flow analysis
• Fitness performance tracking
• Any time-series max sum problem

Variations:
• Find subarray indices (track start/end)
• Find all subarrays with max sum
• Circular array version
• 2D version (maximum sum rectangle)
• K maximum subarrays
• Maximum product subarray

Tips:
• Handle all-negative arrays correctly (return largest element)
• Can be extended to track indices easily
• Works with any data that can be summed
• Foundation for many optimization problems
`);
```

**Interview Tips:**
- Maximum subarray sum: find contiguous subarray with largest sum
- Kadane's algorithm: optimal O(n) solution with O(1) space
- Key insight: at each position, either extend existing subarray or start new one
- Decision rule: extend if (currentSum + nums[i]) > nums[i], else start fresh
- Equivalently: currentSum = max(nums[i], currentSum + nums[i])
- Track maxSum separately as overall maximum seen so far
- Time: O(n) single pass, Space: O(1) only two variables needed
- Handle all-negative arrays: maxSum initializes to first element, not 0
- Can track indices: when starting fresh, update tempStart; when maxSum updates, record final start/end
- Base case: single element (return that element)
- Divide and conquer: O(n log n), less optimal but shows recursive thinking
- DP interpretation: dp[i] = max sum ending at index i
- Recurrence: dp[i] = max(nums[i], dp[i-1] + nums[i])
- Applications: stock trading profit, sensor anomalies, score streaks, traffic peaks, cash flow
- Edge cases: single element, all positive, all negative, zeros, empty array
- Follow-ups: return indices, circular array, 2D max rectangle, max product, k subarrays
- Common mistakes: initializing maxSum to 0 (fails for all-negative), not handling single element
- Variation: maximum product subarray requires tracking both max and min products
- Optimization: early exit not possible, must scan entire array
- Clarify: return sum or subarray? empty subarray allowed? handle negatives how?
- Interview: explain logic clearly, walk through example, mention O(n) is optimal

</details>

### **Real-World Scenarios**

116. Build a simple virtual DOM implementation

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Virtual DOM with Diffing**
```javascript
/**
 * Simple Virtual DOM implementation
 * Virtual nodes represent DOM structure as plain objects
 */

// Create virtual node
function h(type, props, ...children) {
  return {
    type,
    props: props || {},
    children: children.flat()
  };
}

// Create text node
function createTextNode(text) {
  return {
    type: 'TEXT',
    props: {},
    children: [],
    text
  };
}

// Render virtual node to real DOM
function createElement(vnode) {
  if (vnode.type === 'TEXT') {
    return document.createTextNode(vnode.text);
  }
  
  const el = document.createElement(vnode.type);
  
  // Set properties
  Object.entries(vnode.props).forEach(([key, value]) => {
    setAttribute(el, key, value);
  });
  
  // Append children
  vnode.children.forEach(child => {
    el.appendChild(createElement(child));
  });
  
  return el;
}

// Set attribute helper
function setAttribute(el, key, value) {
  if (key.startsWith('on')) {
    const event = key.substring(2).toLowerCase();
    el.addEventListener(event, value);
  } else if (key === 'className') {
    el.className = value;
  } else if (key === 'style' && typeof value === 'object') {
    Object.assign(el.style, value);
  } else {
    el.setAttribute(key, value);
  }
}

// Test
console.log('=== Basic Virtual DOM ===');

const vdom = h('div', { className: 'container' },
  h('h1', {}, 'Hello Virtual DOM'),
  h('p', {}, 'This is a paragraph')
);

console.log('Virtual DOM:', JSON.stringify(vdom, null, 2));

// Render to DOM (in browser environment)
if (typeof document !== 'undefined') {
  const realDOM = createElement(vdom);
  console.log('Real DOM element:', realDOM);
}
```

### **Approach 2: Diffing Algorithm**
```javascript
/**
 * Diff two virtual DOM trees and apply patches
 */

// Diff types
const PATCH_TYPES = {
  REPLACE: 'REPLACE',
  UPDATE_PROPS: 'UPDATE_PROPS',
  UPDATE_TEXT: 'UPDATE_TEXT',
  REORDER: 'REORDER',
  REMOVE: 'REMOVE'
};

// Diff two vnodes
function diff(oldVNode, newVNode) {
  // New node doesn't exist - remove
  if (!newVNode) {
    return { type: PATCH_TYPES.REMOVE };
  }
  
  // Text nodes
  if (oldVNode.type === 'TEXT' && newVNode.type === 'TEXT') {
    if (oldVNode.text !== newVNode.text) {
      return {
        type: PATCH_TYPES.UPDATE_TEXT,
        text: newVNode.text
      };
    }
    return null;
  }
  
  // Different types - replace
  if (oldVNode.type !== newVNode.type) {
    return {
      type: PATCH_TYPES.REPLACE,
      newVNode
    };
  }
  
  // Same type - check props and children
  const propsDiff = diffProps(oldVNode.props, newVNode.props);
  const childrenDiff = diffChildren(oldVNode.children, newVNode.children);
  
  if (propsDiff || childrenDiff) {
    return {
      type: PATCH_TYPES.UPDATE_PROPS,
      props: propsDiff,
      children: childrenDiff
    };
  }
  
  return null;
}

// Diff props
function diffProps(oldProps, newProps) {
  const patches = {};
  
  // Check for changed/new props
  for (const key in newProps) {
    if (oldProps[key] !== newProps[key]) {
      patches[key] = newProps[key];
    }
  }
  
  // Check for removed props
  for (const key in oldProps) {
    if (!(key in newProps)) {
      patches[key] = null;
    }
  }
  
  return Object.keys(patches).length > 0 ? patches : null;
}

// Diff children
function diffChildren(oldChildren, newChildren) {
  const patches = [];
  const length = Math.max(oldChildren.length, newChildren.length);
  
  for (let i = 0; i < length; i++) {
    patches.push(diff(oldChildren[i], newChildren[i]));
  }
  
  return patches;
}

// Apply patch to real DOM
function patch(el, patches) {
  if (!patches) return el;
  
  switch (patches.type) {
    case PATCH_TYPES.REMOVE:
      el.parentNode.removeChild(el);
      return null;
      
    case PATCH_TYPES.REPLACE:
      const newEl = createElement(patches.newVNode);
      el.parentNode.replaceChild(newEl, el);
      return newEl;
      
    case PATCH_TYPES.UPDATE_TEXT:
      el.textContent = patches.text;
      return el;
      
    case PATCH_TYPES.UPDATE_PROPS:
      if (patches.props) {
        updateProps(el, patches.props);
      }
      if (patches.children) {
        patches.children.forEach((childPatch, i) => {
          patch(el.childNodes[i], childPatch);
        });
      }
      return el;
      
    default:
      return el;
  }
}

// Update props on real DOM element
function updateProps(el, props) {
  Object.entries(props).forEach(([key, value]) => {
    if (value === null) {
      el.removeAttribute(key);
    } else {
      setAttribute(el, key, value);
    }
  });
}

// Test
console.log('\n=== Diffing Algorithm ===');

const oldVNode = h('div', { className: 'old' },
  h('h1', {}, 'Old Title'),
  h('p', {}, 'Old content')
);

const newVNode = h('div', { className: 'new' },
  h('h1', {}, 'New Title'),
  h('p', {}, 'New content'),
  h('span', {}, 'Extra element')
);

const patches = diff(oldVNode, newVNode);
console.log('Patches:', JSON.stringify(patches, null, 2));
```

### **Approach 3: Component-Based Virtual DOM**
```javascript
/**
 * Virtual DOM with component support
 */

class Component {
  constructor(props) {
    this.props = props;
    this.state = {};
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.update();
  }
  
  update() {
    if (this._vnode && this._el) {
      const newVNode = this.render();
      const patches = diff(this._vnode, newVNode);
      this._el = patch(this._el, patches);
      this._vnode = newVNode;
    }
  }
  
  render() {
    throw new Error('Component must implement render()');
  }
}

// Mount component to DOM
function mount(component, container) {
  const vnode = component.render();
  const el = createElement(vnode);
  
  component._vnode = vnode;
  component._el = el;
  
  container.appendChild(el);
  
  return component;
}

// Example component
class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  
  increment() {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return h('div', { className: 'counter' },
      h('h2', {}, `Count: ${this.state.count}`),
      h('button', { 
        onclick: () => this.increment()
      }, 'Increment')
    );
  }
}

console.log('\n=== Component-Based ===');

const counter = new Counter({ initialCount: 0 });
console.log('Counter component:', counter);
console.log('Initial render:', JSON.stringify(counter.render(), null, 2));
```

### **Approach 4: Key-Based Reconciliation**
```javascript
/**
 * Efficient list rendering with keys
 */

function diffChildrenWithKeys(oldChildren, newChildren) {
  const oldKeyed = {};
  const newKeyed = {};
  
  // Build key maps
  oldChildren.forEach((child, i) => {
    const key = child.props?.key ?? i;
    oldKeyed[key] = child;
  });
  
  newChildren.forEach((child, i) => {
    const key = child.props?.key ?? i;
    newKeyed[key] = child;
  });
  
  const patches = [];
  const moves = [];
  
  // Find all keys
  const allKeys = new Set([
    ...Object.keys(oldKeyed),
    ...Object.keys(newKeyed)
  ]);
  
  allKeys.forEach(key => {
    const oldChild = oldKeyed[key];
    const newChild = newKeyed[key];
    
    if (!newChild) {
      // Removed
      patches.push({ type: 'remove', key });
    } else if (!oldChild) {
      // Added
      patches.push({ type: 'add', key, vnode: newChild });
    } else {
      // Updated
      const patch = diff(oldChild, newChild);
      if (patch) {
        patches.push({ type: 'update', key, patch });
      }
    }
  });
  
  // Detect moves
  const oldOrder = oldChildren.map((c, i) => c.props?.key ?? i);
  const newOrder = newChildren.map((c, i) => c.props?.key ?? i);
  
  if (JSON.stringify(oldOrder) !== JSON.stringify(newOrder)) {
    moves.push({ oldOrder, newOrder });
  }
  
  return { patches, moves };
}

// Test
console.log('\n=== Key-Based Reconciliation ===');

const oldList = [
  h('li', { key: 'a' }, 'Item A'),
  h('li', { key: 'b' }, 'Item B'),
  h('li', { key: 'c' }, 'Item C')
];

const newList = [
  h('li', { key: 'b' }, 'Item B'),
  h('li', { key: 'c' }, 'Item C (updated)'),
  h('li', { key: 'd' }, 'Item D')
];

const listDiff = diffChildrenWithKeys(oldList, newList);
console.log('List diff:', JSON.stringify(listDiff, null, 2));
```

### **Approach 5: Complete Virtual DOM Library**
```javascript
/**
 * Full-featured Virtual DOM implementation
 */

class VirtualDOM {
  constructor() {
    this.rootComponent = null;
    this.rootElement = null;
  }
  
  // Create element
  createElement(vnode) {
    if (typeof vnode === 'string' || typeof vnode === 'number') {
      return document.createTextNode(vnode);
    }
    
    if (vnode.type === 'TEXT') {
      return document.createTextNode(vnode.text);
    }
    
    const el = document.createElement(vnode.type);
    
    // Set props
    this.updateProps(el, {}, vnode.props);
    
    // Render children
    (vnode.children || []).forEach(child => {
      el.appendChild(this.createElement(child));
    });
    
    return el;
  }
  
  // Update props
  updateProps(el, oldProps, newProps) {
    // Remove old props
    Object.keys(oldProps).forEach(key => {
      if (!(key in newProps)) {
        this.removeProp(el, key, oldProps[key]);
      }
    });
    
    // Set new props
    Object.keys(newProps).forEach(key => {
      if (oldProps[key] !== newProps[key]) {
        this.setProp(el, key, newProps[key]);
      }
    });
  }
  
  // Set property
  setProp(el, key, value) {
    if (key === 'className') {
      el.className = value;
    } else if (key === 'style') {
      if (typeof value === 'object') {
        Object.assign(el.style, value);
      } else {
        el.style.cssText = value;
      }
    } else if (key.startsWith('on')) {
      const event = key.substring(2).toLowerCase();
      el.addEventListener(event, value);
    } else if (key === 'checked' || key === 'disabled') {
      el[key] = value;
    } else {
      el.setAttribute(key, value);
    }
  }
  
  // Remove property
  removeProp(el, key, value) {
    if (key.startsWith('on')) {
      const event = key.substring(2).toLowerCase();
      el.removeEventListener(event, value);
    } else if (key === 'className') {
      el.className = '';
    } else {
      el.removeAttribute(key);
    }
  }
  
  // Diff and patch
  updateElement(parent, oldVNode, newVNode, index = 0) {
    // No old node - add new
    if (!oldVNode) {
      parent.appendChild(this.createElement(newVNode));
      return;
    }
    
    const el = parent.childNodes[index];
    
    // No new node - remove old
    if (!newVNode) {
      parent.removeChild(el);
      return;
    }
    
    // Different types - replace
    if (this.hasChanged(oldVNode, newVNode)) {
      parent.replaceChild(this.createElement(newVNode), el);
      return;
    }
    
    // Same type - update props and children
    if (newVNode.type && newVNode.type !== 'TEXT') {
      this.updateProps(el, oldVNode.props, newVNode.props);
      
      const oldChildren = oldVNode.children || [];
      const newChildren = newVNode.children || [];
      const maxLength = Math.max(oldChildren.length, newChildren.length);
      
      for (let i = 0; i < maxLength; i++) {
        this.updateElement(el, oldChildren[i], newChildren[i], i);
      }
    }
  }
  
  // Check if nodes changed
  hasChanged(oldVNode, newVNode) {
    // String/number nodes
    if (typeof oldVNode !== typeof newVNode) {
      return true;
    }
    
    if (typeof oldVNode === 'string' || typeof oldVNode === 'number') {
      return oldVNode !== newVNode;
    }
    
    // Different types
    if (oldVNode.type !== newVNode.type) {
      return true;
    }
    
    // Text nodes
    if (oldVNode.type === 'TEXT') {
      return oldVNode.text !== newVNode.text;
    }
    
    return false;
  }
  
  // Render to container
  render(vnode, container) {
    if (!this.rootElement) {
      this.rootElement = this.createElement(vnode);
      container.appendChild(this.rootElement);
    } else {
      this.updateElement(container, this.rootComponent, vnode);
    }
    
    this.rootComponent = vnode;
  }
}

// Test
console.log('\n=== Complete Virtual DOM ===');

const vdom = new VirtualDOM();

// Example app
function createApp(count) {
  return h('div', { className: 'app' },
    h('h1', {}, `Count: ${count}`),
    h('ul', {},
      ...Array.from({ length: count }, (_, i) => 
        h('li', { key: i }, `Item ${i + 1}`)
      )
    )
  );
}

console.log('App with count 3:', JSON.stringify(createApp(3), null, 2));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Simple UI Framework
console.log('\n=== UI Framework ===');

class UIFramework {
  constructor() {
    this.vdom = new VirtualDOM();
    this.currentTree = null;
    this.container = null;
  }
  
  createComponent(render, initialState = {}) {
    const component = {
      state: initialState,
      
      setState(newState) {
        this.state = { ...this.state, ...newState };
        component.update();
      },
      
      update() {
        if (!component.container) return;
        
        const newTree = render(component.state);
        this.vdom.updateElement(
          component.container,
          component.currentTree,
          newTree,
          0
        );
        component.currentTree = newTree;
      },
      
      mount(container) {
        component.container = container;
        component.currentTree = render(component.state);
        container.innerHTML = '';
        this.vdom.render(component.currentTree, container);
      }
    };
    
    return component;
  }
}

const framework = new UIFramework();

// Example: Todo app component
const todoApp = framework.createComponent(
  (state) => {
    return h('div', { className: 'todo-app' },
      h('h1', {}, 'Todo List'),
      h('ul', {},
        ...state.todos.map((todo, i) =>
          h('li', { key: i }, todo)
        )
      ),
      h('p', {}, `Total: ${state.todos.length}`)
    );
  },
  { todos: ['Learn Virtual DOM', 'Build app'] }
);

console.log('Todo app created:', todoApp);

// 2. Form Management
console.log('\n=== Form Management ===');

class FormManager {
  constructor() {
    this.vdom = new VirtualDOM();
  }
  
  createForm(fields, onSubmit) {
    const state = {};
    fields.forEach(field => {
      state[field.name] = field.defaultValue || '';
    });
    
    return {
      state,
      
      handleChange(name, value) {
        state[name] = value;
        this.render();
      },
      
      handleSubmit() {
        onSubmit(state);
      },
      
      render() {
        return h('form', { 
          onsubmit: (e) => {
            e.preventDefault();
            this.handleSubmit();
          }
        },
          ...fields.map(field =>
            h('div', { className: 'form-group' },
              h('label', {}, field.label),
              h('input', {
                type: field.type || 'text',
                name: field.name,
                value: state[field.name],
                oninput: (e) => this.handleChange(field.name, e.target.value)
              })
            )
          ),
          h('button', { type: 'submit' }, 'Submit')
        );
      }
    };
  }
}

const formManager = new FormManager();
const loginForm = formManager.createForm(
  [
    { name: 'username', label: 'Username' },
    { name: 'password', label: 'Password', type: 'password' }
  ],
  (data) => console.log('Form submitted:', data)
);

console.log('Login form:', loginForm);

// 3. List Virtualization
console.log('\n=== List Virtualization ===');

class VirtualList {
  constructor(items, itemHeight, viewportHeight) {
    this.items = items;
    this.itemHeight = itemHeight;
    this.viewportHeight = viewportHeight;
    this.scrollTop = 0;
  }
  
  getVisibleRange() {
    const start = Math.floor(this.scrollTop / this.itemHeight);
    const visibleCount = Math.ceil(this.viewportHeight / this.itemHeight);
    const end = Math.min(start + visibleCount, this.items.length);
    
    return { start, end };
  }
  
  render() {
    const { start, end } = this.getVisibleRange();
    const visibleItems = this.items.slice(start, end);
    
    const offsetY = start * this.itemHeight;
    const totalHeight = this.items.length * this.itemHeight;
    
    return h('div', {
      className: 'virtual-list',
      style: {
        height: `${this.viewportHeight}px`,
        overflow: 'auto'
      },
      onscroll: (e) => {
        this.scrollTop = e.target.scrollTop;
        this.update();
      }
    },
      h('div', {
        style: {
          height: `${totalHeight}px`,
          position: 'relative'
        }
      },
        h('div', {
          style: {
            transform: `translateY(${offsetY}px)`
          }
        },
          ...visibleItems.map((item, i) =>
            h('div', {
              key: start + i,
              style: { height: `${this.itemHeight}px` }
            }, item)
          )
        )
      )
    );
  }
}

const bigList = new VirtualList(
  Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`),
  30,
  300
);

console.log('Virtual list (10000 items):', bigList.getVisibleRange());

// 4. Animation System
console.log('\n=== Animation System ===');

class AnimationManager {
  constructor(vdom) {
    this.vdom = vdom;
    this.animations = new Map();
  }
  
  animate(key, from, to, duration, easing = 'linear') {
    const startTime = Date.now();
    
    const easingFunctions = {
      linear: t => t,
      easeIn: t => t * t,
      easeOut: t => t * (2 - t),
      easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
    };
    
    const ease = easingFunctions[easing];
    
    const update = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const eased = ease(progress);
      
      const current = from + (to - from) * eased;
      
      if (progress < 1) {
        this.animations.set(key, current);
        requestAnimationFrame(update);
      } else {
        this.animations.delete(key);
      }
      
      this.render();
    };
    
    update();
  }
  
  render() {
    return h('div', {},
      ...Array.from(this.animations.entries()).map(([key, value]) =>
        h('div', {
          key,
          style: {
            transform: `translateX(${value}px)`,
            transition: 'transform 0.016s'
          }
        }, `Animation ${key}: ${value.toFixed(0)}px`)
      )
    );
  }
}

const animManager = new AnimationManager();
console.log('Animation manager created');

// 5. Router with Virtual DOM
console.log('\n=== Router ===');

class Router {
  constructor(routes) {
    this.routes = routes;
    this.currentRoute = '/';
    
    window.addEventListener('popstate', () => {
      this.currentRoute = window.location.pathname;
      this.render();
    });
  }
  
  navigate(path) {
    this.currentRoute = path;
    window.history.pushState({}, '', path);
    this.render();
  }
  
  render() {
    const route = this.routes[this.currentRoute] || this.routes['/404'];
    
    return h('div', { className: 'app' },
      h('nav', {},
        ...Object.keys(this.routes).map(path =>
          h('a', {
            href: path,
            onclick: (e) => {
              e.preventDefault();
              this.navigate(path);
            }
          }, path)
        )
      ),
      h('main', {}, route())
    );
  }
}

const router = new Router({
  '/': () => h('h1', {}, 'Home Page'),
  '/about': () => h('h1', {}, 'About Page'),
  '/contact': () => h('h1', {}, 'Contact Page'),
  '/404': () => h('h1', {}, 'Not Found')
});

console.log('Router with 4 routes created');
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Virtual DOM Benefits:
┌────────────────────────┬──────────────────────────────────┐
│ Aspect                 │ Benefit                          │
├────────────────────────┼──────────────────────────────────┤
│ Performance            │ Batches DOM updates, minimizes   │
│                        │ reflows/repaints                 │
├────────────────────────┼──────────────────────────────────┤
│ Declarative            │ Describe what UI should look like│
│                        │ not how to change it             │
├────────────────────────┼──────────────────────────────────┤
│ Abstraction            │ Platform-agnostic (works on      │
│                        │ server, mobile, canvas)          │
├────────────────────────┼──────────────────────────────────┤
│ Testability            │ Easy to test without real DOM    │
├────────────────────────┼──────────────────────────────────┤
│ Time Travel            │ Can store/replay states          │
└────────────────────────┴──────────────────────────────────┘

Key Concepts:
• Virtual DOM: lightweight JS representation of real DOM
• Reconciliation: process of comparing old and new virtual trees
• Diffing: algorithm to find minimal set of changes
• Patching: applying changes to real DOM
• Keys: help identify which items changed/moved/removed

Diffing Algorithm Steps:
1. Compare node types
2. If different → replace entire subtree
3. If same → compare props
4. Recursively diff children
5. Generate patch operations

Common Optimizations:
• Key-based reconciliation for lists
• Shallow comparison for props
• Batching multiple updates
• Fiber architecture (incremental rendering)
• Memoization of unchanged subtrees

Real-World Uses:
• React, Preact, Vue use virtual DOM
• Server-side rendering
• Mobile apps (React Native)
• Canvas/WebGL rendering
• Testing without browser

Limitations:
• Memory overhead for virtual tree
• Not always faster for simple updates
• Learning curve for developers
• Debugging can be harder
`);
```

**Interview Tips:**
- Virtual DOM: lightweight JavaScript representation of real DOM tree
- Purpose: minimize expensive DOM operations by batching and optimizing updates
- Core concepts: virtual nodes (vnodes), diffing algorithm, patching
- VNode structure: { type, props, children } - plain JavaScript object
- Diffing: compare old and new virtual trees to find minimal changes
- Reconciliation: process of updating real DOM based on diff
- Three main operations: create (add new), update (modify), remove (delete)
- Key optimization: use "key" prop to track list items across renders
- Keys help identify which items moved, added, or removed in lists
- Diffing algorithm: O(n) with heuristics vs O(n³) naive tree diff
- Heuristics: same level comparison, different types = replace subtree
- Benefits: declarative UI, batched updates, cross-platform, testable
- Trade-offs: memory for virtual tree, not always faster for simple DOM updates
- createElement: converts vnode to real DOM element
- patch: applies diff results to real DOM
- Used by: React, Vue, Preact, Inferno
- Component pattern: encapsulate state and render logic
- Lifecycle: mount (initial render), update (re-render), unmount (cleanup)
- Follow-ups: fiber architecture, concurrent rendering, SSR, fragments
- Clarify: support JSX? handle events? component lifecycle? state management?

</details>

117. Implement a reactive state management system (like Redux)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Store with Reducers**
```javascript
/**
 * Simple Redux-like store implementation
 */

function createStore(reducer, initialState) {
  let state = initialState;
  const listeners = [];
  
  const getState = () => state;
  
  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach(listener => listener());
    return action;
  };
  
  const subscribe = (listener) => {
    listeners.push(listener);
    
    // Return unsubscribe function
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  };
  
  // Initialize state
  dispatch({ type: '@@INIT' });
  
  return { getState, dispatch, subscribe };
}

// Test
console.log('=== Basic Store ===');

// Counter reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET':
      return { ...state, count: action.payload };
    default:
      return state;
  }
}

const store = createStore(counterReducer);

const unsubscribe = store.subscribe(() => {
  console.log('State changed:', store.getState());
});

store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'DECREMENT' });
store.dispatch({ type: 'SET', payload: 10 });

unsubscribe();
```

### **Approach 2: Middleware Support**
```javascript
/**
 * Add middleware support for async actions, logging, etc.
 */

function applyMiddleware(...middlewares) {
  return (createStore) => (reducer, initialState) => {
    const store = createStore(reducer, initialState);
    let dispatch = store.dispatch;
    
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action) => dispatch(action)
    };
    
    const chain = middlewares.map(middleware => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    
    return { ...store, dispatch };
  };
}

function compose(...funcs) {
  if (funcs.length === 0) return arg => arg;
  if (funcs.length === 1) return funcs[0];
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}

// Logger middleware
const logger = (store) => (next) => (action) => {
  console.log('Dispatching:', action);
  console.log('Previous state:', store.getState());
  
  const result = next(action);
  
  console.log('Next state:', store.getState());
  return result;
};

// Thunk middleware for async actions
const thunk = (store) => (next) => (action) => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

// Test
console.log('\n=== Middleware Support ===');

const enhancedCreateStore = applyMiddleware(logger, thunk)(createStore);
const storeWithMiddleware = enhancedCreateStore(counterReducer);

storeWithMiddleware.dispatch({ type: 'INCREMENT' });

// Async action
const incrementAsync = (delay) => (dispatch, getState) => {
  setTimeout(() => {
    dispatch({ type: 'INCREMENT' });
    console.log('Async increment completed');
  }, delay);
};

storeWithMiddleware.dispatch(incrementAsync(100));
```

### **Approach 3: Combine Reducers**
```javascript
/**
 * Combine multiple reducers into one
 */

function combineReducers(reducers) {
  return (state = {}, action) => {
    const nextState = {};
    let hasChanged = false;
    
    for (const key in reducers) {
      const reducer = reducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    
    return hasChanged ? nextState : state;
  };
}

// Test
console.log('\n=== Combine Reducers ===');

// Todo reducer
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.payload, done: false }];
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, done: !todo.done }
          : todo
      );
    case 'REMOVE_TODO':
      return state.filter(todo => todo.id !== action.payload);
    default:
      return state;
  }
}

// User reducer
function userReducer(state = { name: '', isLoggedIn: false }, action) {
  switch (action.type) {
    case 'LOGIN':
      return { name: action.payload, isLoggedIn: true };
    case 'LOGOUT':
      return { name: '', isLoggedIn: false };
    default:
      return state;
  }
}

const rootReducer = combineReducers({
  counter: counterReducer,
  todos: todosReducer,
  user: userReducer
});

const appStore = createStore(rootReducer);

appStore.subscribe(() => {
  console.log('App state:', appStore.getState());
});

appStore.dispatch({ type: 'INCREMENT' });
appStore.dispatch({ type: 'ADD_TODO', payload: 'Learn Redux' });
appStore.dispatch({ type: 'LOGIN', payload: 'John' });
```

### **Approach 4: Selectors and Memoization**
```javascript
/**
 * Efficient state selection with memoization
 */

function createSelector(...inputSelectors) {
  const resultFunc = inputSelectors.pop();
  let lastArgs = null;
  let lastResult = null;
  
  return (state) => {
    const args = inputSelectors.map(selector => selector(state));
    
    if (lastArgs && args.every((arg, i) => arg === lastArgs[i])) {
      return lastResult;
    }
    
    lastArgs = args;
    lastResult = resultFunc(...args);
    return lastResult;
  };
}

// Test
console.log('\n=== Selectors ===');

// Basic selectors
const getTodos = (state) => state.todos;
const getUser = (state) => state.user;

// Memoized selectors
const getCompletedTodos = createSelector(
  getTodos,
  (todos) => {
    console.log('Computing completed todos...');
    return todos.filter(todo => todo.done);
  }
);

const getTodoStats = createSelector(
  getTodos,
  (todos) => ({
    total: todos.length,
    completed: todos.filter(t => t.done).length,
    pending: todos.filter(t => !t.done).length
  })
);

const state = {
  todos: [
    { id: 1, text: 'Task 1', done: true },
    { id: 2, text: 'Task 2', done: false },
    { id: 3, text: 'Task 3', done: true }
  ],
  user: { name: 'John', isLoggedIn: true }
};

console.log('Completed todos:', getCompletedTodos(state));
console.log('Todo stats:', getTodoStats(state));
console.log('Completed todos (cached):', getCompletedTodos(state));
```

### **Approach 5: Observable Store with RxJS-like API**
```javascript
/**
 * Reactive store using observables
 */

class Observable {
  constructor(subscribe) {
    this._subscribe = subscribe;
  }
  
  subscribe(observer) {
    return this._subscribe(observer);
  }
  
  map(fn) {
    return new Observable(observer => {
      return this.subscribe({
        next: value => observer.next(fn(value)),
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
  
  filter(predicate) {
    return new Observable(observer => {
      return this.subscribe({
        next: value => predicate(value) && observer.next(value),
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
}

class ObservableStore {
  constructor(reducer, initialState) {
    this.state = initialState;
    this.reducer = reducer;
    this.observers = [];
  }
  
  dispatch(action) {
    const previousState = this.state;
    this.state = this.reducer(this.state, action);
    
    if (this.state !== previousState) {
      this.observers.forEach(observer => {
        observer.next(this.state);
      });
    }
    
    return action;
  }
  
  select(selector) {
    return new Observable(observer => {
      const listener = (state) => {
        observer.next(selector(state));
      };
      
      // Emit current value
      listener(this.state);
      
      // Subscribe to changes
      this.observers.push({ next: listener });
      
      // Return unsubscribe
      return () => {
        const index = this.observers.findIndex(obs => obs.next === listener);
        if (index > -1) {
          this.observers.splice(index, 1);
        }
      };
    });
  }
  
  getState() {
    return this.state;
  }
}

// Test
console.log('\n=== Observable Store ===');

const observableStore = new ObservableStore(counterReducer, { count: 0 });

observableStore.select(state => state.count)
  .filter(count => count % 2 === 0)
  .subscribe({
    next: count => console.log('Even count:', count)
  });

observableStore.dispatch({ type: 'INCREMENT' }); // 1 (not logged)
observableStore.dispatch({ type: 'INCREMENT' }); // 2 (logged)
observableStore.dispatch({ type: 'INCREMENT' }); // 3 (not logged)
observableStore.dispatch({ type: 'INCREMENT' }); // 4 (logged)
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Shopping Cart
console.log('\n=== Shopping Cart ===');

const cartReducer = (state = { items: [], total: 0 }, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      const existingItem = state.items.find(item => item.id === action.payload.id);
      
      if (existingItem) {
        return {
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
          total: state.total + action.payload.price
        };
      }
      
      return {
        items: [...state.items, { ...action.payload, quantity: 1 }],
        total: state.total + action.payload.price
      };
      
    case 'REMOVE_ITEM':
      const item = state.items.find(item => item.id === action.payload);
      return {
        items: state.items.filter(item => item.id !== action.payload),
        total: state.total - (item.price * item.quantity)
      };
      
    case 'CLEAR_CART':
      return { items: [], total: 0 };
      
    default:
      return state;
  }
};

const cartStore = createStore(cartReducer);

cartStore.subscribe(() => {
  const state = cartStore.getState();
  console.log(`Cart: ${state.items.length} items, Total: $${state.total.toFixed(2)}`);
});

cartStore.dispatch({ type: 'ADD_ITEM', payload: { id: 1, name: 'Book', price: 19.99 } });
cartStore.dispatch({ type: 'ADD_ITEM', payload: { id: 2, name: 'Pen', price: 2.99 } });
cartStore.dispatch({ type: 'ADD_ITEM', payload: { id: 1, name: 'Book', price: 19.99 } });

// 2. Form State Management
console.log('\n=== Form Management ===');

const formReducer = (state = { fields: {}, errors: {}, isValid: true }, action) => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        fields: {
          ...state.fields,
          [action.payload.name]: action.payload.value
        }
      };
      
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.payload.field]: action.payload.message
        },
        isValid: false
      };
      
    case 'CLEAR_ERRORS':
      return {
        ...state,
        errors: {},
        isValid: true
      };
      
    case 'RESET_FORM':
      return { fields: {}, errors: {}, isValid: true };
      
    default:
      return state;
  }
};

const formStore = createStore(formReducer);

formStore.dispatch({ type: 'SET_FIELD', payload: { name: 'email', value: 'user@example.com' } });
formStore.dispatch({ type: 'SET_FIELD', payload: { name: 'password', value: '12345' } });
formStore.dispatch({ type: 'SET_ERROR', payload: { field: 'password', message: 'Password too short' } });

console.log('Form state:', formStore.getState());

// 3. Undo/Redo
console.log('\n=== Undo/Redo ===');

function undoable(reducer) {
  const initialState = {
    past: [],
    present: reducer(undefined, { type: '@@INIT' }),
    future: []
  };
  
  return (state = initialState, action) => {
    const { past, present, future } = state;
    
    switch (action.type) {
      case 'UNDO':
        if (past.length === 0) return state;
        
        return {
          past: past.slice(0, -1),
          present: past[past.length - 1],
          future: [present, ...future]
        };
        
      case 'REDO':
        if (future.length === 0) return state;
        
        return {
          past: [...past, present],
          present: future[0],
          future: future.slice(1)
        };
        
      default:
        const newPresent = reducer(present, action);
        
        if (present === newPresent) return state;
        
        return {
          past: [...past, present],
          present: newPresent,
          future: []
        };
    }
  };
}

const undoableCounter = undoable(counterReducer);
const undoStore = createStore(undoableCounter);

undoStore.subscribe(() => {
  const state = undoStore.getState();
  console.log('Count:', state.present.count, `(${state.past.length} undo, ${state.future.length} redo)`);
});

undoStore.dispatch({ type: 'INCREMENT' });
undoStore.dispatch({ type: 'INCREMENT' });
undoStore.dispatch({ type: 'INCREMENT' });
undoStore.dispatch({ type: 'UNDO' });
undoStore.dispatch({ type: 'UNDO' });
undoStore.dispatch({ type: 'REDO' });

// 4. WebSocket Integration
console.log('\n=== WebSocket Integration ===');

const wsMiddleware = (url) => (store) => (next) => (action) => {
  if (action.type === 'WS_CONNECT') {
    const ws = new WebSocket(url);
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      store.dispatch({ type: 'WS_MESSAGE', payload: data });
    };
    
    ws.onopen = () => {
      store.dispatch({ type: 'WS_CONNECTED' });
    };
    
    ws.onclose = () => {
      store.dispatch({ type: 'WS_DISCONNECTED' });
    };
    
    // Store WebSocket instance
    store.ws = ws;
  }
  
  if (action.type === 'WS_SEND' && store.ws) {
    store.ws.send(JSON.stringify(action.payload));
  }
  
  return next(action);
};

// Example usage (won't actually connect)
console.log('WebSocket middleware configured');

// 5. Persistence
console.log('\n=== Persistence ===');

const persistMiddleware = (key) => (store) => (next) => (action) => {
  const result = next(action);
  
  // Save to localStorage
  try {
    const state = store.getState();
    localStorage.setItem(key, JSON.stringify(state));
  } catch (e) {
    console.warn('Failed to persist state:', e);
  }
  
  return result;
};

function loadPersistedState(key) {
  try {
    const serialized = localStorage.getItem(key);
    return serialized ? JSON.parse(serialized) : undefined;
  } catch (e) {
    console.warn('Failed to load state:', e);
    return undefined;
  }
}

// Usage example
const persistedState = loadPersistedState('app-state');
console.log('Loaded persisted state:', persistedState);
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
State Management Patterns:
┌─────────────────────┬────────────────────────────────────┐
│ Pattern             │ Characteristics                    │
├─────────────────────┼────────────────────────────────────┤
│ Redux               │ Single store, reducers, actions    │
│                     │ Predictable, time-travel debugging │
├─────────────────────┼────────────────────────────────────┤
│ MobX                │ Observable state, automatic updates│
│                     │ Less boilerplate, reactive         │
├─────────────────────┼────────────────────────────────────┤
│ Zustand             │ Hooks-based, simple API            │
│                     │ No providers, minimal boilerplate  │
├─────────────────────┼────────────────────────────────────┤
│ Recoil              │ Atomic state, derived state        │
│                     │ React-specific, fine-grained       │
└─────────────────────┴────────────────────────────────────┘

Redux Principles:
1. Single source of truth (one store)
2. State is read-only (only changed via actions)
3. Changes made with pure functions (reducers)

Core Concepts:
• Store: holds application state
• Actions: plain objects describing what happened
• Reducers: pure functions (state, action) => newState
• Dispatch: send action to store
• Subscribe: listen for state changes

Middleware:
• Sits between dispatch and reducer
• Can modify, delay, or cancel actions
• Use cases: logging, async, routing, crash reporting
• Signature: store => next => action => result

Best Practices:
• Keep reducers pure (no side effects)
• Normalize state shape (flat, not nested)
• Use selectors for derived data
• Memoize expensive selectors
• Split reducers by domain
• Use action creators for consistency
• Add TypeScript for type safety

Common Patterns:
• Async actions with thunks
• Normalized state with entities
• Optimistic updates
• Undo/redo with history
• Persistence to localStorage
• DevTools integration

Performance:
• Shallow comparison for changes
• Reselect for memoized selectors
• Immutable updates (spread, Object.assign)
• Batch updates when possible
• Normalize to avoid deep nesting
`);
```

**Interview Tips:**
- State management: centralized store for application state
- Redux pattern: single store, actions, reducers, unidirectional data flow
- Store: holds state, provides getState(), dispatch(), subscribe()
- Actions: plain objects with "type" property describing what happened
- Reducers: pure functions (state, action) => newState, no side effects
- Dispatch: send action to store, triggers reducer, notifies subscribers
- Immutability: never mutate state directly, always return new objects
- Middleware: intercept actions before they reach reducer
- Middleware signature: store => next => action => result
- Common middleware: thunk (async), logger, router, persistence
- Thunk: dispatch functions instead of objects for async operations
- CombineReducers: merge multiple reducers into single root reducer
- Selectors: functions that extract/compute derived state
- Memoization: cache selector results to avoid recomputation
- Three principles: single source of truth, read-only state, pure reducers
- Benefits: predictable state, time-travel debugging, testable, devtools
- Alternatives: MobX (observable), Zustand (hooks), Recoil (atomic), Context API
- Use cases: complex state, multiple components sharing data, state history
- Trade-offs: boilerplate code, learning curve, overkill for simple apps
- Follow-ups: async actions, normalization, performance, devtools integration
- Clarify: sync or async? middleware? persistence? multiple stores? TypeScript?

</details>

118. Create a dependency injection container

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Dependency Injection Container**
```javascript
/**
 * Simple DI container with register and resolve
 */

class DIContainer {
  constructor() {
    this.services = new Map();
  }
  
  register(name, definition, dependencies = []) {
    this.services.set(name, {
      definition,
      dependencies,
      instance: null,
      singleton: false
    });
  }
  
  registerSingleton(name, definition, dependencies = []) {
    this.services.set(name, {
      definition,
      dependencies,
      instance: null,
      singleton: true
    });
  }
  
  resolve(name) {
    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service '${name}' not found`);
    }
    
    // Return existing singleton instance
    if (service.singleton && service.instance) {
      return service.instance;
    }
    
    // Resolve dependencies
    const dependencies = service.dependencies.map(dep => this.resolve(dep));
    
    // Create instance
    const instance = typeof service.definition === 'function'
      ? new service.definition(...dependencies)
      : service.definition;
    
    // Store singleton instance
    if (service.singleton) {
      service.instance = instance;
    }
    
    return instance;
  }
}

// Test
console.log('=== Basic DI Container ===');

class Database {
  constructor() {
    this.connection = 'Connected to DB';
  }
  
  query(sql) {
    return `Executing: ${sql}`;
  }
}

class UserRepository {
  constructor(database) {
    this.db = database;
  }
  
  findAll() {
    return this.db.query('SELECT * FROM users');
  }
}

class UserService {
  constructor(userRepository) {
    this.repository = userRepository;
  }
  
  getUsers() {
    return this.repository.findAll();
  }
}

const container = new DIContainer();

container.registerSingleton('database', Database);
container.register('userRepository', UserRepository, ['database']);
container.register('userService', UserService, ['userRepository']);

const userService = container.resolve('userService');
console.log(userService.getUsers());

// Verify singleton
const db1 = container.resolve('database');
const db2 = container.resolve('database');
console.log('Same instance:', db1 === db2); // true
```

### **Approach 2: Factory and Value Registration**
```javascript
/**
 * Support different registration types: class, factory, value
 */

class AdvancedDIContainer {
  constructor() {
    this.services = new Map();
  }
  
  // Register a class
  registerClass(name, Class, dependencies = [], options = {}) {
    this.services.set(name, {
      type: 'class',
      definition: Class,
      dependencies,
      singleton: options.singleton || false,
      instance: null
    });
    return this;
  }
  
  // Register a factory function
  registerFactory(name, factory, dependencies = [], options = {}) {
    this.services.set(name, {
      type: 'factory',
      definition: factory,
      dependencies,
      singleton: options.singleton || false,
      instance: null
    });
    return this;
  }
  
  // Register a value
  registerValue(name, value) {
    this.services.set(name, {
      type: 'value',
      definition: value,
      dependencies: [],
      singleton: true,
      instance: value
    });
    return this;
  }
  
  resolve(name) {
    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service '${name}' not found`);
    }
    
    // Return cached singleton
    if (service.singleton && service.instance !== null) {
      return service.instance;
    }
    
    // Resolve dependencies
    const deps = service.dependencies.map(dep => this.resolve(dep));
    
    let instance;
    
    switch (service.type) {
      case 'class':
        instance = new service.definition(...deps);
        break;
        
      case 'factory':
        instance = service.definition(...deps);
        break;
        
      case 'value':
        instance = service.definition;
        break;
        
      default:
        throw new Error(`Unknown service type: ${service.type}`);
    }
    
    if (service.singleton) {
      service.instance = instance;
    }
    
    return instance;
  }
  
  has(name) {
    return this.services.has(name);
  }
  
  clear() {
    this.services.clear();
  }
}

// Test
console.log('\n=== Factory and Value Registration ===');

const container2 = new AdvancedDIContainer();

// Register config value
container2.registerValue('config', {
  apiUrl: 'https://api.example.com',
  timeout: 5000
});

// Register factory
container2.registerFactory(
  'httpClient',
  (config) => {
    return {
      get: (url) => `GET ${config.apiUrl}${url}`,
      post: (url, data) => `POST ${config.apiUrl}${url} with ${JSON.stringify(data)}`
    };
  },
  ['config'],
  { singleton: true }
);

// Register class
class ApiService {
  constructor(httpClient, config) {
    this.http = httpClient;
    this.config = config;
  }
  
  fetchUsers() {
    return this.http.get('/users');
  }
}

container2.registerClass('apiService', ApiService, ['httpClient', 'config']);

const apiService = container2.resolve('apiService');
console.log(apiService.fetchUsers());
```

### **Approach 3: Auto-Wiring with Decorators**
```javascript
/**
 * Automatic dependency injection using decorators
 */

// Decorator metadata storage
const metadata = new WeakMap();

// Injectable decorator
function Injectable(dependencies = []) {
  return function(target) {
    metadata.set(target, { dependencies });
    return target;
  };
}

// Inject decorator for properties
function Inject(serviceName) {
  return function(target, propertyKey) {
    if (!metadata.has(target.constructor)) {
      metadata.set(target.constructor, { dependencies: [] });
    }
    
    const meta = metadata.get(target.constructor);
    meta.propertyInjections = meta.propertyInjections || [];
    meta.propertyInjections.push({ propertyKey, serviceName });
  };
}

class AutoWiringContainer {
  constructor() {
    this.services = new Map();
    this.instances = new Map();
  }
  
  register(name, Class, options = {}) {
    const meta = metadata.get(Class) || { dependencies: [] };
    
    this.services.set(name, {
      Class,
      dependencies: meta.dependencies || [],
      propertyInjections: meta.propertyInjections || [],
      singleton: options.singleton !== false,
      instance: null
    });
    
    return this;
  }
  
  resolve(name) {
    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service '${name}' not found`);
    }
    
    // Return singleton
    if (service.singleton && service.instance) {
      return service.instance;
    }
    
    // Resolve constructor dependencies
    const deps = service.dependencies.map(dep => this.resolve(dep));
    
    // Create instance
    const instance = new service.Class(...deps);
    
    // Inject properties
    service.propertyInjections.forEach(({ propertyKey, serviceName }) => {
      instance[propertyKey] = this.resolve(serviceName);
    });
    
    if (service.singleton) {
      service.instance = instance;
    }
    
    return instance;
  }
}

// Test
console.log('\n=== Auto-Wiring ===');

@Injectable([])
class Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

@Injectable(['logger'])
class DataService {
  constructor(logger) {
    this.logger = logger;
    this.data = [];
  }
  
  add(item) {
    this.logger.log(`Adding item: ${item}`);
    this.data.push(item);
  }
}

const autoContainer = new AutoWiringContainer();
autoContainer.register('logger', Logger);
autoContainer.register('dataService', DataService);

const dataService = autoContainer.resolve('dataService');
dataService.add('test item');
```

### **Approach 4: Scoped Containers**
```javascript
/**
 * Support different scopes: singleton, transient, scoped
 */

const Lifetime = {
  SINGLETON: 'singleton',
  TRANSIENT: 'transient',
  SCOPED: 'scoped'
};

class ScopedContainer {
  constructor(parent = null) {
    this.parent = parent;
    this.services = new Map();
    this.instances = new Map();
    this.scopes = new Map();
  }
  
  register(name, definition, dependencies = [], lifetime = Lifetime.TRANSIENT) {
    this.services.set(name, {
      definition,
      dependencies,
      lifetime
    });
    return this;
  }
  
  resolve(name) {
    // Check scoped instances first
    if (this.instances.has(name)) {
      return this.instances.get(name);
    }
    
    const service = this.services.get(name) || 
                   (this.parent && this.parent.services.get(name));
    
    if (!service) {
      throw new Error(`Service '${name}' not found`);
    }
    
    // Check for singleton in root
    if (service.lifetime === Lifetime.SINGLETON) {
      const root = this.getRoot();
      
      if (root.instances.has(name)) {
        return root.instances.get(name);
      }
      
      const instance = this.createInstance(service);
      root.instances.set(name, instance);
      return instance;
    }
    
    // Scoped - cache in current scope
    if (service.lifetime === Lifetime.SCOPED) {
      const instance = this.createInstance(service);
      this.instances.set(name, instance);
      return instance;
    }
    
    // Transient - always create new
    return this.createInstance(service);
  }
  
  createInstance(service) {
    const deps = service.dependencies.map(dep => this.resolve(dep));
    
    return typeof service.definition === 'function'
      ? new service.definition(...deps)
      : service.definition;
  }
  
  createScope() {
    return new ScopedContainer(this);
  }
  
  getRoot() {
    let root = this;
    while (root.parent) {
      root = root.parent;
    }
    return root;
  }
  
  dispose() {
    this.instances.clear();
  }
}

// Test
console.log('\n=== Scoped Containers ===');

class RequestId {
  constructor() {
    this.id = Math.random().toString(36).substr(2, 9);
  }
}

class RequestLogger {
  constructor(requestId) {
    this.requestId = requestId;
  }
  
  log(message) {
    console.log(`[${this.requestId.id}] ${message}`);
  }
}

const rootContainer = new ScopedContainer();
rootContainer.register('requestId', RequestId, [], Lifetime.SCOPED);
rootContainer.register('logger', RequestLogger, ['requestId'], Lifetime.SCOPED);

// Simulate two requests
const scope1 = rootContainer.createScope();
const logger1 = scope1.resolve('logger');
logger1.log('Request 1 - Action 1');
logger1.log('Request 1 - Action 2');

const scope2 = rootContainer.createScope();
const logger2 = scope2.resolve('logger');
logger2.log('Request 2 - Action 1');
logger2.log('Request 2 - Action 2');

console.log('Different scopes:', logger1.requestId !== logger2.requestId);
```

### **Approach 5: Circular Dependency Detection**
```javascript
/**
 * Detect and handle circular dependencies
 */

class SafeDIContainer {
  constructor() {
    this.services = new Map();
    this.resolving = new Set();
  }
  
  register(name, definition, dependencies = []) {
    this.services.set(name, { definition, dependencies, instance: null });
    return this;
  }
  
  resolve(name) {
    // Check for circular dependency
    if (this.resolving.has(name)) {
      const chain = Array.from(this.resolving).join(' -> ');
      throw new Error(`Circular dependency detected: ${chain} -> ${name}`);
    }
    
    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service '${name}' not found`);
    }
    
    if (service.instance) {
      return service.instance;
    }
    
    // Mark as resolving
    this.resolving.add(name);
    
    try {
      // Resolve dependencies
      const deps = service.dependencies.map(dep => this.resolve(dep));
      
      // Create instance
      const instance = new service.definition(...deps);
      service.instance = instance;
      
      return instance;
    } finally {
      // Remove from resolving
      this.resolving.delete(name);
    }
  }
  
  // Validate all registrations
  validate() {
    const errors = [];
    
    for (const [name, service] of this.services) {
      for (const dep of service.dependencies) {
        if (!this.services.has(dep)) {
          errors.push(`Service '${name}' depends on '${dep}' which is not registered`);
        }
      }
    }
    
    // Try to resolve all to detect circular dependencies
    for (const name of this.services.keys()) {
      try {
        this.resolve(name);
      } catch (error) {
        errors.push(error.message);
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
}

// Test
console.log('\n=== Circular Dependency Detection ===');

class ServiceA {
  constructor(serviceB) {
    this.serviceB = serviceB;
  }
}

class ServiceB {
  constructor(serviceC) {
    this.serviceC = serviceC;
  }
}

class ServiceC {
  constructor() {
    this.name = 'ServiceC';
  }
}

const safeContainer = new SafeDIContainer();
safeContainer.register('serviceA', ServiceA, ['serviceB']);
safeContainer.register('serviceB', ServiceB, ['serviceC']);
safeContainer.register('serviceC', ServiceC, []);

console.log('Valid setup:', safeContainer.validate());

// Try circular dependency
const circularContainer = new SafeDIContainer();
circularContainer.register('serviceA', ServiceA, ['serviceB']);
circularContainer.register('serviceB', ServiceB, ['serviceA']); // Circular!

try {
  circularContainer.resolve('serviceA');
} catch (error) {
  console.log('Caught circular dependency:', error.message);
}
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Express.js-like Middleware
console.log('\n=== Express Middleware ===');

class Application {
  constructor(container) {
    this.container = container;
    this.middlewares = [];
  }
  
  use(middleware) {
    this.middlewares.push(middleware);
  }
  
  handle(req, res) {
    let index = 0;
    
    const next = () => {
      if (index >= this.middlewares.length) return;
      
      const middleware = this.middlewares[index++];
      
      // Resolve dependencies for middleware
      const deps = middleware.dependencies || [];
      const resolvedDeps = deps.map(dep => this.container.resolve(dep));
      
      middleware.handler(req, res, next, ...resolvedDeps);
    };
    
    next();
  }
}

const appContainer = new AdvancedDIContainer();

appContainer.registerValue('logger', {
  log: (msg) => console.log(`[LOGGER] ${msg}`)
});

appContainer.registerValue('auth', {
  verify: (token) => token === 'valid-token'
});

const app = new Application(appContainer);

app.use({
  dependencies: ['logger'],
  handler: (req, res, next, logger) => {
    logger.log(`${req.method} ${req.url}`);
    next();
  }
});

app.use({
  dependencies: ['auth'],
  handler: (req, res, next, auth) => {
    if (!auth.verify(req.headers.token)) {
      res.status = 401;
      res.body = 'Unauthorized';
      return;
    }
    next();
  }
});

const mockReq = { method: 'GET', url: '/api/users', headers: { token: 'valid-token' } };
const mockRes = { status: 200, body: null };

app.handle(mockReq, mockRes);

// 2. Testing with Mocks
console.log('\n=== Testing with Mocks ===');

class TestContainer extends AdvancedDIContainer {
  mock(name, mockValue) {
    this.registerValue(name, mockValue);
    return this;
  }
}

// Production service
class EmailService {
  send(to, message) {
    console.log(`Sending email to ${to}: ${message}`);
    return { sent: true, id: Math.random() };
  }
}

// Service using EmailService
class NotificationService {
  constructor(emailService) {
    this.emailService = emailService;
  }
  
  notify(user, message) {
    return this.emailService.send(user.email, message);
  }
}

// Test setup
const testContainer = new TestContainer();

testContainer.mock('emailService', {
  send: (to, message) => {
    console.log(`[MOCK] Would send email to ${to}`);
    return { sent: true, id: 'mock-id' };
  }
});

testContainer.registerClass('notificationService', NotificationService, ['emailService']);

const notificationService = testContainer.resolve('notificationService');
const result = notificationService.notify({ email: 'user@test.com' }, 'Test message');

console.log('Mock result:', result);

// 3. Plugin System
console.log('\n=== Plugin System ===');

class PluginManager {
  constructor(container) {
    this.container = container;
    this.plugins = new Map();
  }
  
  registerPlugin(name, plugin) {
    this.plugins.set(name, plugin);
    
    // Register plugin's services
    if (plugin.services) {
      for (const [serviceName, service] of Object.entries(plugin.services)) {
        this.container.registerFactory(
          `${name}.${serviceName}`,
          service.factory,
          service.dependencies || []
        );
      }
    }
    
    // Initialize plugin
    if (plugin.initialize) {
      plugin.initialize(this.container);
    }
  }
  
  getPlugin(name) {
    return this.plugins.get(name);
  }
}

const pluginContainer = new AdvancedDIContainer();
const pluginManager = new PluginManager(pluginContainer);

// Example plugin
const analyticsPlugin = {
  name: 'analytics',
  
  services: {
    tracker: {
      factory: () => ({
        track: (event) => console.log(`Tracking: ${event}`)
      })
    }
  },
  
  initialize: (container) => {
    console.log('Analytics plugin initialized');
  }
};

pluginManager.registerPlugin('analytics', analyticsPlugin);

const tracker = pluginContainer.resolve('analytics.tracker');
tracker.track('page_view');

// 4. Configuration Management
console.log('\n=== Configuration Management ===');

class ConfigManager {
  constructor() {
    this.config = new Map();
  }
  
  set(key, value) {
    this.config.set(key, value);
  }
  
  get(key, defaultValue = null) {
    return this.config.has(key) ? this.config.get(key) : defaultValue;
  }
  
  getAll() {
    return Object.fromEntries(this.config);
  }
}

const appContainerWithConfig = new AdvancedDIContainer();

appContainerWithConfig.registerClass('config', ConfigManager, [], { singleton: true });

appContainerWithConfig.registerFactory(
  'database',
  (config) => {
    const dbConfig = {
      host: config.get('DB_HOST', 'localhost'),
      port: config.get('DB_PORT', 5432),
      name: config.get('DB_NAME', 'myapp')
    };
    
    return {
      connect: () => console.log('Connected to:', dbConfig),
      query: (sql) => `Executing: ${sql}`
    };
  },
  ['config'],
  { singleton: true }
);

const config = appContainerWithConfig.resolve('config');
config.set('DB_HOST', 'production-db.example.com');
config.set('DB_NAME', 'production_db');

const database = appContainerWithConfig.resolve('database');
database.connect();

// 5. Microservices Communication
console.log('\n=== Microservices ===');

class ServiceRegistry {
  constructor() {
    this.services = new Map();
  }
  
  register(name, endpoint) {
    this.services.set(name, endpoint);
  }
  
  discover(name) {
    const endpoint = this.services.get(name);
    if (!endpoint) {
      throw new Error(`Service '${name}' not found in registry`);
    }
    return endpoint;
  }
}

class ServiceClient {
  constructor(registry, serviceName) {
    this.registry = registry;
    this.serviceName = serviceName;
  }
  
  call(method, params) {
    const endpoint = this.registry.discover(this.serviceName);
    return `Calling ${endpoint}.${method}(${JSON.stringify(params)})`;
  }
}

const microserviceContainer = new AdvancedDIContainer();

microserviceContainer.registerClass('registry', ServiceRegistry, [], { singleton: true });

microserviceContainer.registerFactory(
  'userServiceClient',
  (registry) => new ServiceClient(registry, 'user-service'),
  ['registry']
);

microserviceContainer.registerFactory(
  'orderServiceClient',
  (registry) => new ServiceClient(registry, 'order-service'),
  ['registry']
);

const registry = microserviceContainer.resolve('registry');
registry.register('user-service', 'http://users-api:3000');
registry.register('order-service', 'http://orders-api:3001');

const userClient = microserviceContainer.resolve('userServiceClient');
const orderClient = microserviceContainer.resolve('orderServiceClient');

console.log(userClient.call('getUser', { id: 123 }));
console.log(orderClient.call('getOrders', { userId: 123 }));
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Dependency Injection Patterns:
┌──────────────────────┬─────────────────────────────────┐
│ Pattern              │ Characteristics                 │
├──────────────────────┼─────────────────────────────────┤
│ Constructor Injection│ Dependencies via constructor    │
│                      │ Most common, explicit deps     │
├──────────────────────┼─────────────────────────────────┤
│ Property Injection   │ Set properties after creation   │
│                      │ Optional dependencies           │
├──────────────────────┼─────────────────────────────────┤
│ Method Injection     │ Pass deps to methods            │
│                      │ Per-operation dependencies      │
└──────────────────────┴─────────────────────────────────┘

Lifetime Management:
┌──────────────┬──────────────────────────────────────┐
│ Lifetime     │ Behavior                             │
├──────────────┼──────────────────────────────────────┤
│ Singleton    │ One instance for entire app          │
│              │ Shared state, cached                 │
├──────────────┼──────────────────────────────────────┤
│ Transient    │ New instance every resolution        │
│              │ No shared state, stateless           │
├──────────────┼──────────────────────────────────────┤
│ Scoped       │ One instance per scope/request       │
│              │ Isolated per operation               │
└──────────────┴──────────────────────────────────────┘

Benefits:
• Decoupling: components don't create dependencies
• Testability: easy to inject mocks/stubs
• Flexibility: swap implementations easily
• Maintainability: centralized dependency management
• Lazy loading: create instances only when needed

Common Features:
• Registration: bind interfaces to implementations
• Resolution: create instances with dependencies
• Lifetime management: singleton, transient, scoped
• Auto-wiring: automatic dependency resolution
• Circular detection: prevent infinite loops
• Validation: check dependency graph

Best Practices:
• Prefer constructor injection (explicit)
• Use interfaces/protocols for abstractions
• Keep dependencies minimal
• Avoid service locator anti-pattern
• Validate container at startup
• Use scopes for request-based dependencies
• Register by interface, resolve by name

Use Cases:
• Large applications with many components
• Testing with mocked dependencies
• Plugin/extension systems
• Microservices communication
• Configuration management
• Middleware pipelines
`);
```

**Interview Tips:**
- Dependency Injection: design pattern where dependencies are provided from outside
- DI Container: manages object creation and lifetime, resolves dependencies
- Three injection types: constructor (common), property (optional), method (per-call)
- Registration: tell container how to create services (class, factory, value)
- Resolution: container creates instance with all dependencies
- Lifetime management: singleton (one instance), transient (always new), scoped (per scope)
- Dependencies list: what each service needs to be created
- Circular dependencies: A needs B, B needs A - must detect and prevent
- Benefits: loose coupling, testability, flexibility, maintainability
- Constructor injection preferred: explicit dependencies visible in signature
- Service locator anti-pattern: don't inject container itself, hide dependencies
- Auto-wiring: automatically resolve dependencies without explicit configuration
- Scopes: useful for web requests (new scope per request)
- Validation: check all dependencies registered before app starts
- Mocking: easy to replace real services with test doubles
- Common use: large apps (Angular, NestJS), testing, plugins, microservices
- Trade-offs: complexity overhead, learning curve, runtime errors if misconfigured
- Alternatives: simple factory pattern, direct instantiation, module pattern
- Follow-ups: async resolution, lazy loading, decorators, hierarchical containers
- Clarify: lifetime requirements? circular detection? validation? TypeScript support?

</details>

119. Implement a template engine (string interpolation)

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Simple String Interpolation**
```javascript
/**
 * Basic template engine with {{ variable }} syntax
 */

function simpleTemplate(template, data) {
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return data.hasOwnProperty(key) ? data[key] : match;
  });
}

// Test
console.log('=== Simple Template ===');

const template1 = 'Hello, {{name}}! You are {{age}} years old.';
const data1 = { name: 'John', age: 25 };

console.log(simpleTemplate(template1, data1));
// "Hello, John! You are 25 years old."

const template2 = 'Welcome to {{city}}, {{name}}!';
const data2 = { name: 'Alice', city: 'New York' };

console.log(simpleTemplate(template2, data2));
// "Welcome to New York, Alice!"
```

### **Approach 2: Nested Property Access**
```javascript
/**
 * Support nested properties with dot notation
 */

function nestedTemplate(template, data) {
  return template.replace(/\{\{([\w.]+)\}\}/g, (match, path) => {
    const keys = path.split('.');
    let value = data;
    
    for (const key of keys) {
      if (value && value.hasOwnProperty(key)) {
        value = value[key];
      } else {
        return match; // Keep original if not found
      }
    }
    
    return value !== undefined ? value : match;
  });
}

// Test
console.log('\n=== Nested Properties ===');

const template3 = 'User: {{user.name}}, Email: {{user.email}}, City: {{user.address.city}}';
const data3 = {
  user: {
    name: 'Bob',
    email: 'bob@example.com',
    address: {
      city: 'San Francisco',
      zip: '94102'
    }
  }
};

console.log(nestedTemplate(template3, data3));
```

### **Approach 3: Expressions and Helpers**
```javascript
/**
 * Support expressions and helper functions
 */

class TemplateEngine {
  constructor() {
    this.helpers = new Map();
  }
  
  registerHelper(name, fn) {
    this.helpers.set(name, fn);
  }
  
  compile(template) {
    return (data) => {
      // Handle expressions: {{ expression }}
      return template.replace(/\{\{([^}]+)\}\}/g, (match, expression) => {
        expression = expression.trim();
        
        try {
          // Create function with data and helpers in scope
          const fn = new Function(
            'data',
            'helpers',
            `with(data) { return ${expression}; }`
          );
          
          const result = fn(data, Object.fromEntries(this.helpers));
          return result !== undefined ? result : '';
        } catch (error) {
          console.error(`Error evaluating: ${expression}`, error);
          return match;
        }
      });
    };
  }
  
  render(template, data) {
    const compiled = this.compile(template);
    return compiled(data);
  }
}

// Test
console.log('\n=== Expressions and Helpers ===');

const engine = new TemplateEngine();

// Register helpers
engine.registerHelper('upper', (str) => str.toUpperCase());
engine.registerHelper('lower', (str) => str.toLowerCase());
engine.registerHelper('truncate', (str, len) => 
  str.length > len ? str.substring(0, len) + '...' : str
);

const template4 = `
Name: {{ name }}
Uppercase: {{ helpers.upper(name) }}
Age next year: {{ age + 1 }}
Is adult: {{ age >= 18 ? 'Yes' : 'No' }}
Bio: {{ helpers.truncate(bio, 20) }}
`;

const data4 = {
  name: 'Charlie',
  age: 17,
  bio: 'This is a very long biography that should be truncated'
};

console.log(engine.render(template4, data4));
```

### **Approach 4: Conditionals and Loops**
```javascript
/**
 * Support control structures: if/else, loops
 */

class AdvancedTemplateEngine {
  compile(template) {
    // Convert template to JavaScript code
    let code = 'let output = "";\n';
    let cursor = 0;
    
    // Regex patterns
    const patterns = {
      variable: /\{\{([^}]+)\}\}/g,
      ifStart: /\{%\s*if\s+([^%]+)\s*%\}/g,
      elseIf: /\{%\s*elseif\s+([^%]+)\s*%\}/g,
      else: /\{%\s*else\s*%\}/g,
      ifEnd: /\{%\s*endif\s*%\}/g,
      forStart: /\{%\s*for\s+(\w+)\s+in\s+([^%]+)\s*%\}/g,
      forEnd: /\{%\s*endfor\s*%\}/g
    };
    
    while (cursor < template.length) {
      // Check for if statement
      patterns.ifStart.lastIndex = cursor;
      let match = patterns.ifStart.exec(template);
      
      if (match && match.index === cursor) {
        code += `if (${match[1]}) {\n`;
        cursor = patterns.ifStart.lastIndex;
        continue;
      }
      
      // Check for else
      patterns.else.lastIndex = cursor;
      match = patterns.else.exec(template);
      
      if (match && match.index === cursor) {
        code += `} else {\n`;
        cursor = patterns.else.lastIndex;
        continue;
      }
      
      // Check for endif
      patterns.ifEnd.lastIndex = cursor;
      match = patterns.ifEnd.exec(template);
      
      if (match && match.index === cursor) {
        code += `}\n`;
        cursor = patterns.ifEnd.lastIndex;
        continue;
      }
      
      // Check for for loop
      patterns.forStart.lastIndex = cursor;
      match = patterns.forStart.exec(template);
      
      if (match && match.index === cursor) {
        const [, itemVar, arrayExpr] = match;
        code += `for (const ${itemVar} of ${arrayExpr}) {\n`;
        cursor = patterns.forStart.lastIndex;
        continue;
      }
      
      // Check for endfor
      patterns.forEnd.lastIndex = cursor;
      match = patterns.forEnd.exec(template);
      
      if (match && match.index === cursor) {
        code += `}\n`;
        cursor = patterns.forEnd.lastIndex;
        continue;
      }
      
      // Check for variable
      patterns.variable.lastIndex = cursor;
      match = patterns.variable.exec(template);
      
      if (match && match.index === cursor) {
        code += `output += (${match[1]}) || '';\n`;
        cursor = patterns.variable.lastIndex;
        continue;
      }
      
      // Regular text
      const nextSpecial = template.substring(cursor).search(/\{[{%]/);
      
      if (nextSpecial === -1) {
        // No more special syntax
        const text = template.substring(cursor).replace(/'/g, "\\'");
        code += `output += '${text}';\n`;
        break;
      } else {
        const text = template.substring(cursor, cursor + nextSpecial).replace(/'/g, "\\'");
        code += `output += '${text}';\n`;
        cursor += nextSpecial;
      }
    }
    
    code += 'return output;';
    
    return new Function('data', `with(data) { ${code} }`);
  }
  
  render(template, data) {
    const compiled = this.compile(template);
    return compiled(data);
  }
}

// Test
console.log('\n=== Conditionals and Loops ===');

const advEngine = new AdvancedTemplateEngine();

const template5 = `
<h1>{{title}}</h1>

{% if user.isLoggedIn %}
  <p>Welcome, {{user.name}}!</p>
{% else %}
  <p>Please log in.</p>
{% endif %}

<h2>Items:</h2>
<ul>
{% for item in items %}
  <li>{{item.name}} - ${{item.price}}</li>
{% endfor %}
</ul>

{% if items.length > 0 %}
  <p>Total items: {{items.length}}</p>
{% else %}
  <p>No items available.</p>
{% endif %}
`;

const data5 = {
  title: 'My Store',
  user: {
    isLoggedIn: true,
    name: 'David'
  },
  items: [
    { name: 'Book', price: 19.99 },
    { name: 'Pen', price: 2.99 },
    { name: 'Notebook', price: 5.99 }
  ]
};

console.log(advEngine.render(template5, data5));
```

### **Approach 5: Component-Based Templates**
```javascript
/**
 * Support reusable components and partials
 */

class ComponentTemplateEngine {
  constructor() {
    this.components = new Map();
    this.partials = new Map();
  }
  
  registerComponent(name, template) {
    this.components.set(name, template);
  }
  
  registerPartial(name, template) {
    this.partials.set(name, template);
  }
  
  render(template, data) {
    // Replace partials: {% include "partial-name" %}
    template = template.replace(
      /\{%\s*include\s+"([^"]+)"\s*%\}/g,
      (match, partialName) => {
        const partial = this.partials.get(partialName);
        return partial ? this.render(partial, data) : match;
      }
    );
    
    // Replace components: <ComponentName prop1="value1" />
    template = template.replace(
      /<(\w+)\s*([^/>]*)\s*\/>/g,
      (match, componentName, propsStr) => {
        const component = this.components.get(componentName);
        
        if (!component) return match;
        
        // Parse props
        const props = {};
        const propRegex = /(\w+)="([^"]*)"/g;
        let propMatch;
        
        while ((propMatch = propRegex.exec(propsStr)) !== null) {
          const [, key, value] = propMatch;
          // Evaluate value expression
          try {
            props[key] = new Function('data', `with(data) { return ${value}; }`)(data);
          } catch {
            props[key] = value;
          }
        }
        
        return this.render(component, { ...data, ...props });
      }
    );
    
    // Replace variables
    template = template.replace(/\{\{([^}]+)\}\}/g, (match, expr) => {
      try {
        const result = new Function('data', `with(data) { return ${expr.trim()}; }`)(data);
        return result !== undefined ? result : '';
      } catch {
        return match;
      }
    });
    
    return template;
  }
}

// Test
console.log('\n=== Component-Based ===');

const compEngine = new ComponentTemplateEngine();

// Register partials
compEngine.registerPartial('header', `
<header>
  <h1>{{siteName}}</h1>
  <nav>Home | About | Contact</nav>
</header>
`);

compEngine.registerPartial('footer', `
<footer>
  <p>&copy; {{year}} {{siteName}}</p>
</footer>
`);

// Register components
compEngine.registerComponent('UserCard', `
<div class="user-card">
  <h3>{{name}}</h3>
  <p>{{email}}</p>
  <p>Role: {{role}}</p>
</div>
`);

compEngine.registerComponent('Button', `
<button class="{{className}}">{{text}}</button>
`);

// Main template
const mainTemplate = `
{% include "header" %}

<main>
  <h2>Users</h2>
  <UserCard name="user.name" email="user.email" role="user.role" />
  
  <Button text="'Click Me'" className="'btn-primary'" />
</main>

{% include "footer" %}
`;

const mainData = {
  siteName: 'My Website',
  year: 2024,
  user: {
    name: 'Emma',
    email: 'emma@example.com',
    role: 'Admin'
  }
};

console.log(compEngine.render(mainTemplate, mainData));
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Email Templates
console.log('\n=== Email Templates ===');

class EmailTemplateEngine {
  constructor() {
    this.engine = new TemplateEngine();
    
    // Register email-specific helpers
    this.engine.registerHelper('formatDate', (date) => {
      return new Date(date).toLocaleDateString();
    });
    
    this.engine.registerHelper('currency', (amount) => {
      return `$${amount.toFixed(2)}`;
    });
  }
  
  renderWelcomeEmail(user) {
    const template = `
Hi {{user.name}},

Welcome to our platform! Your account has been created successfully.

Username: {{user.email}}
Registered: {{ helpers.formatDate(user.registeredAt) }}

Thank you for joining us!

Best regards,
The Team
    `;
    
    return this.engine.render(template, { user });
  }
  
  renderOrderConfirmation(order) {
    const template = `
Order Confirmation #{{order.id}}

Thank you for your order, {{order.customerName}}!

Order Date: {{ helpers.formatDate(order.date) }}
Total: {{ helpers.currency(order.total) }}

Items:
{{order.items.map(item => '- ' + item.name + ': ' + helpers.currency(item.price)).join('\\n')}}

We'll send you tracking information once your order ships.
    `;
    
    return this.engine.render(template, { order });
  }
}

const emailEngine = new EmailTemplateEngine();

console.log(emailEngine.renderWelcomeEmail({
  name: 'Frank',
  email: 'frank@example.com',
  registeredAt: '2024-01-15'
}));

console.log('\n');

console.log(emailEngine.renderOrderConfirmation({
  id: 'ORD-12345',
  customerName: 'Grace',
  date: '2024-01-20',
  total: 49.97,
  items: [
    { name: 'Widget A', price: 19.99 },
    { name: 'Widget B', price: 29.98 }
  ]
}));

// 2. Report Generation
console.log('\n=== Report Generation ===');

class ReportGenerator {
  generateSalesReport(data) {
    const engine = new AdvancedTemplateEngine();
    
    const template = `
# Sales Report - {{reportDate}}

## Summary
- Total Sales: ${{totalSales}}
- Total Orders: {{totalOrders}}
- Average Order: ${{(totalSales / totalOrders).toFixed(2)}}

## Top Products
{% for product in topProducts %}
{{product.rank}}. {{product.name}} - {{product.units}} units - ${{product.revenue}}
{% endfor %}

## Sales by Region
{% for region in regions %}
### {{region.name}}
- Orders: {{region.orders}}
- Revenue: ${{region.revenue}}
{% endfor %}
    `;
    
    return engine.render(template, data);
  }
}

const reportGen = new ReportGenerator();

console.log(reportGen.generateSalesReport({
  reportDate: '2024-01-20',
  totalSales: 125000,
  totalOrders: 450,
  topProducts: [
    { rank: 1, name: 'Product A', units: 120, revenue: 24000 },
    { rank: 2, name: 'Product B', units: 95, revenue: 19000 },
    { rank: 3, name: 'Product C', units: 80, revenue: 16000 }
  ],
  regions: [
    { name: 'North', orders: 150, revenue: 45000 },
    { name: 'South', orders: 180, revenue: 54000 },
    { name: 'West', orders: 120, revenue: 26000 }
  ]
}));

// 3. Static Site Generator
console.log('\n=== Static Site Generator ===');

class StaticSiteGenerator {
  constructor() {
    this.engine = new ComponentTemplateEngine();
    this.layouts = new Map();
  }
  
  registerLayout(name, template) {
    this.layouts.set(name, template);
  }
  
  renderPage(content, layout, data) {
    const layoutTemplate = this.layouts.get(layout);
    
    if (!layoutTemplate) {
      throw new Error(`Layout '${layout}' not found`);
    }
    
    return this.engine.render(layoutTemplate, { ...data, content });
  }
}

const siteGen = new StaticSiteGenerator();

siteGen.registerLayout('default', `
<!DOCTYPE html>
<html>
<head>
  <title>{{title}} - {{siteName}}</title>
</head>
<body>
  <header>
    <h1>{{siteName}}</h1>
  </header>
  
  <main>
    {{content}}
  </main>
  
  <footer>
    <p>&copy; {{year}} {{siteName}}</p>
  </footer>
</body>
</html>
`);

const pageContent = `
<h2>{{pageTitle}}</h2>
<p>{{pageDescription}}</p>
`;

const html = siteGen.renderPage(pageContent, 'default', {
  siteName: 'My Blog',
  title: 'Home',
  year: 2024,
  pageTitle: 'Welcome',
  pageDescription: 'This is the home page.'
});

console.log(html);

// 4. Code Generation
console.log('\n=== Code Generation ===');

class CodeGenerator {
  generateClass(spec) {
    const engine = new AdvancedTemplateEngine();
    
    const template = `
class {{className}} {
  constructor({{spec.constructor.params.join(', ')}}) {
    {% for param in spec.constructor.params %}
    this.{{param}} = {{param}};
    {% endfor %}
  }
  
  {% for method in spec.methods %}
  {{method.name}}({{method.params.join(', ')}}) {
    {{method.body}}
  }
  
  {% endfor %}
}
    `;
    
    return engine.render(template, { className: spec.name, spec });
  }
}

const codeGen = new CodeGenerator();

const classSpec = {
  name: 'Person',
  constructor: {
    params: ['name', 'age']
  },
  methods: [
    {
      name: 'greet',
      params: [],
      body: 'return `Hello, I am ${this.name}`;'
    },
    {
      name: 'celebrateBirthday',
      params: [],
      body: 'this.age++;'
    }
  ]
};

console.log(codeGen.generateClass(classSpec));

// 5. Internationalization (i18n)
console.log('\n=== Internationalization ===');

class I18nTemplateEngine {
  constructor() {
    this.translations = new Map();
    this.currentLocale = 'en';
  }
  
  addTranslations(locale, translations) {
    this.translations.set(locale, translations);
  }
  
  setLocale(locale) {
    this.currentLocale = locale;
  }
  
  t(key) {
    const translations = this.translations.get(this.currentLocale) || {};
    return translations[key] || key;
  }
  
  render(template, data) {
    return template.replace(/\{\{t\s+"([^"]+)"\}\}/g, (match, key) => {
      return this.t(key);
    });
  }
}

const i18nEngine = new I18nTemplateEngine();

i18nEngine.addTranslations('en', {
  'greeting': 'Hello',
  'welcome': 'Welcome to our site',
  'goodbye': 'Goodbye'
});

i18nEngine.addTranslations('es', {
  'greeting': 'Hola',
  'welcome': 'Bienvenido a nuestro sitio',
  'goodbye': 'Adiós'
});

const i18nTemplate = `
<h1>{{t "greeting"}}</h1>
<p>{{t "welcome"}}</p>
<footer>{{t "goodbye"}}</footer>
`;

i18nEngine.setLocale('en');
console.log('English:', i18nEngine.render(i18nTemplate, {}));

i18nEngine.setLocale('es');
console.log('\nSpanish:', i18nEngine.render(i18nTemplate, {}));
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Template Engine Features:
┌──────────────────────┬──────────────────────────────┐
│ Feature              │ Description                  │
├──────────────────────┼──────────────────────────────┤
│ Variable Interpolation│ {{variable}} - simple replace │
│ Nested Access        │ {{user.name}} - dot notation │
│ Expressions          │ {{age + 1}} - evaluate JS    │
│ Conditionals         │ {% if %} - control flow      │
│ Loops                │ {% for %} - iteration        │
│ Components           │ <Component /> - reusable     │
│ Helpers              │ {{helper(value)}} - functions│
│ Partials             │ {% include %} - composition  │
└──────────────────────┴──────────────────────────────┘

Compilation Strategies:
┌──────────────────┬────────────────────────────────┐
│ Strategy         │ When to Use                    │
├──────────────────┼────────────────────────────────┤
│ Runtime          │ Simple, dynamic templates      │
│                  │ Regex replacement              │
├──────────────────┼────────────────────────────────┤
│ Precompilation   │ Production, static templates   │
│                  │ Generate JS functions          │
├──────────────────┼────────────────────────────────┤
│ AST-based        │ Complex transformations        │
│                  │ Parse to tree, transform       │
└──────────────────┴────────────────────────────────┘

Common Syntax Patterns:
• Mustache: {{variable}} - simple, safe
• ERB/EJS: <% code %>, <%= output %> - Ruby/Rails style
• Jinja2/Django: {% tag %}, {{ var }} - Python style
• Handlebars: {{#helper}}, {{variable}} - extended Mustache
• JSX: <Component /> - React style

Security Considerations:
• Always escape HTML to prevent XSS
• Use separate delimiters for safe/unsafe content
• Validate/sanitize user-provided templates
• Avoid eval() when possible
• Whitelist allowed functions/helpers

Performance Optimization:
• Precompile templates in production
• Cache compiled functions
• Minimize regex operations
• Use string concatenation or array join
• Lazy load partials/components
• Stream output for large templates

Real-World Uses:
• Email templates (transactional, marketing)
• Report generation (PDF, HTML)
• Static site generators (blogs, docs)
• Code generation (scaffolding)
• i18n (multilingual content)
• Server-side rendering (SSR)
`);
```

**Interview Tips:**
- Template engine: renders dynamic content by replacing placeholders with data
- Core concept: parse template string, replace variables with actual values
- Common syntaxes: {{variable}} (Mustache), <%= %> (ERB), {% %} (Jinja)
- Variable interpolation: simplest form, regex replace {{key}} with data[key]
- Nested access: support dot notation {{user.name}} for object properties
- Expressions: evaluate JavaScript expressions {{age + 1}}, {{condition ? 'yes' : 'no'}}
- Control structures: conditionals {% if %}, loops {% for item in items %}
- Helpers/filters: custom functions {{formatDate(date)}}, {{uppercase(text)}}
- Partials/includes: reusable template fragments {% include "header" %}
- Components: composable UI elements <Button text="Click" />
- Compilation: convert template to function for performance (precompilation)
- Security: escape HTML to prevent XSS, sanitize user input
- Two strategies: runtime (flexible) vs precompiled (fast)
- Use with(data) or Function() to evaluate expressions in context
- Real-world: emails, reports, SSR, static sites, code generation, i18n
- Popular engines: Handlebars, Mustache, EJS, Pug, Nunjucks
- Trade-offs: flexibility vs security, features vs performance
- Optimization: cache compiled templates, minimize regex, stream output
- Follow-ups: HTML escaping, custom syntax, AST parsing, streaming, async
- Clarify: syntax preference? features needed? security requirements? performance?

</details>

120. Build a simple JavaScript module bundler

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Module Resolver**
```javascript
/**
 * Simple module bundler - resolve dependencies
 */

const fs = require('fs');
const path = require('path');

class BasicBundler {
  constructor(entry) {
    this.entry = entry;
    this.modules = new Map();
    this.moduleId = 0;
  }
  
  // Parse module and extract dependencies
  parseModule(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const id = this.moduleId++;
    
    // Extract require() calls
    const requireRegex = /require\(['"](.+?)['"]\)/g;
    const dependencies = [];
    let match;
    
    while ((match = requireRegex.exec(content)) !== null) {
      dependencies.push(match[1]);
    }
    
    return {
      id,
      filePath,
      content,
      dependencies,
      mapping: {}
    };
  }
  
  // Resolve relative path
  resolvePath(basePath, relativePath) {
    const dir = path.dirname(basePath);
    let resolved = path.resolve(dir, relativePath);
    
    // Add .js extension if missing
    if (!resolved.endsWith('.js')) {
      resolved += '.js';
    }
    
    return resolved;
  }
  
  // Build dependency graph
  buildGraph(entryPath) {
    const queue = [entryPath];
    const entryModule = this.parseModule(entryPath);
    this.modules.set(entryPath, entryModule);
    
    while (queue.length > 0) {
      const currentPath = queue.shift();
      const currentModule = this.modules.get(currentPath);
      
      for (const dependency of currentModule.dependencies) {
        const depPath = this.resolvePath(currentPath, dependency);
        
        // Store mapping for this module
        currentModule.mapping[dependency] = depPath;
        
        // If not already processed, add to queue
        if (!this.modules.has(depPath)) {
          const depModule = this.parseModule(depPath);
          this.modules.set(depPath, depModule);
          queue.push(depPath);
        }
      }
    }
    
    return entryModule;
  }
  
  // Generate bundle code
  bundle() {
    const graph = this.buildGraph(this.entry);
    
    // Convert modules to object
    const modulesCode = Array.from(this.modules.values())
      .map(module => {
        return `
          ${module.id}: {
            factory: function(require, module, exports) {
              ${module.content}
            },
            mapping: ${JSON.stringify(module.mapping)}
          }
        `;
      })
      .join(',');
    
    // Runtime code
    const bundleCode = `
      (function(modules) {
        const moduleCache = {};
        
        function require(id) {
          if (moduleCache[id]) {
            return moduleCache[id].exports;
          }
          
          const module = { exports: {} };
          moduleCache[id] = module;
          
          const moduleInfo = modules[id];
          
          function localRequire(relativePath) {
            const resolvedId = moduleInfo.mapping[relativePath];
            // Find module id by path
            for (const [id, mod] of Object.entries(modules)) {
              if (mod.mapping === undefined) continue;
              const paths = Object.values(mod.mapping);
              if (paths.includes(resolvedId)) {
                const targetMod = Object.values(modules).find(m => 
                  Object.values(m.mapping || {}).includes(resolvedId) ||
                  m.filePath === resolvedId
                );
                if (targetMod) return require(targetMod.id);
              }
            }
            return require(resolvedId);
          }
          
          moduleInfo.factory(localRequire, module, module.exports);
          
          return module.exports;
        }
        
        require(0); // Start with entry module
      })({${modulesCode}});
    `;
    
    return bundleCode;
  }
}

// Simulated file system for demo
console.log('=== Basic Module Bundler ===');
console.log('Creates a dependency graph and bundles modules');
console.log('Entry -> Dependencies -> Bundle');
```

### **Approach 2: AST-Based Parser**
```javascript
/**
 * Parse modules using Abstract Syntax Tree
 */

// Simulated AST parser (in real world, use @babel/parser)
class ASTParser {
  parse(code) {
    // Simple AST representation
    const imports = [];
    const exports = [];
    
    // Parse import statements
    const importRegex = /import\s+(?:{([^}]+)}|\*\s+as\s+(\w+)|(\w+))\s+from\s+['"]([^'"]+)['"]/g;
    let match;
    
    while ((match = importRegex.exec(code)) !== null) {
      const [, named, namespace, defaultImport, source] = match;
      
      if (named) {
        imports.push({
          type: 'named',
          specifiers: named.split(',').map(s => s.trim()),
          source
        });
      } else if (namespace) {
        imports.push({
          type: 'namespace',
          name: namespace,
          source
        });
      } else if (defaultImport) {
        imports.push({
          type: 'default',
          name: defaultImport,
          source
        });
      }
    }
    
    // Parse export statements
    const exportRegex = /export\s+(?:default\s+)?(?:const|let|var|function|class)\s+(\w+)/g;
    
    while ((match = exportRegex.exec(code)) !== null) {
      exports.push(match[1]);
    }
    
    return {
      imports,
      exports,
      code
    };
  }
  
  transform(ast, transformers) {
    let code = ast.code;
    
    transformers.forEach(transformer => {
      code = transformer(code, ast);
    });
    
    return code;
  }
}

class ES6Bundler {
  constructor() {
    this.parser = new ASTParser();
    this.modules = new Map();
  }
  
  addModule(name, code) {
    const ast = this.parser.parse(code);
    this.modules.set(name, ast);
    return this;
  }
  
  bundle() {
    const modulesCode = [];
    
    for (const [name, ast] of this.modules) {
      // Transform imports to require-like calls
      let transformed = this.parser.transform(ast, [
        // Replace imports with internal require
        (code) => {
          return code.replace(
            /import\s+{([^}]+)}\s+from\s+['"]([^'"]+)['"]/g,
            (match, imports, source) => {
              const names = imports.split(',').map(s => s.trim());
              return `const { ${names.join(', ')} } = __require__('${source}');`;
            }
          );
        },
        // Replace default imports
        (code) => {
          return code.replace(
            /import\s+(\w+)\s+from\s+['"]([^'"]+)['"]/g,
            "const $1 = __require__('$2').default;"
          );
        },
        // Replace exports
        (code) => {
          return code.replace(
            /export\s+const\s+(\w+)\s*=/g,
            'const $1 ='
          ) + `\n__exports__.${ast.exports.join(' = ').split(' ')[0]} = ${ast.exports[0]};`;
        }
      ]);
      
      modulesCode.push(`
        '${name}': function(__require__, __exports__) {
          ${transformed}
        }
      `);
    }
    
    return `
      (function() {
        const modules = {${modulesCode.join(',')}};
        const cache = {};
        
        function require(name) {
          if (cache[name]) return cache[name];
          
          const exports = {};
          cache[name] = exports;
          
          modules[name](require, exports);
          
          return exports;
        }
        
        require('main');
      })();
    `;
  }
}

// Test
console.log('\n=== ES6 Module Bundler ===');

const es6Bundler = new ES6Bundler();

es6Bundler.addModule('math', `
  export const add = (a, b) => a + b;
  export const multiply = (a, b) => a * b;
`);

es6Bundler.addModule('main', `
  import { add, multiply } from 'math';
  
  console.log('2 + 3 =', add(2, 3));
  console.log('2 * 3 =', multiply(2, 3));
`);

console.log(es6Bundler.bundle());
```

### **Approach 3: Tree Shaking (Dead Code Elimination)**
```javascript
/**
 * Remove unused exports (tree shaking)
 */

class TreeShakingBundler {
  constructor() {
    this.modules = new Map();
    this.usedExports = new Map();
  }
  
  addModule(name, exports, code) {
    this.modules.set(name, { exports, code });
    this.usedExports.set(name, new Set());
  }
  
  // Analyze which exports are used
  analyzeUsage(entryModule) {
    const queue = [entryModule];
    const visited = new Set();
    
    while (queue.length > 0) {
      const moduleName = queue.shift();
      
      if (visited.has(moduleName)) continue;
      visited.add(moduleName);
      
      const module = this.modules.get(moduleName);
      if (!module) continue;
      
      // Find imports in this module
      const importRegex = /import\s+{([^}]+)}\s+from\s+['"]([^'"]+)['"]/g;
      let match;
      
      while ((match = importRegex.exec(module.code)) !== null) {
        const [, imports, source] = match;
        const importNames = imports.split(',').map(s => s.trim());
        
        // Mark these exports as used
        if (!this.usedExports.has(source)) {
          this.usedExports.set(source, new Set());
        }
        
        importNames.forEach(name => {
          this.usedExports.get(source).add(name);
        });
        
        queue.push(source);
      }
    }
  }
  
  bundle(entry) {
    this.analyzeUsage(entry);
    
    const bundledCode = [];
    
    for (const [moduleName, module] of this.modules) {
      const usedInModule = this.usedExports.get(moduleName);
      
      if (!usedInModule || usedInModule.size === 0) {
        console.log(`Tree shaking: removed unused module '${moduleName}'`);
        continue;
      }
      
      // Filter exports to only include used ones
      const filteredCode = this.filterUnusedExports(
        module.code,
        module.exports,
        usedInModule
      );
      
      bundledCode.push(`// Module: ${moduleName}\n${filteredCode}`);
    }
    
    return bundledCode.join('\n\n');
  }
  
  filterUnusedExports(code, allExports, usedExports) {
    // Remove unused export declarations
    allExports.forEach(exportName => {
      if (!usedExports.has(exportName)) {
        console.log(`Tree shaking: removed unused export '${exportName}'`);
        // In real implementation, use AST to remove the entire declaration
        code = code.replace(
          new RegExp(`export const ${exportName} = [^;]+;`, 'g'),
          `// Removed unused: ${exportName}`
        );
      }
    });
    
    return code;
  }
}

// Test
console.log('\n=== Tree Shaking ===');

const tsBundle = new TreeShakingBundler();

tsBundle.addModule('utils', ['add', 'subtract', 'multiply', 'divide'], `
  export const add = (a, b) => a + b;
  export const subtract = (a, b) => a - b;
  export const multiply = (a, b) => a * b;
  export const divide = (a, b) => a / b;
`);

tsBundle.addModule('main', [], `
  import { add, multiply } from 'utils';
  
  console.log(add(5, 3));
  console.log(multiply(5, 3));
`);

console.log(tsBundle.bundle('main'));
```

### **Approach 4: Code Splitting**
```javascript
/**
 * Split code into multiple chunks for lazy loading
 */

class CodeSplittingBundler {
  constructor() {
    this.modules = new Map();
    this.chunks = new Map();
    this.chunkId = 0;
  }
  
  addModule(name, code, chunk = 'main') {
    this.modules.set(name, { code, chunk });
    
    if (!this.chunks.has(chunk)) {
      this.chunks.set(chunk, []);
    }
    
    this.chunks.get(chunk).push(name);
  }
  
  // Detect dynamic imports
  analyzeDynamicImports(code) {
    const dynamicImports = [];
    const importRegex = /import\(['"]([^'"]+)['"]\)/g;
    let match;
    
    while ((match = importRegex.exec(code)) !== null) {
      dynamicImports.push(match[1]);
    }
    
    return dynamicImports;
  }
  
  // Generate chunk
  generateChunk(chunkName, modules) {
    const moduleCode = modules
      .map(moduleName => {
        const module = this.modules.get(moduleName);
        return `
          '${moduleName}': function(require, exports) {
            ${module.code}
          }
        `;
      })
      .join(',');
    
    return `
      // Chunk: ${chunkName}
      (function(chunkModules) {
        window.__registerChunk__('${chunkName}', chunkModules);
      })({${moduleCode}});
    `;
  }
  
  // Generate runtime
  generateRuntime() {
    return `
      (function() {
        const chunks = {};
        const moduleCache = {};
        const chunkCache = {};
        
        window.__registerChunk__ = function(chunkName, modules) {
          chunks[chunkName] = modules;
          
          // Execute pending imports
          if (chunkCache[chunkName]) {
            chunkCache[chunkName].forEach(resolve => resolve());
            delete chunkCache[chunkName];
          }
        };
        
        function require(moduleName) {
          if (moduleCache[moduleName]) {
            return moduleCache[moduleName];
          }
          
          const exports = {};
          moduleCache[moduleName] = exports;
          
          // Find module in chunks
          for (const chunkModules of Object.values(chunks)) {
            if (chunkModules[moduleName]) {
              chunkModules[moduleName](require, exports);
              return exports;
            }
          }
          
          throw new Error(\`Module '\${moduleName}' not found\`);
        }
        
        window.__import__ = function(chunkName) {
          return new Promise((resolve, reject) => {
            if (chunks[chunkName]) {
              resolve();
              return;
            }
            
            // Register pending import
            if (!chunkCache[chunkName]) {
              chunkCache[chunkName] = [];
            }
            chunkCache[chunkName].push(resolve);
            
            // Load chunk script
            const script = document.createElement('script');
            script.src = \`/chunks/\${chunkName}.js\`;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error(\`Failed to load chunk '\${chunkName}'\`));
            document.head.appendChild(script);
          });
        };
        
        window.__require__ = require;
      })();
    `;
  }
  
  bundle() {
    const output = {
      runtime: this.generateRuntime(),
      chunks: {}
    };
    
    for (const [chunkName, modules] of this.chunks) {
      output.chunks[chunkName] = this.generateChunk(chunkName, modules);
    }
    
    return output;
  }
}

// Test
console.log('\n=== Code Splitting ===');

const csBundler = new CodeSplittingBundler();

csBundler.addModule('main', `
  console.log('Main module loaded');
  
  document.getElementById('loadBtn').addEventListener('click', async () => {
    await window.__import__('feature');
    const feature = window.__require__('feature');
    feature.init();
  });
`, 'main');

csBundler.addModule('feature', `
  export function init() {
    console.log('Feature loaded dynamically!');
  }
`, 'feature');

const result = csBundler.bundle();

console.log('Runtime:', result.runtime);
console.log('\nMain chunk:', result.chunks.main);
console.log('\nFeature chunk:', result.chunks.feature);
```

### **Approach 5: Plugin System**
```javascript
/**
 * Extensible bundler with plugin support
 */

class PluginBundler {
  constructor() {
    this.plugins = [];
    this.hooks = {
      beforeBundle: [],
      afterParse: [],
      beforeEmit: [],
      afterBundle: []
    };
  }
  
  use(plugin) {
    this.plugins.push(plugin);
    
    // Register plugin hooks
    if (plugin.apply) {
      plugin.apply(this);
    }
    
    return this;
  }
  
  tap(hookName, callback) {
    if (this.hooks[hookName]) {
      this.hooks[hookName].push(callback);
    }
  }
  
  async callHook(hookName, context) {
    const hooks = this.hooks[hookName] || [];
    
    for (const hook of hooks) {
      context = await hook(context) || context;
    }
    
    return context;
  }
  
  async bundle(entry, modules) {
    let context = {
      entry,
      modules,
      output: ''
    };
    
    // Call beforeBundle hooks
    context = await this.callHook('beforeBundle', context);
    
    // Parse modules
    const parsedModules = new Map();
    
    for (const [name, code] of Object.entries(modules)) {
      let moduleContext = { name, code };
      moduleContext = await this.callHook('afterParse', moduleContext);
      parsedModules.set(name, moduleContext.code);
    }
    
    context.modules = parsedModules;
    
    // Generate output
    let output = this.generateBundle(context);
    context.output = output;
    
    // Call beforeEmit hooks
    context = await this.callHook('beforeEmit', context);
    
    // Call afterBundle hooks
    context = await this.callHook('afterBundle', context);
    
    return context.output;
  }
  
  generateBundle(context) {
    const moduleCode = Array.from(context.modules.entries())
      .map(([name, code]) => `'${name}': function() { ${code} }`)
      .join(',');
    
    return `(function() {
      const modules = {${moduleCode}};
      modules['${context.entry}']();
    })();`;
  }
}

// Example plugins
const MinifyPlugin = {
  apply(bundler) {
    bundler.tap('beforeEmit', (context) => {
      console.log('[MinifyPlugin] Minifying output...');
      
      // Simple minification: remove extra whitespace
      context.output = context.output
        .replace(/\s+/g, ' ')
        .replace(/\n/g, '');
      
      return context;
    });
  }
};

const AnalyzerPlugin = {
  apply(bundler) {
    bundler.tap('afterBundle', (context) => {
      console.log('[AnalyzerPlugin] Bundle analysis:');
      console.log(`  Entry: ${context.entry}`);
      console.log(`  Modules: ${context.modules.size}`);
      console.log(`  Output size: ${context.output.length} bytes`);
      
      return context;
    });
  }
};

const TransformPlugin = {
  apply(bundler) {
    bundler.tap('afterParse', (moduleContext) => {
      console.log(`[TransformPlugin] Transforming ${moduleContext.name}...`);
      
      // Example: transform console.log to custom logger
      moduleContext.code = moduleContext.code.replace(
        /console\.log/g,
        'logger.info'
      );
      
      return moduleContext;
    });
  }
};

// Test
console.log('\n=== Plugin System ===');

const pluginBundler = new PluginBundler();

pluginBundler
  .use(TransformPlugin)
  .use(MinifyPlugin)
  .use(AnalyzerPlugin);

pluginBundler.bundle('main', {
  main: `
    console.log('Hello from main');
    console.log('Bundle created!');
  `
}).then(output => {
  console.log('\nFinal output:', output);
});
```

### **Real-World Use Cases**
```javascript
/**
 * Practical bundler applications
 */

// 1. Development Server with HMR (Hot Module Replacement)
console.log('\n=== Development Server ===');

class DevServer {
  constructor(bundler) {
    this.bundler = bundler;
    this.watchers = new Map();
    this.clients = new Set();
  }
  
  watch(files) {
    files.forEach(file => {
      console.log(`Watching: ${file}`);
      
      // Simulate file watcher
      this.watchers.set(file, {
        onChange: () => this.onFileChange(file)
      });
    });
  }
  
  onFileChange(file) {
    console.log(`File changed: ${file}`);
    
    // Rebuild
    const newBundle = this.bundler.bundle();
    
    // Notify clients
    this.notifyClients({
      type: 'update',
      file,
      bundle: newBundle
    });
  }
  
  notifyClients(message) {
    console.log(`Notifying ${this.clients.size} client(s):`, message.type);
    
    this.clients.forEach(client => {
      // In real implementation, use WebSocket
      console.log(`  -> Client received update for ${message.file}`);
    });
  }
  
  addClient(client) {
    this.clients.add(client);
  }
}

const devBundler = new PluginBundler();
const devServer = new DevServer(devBundler);

devServer.watch(['src/main.js', 'src/utils.js']);
devServer.addClient({ id: 'client-1' });

// Simulate file change
setTimeout(() => {
  const watcher = devServer.watchers.get('src/main.js');
  watcher.onChange();
}, 100);

// 2. Asset Pipeline (Images, CSS)
console.log('\n=== Asset Pipeline ===');

class AssetBundler {
  constructor() {
    this.assets = new Map();
    this.loaders = new Map();
  }
  
  registerLoader(extension, loader) {
    this.loaders.set(extension, loader);
  }
  
  async processAsset(filePath, content) {
    const ext = filePath.split('.').pop();
    const loader = this.loaders.get(ext);
    
    if (!loader) {
      throw new Error(`No loader for .${ext} files`);
    }
    
    return await loader(content);
  }
  
  async bundle(assets) {
    const processed = new Map();
    
    for (const [path, content] of Object.entries(assets)) {
      const result = await this.processAsset(path, content);
      processed.set(path, result);
    }
    
    return this.generateBundle(processed);
  }
  
  generateBundle(assets) {
    const assetMap = {};
    
    for (const [path, content] of assets) {
      assetMap[path] = content;
    }
    
    return `
      window.__assets__ = ${JSON.stringify(assetMap)};
      
      function loadAsset(path) {
        return window.__assets__[path];
      }
    `;
  }
}

const assetBundler = new AssetBundler();

// Register loaders
assetBundler.registerLoader('css', (content) => {
  console.log('Processing CSS...');
  return {
    type: 'css',
    content: content.replace(/\s+/g, ' ') // Minify
  };
});

assetBundler.registerLoader('png', (content) => {
  console.log('Processing image...');
  return {
    type: 'image',
    url: `data:image/png;base64,${Buffer.from(content).toString('base64')}`
  };
});

assetBundler.bundle({
  'styles.css': 'body { margin: 0; padding: 0; }',
  'logo.png': 'fake-image-data'
}).then(bundle => {
  console.log('Asset bundle created');
});

// 3. Multi-Target Bundler (Browser, Node, Worker)
console.log('\n=== Multi-Target Bundler ===');

class MultiTargetBundler {
  constructor() {
    this.targets = {
      browser: {
        globals: ['window', 'document'],
        wrapper: (code) => `(function(window, document) { ${code} })(window, document);`
      },
      node: {
        globals: ['process', 'require'],
        wrapper: (code) => `(function(process, require) { ${code} })(process, require);`
      },
      worker: {
        globals: ['self', 'postMessage'],
        wrapper: (code) => `(function(self, postMessage) { ${code} })(self, postMessage);`
      }
    };
  }
  
  bundle(code, target) {
    const config = this.targets[target];
    
    if (!config) {
      throw new Error(`Unknown target: ${target}`);
    }
    
    console.log(`Building for ${target}...`);
    console.log(`Available globals: ${config.globals.join(', ')}`);
    
    return config.wrapper(code);
  }
}

const multiTargetBundler = new MultiTargetBundler();

const sourceCode = `
  console.log('Universal module');
`;

console.log('Browser bundle:', multiTargetBundler.bundle(sourceCode, 'browser'));
console.log('Node bundle:', multiTargetBundler.bundle(sourceCode, 'node'));
console.log('Worker bundle:', multiTargetBundler.bundle(sourceCode, 'worker'));

// 4. Dependency Graph Visualization
console.log('\n=== Dependency Graph ===');

class DependencyAnalyzer {
  constructor() {
    this.graph = new Map();
  }
  
  addModule(name, dependencies) {
    this.graph.set(name, dependencies);
  }
  
  visualize() {
    console.log('Dependency Graph:');
    console.log('─────────────────');
    
    for (const [module, deps] of this.graph) {
      console.log(`${module}`);
      
      deps.forEach((dep, index) => {
        const isLast = index === deps.length - 1;
        const prefix = isLast ? '└─' : '├─';
        console.log(`  ${prefix} ${dep}`);
      });
      
      console.log('');
    }
  }
  
  findCircular() {
    const visited = new Set();
    const recursionStack = new Set();
    const cycles = [];
    
    const dfs = (module, path = []) => {
      if (recursionStack.has(module)) {
        const cycleStart = path.indexOf(module);
        cycles.push([...path.slice(cycleStart), module]);
        return;
      }
      
      if (visited.has(module)) return;
      
      visited.add(module);
      recursionStack.add(module);
      path.push(module);
      
      const deps = this.graph.get(module) || [];
      
      for (const dep of deps) {
        dfs(dep, [...path]);
      }
      
      recursionStack.delete(module);
    };
    
    for (const module of this.graph.keys()) {
      dfs(module);
    }
    
    return cycles;
  }
}

const analyzer = new DependencyAnalyzer();

analyzer.addModule('main', ['utils', 'api']);
analyzer.addModule('utils', ['helpers']);
analyzer.addModule('api', ['http', 'utils']);
analyzer.addModule('http', []);
analyzer.addModule('helpers', []);

analyzer.visualize();

const cycles = analyzer.findCircular();
if (cycles.length > 0) {
  console.log('Circular dependencies found:');
  cycles.forEach(cycle => {
    console.log(`  ${cycle.join(' -> ')}`);
  });
} else {
  console.log('No circular dependencies detected');
}

// 5. Build Optimization Pipeline
console.log('\n=== Build Optimization ===');

class OptimizationPipeline {
  constructor() {
    this.optimizers = [];
  }
  
  addOptimizer(name, fn) {
    this.optimizers.push({ name, fn });
    return this;
  }
  
  async optimize(code) {
    let optimized = code;
    const stats = {
      original: code.length,
      steps: []
    };
    
    for (const optimizer of this.optimizers) {
      const before = optimized.length;
      optimized = await optimizer.fn(optimized);
      const after = optimized.length;
      
      stats.steps.push({
        name: optimizer.name,
        before,
        after,
        saved: before - after,
        percentage: ((before - after) / before * 100).toFixed(2)
      });
    }
    
    stats.final = optimized.length;
    stats.totalSaved = stats.original - stats.final;
    stats.totalPercentage = ((stats.totalSaved / stats.original) * 100).toFixed(2);
    
    return { code: optimized, stats };
  }
  
  printStats(stats) {
    console.log('\nOptimization Report:');
    console.log(`Original size: ${stats.original} bytes`);
    console.log('');
    
    stats.steps.forEach(step => {
      console.log(`${step.name}:`);
      console.log(`  Before: ${step.before} bytes`);
      console.log(`  After:  ${step.after} bytes`);
      console.log(`  Saved:  ${step.saved} bytes (${step.percentage}%)`);
      console.log('');
    });
    
    console.log(`Final size: ${stats.final} bytes`);
    console.log(`Total saved: ${stats.totalSaved} bytes (${stats.totalPercentage}%)`);
  }
}

const pipeline = new OptimizationPipeline();

pipeline
  .addOptimizer('Remove Comments', (code) => {
    return code.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
  })
  .addOptimizer('Remove Whitespace', (code) => {
    return code.replace(/\s+/g, ' ').trim();
  })
  .addOptimizer('Shorten Variables', (code) => {
    // Simple example: just demonstrate the concept
    return code
      .replace(/veryLongVariableName/g, 'a')
      .replace(/anotherLongName/g, 'b');
  });

const sampleCode = `
  // This is a comment
  const veryLongVariableName = 42;
  const anotherLongName = 'hello';
  
  /* Multi-line
     comment */
  function test() {
    console.log(veryLongVariableName, anotherLongName);
  }
`;

pipeline.optimize(sampleCode).then(result => {
  pipeline.printStats(result.stats);
  console.log('\nOptimized code:', result.code);
});
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Module Bundler Concepts:
┌──────────────────────┬────────────────────────────────┐
│ Concept              │ Description                    │
├──────────────────────┼────────────────────────────────┤
│ Entry Point          │ Starting module for bundling   │
│ Dependency Graph     │ Tree of module dependencies    │
│ Module Resolution    │ Find modules by path/name      │
│ Parsing              │ Extract imports/exports (AST)  │
│ Transformation       │ Convert module formats         │
│ Code Generation      │ Produce final bundle           │
│ Tree Shaking         │ Remove unused code             │
│ Code Splitting       │ Divide into multiple chunks    │
│ Hot Module Replace   │ Update modules without reload  │
└──────────────────────┴────────────────────────────────┘

Module Formats:
┌──────────────┬────────────────────────────────────┐
│ Format       │ Syntax                             │
├──────────────┼────────────────────────────────────┤
│ CommonJS     │ require() / module.exports         │
│              │ Node.js default                    │
├──────────────┼────────────────────────────────────┤
│ ES Modules   │ import/export                      │
│              │ Browser & modern Node              │
├──────────────┼────────────────────────────────────┤
│ AMD          │ define() / require()               │
│              │ RequireJS, legacy browser          │
├──────────────┼────────────────────────────────────┤
│ UMD          │ Universal (works everywhere)       │
│              │ Combines CJS, AMD, globals         │
└──────────────┴────────────────────────────────────┘

Build Phases:
1. Parse: Read source files, build AST
2. Resolve: Find all dependencies
3. Transform: Convert syntax (Babel, TypeScript)
4. Optimize: Minify, tree shake, dedupe
5. Emit: Write output files

Optimization Techniques:
• Tree shaking: remove unused exports
• Dead code elimination: remove unreachable code
• Minification: remove whitespace, shorten names
• Code splitting: lazy load chunks
• Scope hoisting: flatten module scopes
• Deduplication: merge identical modules
• Compression: gzip/brotli output

Popular Bundlers:
• Webpack: full-featured, plugin ecosystem
• Rollup: ES modules, excellent tree shaking
• Parcel: zero-config, fast builds
• esbuild: extremely fast, Go-based
• Vite: fast dev server, Rollup for prod

Performance Factors:
• Dependency resolution: O(n) modules
• AST parsing: most expensive phase
• Transformation: depends on plugins
• Bundle size: affects load time
• Build time: dev experience

Best Practices:
• Use code splitting for large apps
• Enable tree shaking (ES modules)
• Minimize dependencies
• Use production builds
• Enable caching
• Lazy load routes/features
• Analyze bundle size regularly
• Use source maps for debugging

Real-World Features:
• Development server with HMR
• Asset pipeline (CSS, images)
• Multiple output targets
• Plugin system for extensibility
• Source maps for debugging
• Watch mode for development
• Optimization pipeline
• Dependency graph analysis
`);
```

**Interview Tips:**
- Module bundler: combines multiple files into one or more bundles for deployment
- Core process: parse modules → resolve dependencies → transform → bundle
- Entry point: starting module, builds dependency graph from there
- Dependency graph: tree structure showing which modules import which
- Module resolution: convert import paths to actual file paths
- AST (Abstract Syntax Tree): parsed representation of code, enables transformations
- CommonJS vs ES modules: require/exports vs import/export
- Tree shaking: remove unused exports, requires static analysis (ES modules)
- Code splitting: divide bundle into chunks loaded on-demand
- Lazy loading: load chunks when needed (reduces initial load time)
- HMR (Hot Module Replacement): update modules without full page reload
- Scope hoisting: flatten module wrappers, reduces overhead
- Minification: remove whitespace, shorten names, optimize code
- Source maps: map bundled code back to original for debugging
- Plugin system: extensibility (loaders, transforms, optimizations)
- Webpack: most popular, full-featured, complex config
- Rollup: excellent tree shaking, ES module focus
- Vite/esbuild: modern, extremely fast builds
- Build phases: parse → resolve → transform → optimize → emit
- Performance: AST parsing is expensive, caching helps
- Real-world: dev server, asset pipeline, multi-target, optimization
- Trade-offs: build time vs bundle size vs features
- Follow-ups: circular deps, async imports, chunking strategy, caching
- Clarify: target environment? module format? optimization level? plugin needs?

</details>

121. Implement a custom pipe for filtering data

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Angular Pipe**
```typescript
/**
 * Simple filter pipe for Angular
 */

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filter'
})
export class FilterPipe implements PipeTransform {
  transform(items: any[], searchTerm: string, property?: string): any[] {
    if (!items || !searchTerm) {
      return items;
    }
    
    searchTerm = searchTerm.toLowerCase();
    
    return items.filter(item => {
      if (property) {
        // Filter by specific property
        const value = this.getNestedProperty(item, property);
        return value && value.toString().toLowerCase().includes(searchTerm);
      } else {
        // Filter by any property
        return Object.values(item).some(value => 
          value && value.toString().toLowerCase().includes(searchTerm)
        );
      }
    });
  }
  
  private getNestedProperty(obj: any, path: string): any {
    return path.split('.').reduce((current, prop) => 
      current ? current[prop] : null, obj
    );
  }
}

// Usage in component:
/*
@Component({
  selector: 'app-users',
  template: `
    <input [(ngModel)]="searchTerm" placeholder="Search...">
    
    <div *ngFor="let user of users | filter:searchTerm:'name'">
      {{ user.name }} - {{ user.email }}
    </div>
  `
})
export class UsersComponent {
  searchTerm = '';
  users = [
    { name: 'Alice', email: 'alice@example.com', age: 25 },
    { name: 'Bob', email: 'bob@example.com', age: 30 },
    { name: 'Charlie', email: 'charlie@example.com', age: 35 }
  ];
}
*/

console.log('=== Basic Angular Filter Pipe ===');
console.log('Filters array by search term');
console.log('Usage: items | filter:searchTerm:property');
```

### **Approach 2: Multi-Criteria Filter Pipe**
```typescript
/**
 * Advanced filter with multiple criteria
 */

import { Pipe, PipeTransform } from '@angular/core';

interface FilterCriteria {
  property: string;
  value: any;
  operator?: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'gt' | 'lt' | 'gte' | 'lte';
}

@Pipe({
  name: 'advancedFilter'
})
export class AdvancedFilterPipe implements PipeTransform {
  transform(items: any[], criteria: FilterCriteria | FilterCriteria[]): any[] {
    if (!items || !criteria) {
      return items;
    }
    
    const criteriaArray = Array.isArray(criteria) ? criteria : [criteria];
    
    return items.filter(item => {
      return criteriaArray.every(criterion => 
        this.matchesCriterion(item, criterion)
      );
    });
  }
  
  private matchesCriterion(item: any, criterion: FilterCriteria): boolean {
    const value = this.getNestedProperty(item, criterion.property);
    const filterValue = criterion.value;
    const operator = criterion.operator || 'equals';
    
    if (value === null || value === undefined) {
      return false;
    }
    
    switch (operator) {
      case 'equals':
        return value === filterValue;
        
      case 'contains':
        return value.toString().toLowerCase()
          .includes(filterValue.toString().toLowerCase());
        
      case 'startsWith':
        return value.toString().toLowerCase()
          .startsWith(filterValue.toString().toLowerCase());
        
      case 'endsWith':
        return value.toString().toLowerCase()
          .endsWith(filterValue.toString().toLowerCase());
        
      case 'gt':
        return value > filterValue;
        
      case 'lt':
        return value < filterValue;
        
      case 'gte':
        return value >= filterValue;
        
      case 'lte':
        return value <= filterValue;
        
      default:
        return false;
    }
  }
  
  private getNestedProperty(obj: any, path: string): any {
    return path.split('.').reduce((current, prop) => 
      current ? current[prop] : null, obj
    );
  }
}

// Usage:
/*
@Component({
  template: `
    <!-- Single criterion -->
    <div *ngFor="let user of users | advancedFilter:{property: 'age', value: 30, operator: 'gt'}">
      {{ user.name }} ({{ user.age }})
    </div>
    
    <!-- Multiple criteria -->
    <div *ngFor="let user of users | advancedFilter:[
      {property: 'age', value: 25, operator: 'gte'},
      {property: 'name', value: 'a', operator: 'contains'}
    ]">
      {{ user.name }}
    </div>
  `
})
*/

console.log('\n=== Advanced Filter Pipe ===');
console.log('Supports multiple operators: equals, contains, gt, lt, etc.');
console.log('Can chain multiple criteria');
```

### **Approach 3: Pure vs Impure Pipes**
```typescript
/**
 * Demonstrate pure vs impure pipes
 */

// Pure pipe (default) - only runs when input reference changes
@Pipe({
  name: 'pureFilter',
  pure: true // Default
})
export class PureFilterPipe implements PipeTransform {
  transform(items: any[], searchTerm: string): any[] {
    console.log('PureFilter transform called');
    
    if (!items || !searchTerm) {
      return items;
    }
    
    return items.filter(item => 
      JSON.stringify(item).toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
}

// Impure pipe - runs on every change detection cycle
@Pipe({
  name: 'impureFilter',
  pure: false
})
export class ImpureFilterPipe implements PipeTransform {
  transform(items: any[], searchTerm: string): any[] {
    console.log('ImpureFilter transform called');
    
    if (!items || !searchTerm) {
      return items;
    }
    
    return items.filter(item => 
      JSON.stringify(item).toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
}

// Usage comparison:
/*
@Component({
  template: `
    <input [(ngModel)]="searchTerm">
    
    <!-- Pure pipe: only re-runs when items reference or searchTerm changes -->
    <div *ngFor="let item of items | pureFilter:searchTerm">
      {{ item.name }}
    </div>
    
    <!-- Impure pipe: re-runs on every change detection -->
    <div *ngFor="let item of items | impureFilter:searchTerm">
      {{ item.name }}
    </div>
    
    <button (click)="addItem()">Add Item</button>
  `
})
export class PipeComparisonComponent {
  searchTerm = '';
  items = [{ name: 'Item 1' }];
  
  addItem() {
    // Pure pipe won't detect this change (same reference)
    this.items.push({ name: 'Item ' + (this.items.length + 1) });
    
    // To trigger pure pipe, create new array:
    // this.items = [...this.items, { name: 'Item ' + (this.items.length + 1) }];
  }
}
*/

console.log('\n=== Pure vs Impure Pipes ===');
console.log('Pure: Only runs on reference change (performance)');
console.log('Impure: Runs every change detection (flexible but slower)');
```

### **Approach 4: Memoized Filter Pipe**
```typescript
/**
 * Cache results for better performance
 */

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'memoizedFilter'
})
export class MemoizedFilterPipe implements PipeTransform {
  private cache = new Map<string, any[]>();
  
  transform(items: any[], searchTerm: string, property?: string): any[] {
    if (!items || !searchTerm) {
      return items;
    }
    
    // Create cache key
    const cacheKey = this.getCacheKey(items, searchTerm, property);
    
    // Return cached result if available
    if (this.cache.has(cacheKey)) {
      console.log('Returning cached result');
      return this.cache.get(cacheKey)!;
    }
    
    console.log('Computing new result');
    
    // Compute result
    searchTerm = searchTerm.toLowerCase();
    
    const result = items.filter(item => {
      if (property) {
        const value = item[property];
        return value && value.toString().toLowerCase().includes(searchTerm);
      } else {
        return Object.values(item).some(value => 
          value && value.toString().toLowerCase().includes(searchTerm)
        );
      }
    });
    
    // Cache result (limit cache size)
    if (this.cache.size > 100) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(cacheKey, result);
    
    return result;
  }
  
  private getCacheKey(items: any[], searchTerm: string, property?: string): string {
    // Simple hash based on array length, search term, and property
    return `${items.length}-${searchTerm}-${property || 'all'}`;
  }
}

console.log('\n=== Memoized Filter Pipe ===');
console.log('Caches results to avoid recomputation');
console.log('Good for expensive filters on large datasets');
```

### **Approach 5: Async Filter Pipe**
```typescript
/**
 * Filter with async operations (API search)
 */

import { Pipe, PipeTransform } from '@angular/core';
import { Observable, of, BehaviorSubject } from 'rxjs';
import { debounceTime, distinctUntilChanged, switchMap, catchError } from 'rxjs/operators';

@Pipe({
  name: 'asyncFilter'
})
export class AsyncFilterPipe implements PipeTransform {
  private searchSubject = new BehaviorSubject<string>('');
  
  transform(items: any[], searchTerm: string): Observable<any[]> {
    if (!searchTerm) {
      return of(items);
    }
    
    this.searchSubject.next(searchTerm);
    
    return this.searchSubject.pipe(
      debounceTime(300), // Wait 300ms after last keystroke
      distinctUntilChanged(), // Only if changed
      switchMap(term => this.performSearch(items, term)),
      catchError(error => {
        console.error('Search error:', error);
        return of(items);
      })
    );
  }
  
  private performSearch(items: any[], searchTerm: string): Observable<any[]> {
    // Simulate async operation (e.g., API call)
    return new Observable(observer => {
      setTimeout(() => {
        const filtered = items.filter(item => 
          JSON.stringify(item).toLowerCase().includes(searchTerm.toLowerCase())
        );
        observer.next(filtered);
        observer.complete();
      }, 100);
    });
  }
}

// Usage with async pipe:
/*
@Component({
  template: `
    <input [(ngModel)]="searchTerm">
    
    <div *ngFor="let item of (items | asyncFilter:searchTerm | async)">
      {{ item.name }}
    </div>
  `
})
*/

console.log('\n=== Async Filter Pipe ===');
console.log('Supports debouncing and async operations');
console.log('Good for API-based searches');
```

### **Real-World Use Cases**
```typescript
/**
 * Practical pipe implementations
 */

// 1. Table Filter Pipe
console.log('\n=== Table Filter Pipe ===');

@Pipe({
  name: 'tableFilter'
})
export class TableFilterPipe implements PipeTransform {
  transform(
    items: any[], 
    filters: { [key: string]: any },
    globalSearch?: string
  ): any[] {
    if (!items) return [];
    
    let filtered = items;
    
    // Apply column-specific filters
    if (filters) {
      filtered = filtered.filter(item => {
        return Object.keys(filters).every(key => {
          const filterValue = filters[key];
          
          if (!filterValue) return true;
          
          const itemValue = item[key];
          
          if (itemValue === null || itemValue === undefined) {
            return false;
          }
          
          // Handle different types
          if (typeof filterValue === 'boolean') {
            return itemValue === filterValue;
          }
          
          if (typeof filterValue === 'number') {
            return itemValue === filterValue;
          }
          
          if (Array.isArray(filterValue)) {
            return filterValue.includes(itemValue);
          }
          
          return itemValue.toString().toLowerCase()
            .includes(filterValue.toString().toLowerCase());
        });
      });
    }
    
    // Apply global search
    if (globalSearch) {
      const search = globalSearch.toLowerCase();
      filtered = filtered.filter(item => {
        return Object.values(item).some(value => 
          value && value.toString().toLowerCase().includes(search)
        );
      });
    }
    
    return filtered;
  }
}

/*
Usage:
<input [(ngModel)]="globalSearch" placeholder="Search all...">

<table>
  <thead>
    <tr>
      <th>Name <input [(ngModel)]="filters.name"></th>
      <th>Status <select [(ngModel)]="filters.status">...</select></th>
      <th>Age <input [(ngModel)]="filters.age" type="number"></th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let user of users | tableFilter:filters:globalSearch">
      <td>{{ user.name }}</td>
      <td>{{ user.status }}</td>
      <td>{{ user.age }}</td>
    </tr>
  </tbody>
</table>
*/

// 2. Date Range Filter Pipe
console.log('\n=== Date Range Filter ===');

interface DateRange {
  start?: Date;
  end?: Date;
}

@Pipe({
  name: 'dateRangeFilter'
})
export class DateRangeFilterPipe implements PipeTransform {
  transform(items: any[], dateProperty: string, range: DateRange): any[] {
    if (!items || !range || (!range.start && !range.end)) {
      return items;
    }
    
    return items.filter(item => {
      const date = new Date(item[dateProperty]);
      
      if (isNaN(date.getTime())) {
        return false;
      }
      
      if (range.start && date < range.start) {
        return false;
      }
      
      if (range.end && date > range.end) {
        return false;
      }
      
      return true;
    });
  }
}

/*
Usage:
<input type="date" [(ngModel)]="dateRange.start">
<input type="date" [(ngModel)]="dateRange.end">

<div *ngFor="let order of orders | dateRangeFilter:'orderDate':dateRange">
  {{ order.id }} - {{ order.orderDate | date }}
</div>
*/

// 3. Fuzzy Search Pipe
console.log('\n=== Fuzzy Search Pipe ===');

@Pipe({
  name: 'fuzzySearch'
})
export class FuzzySearchPipe implements PipeTransform {
  transform(items: any[], searchTerm: string, properties: string[]): any[] {
    if (!items || !searchTerm) {
      return items;
    }
    
    const pattern = searchTerm.toLowerCase().split('').join('.*');
    const regex = new RegExp(pattern);
    
    return items.filter(item => {
      return properties.some(prop => {
        const value = item[prop];
        if (!value) return false;
        
        return regex.test(value.toString().toLowerCase());
      });
    }).sort((a, b) => {
      // Sort by relevance (exact match first)
      const aScore = this.getRelevanceScore(a, searchTerm, properties);
      const bScore = this.getRelevanceScore(b, searchTerm, properties);
      return bScore - aScore;
    });
  }
  
  private getRelevanceScore(item: any, searchTerm: string, properties: string[]): number {
    let score = 0;
    
    properties.forEach(prop => {
      const value = item[prop]?.toString().toLowerCase() || '';
      const term = searchTerm.toLowerCase();
      
      if (value === term) {
        score += 100; // Exact match
      } else if (value.startsWith(term)) {
        score += 50; // Starts with
      } else if (value.includes(term)) {
        score += 25; // Contains
      } else {
        score += 1; // Fuzzy match
      }
    });
    
    return score;
  }
}

/*
Usage:
<input [(ngModel)]="searchTerm" placeholder="Fuzzy search...">

<div *ngFor="let user of users | fuzzySearch:searchTerm:['name', 'email']">
  {{ user.name }} - {{ user.email }}
</div>

Example: searching "jn" will match "John", "Jane", "Jonathan"
*/

// 4. Category Filter Pipe
console.log('\n=== Category Filter ===');

@Pipe({
  name: 'categoryFilter'
})
export class CategoryFilterPipe implements PipeTransform {
  transform(
    items: any[], 
    selectedCategories: string[], 
    categoryProperty: string = 'category'
  ): any[] {
    if (!items || !selectedCategories || selectedCategories.length === 0) {
      return items;
    }
    
    return items.filter(item => {
      const itemCategory = item[categoryProperty];
      
      // Handle single category
      if (typeof itemCategory === 'string') {
        return selectedCategories.includes(itemCategory);
      }
      
      // Handle multiple categories (array)
      if (Array.isArray(itemCategory)) {
        return itemCategory.some(cat => selectedCategories.includes(cat));
      }
      
      return false;
    });
  }
}

/*
Usage:
<div class="filters">
  <label *ngFor="let category of categories">
    <input 
      type="checkbox" 
      [value]="category"
      (change)="toggleCategory(category)"
      [checked]="selectedCategories.includes(category)">
    {{ category }}
  </label>
</div>

<div *ngFor="let product of products | categoryFilter:selectedCategories">
  {{ product.name }} - {{ product.category }}
</div>
*/

// 5. Price Range Filter Pipe
console.log('\n=== Price Range Filter ===');

interface PriceRange {
  min?: number;
  max?: number;
}

@Pipe({
  name: 'priceRangeFilter'
})
export class PriceRangeFilterPipe implements PipeTransform {
  transform(
    items: any[], 
    range: PriceRange, 
    priceProperty: string = 'price'
  ): any[] {
    if (!items || !range) {
      return items;
    }
    
    return items.filter(item => {
      const price = parseFloat(item[priceProperty]);
      
      if (isNaN(price)) {
        return false;
      }
      
      if (range.min !== undefined && price < range.min) {
        return false;
      }
      
      if (range.max !== undefined && price > range.max) {
        return false;
      }
      
      return true;
    });
  }
}

/*
Usage:
<div class="price-filter">
  <label>
    Min: <input type="number" [(ngModel)]="priceRange.min">
  </label>
  <label>
    Max: <input type="number" [(ngModel)]="priceRange.max">
  </label>
</div>

<div *ngFor="let product of products | priceRangeFilter:priceRange">
  {{ product.name }} - ${{ product.price }}
</div>
*/

// 6. Search Highlight Pipe
console.log('\n=== Search Highlight ===');

@Pipe({
  name: 'highlight'
})
export class HighlightPipe implements PipeTransform {
  transform(text: string, search: string): string {
    if (!search || !text) {
      return text;
    }
    
    const pattern = search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(pattern, 'gi');
    
    return text.replace(regex, match => `<mark>${match}</mark>`);
  }
}

/*
Usage:
<input [(ngModel)]="searchTerm">

<div *ngFor="let user of users | filter:searchTerm">
  <div [innerHTML]="user.name | highlight:searchTerm"></div>
  <div [innerHTML]="user.email | highlight:searchTerm"></div>
</div>

CSS:
mark {
  background-color: yellow;
  font-weight: bold;
}
*/

// 7. Sort and Filter Combined
console.log('\n=== Sort and Filter ===');

interface SortConfig {
  property: string;
  direction: 'asc' | 'desc';
}

@Pipe({
  name: 'sortAndFilter'
})
export class SortAndFilterPipe implements PipeTransform {
  transform(
    items: any[], 
    searchTerm: string, 
    sortConfig?: SortConfig
  ): any[] {
    if (!items) return [];
    
    let result = [...items];
    
    // Filter
    if (searchTerm) {
      const search = searchTerm.toLowerCase();
      result = result.filter(item => 
        Object.values(item).some(value => 
          value && value.toString().toLowerCase().includes(search)
        )
      );
    }
    
    // Sort
    if (sortConfig) {
      result.sort((a, b) => {
        const aValue = a[sortConfig.property];
        const bValue = b[sortConfig.property];
        
        let comparison = 0;
        
        if (aValue > bValue) {
          comparison = 1;
        } else if (aValue < bValue) {
          comparison = -1;
        }
        
        return sortConfig.direction === 'asc' ? comparison : -comparison;
      });
    }
    
    return result;
  }
}

/*
Usage:
<input [(ngModel)]="searchTerm" placeholder="Search...">

<button (click)="setSortConfig('name', 'asc')">Name ↑</button>
<button (click)="setSortConfig('name', 'desc')">Name ↓</button>
<button (click)="setSortConfig('age', 'asc')">Age ↑</button>

<div *ngFor="let user of users | sortAndFilter:searchTerm:sortConfig">
  {{ user.name }} - {{ user.age }}
</div>
*/
```

### **Performance Comparison**
```typescript
console.log('\n=== Performance ===');

console.log(`
Angular Pipe Concepts:
┌──────────────────────┬────────────────────────────────┐
│ Concept              │ Description                    │
├──────────────────────┼────────────────────────────────┤
│ Pure Pipe            │ Only runs on input reference   │
│ (default)            │ change. Better performance     │
├──────────────────────┼────────────────────────────────┤
│ Impure Pipe          │ Runs on every change detection │
│ (pure: false)        │ More flexible, slower          │
├──────────────────────┼────────────────────────────────┤
│ Memoization          │ Cache results to avoid recomp  │
│                      │ Good for expensive operations  │
├──────────────────────┼────────────────────────────────┤
│ Async Pipe           │ Subscribe to Observable/Promise│
│                      │ Auto unsubscribe, clean        │
└──────────────────────┴────────────────────────────────┘

Pipe Best Practices:
• Default to pure pipes (performance)
• Keep transform logic simple
• Don't mutate input arrays
• Use memoization for expensive operations
• Consider async operations separately
• Avoid side effects in transform
• Return new array, don't modify original
• Use type safety with TypeScript
• Document complex filter logic
• Test with various data sizes

Performance Tips:
• Pure pipes: only run on reference change
  - Use immutable operations (map, filter, etc.)
  - Create new array: [...items, newItem]
  - Triggers pipe: this.items = [...this.items]
  
• Impure pipes: run every change detection
  - Use sparingly, only when necessary
  - Can cause performance issues
  - Good for: date/time, random values
  
• Caching: store results for repeated inputs
  - Use WeakMap for object keys
  - Limit cache size
  - Clear cache periodically

Common Filter Operations:
• Text search: includes, startsWith, endsWith
• Numeric range: min/max filtering
• Date range: between two dates
• Category: filter by selected categories
• Multi-criteria: combine multiple filters
• Fuzzy search: approximate matching
• Regex: pattern-based filtering

Real-World Patterns:
• Table filtering (column + global search)
• E-commerce (price, category, rating)
• Date pickers (date range filtering)
• Search with highlighting
• Sort + filter combined
• Faceted search (multiple dimensions)
• Auto-complete with debouncing

Testing Pipes:
• Unit test transform method
• Test edge cases (null, undefined, empty)
• Test different input types
• Test performance with large datasets
• Mock dependencies (services)
• Test pure vs impure behavior

Common Pitfalls:
• Forgetting to return items if no filter
• Mutating input array (breaks change detection)
• Expensive operations in impure pipes
• Not handling null/undefined
• Memory leaks with impure pipes
• Over-filtering (removing too much)
`);
```

**Interview Tips:**
- Pipe: transform data in Angular templates using | syntax
- PipeTransform interface: implement transform() method
- Pure pipe (default): only runs when input reference changes (performance)
- Impure pipe (pure: false): runs every change detection cycle (flexible but slower)
- Use @Pipe decorator with name property
- Transform method: receives value and optional parameters
- Pure pipes require immutable operations: [...array] instead of array.push()
- Memoization: cache results to avoid recomputation
- Multiple parameters: pipe:param1:param2:param3
- Return items if no filter (important for null/undefined)
- Don't mutate input array, return new array
- Async pipe: subscribe to Observable/Promise, auto unsubscribe
- Chaining pipes: value | pipe1 | pipe2 | pipe3
- Common use cases: filter, sort, search, date range, price range
- Performance: pure pipes are fast, impure can cause issues with large datasets
- Testing: unit test transform method with various inputs
- Best practice: keep logic simple, avoid side effects
- Real-world: table filters, e-commerce filters, search with highlight
- Trade-offs: pure (fast, limited) vs impure (flexible, slow)
- Follow-ups: async operations, complex criteria, performance optimization
- Clarify: pure or impure? caching needed? multiple parameters? async?

</details>

122. Create a custom directive for input validation

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Validation Directive**
```typescript
/**
 * Simple email validation directive
 */

import { Directive, Input } from '@angular/core';
import { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors } from '@angular/forms';

@Directive({
  selector: '[appEmailValidator]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: EmailValidatorDirective,
    multi: true
  }]
})
export class EmailValidatorDirective implements Validator {
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value) {
      return null; // Don't validate empty values
    }
    
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    const valid = emailRegex.test(control.value);
    
    return valid ? null : { email: { value: control.value } };
  }
}

// Usage in template:
/*
<form #form="ngForm">
  <input 
    type="email" 
    name="email" 
    [(ngModel)]="user.email"
    appEmailValidator
    #emailField="ngModel">
  
  <div *ngIf="emailField.invalid && emailField.touched">
    <span *ngIf="emailField.errors?.['email']">
      Please enter a valid email address
    </span>
  </div>
</form>
*/

console.log('=== Basic Email Validation Directive ===');
console.log('Validates email format using regex');
console.log('Integrates with Angular forms (template-driven)');
```

### **Approach 2: Parameterized Validation Directive**
```typescript
/**
 * Min/Max length validator with custom parameters
 */

import { Directive, Input } from '@angular/core';
import { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors } from '@angular/forms';

@Directive({
  selector: '[appMinMax]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: MinMaxValidatorDirective,
    multi: true
  }]
})
export class MinMaxValidatorDirective implements Validator {
  @Input('appMinMax') minMax?: { min?: number; max?: number };
  
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value || !this.minMax) {
      return null;
    }
    
    const length = control.value.toString().length;
    const errors: ValidationErrors = {};
    
    if (this.minMax.min !== undefined && length < this.minMax.min) {
      errors['minLength'] = {
        requiredLength: this.minMax.min,
        actualLength: length
      };
    }
    
    if (this.minMax.max !== undefined && length > this.minMax.max) {
      errors['maxLength'] = {
        requiredLength: this.minMax.max,
        actualLength: length
      };
    }
    
    return Object.keys(errors).length > 0 ? errors : null;
  }
}

// Usage:
/*
<input 
  [(ngModel)]="username"
  name="username"
  [appMinMax]="{min: 3, max: 20}"
  #usernameField="ngModel">

<div *ngIf="usernameField.errors?.['minLength']">
  Minimum {{ usernameField.errors?.['minLength'].requiredLength }} characters
</div>
<div *ngIf="usernameField.errors?.['maxLength']">
  Maximum {{ usernameField.errors?.['maxLength'].requiredLength }} characters
</div>
*/

console.log('\n=== Parameterized Min/Max Directive ===');
console.log('Accepts min/max parameters via @Input');
console.log('Provides detailed error information');
```

### **Approach 3: Pattern Matching Directive**
```typescript
/**
 * Custom pattern validator with common presets
 */

import { Directive, Input } from '@angular/core';
import { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors } from '@angular/forms';

type PatternType = 'phone' | 'zipCode' | 'creditCard' | 'url' | 'alphanumeric' | 'custom';

@Directive({
  selector: '[appPattern]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: PatternValidatorDirective,
    multi: true
  }]
})
export class PatternValidatorDirective implements Validator {
  @Input('appPattern') patternType?: PatternType;
  @Input('appPatternCustom') customPattern?: string;
  
  private patterns: Record<PatternType, RegExp> = {
    phone: /^\+?1?\d{9,15}$/,
    zipCode: /^\d{5}(-\d{4})?$/,
    creditCard: /^\d{4}\s?\d{4}\s?\d{4}\s?\d{4}$/,
    url: /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,
    alphanumeric: /^[a-zA-Z0-9]+$/,
    custom: /.*/
  };
  
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value || !this.patternType) {
      return null;
    }
    
    let pattern: RegExp;
    
    if (this.patternType === 'custom' && this.customPattern) {
      pattern = new RegExp(this.customPattern);
    } else {
      pattern = this.patterns[this.patternType];
    }
    
    const valid = pattern.test(control.value);
    
    return valid ? null : {
      pattern: {
        type: this.patternType,
        value: control.value,
        requiredPattern: pattern.toString()
      }
    };
  }
}

// Usage:
/*
<!-- Phone validation -->
<input 
  [(ngModel)]="phone"
  name="phone"
  appPattern="phone"
  #phoneField="ngModel">

<!-- Custom pattern -->
<input 
  [(ngModel)]="code"
  name="code"
  appPattern="custom"
  appPatternCustom="^[A-Z]{3}\d{3}$"
  #codeField="ngModel">

<div *ngIf="phoneField.errors?.['pattern']">
  Invalid {{ phoneField.errors?.['pattern'].type }} format
</div>
*/

console.log('\n=== Pattern Matching Directive ===');
console.log('Supports common patterns: phone, zipCode, creditCard, url');
console.log('Also supports custom regex patterns');
```

### **Approach 4: Async Validation Directive**
```typescript
/**
 * Async validator (check username availability)
 */

import { Directive, Input } from '@angular/core';
import { NG_ASYNC_VALIDATORS, AsyncValidator, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, debounceTime, switchMap, catchError } from 'rxjs/operators';

@Directive({
  selector: '[appUniqueUsername]',
  providers: [{
    provide: NG_ASYNC_VALIDATORS,
    useExisting: UniqueUsernameValidatorDirective,
    multi: true
  }]
})
export class UniqueUsernameValidatorDirective implements AsyncValidator {
  @Input('appUniqueUsername') existingUsernames: string[] = [];
  
  validate(control: AbstractControl): Observable<ValidationErrors | null> {
    if (!control.value) {
      return of(null);
    }
    
    // Simulate API call to check username
    return of(control.value).pipe(
      debounceTime(500), // Wait 500ms after user stops typing
      switchMap(username => this.checkUsername(username)),
      map(isTaken => isTaken ? { usernameTaken: { value: control.value } } : null),
      catchError(() => of(null))
    );
  }
  
  private checkUsername(username: string): Observable<boolean> {
    // Simulate API call
    return new Observable(observer => {
      setTimeout(() => {
        const taken = this.existingUsernames.includes(username.toLowerCase());
        observer.next(taken);
        observer.complete();
      }, 300);
    });
  }
}

// Usage:
/*
<input 
  [(ngModel)]="username"
  name="username"
  [appUniqueUsername]="['admin', 'user', 'test']"
  #usernameField="ngModel">

<div *ngIf="usernameField.pending">
  Checking username...
</div>
<div *ngIf="usernameField.errors?.['usernameTaken']">
  Username is already taken
</div>
*/

console.log('\n=== Async Validation Directive ===');
console.log('Validates against API (simulated)');
console.log('Uses debounceTime to reduce API calls');
```

### **Approach 5: Cross-Field Validation Directive**
```typescript
/**
 * Compare two fields (e.g., password confirmation)
 */

import { Directive, Input } from '@angular/core';
import { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors, FormGroup } from '@angular/forms';

@Directive({
  selector: '[appMatchFields]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: MatchFieldsValidatorDirective,
    multi: true
  }]
})
export class MatchFieldsValidatorDirective implements Validator {
  @Input('appMatchFields') fieldToMatch?: string;
  
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value || !this.fieldToMatch) {
      return null;
    }
    
    const parent = control.parent as FormGroup;
    
    if (!parent) {
      return null;
    }
    
    const matchControl = parent.get(this.fieldToMatch);
    
    if (!matchControl) {
      return null;
    }
    
    const match = control.value === matchControl.value;
    
    return match ? null : {
      fieldMismatch: {
        field: this.fieldToMatch,
        value: control.value
      }
    };
  }
}

// Usage:
/*
<form #form="ngForm">
  <input 
    type="password"
    [(ngModel)]="password"
    name="password"
    #passwordField="ngModel">
  
  <input 
    type="password"
    [(ngModel)]="confirmPassword"
    name="confirmPassword"
    appMatchFields="password"
    #confirmField="ngModel">
  
  <div *ngIf="confirmField.errors?.['fieldMismatch'] && confirmField.touched">
    Passwords do not match
  </div>
</form>
*/

console.log('\n=== Cross-Field Validation ===');
console.log('Compares two fields (e.g., password confirmation)');
console.log('Accesses parent form to get other field');
```

### **Real-World Use Cases**
```typescript
/**
 * Practical validation directives
 */

// 1. Credit Card Validator with Luhn Algorithm
console.log('\n=== Credit Card Validator ===');

@Directive({
  selector: '[appCreditCard]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: CreditCardValidatorDirective,
    multi: true
  }]
})
export class CreditCardValidatorDirective implements Validator {
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value) {
      return null;
    }
    
    const cardNumber = control.value.replace(/\s/g, '');
    
    // Check if only digits
    if (!/^\d+$/.test(cardNumber)) {
      return { creditCard: { message: 'Must contain only digits' } };
    }
    
    // Check length (13-19 digits)
    if (cardNumber.length < 13 || cardNumber.length > 19) {
      return { creditCard: { message: 'Invalid length' } };
    }
    
    // Luhn algorithm
    if (!this.luhnCheck(cardNumber)) {
      return { creditCard: { message: 'Invalid card number' } };
    }
    
    return null;
  }
  
  private luhnCheck(cardNumber: string): boolean {
    let sum = 0;
    let isEven = false;
    
    // Loop through values from right to left
    for (let i = cardNumber.length - 1; i >= 0; i--) {
      let digit = parseInt(cardNumber[i], 10);
      
      if (isEven) {
        digit *= 2;
        if (digit > 9) {
          digit -= 9;
        }
      }
      
      sum += digit;
      isEven = !isEven;
    }
    
    return sum % 10 === 0;
  }
}

/*
Usage:
<input 
  [(ngModel)]="cardNumber"
  name="cardNumber"
  appCreditCard
  #cardField="ngModel">

<div *ngIf="cardField.errors?.['creditCard']">
  {{ cardField.errors?.['creditCard'].message }}
</div>
*/

// 2. Password Strength Validator
console.log('\n=== Password Strength Validator ===');

interface PasswordStrength {
  hasMinLength: boolean;
  hasUpperCase: boolean;
  hasLowerCase: boolean;
  hasNumber: boolean;
  hasSpecialChar: boolean;
  strength: 'weak' | 'medium' | 'strong';
}

@Directive({
  selector: '[appPasswordStrength]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: PasswordStrengthValidatorDirective,
    multi: true
  }]
})
export class PasswordStrengthValidatorDirective implements Validator {
  @Input('appPasswordStrength') minStrength: 'weak' | 'medium' | 'strong' = 'medium';
  
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value) {
      return null;
    }
    
    const strength = this.calculateStrength(control.value);
    
    const strengthLevels = { weak: 1, medium: 2, strong: 3 };
    
    if (strengthLevels[strength.strength] < strengthLevels[this.minStrength]) {
      return {
        passwordStrength: {
          required: this.minStrength,
          actual: strength.strength,
          details: strength
        }
      };
    }
    
    return null;
  }
  
  private calculateStrength(password: string): PasswordStrength {
    const strength: PasswordStrength = {
      hasMinLength: password.length >= 8,
      hasUpperCase: /[A-Z]/.test(password),
      hasLowerCase: /[a-z]/.test(password),
      hasNumber: /\d/.test(password),
      hasSpecialChar: /[!@#$%^&*(),.?":{}|<>]/.test(password),
      strength: 'weak'
    };
    
    const score = Object.values(strength).filter(v => v === true).length;
    
    if (score >= 5) {
      strength.strength = 'strong';
    } else if (score >= 3) {
      strength.strength = 'medium';
    }
    
    return strength;
  }
}

/*
Usage:
<input 
  type="password"
  [(ngModel)]="password"
  name="password"
  appPasswordStrength="strong"
  #passwordField="ngModel">

<div *ngIf="passwordField.errors?.['passwordStrength']">
  <p>Password must be {{ passwordField.errors?.['passwordStrength'].required }}</p>
  <ul>
    <li [class.valid]="passwordField.errors?.['passwordStrength'].details.hasMinLength">
      At least 8 characters
    </li>
    <li [class.valid]="passwordField.errors?.['passwordStrength'].details.hasUpperCase">
      Contains uppercase letter
    </li>
    <li [class.valid]="passwordField.errors?.['passwordStrength'].details.hasLowerCase">
      Contains lowercase letter
    </li>
    <li [class.valid]="passwordField.errors?.['passwordStrength'].details.hasNumber">
      Contains number
    </li>
    <li [class.valid]="passwordField.errors?.['passwordStrength'].details.hasSpecialChar">
      Contains special character
    </li>
  </ul>
</div>
*/

// 3. Date Range Validator
console.log('\n=== Date Range Validator ===');

@Directive({
  selector: '[appDateRange]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: DateRangeValidatorDirective,
    multi: true
  }]
})
export class DateRangeValidatorDirective implements Validator {
  @Input('appDateRange') range?: { min?: Date; max?: Date };
  
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value || !this.range) {
      return null;
    }
    
    const date = new Date(control.value);
    
    if (isNaN(date.getTime())) {
      return { dateRange: { message: 'Invalid date' } };
    }
    
    if (this.range.min && date < this.range.min) {
      return {
        dateRange: {
          message: 'Date is before minimum',
          min: this.range.min,
          actual: date
        }
      };
    }
    
    if (this.range.max && date > this.range.max) {
      return {
        dateRange: {
          message: 'Date is after maximum',
          max: this.range.max,
          actual: date
        }
      };
    }
    
    return null;
  }
}

/*
Usage:
<input 
  type="date"
  [(ngModel)]="birthDate"
  name="birthDate"
  [appDateRange]="{min: minDate, max: maxDate}"
  #dateField="ngModel">

Component:
minDate = new Date(1900, 0, 1);
maxDate = new Date();
*/

// 4. File Upload Validator
console.log('\n=== File Upload Validator ===');

@Directive({
  selector: '[appFileValidation]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: FileValidationDirective,
    multi: true
  }]
})
export class FileValidationDirective implements Validator {
  @Input('appFileValidation') config?: {
    maxSize?: number; // in bytes
    allowedTypes?: string[]; // ['image/png', 'image/jpeg']
  };
  
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value || !this.config) {
      return null;
    }
    
    const file = control.value as File;
    
    // Check file size
    if (this.config.maxSize && file.size > this.config.maxSize) {
      return {
        fileValidation: {
          message: 'File too large',
          maxSize: this.config.maxSize,
          actualSize: file.size
        }
      };
    }
    
    // Check file type
    if (this.config.allowedTypes && !this.config.allowedTypes.includes(file.type)) {
      return {
        fileValidation: {
          message: 'Invalid file type',
          allowedTypes: this.config.allowedTypes,
          actualType: file.type
        }
      };
    }
    
    return null;
  }
}

/*
Usage:
<input 
  type="file"
  (change)="onFileSelected($event)"
  [appFileValidation]="{
    maxSize: 5242880,
    allowedTypes: ['image/png', 'image/jpeg', 'image/gif']
  }">

Component:
onFileSelected(event: Event) {
  const input = event.target as HTMLInputElement;
  if (input.files && input.files[0]) {
    this.selectedFile = input.files[0];
  }
}
*/

// 5. Conditional Validation Directive
console.log('\n=== Conditional Validator ===');

@Directive({
  selector: '[appConditionalValidator]',
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: ConditionalValidatorDirective,
    multi: true
  }]
})
export class ConditionalValidatorDirective implements Validator {
  @Input('appConditionalValidator') condition?: boolean;
  @Input('appConditionalValidatorType') validatorType?: 'required' | 'email' | 'minLength';
  @Input('appConditionalValidatorParam') param?: any;
  
  validate(control: AbstractControl): ValidationErrors | null {
    // Only validate if condition is true
    if (!this.condition) {
      return null;
    }
    
    if (!control.value) {
      return { required: true };
    }
    
    switch (this.validatorType) {
      case 'required':
        return control.value ? null : { required: true };
        
      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(control.value) ? null : { email: true };
        
      case 'minLength':
        const length = control.value.length;
        return length >= this.param ? null : {
          minLength: { requiredLength: this.param, actualLength: length }
        };
        
      default:
        return null;
    }
  }
}

/*
Usage:
<form #form="ngForm">
  <label>
    <input 
      type="checkbox" 
      [(ngModel)]="hasCompany"
      name="hasCompany">
    I work for a company
  </label>
  
  <input 
    [(ngModel)]="companyName"
    name="companyName"
    [appConditionalValidator]="hasCompany"
    appConditionalValidatorType="required"
    #companyField="ngModel">
  
  <div *ngIf="companyField.invalid && hasCompany">
    Company name is required
  </div>
</form>
*/

// 6. Custom Error Display Directive
console.log('\n=== Error Display Directive ===');

@Directive({
  selector: '[appShowErrors]'
})
export class ShowErrorsDirective {
  @Input('appShowErrors') control?: AbstractControl;
  
  constructor(private el: ElementRef, private renderer: Renderer2) {}
  
  ngOnInit() {
    if (!this.control) return;
    
    this.control.statusChanges?.subscribe(() => {
      this.updateErrors();
    });
    
    this.updateErrors();
  }
  
  private updateErrors() {
    if (!this.control) return;
    
    const errors = this.control.errors;
    const touched = this.control.touched;
    
    // Clear previous errors
    this.renderer.setProperty(this.el.nativeElement, 'innerHTML', '');
    
    if (errors && touched) {
      const errorMessages = this.getErrorMessages(errors);
      
      errorMessages.forEach(message => {
        const div = this.renderer.createElement('div');
        const text = this.renderer.createText(message);
        
        this.renderer.addClass(div, 'error-message');
        this.renderer.appendChild(div, text);
        this.renderer.appendChild(this.el.nativeElement, div);
      });
    }
  }
  
  private getErrorMessages(errors: ValidationErrors): string[] {
    const messages: string[] = [];
    
    if (errors['required']) {
      messages.push('This field is required');
    }
    
    if (errors['email']) {
      messages.push('Please enter a valid email');
    }
    
    if (errors['minLength']) {
      messages.push(`Minimum ${errors['minLength'].requiredLength} characters required`);
    }
    
    if (errors['maxLength']) {
      messages.push(`Maximum ${errors['maxLength'].requiredLength} characters allowed`);
    }
    
    if (errors['pattern']) {
      messages.push(`Invalid ${errors['pattern'].type} format`);
    }
    
    return messages;
  }
}

/*
Usage:
<input 
  [(ngModel)]="email"
  name="email"
  appEmailValidator
  #emailField="ngModel">

<div [appShowErrors]="emailField.control"></div>

CSS:
.error-message {
  color: red;
  font-size: 12px;
  margin-top: 4px;
}
*/

// 7. Debounced Validation Directive
console.log('\n=== Debounced Validator ===');

@Directive({
  selector: '[appDebouncedValidator]'
})
export class DebouncedValidatorDirective implements OnInit {
  @Input('appDebouncedValidator') debounceTime: number = 500;
  
  constructor(@Self() private ngControl: NgControl) {}
  
  ngOnInit() {
    if (!this.ngControl.control) return;
    
    // Store original value changes
    const originalValueChanges = this.ngControl.control.valueChanges;
    
    // Replace with debounced version
    this.ngControl.control.valueChanges = originalValueChanges?.pipe(
      debounceTime(this.debounceTime),
      distinctUntilChanged()
    );
  }
}

/*
Usage:
<input 
  [(ngModel)]="searchTerm"
  name="search"
  appDebouncedValidator
  [appDebouncedValidator]="800"
  #searchField="ngModel">
*/
```

### **Performance Comparison**
```typescript
console.log('\n=== Performance ===');

console.log(`
Angular Validation Concepts:
┌──────────────────────┬────────────────────────────────┐
│ Concept              │ Description                    │
├──────────────────────┼────────────────────────────────┤
│ Validator            │ Implements validate() method   │
│                      │ Returns ValidationErrors or null│
├──────────────────────┼────────────────────────────────┤
│ AsyncValidator       │ Returns Observable<Errors>     │
│                      │ Used for API calls             │
├──────────────────────┼────────────────────────────────┤
│ NG_VALIDATORS        │ Token for sync validators      │
│                      │ Register in providers array    │
├──────────────────────┼────────────────────────────────┤
│ NG_ASYNC_VALIDATORS  │ Token for async validators     │
│                      │ Separate from sync validators  │
├──────────────────────┼────────────────────────────────┤
│ ValidationErrors     │ Object with error details      │
│                      │ { errorKey: { ...details } }   │
└──────────────────────┴────────────────────────────────┘

Validation Best Practices:
• Return null for valid values
• Return ValidationErrors object for invalid
• Don't validate empty values (use required separately)
• Provide detailed error information
• Use multi: true in providers
• Debounce async validators
• Handle edge cases (null, undefined, empty string)
• Make directives reusable
• Type-safe with TypeScript
• Test thoroughly

Common Validation Types:
┌──────────────────┬────────────────────────────────┐
│ Type             │ Use Case                       │
├──────────────────┼────────────────────────────────┤
│ Format           │ Email, phone, URL, pattern     │
│ Length           │ Min/max characters             │
│ Range            │ Min/max numbers, dates         │
│ Comparison       │ Match fields (password confirm)│
│ Uniqueness       │ Check against API/database     │
│ Custom Logic     │ Business rules, complex checks │
│ File             │ Size, type, dimensions         │
└──────────────────┴────────────────────────────────┘

Directive Lifecycle:
1. Directive created and attached to element
2. @Input values bound
3. validate() called initially
4. validate() called on value changes
5. Errors propagated to form control
6. Template updated based on control state

Form Control States:
• valid/invalid: validation status
• pristine/dirty: user interaction
• touched/untouched: focus/blur events
• pending: async validation in progress
• disabled/enabled: control state

Error Display Strategies:
• Show on touch: touched && invalid
• Show on submit: submitted && invalid
• Show immediately: always show if invalid
• Show with delay: debounce error display
• Custom directive: automate error display

Integration Points:
• Template-driven forms: NG_VALIDATORS
• Reactive forms: add to FormControl/FormGroup
• Custom validators: implement Validator interface
• Async validators: implement AsyncValidator
• Cross-field: access parent FormGroup

Performance Optimization:
• Debounce async validators (reduce API calls)
• Cache validation results when possible
• Use pure functions for validation logic
• Avoid expensive operations in validate()
• Unsubscribe from observables properly
• Limit validator execution frequency

Real-World Patterns:
• Email format validation
• Password strength checking
• Credit card with Luhn algorithm
• Async username availability
• Cross-field password confirmation
• Conditional validation (show/hide)
• File upload restrictions
• Date range validation
• Custom pattern matching
• Auto-display errors

Testing Directives:
• Unit test validate() method
• Test with various input values
• Test edge cases (null, empty, invalid)
• Mock async operations
• Test error message content
• Test integration with forms
`);
```

**Interview Tips:**
- Validation directive: Angular directive that validates form input
- Implements Validator or AsyncValidator interface
- Register with NG_VALIDATORS or NG_ASYNC_VALIDATORS token
- multi: true allows multiple validators on same element
- validate() method: receives AbstractControl, returns ValidationErrors or null
- Return null for valid, { errorKey: details } for invalid
- ValidationErrors: object with error key and details
- Don't validate empty values (null check first)
- @Input for parameters: [appMinMax]="{min: 3, max: 20}"
- Async validators: return Observable<ValidationErrors | null>
- Use debounceTime for async validators (reduce API calls)
- Cross-field validation: access control.parent to get other fields
- Form states: valid/invalid, pristine/dirty, touched/untouched, pending
- Error display: check touched && invalid before showing
- Template-driven forms: attach directive to input element
- Reactive forms: add validator to FormControl
- Common validators: email, pattern, min/max length, required, custom logic
- Real-world: password strength, credit card (Luhn), async username check
- Performance: debounce, cache results, avoid expensive operations
- Trade-offs: sync (fast) vs async (flexible but slower)
- Follow-ups: async validation, cross-field, conditional, file upload
- Clarify: sync or async? parameters? error messages? integration with forms?

</details>

123. Build a custom async validator for forms

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Simple Username Availability Validator**
```typescript
/**
 * Check if username is available via API
 */

import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, catchError, debounceTime, switchMap } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';

export function usernameAvailabilityValidator(http: HttpClient): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }
    
    return of(control.value).pipe(
      debounceTime(500), // Wait 500ms after user stops typing
      switchMap(username => 
        http.get<{ available: boolean }>(`/api/check-username/${username}`)
      ),
      map(response => response.available ? null : { usernameTaken: true }),
      catchError(() => of(null)) // Handle errors gracefully
    );
  };
}

// Usage in component:
/*
import { FormBuilder, FormGroup, Validators } from '@angular/forms';

export class SignupComponent {
  signupForm: FormGroup;
  
  constructor(
    private fb: FormBuilder,
    private http: HttpClient
  ) {
    this.signupForm = this.fb.group({
      username: ['', 
        [Validators.required, Validators.minLength(3)],
        [usernameAvailabilityValidator(this.http)]  // Async validator
      ]
    });
  }
}

// Template:
<form [formGroup]="signupForm">
  <input formControlName="username">
  
  <div *ngIf="signupForm.get('username')?.pending">
    Checking username...
  </div>
  
  <div *ngIf="signupForm.get('username')?.hasError('usernameTaken')">
    Username is already taken
  </div>
</form>
*/

console.log('=== Simple Username Availability Validator ===');
console.log('Checks API with debouncing');
console.log('Shows pending state while validating');
```

### **Approach 2: Email Domain Validator**
```typescript
/**
 * Validate email domain against whitelist/blacklist
 */

import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, delay } from 'rxjs/operators';

export function emailDomainValidator(
  allowedDomains?: string[],
  blockedDomains?: string[]
): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }
    
    const email = control.value;
    const domain = email.split('@')[1]?.toLowerCase();
    
    if (!domain) {
      return of({ invalidEmail: true });
    }
    
    // Simulate API call
    return of(domain).pipe(
      delay(300), // Simulate network delay
      map(dom => {
        // Check blocked domains
        if (blockedDomains && blockedDomains.includes(dom)) {
          return { domainBlocked: { domain: dom } };
        }
        
        // Check allowed domains
        if (allowedDomains && allowedDomains.length > 0) {
          if (!allowedDomains.includes(dom)) {
            return { domainNotAllowed: { domain: dom, allowed: allowedDomains } };
          }
        }
        
        return null;
      })
    );
  };
}

// Usage:
/*
this.form = this.fb.group({
  email: ['',
    [Validators.required, Validators.email],
    [emailDomainValidator(['company.com', 'example.com'], ['spam.com'])]
  ]
});

// Template:
<input formControlName="email">

<div *ngIf="form.get('email')?.hasError('domainBlocked')">
  This email domain is not allowed
</div>

<div *ngIf="form.get('email')?.hasError('domainNotAllowed')">
  Please use: {{ form.get('email')?.errors?.['domainNotAllowed'].allowed.join(', ') }}
</div>
*/

console.log('\n=== Email Domain Validator ===');
console.log('Validates against whitelist/blacklist');
console.log('Simulates async API check');
```

### **Approach 3: Password Breach Checker**
```typescript
/**
 * Check if password has been compromised (Have I Been Pwned API)
 */

import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, catchError, debounceTime, switchMap, distinctUntilChanged } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';
import * as crypto from 'crypto';

export function passwordBreachValidator(http: HttpClient): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value || control.value.length < 8) {
      return of(null); // Skip validation for short passwords
    }
    
    return of(control.value).pipe(
      debounceTime(1000), // Wait longer for password typing
      distinctUntilChanged(),
      switchMap(password => this.checkPasswordBreach(http, password)),
      map(breached => breached ? { passwordBreached: true } : null),
      catchError(error => {
        console.error('Error checking password breach:', error);
        return of(null); // Don't block form on error
      })
    );
  };
  
  function checkPasswordBreach(http: HttpClient, password: string): Observable<boolean> {
    // Hash password with SHA-1
    const hash = crypto.createHash('sha1').update(password).digest('hex').toUpperCase();
    const prefix = hash.substring(0, 5);
    const suffix = hash.substring(5);
    
    // Check against Have I Been Pwned API (k-anonymity model)
    return http.get(`https://api.pwnedpasswords.com/range/${prefix}`, {
      responseType: 'text'
    }).pipe(
      map(response => {
        // Check if hash suffix appears in response
        const hashes = response.split('\n');
        return hashes.some(line => line.startsWith(suffix));
      })
    );
  }
}

/*
Usage:
this.form = this.fb.group({
  password: ['',
    [Validators.required, Validators.minLength(8)],
    [passwordBreachValidator(this.http)]
  ]
});

<input type="password" formControlName="password">

<div *ngIf="form.get('password')?.pending">
  Checking password security...
</div>

<div *ngIf="form.get('password')?.hasError('passwordBreached')">
  This password has been compromised in a data breach. Please choose a different one.
</div>
*/

console.log('\n=== Password Breach Validator ===');
console.log('Checks Have I Been Pwned API');
console.log('Uses k-anonymity for privacy');
```

### **Approach 4: Debounced API Validator with Caching**
```typescript
/**
 * Generic async validator with caching
 */

import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, catchError, debounceTime, switchMap, tap } from 'rxjs/operators';

export class CachedAsyncValidator {
  private cache = new Map<string, ValidationErrors | null>();
  
  createValidator(
    validationFn: (value: any) => Observable<boolean>,
    errorKey: string,
    debounceMs: number = 500
  ): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) {
        return of(null);
      }
      
      const cacheKey = `${errorKey}-${control.value}`;
      
      // Check cache
      if (this.cache.has(cacheKey)) {
        console.log('Returning cached result for:', control.value);
        return of(this.cache.get(cacheKey)!);
      }
      
      console.log('Validating:', control.value);
      
      return of(control.value).pipe(
        debounceTime(debounceMs),
        switchMap(value => validationFn(value)),
        map(isValid => {
          const error = isValid ? null : { [errorKey]: true };
          
          // Cache result
          this.cache.set(cacheKey, error);
          
          // Limit cache size
          if (this.cache.size > 100) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
          }
          
          return error;
        }),
        catchError(() => of(null))
      );
    };
  }
  
  clearCache() {
    this.cache.clear();
  }
}

// Usage:
/*
export class MyComponent {
  cachedValidator = new CachedAsyncValidator();
  
  form = this.fb.group({
    email: ['',
      [Validators.required, Validators.email],
      [this.cachedValidator.createValidator(
        (email) => this.http.get<{exists: boolean}>(`/api/check-email/${email}`)
          .pipe(map(res => !res.exists)),
        'emailTaken',
        800
      )]
    ],
    
    username: ['',
      [Validators.required],
      [this.cachedValidator.createValidator(
        (username) => this.http.get<{available: boolean}>(`/api/check-username/${username}`)
          .pipe(map(res => res.available)),
        'usernameTaken',
        500
      )]
    ]
  });
}
*/

console.log('\n=== Cached Async Validator ===');
console.log('Generic validator with caching');
console.log('Reuses results for same input');
```

### **Approach 5: Multi-Field Async Validator**
```typescript
/**
 * Async validator that checks multiple fields
 */

import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { Observable, of, combineLatest } from 'rxjs';
import { map, debounceTime, switchMap, catchError } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';

export function addressValidator(http: HttpClient): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    const street = control.get('street')?.value;
    const city = control.get('city')?.value;
    const zipCode = control.get('zipCode')?.value;
    
    if (!street || !city || !zipCode) {
      return of(null); // Wait for all fields to be filled
    }
    
    return of({ street, city, zipCode }).pipe(
      debounceTime(1000),
      switchMap(address => 
        http.post<{ valid: boolean; suggestions?: any[] }>('/api/validate-address', address)
      ),
      map(response => {
        if (response.valid) {
          return null;
        }
        
        return {
          invalidAddress: {
            message: 'Address could not be verified',
            suggestions: response.suggestions || []
          }
        };
      }),
      catchError(() => of(null))
    );
  };
}

// Usage:
/*
this.form = this.fb.group({
  address: this.fb.group({
    street: ['', Validators.required],
    city: ['', Validators.required],
    zipCode: ['', Validators.required]
  }, {
    asyncValidators: [addressValidator(this.http)]  // Group-level validator
  })
});

// Template:
<div formGroupName="address">
  <input formControlName="street" placeholder="Street">
  <input formControlName="city" placeholder="City">
  <input formControlName="zipCode" placeholder="Zip Code">
  
  <div *ngIf="form.get('address')?.pending">
    Validating address...
  </div>
  
  <div *ngIf="form.get('address')?.hasError('invalidAddress')">
    {{ form.get('address')?.errors?.['invalidAddress'].message }}
    
    <div *ngIf="form.get('address')?.errors?.['invalidAddress'].suggestions?.length">
      Did you mean:
      <ul>
        <li *ngFor="let suggestion of form.get('address')?.errors?.['invalidAddress'].suggestions">
          {{ suggestion }}
        </li>
      </ul>
    </div>
  </div>
</div>
*/

console.log('\n=== Multi-Field Async Validator ===');
console.log('Validates entire address group');
console.log('Returns suggestions for corrections');
```

### **Real-World Use Cases**
```typescript
/**
 * Practical async validators
 */

// 1. Slug/URL Validator
console.log('\n=== Slug Validator ===');

export function slugValidator(http: HttpClient, resourceType: string): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }
    
    const slug = control.value.toLowerCase().trim();
    
    // Check format first
    if (!/^[a-z0-9-]+$/.test(slug)) {
      return of({ invalidSlugFormat: true });
    }
    
    // Check availability
    return of(slug).pipe(
      debounceTime(500),
      switchMap(s => 
        http.get<{ available: boolean }>(`/api/${resourceType}/check-slug/${s}`)
      ),
      map(response => response.available ? null : { slugTaken: { slug } }),
      catchError(() => of(null))
    );
  };
}

/*
Usage for blog posts:
this.form = this.fb.group({
  title: ['', Validators.required],
  slug: ['',
    [Validators.required],
    [slugValidator(this.http, 'posts')]
  ]
});

// Auto-generate slug from title
this.form.get('title')?.valueChanges.subscribe(title => {
  const slug = title.toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-');
  this.form.get('slug')?.setValue(slug);
});
*/

// 2. Credit Card Validator with BIN Lookup
console.log('\n=== Credit Card BIN Validator ===');

interface CardInfo {
  type: string;
  brand: string;
  valid: boolean;
}

export function creditCardValidator(http: HttpClient): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }
    
    const cardNumber = control.value.replace(/\s/g, '');
    
    // Basic validation first
    if (!/^\d{13,19}$/.test(cardNumber)) {
      return of({ invalidCardFormat: true });
    }
    
    // Get BIN (first 6 digits)
    const bin = cardNumber.substring(0, 6);
    
    return of(bin).pipe(
      debounceTime(800),
      switchMap(b => 
        http.get<CardInfo>(`/api/card/bin-lookup/${b}`)
      ),
      map(cardInfo => {
        if (!cardInfo.valid) {
          return { invalidCard: { message: 'Card not supported' } };
        }
        
        // Also set card type for display
        control.root.get('cardType')?.setValue(cardInfo.brand, { emitEvent: false });
        
        return null;
      }),
      catchError(() => of({ cardValidationError: true }))
    );
  };
}

/*
Usage:
this.form = this.fb.group({
  cardNumber: ['',
    [Validators.required],
    [creditCardValidator(this.http)]
  ],
  cardType: [''] // Auto-populated by validator
});
*/

// 3. Promo Code Validator
console.log('\n=== Promo Code Validator ===');

interface PromoCodeInfo {
  valid: boolean;
  discount?: number;
  expiresAt?: Date;
  message?: string;
}

export function promoCodeValidator(http: HttpClient): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }
    
    const code = control.value.toUpperCase();
    
    return of(code).pipe(
      debounceTime(500),
      switchMap(c => 
        http.post<PromoCodeInfo>('/api/validate-promo-code', {
          code: c,
          cartTotal: control.root.get('cartTotal')?.value
        })
      ),
      map(info => {
        if (!info.valid) {
          return {
            invalidPromoCode: {
              message: info.message || 'Invalid promo code'
            }
          };
        }
        
        // Store discount info for later use
        control.root.get('discount')?.setValue(info.discount, { emitEvent: false });
        
        return null;
      }),
      catchError(() => of({ promoCodeError: true }))
    );
  };
}

/*
Usage:
this.form = this.fb.group({
  promoCode: ['',
    [],
    [promoCodeValidator(this.http)]
  ],
  cartTotal: [100],
  discount: [0]
});

// Template shows discount when code is valid
<input formControlName="promoCode" placeholder="Enter promo code">

<div *ngIf="form.get('promoCode')?.pending">
  Validating code...
</div>

<div *ngIf="form.get('promoCode')?.valid && form.get('discount')?.value">
  Discount applied: ${{ form.get('discount')?.value }}
</div>
*/

// 4. Social Media Handle Validator
console.log('\n=== Social Media Validator ===');

export function socialHandleValidator(
  http: HttpClient,
  platform: 'twitter' | 'instagram' | 'tiktok'
): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }
    
    const handle = control.value.replace('@', '').toLowerCase();
    
    // Platform-specific format validation
    const patterns = {
      twitter: /^[A-Za-z0-9_]{1,15}$/,
      instagram: /^[A-Za-z0-9._]{1,30}$/,
      tiktok: /^[A-Za-z0-9._]{2,24}$/
    };
    
    if (!patterns[platform].test(handle)) {
      return of({ invalidHandleFormat: { platform } });
    }
    
    // Check if handle exists
    return of(handle).pipe(
      debounceTime(700),
      switchMap(h => 
        http.get<{ exists: boolean; verified?: boolean }>
          (`/api/social/${platform}/check/${h}`)
      ),
      map(response => {
        if (!response.exists) {
          return { handleNotFound: { platform, handle } };
        }
        
        // Store verification status
        if (response.verified) {
          control.root.get(`${platform}Verified`)?.setValue(true, { emitEvent: false });
        }
        
        return null;
      }),
      catchError(() => of(null))
    );
  };
}

/*
Usage:
this.form = this.fb.group({
  twitterHandle: ['',
    [],
    [socialHandleValidator(this.http, 'twitter')]
  ],
  twitterVerified: [false]
});
*/

// 5. File Upload Validator (Async)
console.log('\n=== Async File Validator ===');

interface FileValidationResult {
  valid: boolean;
  errors?: string[];
  virusScan?: boolean;
  metadata?: any;
}

export function fileUploadValidator(http: HttpClient): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    const file = control.value as File;
    
    if (!file) {
      return of(null);
    }
    
    // Convert file to base64 or FormData
    const formData = new FormData();
    formData.append('file', file);
    
    return http.post<FileValidationResult>('/api/validate-file', formData).pipe(
      map(result => {
        if (!result.valid) {
          return {
            fileValidation: {
              errors: result.errors || ['File validation failed']
            }
          };
        }
        
        // Store metadata
        if (result.metadata) {
          control.root.get('fileMetadata')?.setValue(result.metadata, { emitEvent: false });
        }
        
        return null;
      }),
      catchError(error => {
        return of({
          fileUploadError: {
            message: 'Error uploading file for validation'
          }
        });
      })
    );
  };
}

/*
Usage:
this.form = this.fb.group({
  file: [null,
    [],
    [fileUploadValidator(this.http)]
  ],
  fileMetadata: [null]
});

onFileSelected(event: Event) {
  const input = event.target as HTMLInputElement;
  if (input.files && input.files[0]) {
    this.form.get('file')?.setValue(input.files[0]);
  }
}

<input type="file" (change)="onFileSelected($event)">

<div *ngIf="form.get('file')?.pending">
  Scanning file...
</div>
*/

// 6. Coordinated Validators (With Retry)
console.log('\n=== Validator with Retry ===');

export function validatorWithRetry(
  http: HttpClient,
  url: string,
  maxRetries: number = 3
): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }
    
    return of(control.value).pipe(
      debounceTime(500),
      switchMap(value => this.validateWithRetry(http, url, value, maxRetries)),
      catchError(() => of({ validationError: true }))
    );
  };
  
  function validateWithRetry(
    http: HttpClient,
    url: string,
    value: any,
    retriesLeft: number
  ): Observable<ValidationErrors | null> {
    return http.post<{ valid: boolean }>(url, { value }).pipe(
      map(response => response.valid ? null : { invalid: true }),
      catchError(error => {
        if (retriesLeft > 0) {
          console.log(`Retrying... (${retriesLeft} attempts left)`);
          return validateWithRetry(http, url, value, retriesLeft - 1);
        }
        throw error;
      })
    );
  }
}

// 7. Conditional Async Validator
console.log('\n=== Conditional Async Validator ===');

export function conditionalAsyncValidator(
  condition: () => boolean,
  validator: AsyncValidatorFn
): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!condition()) {
      return of(null); // Skip validation if condition not met
    }
    
    return validator(control);
  };
}

/*
Usage:
this.form = this.fb.group({
  requiresVerification: [false],
  email: ['',
    [Validators.email],
    [conditionalAsyncValidator(
      () => this.form?.get('requiresVerification')?.value === true,
      emailVerificationValidator(this.http)
    )]
  ]
});
*/
```

### **Performance Comparison**
```typescript
console.log('\n=== Performance ===');

console.log(`
Async Validator Best Practices:
┌──────────────────────┬────────────────────────────────┐
│ Practice             │ Reason                         │
├──────────────────────┼────────────────────────────────┤
│ Debouncing           │ Reduce API calls, wait for     │
│ (debounceTime)       │ user to finish typing          │
├──────────────────────┼────────────────────────────────┤
│ Caching              │ Reuse results for same input   │
│                      │ Improves performance           │
├──────────────────────┼────────────────────────────────┤
│ Error Handling       │ Use catchError to prevent form │
│ (catchError)         │ from being blocked on errors   │
├──────────────────────┼────────────────────────────────┤
│ distinctUntilChanged │ Only validate when value       │
│                      │ actually changes               │
├──────────────────────┼────────────────────────────────┤
│ switchMap            │ Cancel previous requests when  │
│                      │ new value comes in             │
└──────────────────────┴────────────────────────────────┘

Async Validation Flow:
1. User types in input
2. Value changes detected
3. Debounce timer starts
4. After debounce, API call made
5. Control marked as "pending"
6. Response received
7. Validation result applied
8. Control marked as "valid" or "invalid"

RxJS Operators for Validators:
• debounceTime(ms): wait before validating
• distinctUntilChanged(): skip if same value
• switchMap(): cancel previous requests
• map(): transform response to errors
• catchError(): handle failures gracefully
• tap(): side effects (logging, caching)
• retry(n): retry failed requests
• timeout(ms): prevent hanging requests

Performance Optimization:
• Debounce: 300-1000ms depending on operation
• Cache: store results, limit size (100-1000 items)
• Cancel: use switchMap to abort old requests
• Conditional: skip validation when not needed
• Batch: combine multiple checks in one request
• Timeout: fail fast on slow requests
• Offline: handle network errors

Common Patterns:
┌──────────────────────┬────────────────────────────────┐
│ Pattern              │ Use Case                       │
├──────────────────────┼────────────────────────────────┤
│ Username/Email Check │ Uniqueness validation          │
│ Domain Whitelist     │ Corporate email validation     │
│ Password Breach      │ Security (HIBP API)            │
│ Address Validation   │ Shipping address verification  │
│ Promo Code           │ Discount code validation       │
│ Slug/URL             │ SEO-friendly URL checking      │
│ Credit Card BIN      │ Card type detection            │
│ Social Handle        │ Profile linking validation     │
│ File Upload          │ Virus scan, metadata check     │
└──────────────────────┴────────────────────────────────┘

Testing Async Validators:
• Use fakeAsync and tick() for timing
• Mock HTTP responses with HttpTestingController
• Test debounce behavior
• Test error handling
• Test caching logic
• Test pending state
• Verify API calls are made correctly

Error Handling Strategies:
• Return null on error (don't block form)
• Log errors for debugging
• Show generic message to user
• Implement retry logic
• Use timeout to prevent hanging
• Provide fallback validation

Integration Tips:
• Add to FormControl as third parameter
• Can combine with sync validators
• Use at field or group level
• Handle pending state in template
• Show loading indicator
• Disable submit while validating
• Clear errors on value change

Real-World Considerations:
• Rate limiting: respect API limits
• Network failures: handle gracefully
• Privacy: don't leak sensitive data
• UX: clear pending indicators
• Performance: minimize API calls
• Security: validate server-side too
• Accessibility: announce validation status
`);
```

**Interview Tips:**
- Async validator: validates against external source (API, database)
- Returns Observable<ValidationErrors | null>
- Third parameter in FormControl: FormControl('', syncValidators, asyncValidators)
- Use debounceTime to wait after user stops typing (reduce API calls)
- switchMap cancels previous requests when new value comes in
- Control has "pending" state while async validation runs
- Always use catchError to handle failures gracefully (return of(null))
- distinctUntilChanged skips validation if value hasn't changed
- Caching: store results to avoid repeated API calls for same value
- Common use cases: username availability, email uniqueness, password breach check
- Multi-field validators: apply at FormGroup level, access child controls
- Show loading state in template: *ngIf="control.pending"
- Performance: debounce (300-1000ms), cache, cancel old requests
- Error handling: don't block form on network errors
- Security: always validate server-side too (client-side can be bypassed)
- Testing: use fakeAsync, tick(), HttpTestingController for mocking
- RxJS operators: debounceTime, switchMap, map, catchError, tap
- Best practices: debounce, cache, handle errors, show pending state
- Trade-offs: better validation vs increased latency and API load
- Follow-ups: caching strategy, retry logic, timeout, batching, offline handling
- Clarify: API endpoint? debounce time? caching? error handling? retry logic?

</details>

124. Implement a custom RxJS operator

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Custom Operator**
```typescript
/**
 * Simple operator that logs values passing through
 */

import { Observable } from 'rxjs';

// Custom operator using pipe
function debug<T>(tag: string) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      console.log(`[${tag}] Subscribed`);
      
      return source.subscribe({
        next: (value) => {
          console.log(`[${tag}] Next:`, value);
          observer.next(value);
        },
        error: (error) => {
          console.log(`[${tag}] Error:`, error);
          observer.error(error);
        },
        complete: () => {
          console.log(`[${tag}] Complete`);
          observer.complete();
        }
      });
    });
  };
}

// Usage:
/*
import { of } from 'rxjs';

of(1, 2, 3)
  .pipe(
    debug('Stream 1'),
    map(x => x * 2),
    debug('After map')
  )
  .subscribe(value => console.log('Final:', value));

// Output:
// [Stream 1] Subscribed
// [Stream 1] Next: 1
// [After map] Subscribed
// [After map] Next: 2
// Final: 2
// ...
*/

console.log('=== Basic Debug Operator ===');
console.log('Logs all events passing through stream');
console.log('Useful for debugging RxJS pipelines');
```

### **Approach 2: Operator with Parameters**
```typescript
/**
 * Filter by predicate with optional default value
 */

import { Observable } from 'rxjs';

function filterWithDefault<T>(
  predicate: (value: T) => boolean,
  defaultValue: T
) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      let hasEmitted = false;
      
      return source.subscribe({
        next: (value) => {
          if (predicate(value)) {
            hasEmitted = true;
            observer.next(value);
          }
        },
        error: (error) => observer.error(error),
        complete: () => {
          if (!hasEmitted) {
            observer.next(defaultValue);
          }
          observer.complete();
        }
      });
    });
  };
}

// Usage:
/*
import { of } from 'rxjs';

of(1, 2, 3, 4, 5)
  .pipe(
    filterWithDefault(x => x > 10, 0)
  )
  .subscribe(console.log);
// Output: 0 (default, since no values > 10)

of(1, 2, 15, 4, 5)
  .pipe(
    filterWithDefault(x => x > 10, 0)
  )
  .subscribe(console.log);
// Output: 15
*/

console.log('\n=== Filter with Default ===');
console.log('Filters values, emits default if none match');
```

### **Approach 3: Stateful Operator**
```typescript
/**
 * Accumulate values and emit when threshold reached
 */

import { Observable } from 'rxjs';

function bufferByCount<T>(count: number) {
  return (source: Observable<T>) => {
    return new Observable<T[]>(observer => {
      let buffer: T[] = [];
      
      return source.subscribe({
        next: (value) => {
          buffer.push(value);
          
          if (buffer.length >= count) {
            observer.next([...buffer]);
            buffer = [];
          }
        },
        error: (error) => observer.error(error),
        complete: () => {
          if (buffer.length > 0) {
            observer.next(buffer);
          }
          observer.complete();
        }
      });
    });
  };
}

// Usage:
/*
import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

interval(100)
  .pipe(
    take(10),
    bufferByCount(3)
  )
  .subscribe(batch => console.log('Batch:', batch));

// Output:
// Batch: [0, 1, 2]
// Batch: [3, 4, 5]
// Batch: [6, 7, 8]
// Batch: [9]
*/

console.log('\n=== Buffer by Count ===');
console.log('Collects values and emits in batches');
console.log('Stateful operator with internal buffer');
```

### **Approach 4: Operator with Side Effects**
```typescript
/**
 * Tap into stream for side effects at different points
 */

import { Observable } from 'rxjs';

interface TapConfig<T> {
  onNext?: (value: T) => void;
  onError?: (error: any) => void;
  onComplete?: () => void;
  onSubscribe?: () => void;
  onUnsubscribe?: () => void;
}

function tapAdvanced<T>(config: TapConfig<T>) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      config.onSubscribe?.();
      
      const subscription = source.subscribe({
        next: (value) => {
          config.onNext?.(value);
          observer.next(value);
        },
        error: (error) => {
          config.onError?.(error);
          observer.error(error);
        },
        complete: () => {
          config.onComplete?.();
          observer.complete();
        }
      });
      
      return () => {
        config.onUnsubscribe?.();
        subscription.unsubscribe();
      };
    });
  };
}

// Usage:
/*
import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

const subscription = interval(100)
  .pipe(
    take(5),
    tapAdvanced({
      onSubscribe: () => console.log('Subscribed!'),
      onNext: (value) => console.log('Processing:', value),
      onComplete: () => console.log('Stream complete'),
      onUnsubscribe: () => console.log('Unsubscribed')
    })
  )
  .subscribe();

setTimeout(() => subscription.unsubscribe(), 350);
*/

console.log('\n=== Advanced Tap ===');
console.log('Side effects at all lifecycle points');
console.log('Includes subscribe/unsubscribe hooks');
```

### **Approach 5: Transformation Operator**
```typescript
/**
 * Rate limiting operator
 */

import { Observable } from 'rxjs';

function rateLimit<T>(maxEmissions: number, timeWindow: number) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      let emissions: number[] = [];
      
      return source.subscribe({
        next: (value) => {
          const now = Date.now();
          
          // Remove old emissions outside time window
          emissions = emissions.filter(time => now - time < timeWindow);
          
          if (emissions.length < maxEmissions) {
            emissions.push(now);
            observer.next(value);
          } else {
            console.log('Rate limit exceeded, dropping value:', value);
          }
        },
        error: (error) => observer.error(error),
        complete: () => observer.complete()
      });
    });
  };
}

// Usage:
/*
import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

// Allow max 3 emissions per 1000ms
interval(100)
  .pipe(
    take(10),
    rateLimit(3, 1000)
  )
  .subscribe(value => console.log('Emitted:', value));

// Output: Emits first 3 values, then rate-limits remaining
*/

console.log('\n=== Rate Limit Operator ===');
console.log('Limits emissions per time window');
console.log('Drops excess values');
```

### **Real-World Use Cases**
```typescript
/**
 * Practical custom operators
 */

// 1. Retry with Exponential Backoff
console.log('\n=== Retry with Backoff ===');

import { Observable, throwError, timer } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

function retryWithBackoff<T>(
  maxRetries: number,
  initialDelay: number = 1000,
  backoffMultiplier: number = 2
) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      let retryCount = 0;
      
      const attempt = () => {
        source.subscribe({
          next: (value) => observer.next(value),
          error: (error) => {
            if (retryCount >= maxRetries) {
              console.log('Max retries reached');
              observer.error(error);
              return;
            }
            
            const delay = initialDelay * Math.pow(backoffMultiplier, retryCount);
            console.log(`Retry ${retryCount + 1}/${maxRetries} after ${delay}ms`);
            retryCount++;
            
            setTimeout(attempt, delay);
          },
          complete: () => observer.complete()
        });
      };
      
      attempt();
    });
  };
}

/*
Usage:
fetchData()
  .pipe(
    retryWithBackoff(3, 1000, 2)
  )
  .subscribe({
    next: data => console.log('Success:', data),
    error: err => console.log('Failed after retries:', err)
  });

// Retry schedule: 1s, 2s, 4s
*/

// 2. Cache and Replay
console.log('\n=== Cache Operator ===');

function cache<T>(ttl: number = Infinity) {
  return (source: Observable<T>) => {
    let cachedValue: T | undefined;
    let cacheTime: number | undefined;
    let inProgress: Observable<T> | undefined;
    
    return new Observable<T>(observer => {
      const now = Date.now();
      
      // Return cached value if valid
      if (cachedValue !== undefined && 
          cacheTime !== undefined && 
          (ttl === Infinity || now - cacheTime < ttl)) {
        console.log('Returning cached value');
        observer.next(cachedValue);
        observer.complete();
        return;
      }
      
      // Wait for in-progress request
      if (inProgress) {
        console.log('Waiting for in-progress request');
        return inProgress.subscribe(observer);
      }
      
      // Make new request
      console.log('Fetching new value');
      inProgress = new Observable<T>(obs => {
        return source.subscribe({
          next: (value) => {
            cachedValue = value;
            cacheTime = Date.now();
            obs.next(value);
            observer.next(value);
          },
          error: (error) => {
            inProgress = undefined;
            obs.error(error);
            observer.error(error);
          },
          complete: () => {
            inProgress = undefined;
            obs.complete();
            observer.complete();
          }
        });
      });
      
      return inProgress.subscribe(observer);
    });
  };
}

/*
Usage:
const apiCall$ = http.get('/api/data').pipe(
  cache(5000) // Cache for 5 seconds
);

// First call: makes API request
apiCall$.subscribe(data => console.log('Call 1:', data));

// Second call (within 5s): returns cached
setTimeout(() => {
  apiCall$.subscribe(data => console.log('Call 2:', data));
}, 1000);
*/

// 3. Debounce with Immediate
console.log('\n=== Debounce with Immediate ===');

function debounceWithImmediate<T>(duration: number, immediate: boolean = true) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      let timeout: any;
      let isFirstEmission = true;
      
      return source.subscribe({
        next: (value) => {
          const shouldEmitImmediately = immediate && isFirstEmission;
          
          if (shouldEmitImmediately) {
            observer.next(value);
            isFirstEmission = false;
          }
          
          clearTimeout(timeout);
          
          timeout = setTimeout(() => {
            if (!shouldEmitImmediately) {
              observer.next(value);
            }
            isFirstEmission = true;
          }, duration);
        },
        error: (error) => {
          clearTimeout(timeout);
          observer.error(error);
        },
        complete: () => {
          clearTimeout(timeout);
          observer.complete();
        }
      });
    });
  };
}

/*
Usage: Search with immediate first result
searchInput$
  .pipe(
    debounceWithImmediate(500, true)
  )
  .subscribe(term => performSearch(term));

// First keystroke: searches immediately
// Subsequent keystrokes: debounced 500ms
*/

// 4. Conditional Operator
console.log('\n=== Conditional Operator ===');

function switchWhen<T>(
  condition: (value: T) => boolean,
  trueOperator: (source: Observable<T>) => Observable<T>,
  falseOperator?: (source: Observable<T>) => Observable<T>
) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      return source.subscribe({
        next: (value) => {
          const result = condition(value);
          
          const operator = result ? trueOperator : falseOperator;
          
          if (operator) {
            operator(new Observable(obs => {
              obs.next(value);
              obs.complete();
            })).subscribe({
              next: (v) => observer.next(v),
              error: (e) => observer.error(e)
            });
          } else {
            observer.next(value);
          }
        },
        error: (error) => observer.error(error),
        complete: () => observer.complete()
      });
    });
  };
}

/*
Usage:
numbers$
  .pipe(
    switchWhen(
      x => x > 10,
      source => source.pipe(map(x => x * 2)),  // If > 10
      source => source.pipe(map(x => x + 1))   // If <= 10
    )
  )
  .subscribe(console.log);
*/

// 5. Timeout with Fallback
console.log('\n=== Timeout with Fallback ===');

function timeoutWithFallback<T>(
  duration: number,
  fallback: Observable<T>
) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      let completed = false;
      
      const timeout = setTimeout(() => {
        if (!completed) {
          console.log('Timeout! Using fallback');
          fallback.subscribe({
            next: (value) => observer.next(value),
            error: (error) => observer.error(error),
            complete: () => observer.complete()
          });
        }
      }, duration);
      
      const subscription = source.subscribe({
        next: (value) => {
          clearTimeout(timeout);
          completed = true;
          observer.next(value);
        },
        error: (error) => {
          clearTimeout(timeout);
          completed = true;
          observer.error(error);
        },
        complete: () => {
          clearTimeout(timeout);
          completed = true;
          observer.complete();
        }
      });
      
      return () => {
        clearTimeout(timeout);
        subscription.unsubscribe();
      };
    });
  };
}

/*
Usage:
slowApiCall$
  .pipe(
    timeoutWithFallback(3000, of({ cached: true, data: [] }))
  )
  .subscribe(data => console.log(data));

// If API takes > 3s, uses fallback
*/

// 6. Distinct by Property
console.log('\n=== Distinct by Property ===');

function distinctByProperty<T>(propertySelector: (value: T) => any) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      const seen = new Set();
      
      return source.subscribe({
        next: (value) => {
          const key = propertySelector(value);
          
          if (!seen.has(key)) {
            seen.add(key);
            observer.next(value);
          }
        },
        error: (error) => observer.error(error),
        complete: () => observer.complete()
      });
    });
  };
}

/*
Usage:
interface User {
  id: number;
  name: string;
}

users$
  .pipe(
    distinctByProperty(user => user.id)
  )
  .subscribe(user => console.log(user));

// Only emits users with unique IDs
*/

// 7. Batch Requests
console.log('\n=== Batch Requests ===');

function batchRequests<T, R>(
  batchSize: number,
  batchDelay: number,
  requestFn: (batch: T[]) => Observable<R[]>
) {
  return (source: Observable<T>) => {
    return new Observable<R>(observer => {
      let batch: T[] = [];
      let timeout: any;
      
      const processBatch = () => {
        if (batch.length === 0) return;
        
        const currentBatch = [...batch];
        batch = [];
        
        requestFn(currentBatch).subscribe({
          next: (results) => {
            results.forEach(result => observer.next(result));
          },
          error: (error) => observer.error(error)
        });
      };
      
      const subscription = source.subscribe({
        next: (value) => {
          batch.push(value);
          
          if (batch.length >= batchSize) {
            clearTimeout(timeout);
            processBatch();
          } else {
            clearTimeout(timeout);
            timeout = setTimeout(processBatch, batchDelay);
          }
        },
        error: (error) => {
          clearTimeout(timeout);
          processBatch();
          observer.error(error);
        },
        complete: () => {
          clearTimeout(timeout);
          processBatch();
          observer.complete();
        }
      });
      
      return () => {
        clearTimeout(timeout);
        subscription.unsubscribe();
      };
    });
  };
}

/*
Usage:
userIds$
  .pipe(
    batchRequests(
      10,              // Batch size
      500,             // Wait 500ms for more
      (ids) => http.post('/api/users/batch', { ids })
    )
  )
  .subscribe(users => console.log(users));

// Batches user ID requests efficiently
*/
```

### **Performance Comparison**
```typescript
console.log('\n=== Performance ===');

console.log(`
Custom RxJS Operator Patterns:
┌──────────────────────┬────────────────────────────────┐
│ Pattern              │ Use Case                       │
├──────────────────────┼────────────────────────────────┤
│ Transformation       │ Modify values (map, filter)    │
│ Filtering            │ Conditional emission           │
│ Combination          │ Merge multiple streams         │
│ Error Handling       │ Retry, fallback, catch         │
│ Utility              │ Tap, debug, log                │
│ Buffering            │ Collect and batch values       │
│ Time-based           │ Debounce, throttle, delay      │
│ Stateful             │ Remember previous values       │
└──────────────────────┴────────────────────────────────┘

Operator Structure:
function myOperator<T>(params) {
  return (source: Observable<T>) => {
    return new Observable<T>(observer => {
      return source.subscribe({
        next: (value) => observer.next(value),
        error: (error) => observer.error(error),
        complete: () => observer.complete()
      });
    });
  };
}

Key Concepts:
• Operator is a function that returns a function
• Takes source Observable, returns new Observable
• Subscribe to source, forward events to observer
• Can transform, filter, buffer, or delay values
• Must handle next, error, and complete
• Return unsubscribe function for cleanup

Best Practices:
• Always forward errors and completion
• Clean up resources (timers, subscriptions)
• Handle unsubscribe properly
• Don't swallow errors silently
• Make operators pure (no side effects unless intended)
• Use TypeScript generics for type safety
• Test with marble diagrams
• Document behavior clearly

Common Use Cases:
• Debug: log values at specific points
• Retry: with exponential backoff
• Cache: store and reuse results
• Rate limit: control emission rate
• Batch: collect values for bulk operations
• Timeout: with fallback values
• Conditional: different paths based on value
• Distinct: by property or custom logic

Testing Operators:
• Use TestScheduler for marble testing
• Test next, error, complete paths
• Test cleanup/unsubscribe
• Test with multiple subscribers
• Test timing behavior
• Mock dependencies

Performance Tips:
• Minimize subscriptions
• Unsubscribe to prevent leaks
• Use shareReplay for expensive operations
• Batch API requests when possible
• Debounce user input
• Cache frequently accessed data
• Use switchMap to cancel old requests

Real-World Applications:
• API retry with backoff
• Search debouncing with immediate first
• Request caching with TTL
• Rate limiting API calls
• Batching database operations
• Timeout with fallback data
• Conditional transformations
• Distinct by complex keys
`);
```

**Interview Tips:**
- Custom operator: function that takes Observable and returns Observable
- Pattern: (source: Observable<T>) => Observable<R>
- Must subscribe to source and forward to observer
- Handle all three events: next, error, complete
- Return unsubscribe function for cleanup
- Operators are composable: pipe(op1, op2, op3)
- Higher-order function: returns function that returns Observable
- Pure vs impure: pure has no side effects, impure may (like tap)
- Stateful operators: maintain internal state between emissions
- Common patterns: transform, filter, buffer, delay, retry
- Must handle unsubscribe to prevent memory leaks
- Use TypeScript generics for type safety: <T, R>
- Testing: use marble diagrams and TestScheduler
- Real-world examples: retry with backoff, cache with TTL, rate limiting
- Difference from pipeable operator: custom creates new Observable
- Built-in operators: map, filter, debounceTime, switchMap, etc.
- Side effects: use tap or custom operator with onNext callback
- Error handling: always forward errors, don't swallow
- Performance: minimize subscriptions, clean up resources
- Trade-offs: flexibility vs complexity, reusability vs specificity
- Follow-ups: stateful operators, error recovery, cancellation, testing
- Clarify: transformation needed? stateful? error handling? cleanup required?

</details>

125. Create a reusable form component with ControlValueAccessor

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic ControlValueAccessor**
```typescript
/**
 * Simple custom input component
 */

import { Component, forwardRef } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Component({
  selector: 'app-custom-input',
  template: `
    <div class="custom-input">
      <label>{{ label }}</label>
      <input
        [type]="type"
        [value]="value"
        (input)="onInput($event)"
        (blur)="onTouched()"
        [disabled]="disabled">
    </div>
  `,
  styles: [`
    .custom-input {
      margin: 10px 0;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 100%;
    }
    input:disabled {
      background-color: #f0f0f0;
    }
  `],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CustomInputComponent),
    multi: true
  }]
})
export class CustomInputComponent implements ControlValueAccessor {
  @Input() label = '';
  @Input() type = 'text';
  
  value: any = '';
  disabled = false;
  
  onChange: any = () => {};
  onTouched: any = () => {};
  
  // Called by Angular when value changes from outside
  writeValue(value: any): void {
    this.value = value || '';
  }
  
  // Register callback for value changes
  registerOnChange(fn: any): void {
    this.onChange = fn;
  }
  
  // Register callback for touch events
  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }
  
  // Called when form control is disabled/enabled
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  // Handle input event
  onInput(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.value = input.value;
    this.onChange(this.value);
  }
}

// Usage:
/*
// Template:
<form [formGroup]="form">
  <app-custom-input 
    formControlName="username"
    label="Username">
  </app-custom-input>
</form>

// Component:
this.form = this.fb.group({
  username: ['', Validators.required]
});
*/

console.log('=== Basic ControlValueAccessor ===');
console.log('Implements ControlValueAccessor interface');
console.log('Works with formControlName and ngModel');
```

### **Approach 2: Rating Component**
```typescript
/**
 * Star rating component
 */

import { Component, forwardRef, Input } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Component({
  selector: 'app-rating',
  template: `
    <div class="rating">
      <span
        *ngFor="let star of stars; let i = index"
        class="star"
        [class.filled]="i < value"
        [class.disabled]="disabled"
        (click)="rate(i + 1)"
        (mouseenter)="hoverValue = i + 1"
        (mouseleave)="hoverValue = 0">
        {{ (hoverValue > 0 && i < hoverValue) || i < value ? '★' : '☆' }}
      </span>
      <span class="rating-text" *ngIf="showText">
        {{ value }}/{{ maxRating }}
      </span>
    </div>
  `,
  styles: [`
    .rating {
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }
    .star {
      font-size: 24px;
      cursor: pointer;
      color: #ffd700;
      user-select: none;
    }
    .star.disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
    .rating-text {
      margin-left: 10px;
      font-size: 14px;
      color: #666;
    }
  `],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RatingComponent),
    multi: true
  }]
})
export class RatingComponent implements ControlValueAccessor {
  @Input() maxRating = 5;
  @Input() showText = true;
  
  value = 0;
  hoverValue = 0;
  disabled = false;
  stars: number[] = [];
  
  onChange: any = () => {};
  onTouched: any = () => {};
  
  ngOnInit() {
    this.stars = Array(this.maxRating).fill(0);
  }
  
  writeValue(value: number): void {
    this.value = value || 0;
  }
  
  registerOnChange(fn: any): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }
  
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  rate(rating: number): void {
    if (this.disabled) return;
    
    this.value = rating;
    this.onChange(this.value);
    this.onTouched();
  }
}

/*
Usage:
<form [formGroup]="form">
  <app-rating 
    formControlName="rating"
    [maxRating]="5"
    [showText]="true">
  </app-rating>
</form>

this.form = this.fb.group({
  rating: [0, [Validators.min(1), Validators.max(5)]]
});
*/

console.log('\n=== Rating Component ===');
console.log('Interactive star rating with hover');
console.log('Fully integrated with Angular forms');
```

### **Approach 3: Tag Input Component**
```typescript
/**
 * Tag/chip input component
 */

import { Component, forwardRef, Input } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Component({
  selector: 'app-tag-input',
  template: `
    <div class="tag-input" [class.disabled]="disabled">
      <div class="tags">
        <span 
          *ngFor="let tag of tags; let i = index" 
          class="tag">
          {{ tag }}
          <button 
            type="button"
            (click)="removeTag(i)"
            [disabled]="disabled">
            ×
          </button>
        </span>
      </div>
      <input
        #input
        type="text"
        [placeholder]="placeholder"
        (keydown.enter)="addTag($event)"
        (keydown.backspace)="onBackspace($event)"
        (blur)="onTouched()"
        [disabled]="disabled">
    </div>
  `,
  styles: [`
    .tag-input {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 40px;
    }
    .tag-input.disabled {
      background-color: #f0f0f0;
    }
    .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background-color: #007bff;
      color: white;
      border-radius: 3px;
      font-size: 14px;
    }
    .tag button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      padding: 0;
      line-height: 1;
    }
    input {
      flex: 1;
      border: none;
      outline: none;
      min-width: 100px;
    }
  `],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TagInputComponent),
    multi: true
  }]
})
export class TagInputComponent implements ControlValueAccessor {
  @Input() placeholder = 'Add tag...';
  @Input() maxTags?: number;
  
  tags: string[] = [];
  disabled = false;
  
  onChange: any = () => {};
  onTouched: any = () => {};
  
  writeValue(value: string[]): void {
    this.tags = value || [];
  }
  
  registerOnChange(fn: any): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }
  
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  addTag(event: Event): void {
    event.preventDefault();
    
    const input = event.target as HTMLInputElement;
    const value = input.value.trim();
    
    if (value && !this.tags.includes(value)) {
      if (!this.maxTags || this.tags.length < this.maxTags) {
        this.tags = [...this.tags, value];
        this.onChange(this.tags);
        input.value = '';
      }
    }
  }
  
  removeTag(index: number): void {
    this.tags = this.tags.filter((_, i) => i !== index);
    this.onChange(this.tags);
  }
  
  onBackspace(event: KeyboardEvent): void {
    const input = event.target as HTMLInputElement;
    
    if (input.value === '' && this.tags.length > 0) {
      this.removeTag(this.tags.length - 1);
    }
  }
}

/*
Usage:
<form [formGroup]="form">
  <app-tag-input 
    formControlName="tags"
    placeholder="Add skills..."
    [maxTags]="10">
  </app-tag-input>
</form>

this.form = this.fb.group({
  tags: [['JavaScript', 'TypeScript']]
});
*/

console.log('\n=== Tag Input Component ===');
console.log('Add/remove tags with keyboard');
console.log('Value is array of strings');
```

### **Approach 4: Date Range Picker**
```typescript
/**
 * Date range component
 */

import { Component, forwardRef } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

interface DateRange {
  start: Date | null;
  end: Date | null;
}

@Component({
  selector: 'app-date-range',
  template: `
    <div class="date-range">
      <div class="date-input">
        <label>Start Date</label>
        <input
          type="date"
          [value]="startDateString"
          (change)="onStartChange($event)"
          [disabled]="disabled">
      </div>
      
      <div class="date-input">
        <label>End Date</label>
        <input
          type="date"
          [value]="endDateString"
          (change)="onEndChange($event)"
          [min]="startDateString"
          [disabled]="disabled">
      </div>
    </div>
    
    <div class="error" *ngIf="hasError">
      End date must be after start date
    </div>
  `,
  styles: [`
    .date-range {
      display: flex;
      gap: 20px;
    }
    .date-input {
      flex: 1;
    }
    .date-input label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .date-input input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .error {
      color: red;
      font-size: 12px;
      margin-top: 5px;
    }
  `],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DateRangeComponent),
    multi: true
  }]
})
export class DateRangeComponent implements ControlValueAccessor {
  value: DateRange = { start: null, end: null };
  disabled = false;
  hasError = false;
  
  onChange: any = () => {};
  onTouched: any = () => {};
  
  get startDateString(): string {
    return this.value.start ? this.formatDate(this.value.start) : '';
  }
  
  get endDateString(): string {
    return this.value.end ? this.formatDate(this.value.end) : '';
  }
  
  writeValue(value: DateRange): void {
    this.value = value || { start: null, end: null };
  }
  
  registerOnChange(fn: any): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }
  
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  onStartChange(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.value.start = input.value ? new Date(input.value) : null;
    this.validate();
    this.onChange(this.value);
    this.onTouched();
  }
  
  onEndChange(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.value.end = input.value ? new Date(input.value) : null;
    this.validate();
    this.onChange(this.value);
    this.onTouched();
  }
  
  validate(): void {
    if (this.value.start && this.value.end) {
      this.hasError = this.value.end < this.value.start;
    } else {
      this.hasError = false;
    }
  }
  
  formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }
}

/*
Usage:
<form [formGroup]="form">
  <app-date-range formControlName="dateRange"></app-date-range>
</form>

this.form = this.fb.group({
  dateRange: [{ start: new Date(), end: null }]
});
*/

console.log('\n=== Date Range Component ===');
console.log('Two date pickers with validation');
console.log('Value is {start, end} object');
```

### **Approach 5: Rich Text Editor (Simplified)**
```typescript
/**
 * Simple rich text editor
 */

import { Component, forwardRef, ElementRef, ViewChild } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Component({
  selector: 'app-rich-editor',
  template: `
    <div class="rich-editor">
      <div class="toolbar">
        <button 
          type="button"
          (click)="execCommand('bold')"
          [disabled]="disabled">
          <strong>B</strong>
        </button>
        <button 
          type="button"
          (click)="execCommand('italic')"
          [disabled]="disabled">
          <em>I</em>
        </button>
        <button 
          type="button"
          (click)="execCommand('underline')"
          [disabled]="disabled">
          <u>U</u>
        </button>
        <button 
          type="button"
          (click)="execCommand('insertUnorderedList')"
          [disabled]="disabled">
          List
        </button>
      </div>
      
      <div
        #editor
        class="editor-content"
        contenteditable="true"
        (input)="onInput()"
        (blur)="onTouched()"
        [attr.contenteditable]="!disabled">
      </div>
    </div>
  `,
  styles: [`
    .rich-editor {
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .toolbar {
      display: flex;
      gap: 5px;
      padding: 8px;
      background-color: #f5f5f5;
      border-bottom: 1px solid #ccc;
    }
    .toolbar button {
      padding: 5px 10px;
      border: 1px solid #ccc;
      background: white;
      cursor: pointer;
      border-radius: 3px;
    }
    .toolbar button:hover {
      background-color: #e0e0e0;
    }
    .toolbar button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .editor-content {
      min-height: 150px;
      padding: 10px;
      outline: none;
    }
    .editor-content[contenteditable="false"] {
      background-color: #f0f0f0;
    }
  `],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RichEditorComponent),
    multi: true
  }]
})
export class RichEditorComponent implements ControlValueAccessor {
  @ViewChild('editor', { static: true }) editorRef!: ElementRef;
  
  disabled = false;
  
  onChange: any = () => {};
  onTouched: any = () => {};
  
  writeValue(value: string): void {
    if (this.editorRef) {
      this.editorRef.nativeElement.innerHTML = value || '';
    }
  }
  
  registerOnChange(fn: any): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }
  
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  onInput(): void {
    const html = this.editorRef.nativeElement.innerHTML;
    this.onChange(html);
  }
  
  execCommand(command: string): void {
    document.execCommand(command, false);
    this.editorRef.nativeElement.focus();
    this.onInput();
  }
}

/*
Usage:
<form [formGroup]="form">
  <app-rich-editor formControlName="content"></app-rich-editor>
</form>

this.form = this.fb.group({
  content: ['<p>Initial content</p>']
});
*/

console.log('\n=== Rich Text Editor ===');
console.log('Contenteditable with formatting toolbar');
console.log('Value is HTML string');
```

### **Real-World Use Cases**
```typescript
/**
 * Advanced custom form controls
 */

// Complete implementation in separate files would include:

console.log('\n=== Real-World Components ===');

console.log(`
1. Autocomplete Component:
   - Search as you type
   - Debounced API calls
   - Keyboard navigation
   - Highlight matching text
   - Custom templates for options

2. File Upload Component:
   - Drag & drop support
   - Preview thumbnails
   - Progress indicator
   - File validation
   - Multiple files support

3. Color Picker Component:
   - Visual color selection
   - RGB/HSL/HEX formats
   - Predefined palettes
   - Opacity control
   - Recent colors

4. Slider Component:
   - Range selection
   - Step values
   - Custom labels
   - Vertical/horizontal
   - Tooltips with value

5. Phone Input Component:
   - Country code selector
   - Format as you type
   - Validation
   - Flag icons
   - International formats

6. Address Input Component:
   - Google Maps integration
   - Autocomplete suggestions
   - Structured output
   - Validation
   - Custom formatting

7. WYSIWYG Editor Component:
   - Rich text formatting
   - Image upload
   - Tables, links
   - Markdown support
   - Custom plugins
`);
```

### **Performance Comparison**
```typescript
console.log('\n=== Performance ===');

console.log(`
ControlValueAccessor Interface:
┌──────────────────────┬────────────────────────────────┐
│ Method               │ Purpose                        │
├──────────────────────┼────────────────────────────────┤
│ writeValue()         │ Write value from form to view  │
│                      │ Called when form value changes │
├──────────────────────┼────────────────────────────────┤
│ registerOnChange()   │ Register callback for changes  │
│                      │ Call when component value changes│
├──────────────────────┼────────────────────────────────┤
│ registerOnTouched()  │ Register callback for blur     │
│                      │ Call when component is touched │
├──────────────────────┼────────────────────────────────┤
│ setDisabledState()   │ Set disabled state             │
│ (optional)           │ Handle form disable/enable     │
└──────────────────────┴────────────────────────────────┘

Provider Configuration:
providers: [{
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MyComponent),
  multi: true
}]

• NG_VALUE_ACCESSOR: token for form controls
• useExisting: use component class
• forwardRef: resolve forward references
• multi: allow multiple providers

Best Practices:
• Always implement all 4 methods
• Call onChange when value changes internally
• Call onTouched on blur events
• Handle null/undefined in writeValue
• Don't call onChange in writeValue (loop!)
• Clean up subscriptions in ngOnDestroy
• Use forwardRef for provider
• Type value appropriately (string, object, etc.)
• Support disabled state
• Emit value on every change

Common Patterns:
• Input components: text, number, select
• Complex inputs: date range, tags, rating
• Rich editors: WYSIWYG, markdown
• File uploads: with preview, progress
• Autocomplete: with async search
• Custom selects: with search, multi-select
• Color pickers: visual selection
• Sliders: range, single value

Value Types:
• Primitive: string, number, boolean
• Object: {start: Date, end: Date}
• Array: string[], File[]
• Complex: nested objects, custom types

Integration:
• Template-driven: works with ngModel
• Reactive: works with formControlName
• Validation: combine with validators
• Async validators: supported
• Form array: can be used in arrays
• Form group: can contain other controls

Testing:
• Test writeValue updates view
• Test user interaction calls onChange
• Test onTouched on blur
• Test disabled state
• Test with FormControl
• Test validation integration

Advantages:
• Seamless Angular forms integration
• Reusable across projects
• Consistent API with built-in controls
• Works with validation
• Type-safe with TypeScript
• Encapsulates complex logic

Common Mistakes:
• Calling onChange in writeValue
• Not handling null values
• Forgetting onTouched
• Missing forwardRef in provider
• Not cleaning up resources
• Mutating input values
`);
```

**Interview Tips:**
- ControlValueAccessor: interface to integrate custom components with Angular forms
- Four methods: writeValue, registerOnChange, registerOnTouched, setDisabledState
- writeValue: called when form sets value, updates component view
- registerOnChange: registers callback, call it when component value changes
- registerOnTouched: registers callback, call it on blur (touched)
- setDisabledState: optional, handle disabled state
- Provider: NG_VALUE_ACCESSOR token with multi: true
- Use forwardRef to resolve circular dependency
- Works with both template-driven (ngModel) and reactive (formControlName)
- Don't call onChange inside writeValue (creates loop!)
- Handle null/undefined in writeValue
- Common uses: rating stars, tag input, date range, rich editor, file upload
- Value can be any type: string, object, array, complex
- Integrates with validators: sync and async
- Call onChange on every internal value change
- Call onTouched on blur events
- Best practice: encapsulate complex input logic
- Testing: test all four methods, user interaction, form integration
- Real-world: autocomplete, color picker, phone input, address input
- Trade-offs: reusability vs complexity, flexibility vs simplicity
- Follow-ups: validation, async updates, complex values, accessibility
- Clarify: value type? validation needed? async operations? accessibility?

</details>

### **Performance & Optimization**

126. Implement lazy loading for images

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Intersection Observer API**
```javascript
/**
 * Modern lazy loading with Intersection Observer
 */

class LazyImageLoader {
  constructor(options = {}) {
    this.options = {
      root: null,
      rootMargin: '50px',
      threshold: 0.01,
      ...options
    };
    
    this.observer = null;
    this.init();
  }
  
  init() {
    if (!('IntersectionObserver' in window)) {
      console.warn('IntersectionObserver not supported, loading all images');
      this.loadAllImages();
      return;
    }
    
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      this.options
    );
    
    this.observeImages();
  }
  
  observeImages() {
    const images = document.querySelectorAll('img[data-src]');
    
    images.forEach(img => {
      this.observer.observe(img);
    });
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    const srcset = img.dataset.srcset;
    
    if (!src) return;
    
    // Show loading state
    img.classList.add('loading');
    
    // Create new image to preload
    const tempImg = new Image();
    
    tempImg.onload = () => {
      img.src = src;
      if (srcset) {
        img.srcset = srcset;
      }
      img.classList.remove('loading');
      img.classList.add('loaded');
    };
    
    tempImg.onerror = () => {
      img.classList.remove('loading');
      img.classList.add('error');
      console.error('Failed to load image:', src);
    };
    
    tempImg.src = src;
  }
  
  loadAllImages() {
    const images = document.querySelectorAll('img[data-src]');
    images.forEach(img => this.loadImage(img));
  }
  
  disconnect() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

// Usage:
/*
HTML:
<img 
  data-src="image.jpg" 
  data-srcset="image-480w.jpg 480w, image-800w.jpg 800w"
  alt="Description"
  class="lazy">

CSS:
.lazy {
  background-color: #f0f0f0;
  min-height: 200px;
}

.lazy.loading {
  opacity: 0.5;
}

.lazy.loaded {
  animation: fadeIn 0.3s;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

JavaScript:
const lazyLoader = new LazyImageLoader({
  rootMargin: '100px',  // Load 100px before entering viewport
  threshold: 0.01
});
*/

console.log('=== Intersection Observer Lazy Loading ===');
console.log('Modern, performant approach');
console.log('Loads images as they enter viewport');
```

### **Approach 2: Scroll Event with Debouncing**
```javascript
/**
 * Fallback using scroll events
 */

class ScrollBasedLazyLoader {
  constructor(options = {}) {
    this.options = {
      threshold: 200,  // Load when 200px from viewport
      debounceDelay: 100,
      ...options
    };
    
    this.images = [];
    this.scrollTimeout = null;
    
    this.init();
  }
  
  init() {
    this.images = Array.from(document.querySelectorAll('img[data-src]'));
    
    if (this.images.length === 0) return;
    
    // Initial check
    this.checkImages();
    
    // Listen to scroll events
    window.addEventListener('scroll', this.handleScroll.bind(this), { passive: true });
    window.addEventListener('resize', this.handleScroll.bind(this), { passive: true });
  }
  
  handleScroll() {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
    
    this.scrollTimeout = setTimeout(() => {
      this.checkImages();
    }, this.options.debounceDelay);
  }
  
  checkImages() {
    this.images = this.images.filter(img => {
      if (this.isInViewport(img)) {
        this.loadImage(img);
        return false; // Remove from array
      }
      return true; // Keep in array
    });
    
    // Remove listeners if all images loaded
    if (this.images.length === 0) {
      this.cleanup();
    }
  }
  
  isInViewport(element) {
    const rect = element.getBoundingClientRect();
    const windowHeight = window.innerHeight || document.documentElement.clientHeight;
    
    return (
      rect.top <= windowHeight + this.options.threshold &&
      rect.bottom >= -this.options.threshold
    );
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    
    if (!src) return;
    
    img.classList.add('loading');
    
    const tempImg = new Image();
    
    tempImg.onload = () => {
      img.src = src;
      img.classList.remove('loading');
      img.classList.add('loaded');
    };
    
    tempImg.onerror = () => {
      img.classList.remove('loading');
      img.classList.add('error');
    };
    
    tempImg.src = src;
  }
  
  cleanup() {
    window.removeEventListener('scroll', this.handleScroll.bind(this));
    window.removeEventListener('resize', this.handleScroll.bind(this));
    
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
  }
}

// Usage:
/*
const lazyLoader = new ScrollBasedLazyLoader({
  threshold: 300,
  debounceDelay: 150
});
*/

console.log('\n=== Scroll-Based Lazy Loading ===');
console.log('Fallback for older browsers');
console.log('Uses debounced scroll events');
```

### **Approach 3: Progressive Image Loading**
```javascript
/**
 * Load low-quality placeholder first, then high-quality
 */

class ProgressiveImageLoader {
  constructor() {
    this.observer = null;
    this.init();
  }
  
  init() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(
        (entries) => this.handleIntersection(entries),
        { rootMargin: '50px' }
      );
      
      this.observeImages();
    } else {
      this.loadAllImages();
    }
  }
  
  observeImages() {
    const images = document.querySelectorAll('.progressive-image[data-src]');
    images.forEach(img => this.observer.observe(img));
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadProgressiveImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadProgressiveImage(img) {
    const placeholder = img.dataset.placeholder;  // Low-quality image
    const src = img.dataset.src;                  // High-quality image
    
    // Load placeholder first
    if (placeholder) {
      this.loadImage(img, placeholder, 'placeholder-loaded');
    }
    
    // Then load full image
    this.loadImage(img, src, 'full-loaded');
  }
  
  loadImage(img, src, className) {
    const tempImg = new Image();
    
    tempImg.onload = () => {
      img.src = src;
      img.classList.add(className);
    };
    
    tempImg.src = src;
  }
  
  loadAllImages() {
    const images = document.querySelectorAll('.progressive-image[data-src]');
    images.forEach(img => this.loadProgressiveImage(img));
  }
}

// Usage:
/*
HTML:
<img 
  class="progressive-image"
  data-placeholder="image-thumb.jpg"
  data-src="image-full.jpg"
  alt="Description">

CSS:
.progressive-image {
  filter: blur(10px);
  transition: filter 0.3s;
}

.progressive-image.placeholder-loaded {
  filter: blur(5px);
}

.progressive-image.full-loaded {
  filter: blur(0);
}

JavaScript:
const progressiveLoader = new ProgressiveImageLoader();
*/

console.log('\n=== Progressive Image Loading ===');
console.log('Loads low-quality placeholder first');
console.log('Smooth transition to high-quality');
```

### **Approach 4: Background Image Lazy Loading**
```javascript
/**
 * Lazy load background images
 */

class BackgroundLazyLoader {
  constructor(options = {}) {
    this.options = {
      selector: '[data-bg]',
      rootMargin: '50px',
      ...options
    };
    
    this.observer = null;
    this.init();
  }
  
  init() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(
        (entries) => this.handleIntersection(entries),
        { rootMargin: this.options.rootMargin }
      );
      
      this.observeElements();
    } else {
      this.loadAllBackgrounds();
    }
  }
  
  observeElements() {
    const elements = document.querySelectorAll(this.options.selector);
    elements.forEach(el => this.observer.observe(el));
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadBackground(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadBackground(element) {
    const bg = element.dataset.bg;
    const bgSet = element.dataset.bgSet; // Multiple backgrounds
    
    if (!bg && !bgSet) return;
    
    element.classList.add('bg-loading');
    
    // Preload image
    const img = new Image();
    
    img.onload = () => {
      if (bg) {
        element.style.backgroundImage = `url('${bg}')`;
      }
      
      if (bgSet) {
        // Handle responsive backgrounds
        const sources = bgSet.split(',').map(s => s.trim());
        element.style.backgroundImage = `url('${sources[0].split(' ')[0]}')`;
      }
      
      element.classList.remove('bg-loading');
      element.classList.add('bg-loaded');
    };
    
    img.onerror = () => {
      element.classList.remove('bg-loading');
      element.classList.add('bg-error');
    };
    
    img.src = bg || bgSet.split(',')[0].split(' ')[0];
  }
  
  loadAllBackgrounds() {
    const elements = document.querySelectorAll(this.options.selector);
    elements.forEach(el => this.loadBackground(el));
  }
}

// Usage:
/*
HTML:
<div 
  data-bg="hero-image.jpg"
  data-bg-set="hero-small.jpg 480w, hero-large.jpg 1024w"
  class="hero">
  <h1>Hero Content</h1>
</div>

CSS:
[data-bg] {
  background-size: cover;
  background-position: center;
  background-color: #f0f0f0;
}

[data-bg].bg-loading {
  opacity: 0.5;
}

[data-bg].bg-loaded {
  animation: fadeIn 0.5s;
}

JavaScript:
const bgLoader = new BackgroundLazyLoader({
  selector: '[data-bg]',
  rootMargin: '100px'
});
*/

console.log('\n=== Background Image Lazy Loading ===');
console.log('For CSS background images');
console.log('Supports responsive backgrounds');
```

### **Approach 5: Native Loading Attribute**
```javascript
/**
 * Use native lazy loading with fallback
 */

class NativeLazyLoader {
  constructor() {
    this.init();
  }
  
  init() {
    if (this.supportsNativeLazyLoading()) {
      console.log('Using native lazy loading');
      this.setupNativeLazyLoading();
    } else {
      console.log('Native lazy loading not supported, using fallback');
      this.setupFallback();
    }
  }
  
  supportsNativeLazyLoading() {
    return 'loading' in HTMLImageElement.prototype;
  }
  
  setupNativeLazyLoading() {
    const images = document.querySelectorAll('img[data-src]');
    
    images.forEach(img => {
      img.src = img.dataset.src;
      img.loading = 'lazy';
      
      if (img.dataset.srcset) {
        img.srcset = img.dataset.srcset;
      }
    });
  }
  
  setupFallback() {
    // Use Intersection Observer as fallback
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            
            if (img.dataset.srcset) {
              img.srcset = img.dataset.srcset;
            }
            
            observer.unobserve(img);
          }
        });
      },
      { rootMargin: '50px' }
    );
    
    const images = document.querySelectorAll('img[data-src]');
    images.forEach(img => observer.observe(img));
  }
}

// Usage:
/*
HTML:
<img 
  data-src="image.jpg"
  data-srcset="image-480w.jpg 480w, image-800w.jpg 800w"
  alt="Description"
  loading="lazy">  <!-- Native attribute -->

JavaScript:
const nativeLoader = new NativeLazyLoader();
*/

console.log('\n=== Native Lazy Loading ===');
console.log('Uses loading="lazy" attribute');
console.log('Fallback to Intersection Observer');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical implementations
 */

// 1. Image Gallery with Lazy Loading
console.log('\n=== Image Gallery ===');

class LazyGallery {
  constructor(containerSelector) {
    this.container = document.querySelector(containerSelector);
    this.images = [];
    this.observer = null;
    
    this.init();
  }
  
  init() {
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      { rootMargin: '100px' }
    );
    
    this.loadInitialImages();
  }
  
  loadInitialImages() {
    // Load first few images immediately
    const allImages = this.container.querySelectorAll('img[data-src]');
    const visibleCount = 6;
    
    allImages.forEach((img, index) => {
      if (index < visibleCount) {
        this.loadImage(img);
      } else {
        this.observer.observe(img);
      }
    });
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    const thumb = img.dataset.thumb;
    
    // Load thumbnail first
    if (thumb) {
      img.src = thumb;
      img.classList.add('thumb-loaded');
    }
    
    // Then load full image
    const fullImg = new Image();
    
    fullImg.onload = () => {
      img.src = src;
      img.classList.remove('thumb-loaded');
      img.classList.add('full-loaded');
    };
    
    fullImg.src = src;
  }
  
  addImage(imageSrc, thumbSrc) {
    const img = document.createElement('img');
    img.dataset.src = imageSrc;
    img.dataset.thumb = thumbSrc;
    img.alt = 'Gallery image';
    
    this.container.appendChild(img);
    this.observer.observe(img);
  }
}

/*
Usage:
<div id="gallery" class="image-gallery">
  <img data-src="img1-full.jpg" data-thumb="img1-thumb.jpg">
  <img data-src="img2-full.jpg" data-thumb="img2-thumb.jpg">
  <!-- More images -->
</div>

const gallery = new LazyGallery('#gallery');
*/

// 2. Infinite Scroll with Lazy Loading
console.log('\n=== Infinite Scroll ===');

class InfiniteScrollGallery {
  constructor(containerSelector, apiEndpoint) {
    this.container = document.querySelector(containerSelector);
    this.apiEndpoint = apiEndpoint;
    this.page = 1;
    this.loading = false;
    this.hasMore = true;
    
    this.observer = null;
    this.sentinel = null;
    
    this.init();
  }
  
  init() {
    this.createSentinel();
    this.setupObserver();
    this.loadMore();
  }
  
  createSentinel() {
    this.sentinel = document.createElement('div');
    this.sentinel.className = 'sentinel';
    this.container.appendChild(this.sentinel);
  }
  
  setupObserver() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !this.loading && this.hasMore) {
            this.loadMore();
          }
        });
      },
      { rootMargin: '200px' }
    );
    
    this.observer.observe(this.sentinel);
  }
  
  async loadMore() {
    this.loading = true;
    
    try {
      const response = await fetch(`${this.apiEndpoint}?page=${this.page}`);
      const data = await response.json();
      
      if (data.images.length === 0) {
        this.hasMore = false;
        return;
      }
      
      this.renderImages(data.images);
      this.page++;
    } catch (error) {
      console.error('Failed to load images:', error);
    } finally {
      this.loading = false;
    }
  }
  
  renderImages(images) {
    images.forEach(imageData => {
      const img = document.createElement('img');
      img.dataset.src = imageData.url;
      img.alt = imageData.alt || '';
      img.loading = 'lazy';
      
      this.container.insertBefore(img, this.sentinel);
      
      // Trigger lazy loading
      img.src = imageData.url;
    });
  }
}

/*
Usage:
<div id="infinite-gallery"></div>

const infiniteGallery = new InfiniteScrollGallery(
  '#infinite-gallery',
  '/api/images'
);
*/

// 3. Responsive Image Lazy Loading
console.log('\n=== Responsive Images ===');

class ResponsiveLazyLoader {
  constructor() {
    this.observer = null;
    this.init();
  }
  
  init() {
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      { rootMargin: '50px' }
    );
    
    this.observeImages();
  }
  
  observeImages() {
    const images = document.querySelectorAll('img[data-src]');
    images.forEach(img => this.observer.observe(img));
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadResponsiveImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadResponsiveImage(img) {
    const src = img.dataset.src;
    const srcset = img.dataset.srcset;
    const sizes = img.dataset.sizes;
    
    // Determine best image based on viewport
    const selectedSrc = this.selectBestSource(srcset, sizes);
    
    const tempImg = new Image();
    
    tempImg.onload = () => {
      img.src = selectedSrc || src;
      
      if (srcset) {
        img.srcset = srcset;
      }
      
      if (sizes) {
        img.sizes = sizes;
      }
      
      img.classList.add('loaded');
    };
    
    tempImg.src = selectedSrc || src;
  }
  
  selectBestSource(srcset, sizes) {
    if (!srcset) return null;
    
    const sources = srcset.split(',').map(s => {
      const [url, descriptor] = s.trim().split(' ');
      const width = parseInt(descriptor);
      return { url, width };
    });
    
    const viewportWidth = window.innerWidth;
    const dpr = window.devicePixelRatio || 1;
    const targetWidth = viewportWidth * dpr;
    
    // Find closest match
    const sorted = sources.sort((a, b) => a.width - b.width);
    const selected = sorted.find(s => s.width >= targetWidth) || sorted[sorted.length - 1];
    
    return selected.url;
  }
}

/*
Usage:
<img 
  data-src="image.jpg"
  data-srcset="image-320w.jpg 320w, image-640w.jpg 640w, image-1024w.jpg 1024w"
  data-sizes="(max-width: 600px) 320px, (max-width: 1024px) 640px, 1024px"
  alt="Responsive image">

const responsiveLoader = new ResponsiveLazyLoader();
*/

// 4. Lazy Loading with Retry
console.log('\n=== With Retry Logic ===');

class LazyLoaderWithRetry {
  constructor(maxRetries = 3) {
    this.maxRetries = maxRetries;
    this.observer = null;
    this.init();
  }
  
  init() {
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      { rootMargin: '50px' }
    );
    
    this.observeImages();
  }
  
  observeImages() {
    const images = document.querySelectorAll('img[data-src]');
    images.forEach(img => {
      img.dataset.retries = '0';
      this.observer.observe(img);
    });
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadImageWithRetry(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadImageWithRetry(img, retryCount = 0) {
    const src = img.dataset.src;
    
    img.classList.add('loading');
    
    const tempImg = new Image();
    
    tempImg.onload = () => {
      img.src = src;
      img.classList.remove('loading');
      img.classList.add('loaded');
    };
    
    tempImg.onerror = () => {
      if (retryCount < this.maxRetries) {
        console.log(`Retry ${retryCount + 1}/${this.maxRetries} for:`, src);
        
        setTimeout(() => {
          this.loadImageWithRetry(img, retryCount + 1);
        }, Math.pow(2, retryCount) * 1000); // Exponential backoff
      } else {
        console.error('Failed to load after retries:', src);
        img.classList.remove('loading');
        img.classList.add('error');
        
        // Show fallback image
        img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect fill="%23ddd"/><text x="50%" y="50%" text-anchor="middle">Error</text></svg>';
      }
    };
    
    tempImg.src = src;
  }
}

/*
Usage:
const lazyLoader = new LazyLoaderWithRetry(3);
*/

// 5. Performance Monitoring
console.log('\n=== With Performance Monitoring ===');

class MonitoredLazyLoader {
  constructor() {
    this.metrics = {
      totalImages: 0,
      loadedImages: 0,
      failedImages: 0,
      totalLoadTime: 0,
      averageLoadTime: 0
    };
    
    this.observer = null;
    this.init();
  }
  
  init() {
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      { rootMargin: '50px' }
    );
    
    const images = document.querySelectorAll('img[data-src]');
    this.metrics.totalImages = images.length;
    
    images.forEach(img => this.observer.observe(img));
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    const startTime = performance.now();
    
    const tempImg = new Image();
    
    tempImg.onload = () => {
      const loadTime = performance.now() - startTime;
      
      img.src = src;
      img.classList.add('loaded');
      
      this.metrics.loadedImages++;
      this.metrics.totalLoadTime += loadTime;
      this.metrics.averageLoadTime = 
        this.metrics.totalLoadTime / this.metrics.loadedImages;
      
      this.logMetrics();
    };
    
    tempImg.onerror = () => {
      this.metrics.failedImages++;
      img.classList.add('error');
      
      this.logMetrics();
    };
    
    tempImg.src = src;
  }
  
  logMetrics() {
    console.log('Lazy Loading Metrics:', {
      total: this.metrics.totalImages,
      loaded: this.metrics.loadedImages,
      failed: this.metrics.failedImages,
      avgLoadTime: `${this.metrics.averageLoadTime.toFixed(2)}ms`,
      progress: `${((this.metrics.loadedImages / this.metrics.totalImages) * 100).toFixed(1)}%`
    });
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
}

/*
Usage:
const monitoredLoader = new MonitoredLazyLoader();

// Get metrics
setTimeout(() => {
  const metrics = monitoredLoader.getMetrics();
  console.log('Final metrics:', metrics);
}, 5000);
*/
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Lazy Loading Strategies:
┌──────────────────────┬────────────────────────────────┐
│ Strategy             │ Use Case                       │
├──────────────────────┼────────────────────────────────┤
│ Intersection Observer│ Modern, performant, recommended│
│                      │ No scroll event listeners      │
├──────────────────────┼────────────────────────────────┤
│ Scroll Events        │ Fallback for old browsers      │
│                      │ Requires debouncing            │
├──────────────────────┼────────────────────────────────┤
│ Native loading="lazy"│ Simplest, browser-native       │
│                      │ Limited browser support        │
├──────────────────────┼────────────────────────────────┤
│ Progressive Loading  │ Better UX, load placeholder    │
│                      │ Then full image                │
└──────────────────────┴────────────────────────────────┘

Benefits:
• Faster initial page load
• Reduced bandwidth usage
• Better Core Web Vitals (LCP, CLS)
• Improved mobile experience
• Less memory consumption
• Reduced server load

Best Practices:
• Set width/height to prevent layout shift
• Use placeholder or blur effect
• Load images slightly before viewport (rootMargin)
• Provide alt text for accessibility
• Add fallback for unsupported browsers
• Handle loading states visually
• Include retry logic for failures
• Monitor performance metrics

Optimization Tips:
• Use srcset for responsive images
• Compress images appropriately
• Use modern formats (WebP, AVIF)
• Implement progressive loading
• Cache loaded images
• Prioritize above-the-fold images
• Lazy load background images too
• Consider image CDN

Performance Metrics:
• First Contentful Paint (FCP)
• Largest Contentful Paint (LCP)
• Cumulative Layout Shift (CLS)
• Total Blocking Time (TBT)
• Bandwidth saved
• Load time reduction

Common Pitfalls:
• Not setting image dimensions (CLS)
• Loading too aggressively (rootMargin too large)
• Not handling errors
• Forgetting SEO considerations
• Breaking browser back button
• Ignoring accessibility

Browser Support:
• Intersection Observer: 95%+
• Native lazy loading: 75%+
• Scroll events: 100%
• Progressive enhancement recommended

Real-World Impact:
• 50-70% reduction in initial page weight
• 2-3x faster initial load time
• Improved mobile data usage
• Better user experience
• Higher conversion rates
• Lower bounce rates
`);
```

**Interview Tips:**
- Lazy loading: defer loading images until needed (viewport proximity)
- Intersection Observer: modern API, monitors element visibility, no scroll listeners
- Native loading="lazy": browser-native, simplest but limited support
- Scroll events: fallback for older browsers, requires debouncing
- Progressive loading: show low-quality placeholder, then high-quality
- Benefits: faster initial load, reduced bandwidth, better Core Web Vitals
- rootMargin: load images before entering viewport (e.g., '50px')
- Prevent layout shift: set width/height attributes on images
- data-src attribute: stores actual image URL
- Preload with new Image(): ensures image loads before displaying
- IntersectionObserver callback: called when element intersects viewport
- unobserve(): stop watching element after loading
- Handle errors: show fallback image, implement retry logic
- Responsive images: use srcset and sizes attributes
- Background images: use data-bg attribute, similar technique
- Performance: significant reduction in initial page weight (50-70%)
- SEO: search engines can handle lazy loading with proper implementation
- Accessibility: always include alt text, ensure keyboard navigation works
- Real-world: image galleries, infinite scroll, product listings
- Trade-offs: complexity vs performance gain, UX vs implementation
- Follow-ups: SEO impact, CLS prevention, error handling, retry logic
- Clarify: browser support needed? progressive loading? responsive images?

</details>

127. Create a web worker for heavy computations

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Web Worker**
```javascript
/**
 * Simple worker for computation
 */

// Main thread (main.js)
class WorkerManager {
  constructor(workerScript) {
    this.worker = new Worker(workerScript);
    this.setupListeners();
  }
  
  setupListeners() {
    this.worker.onmessage = (event) => {
      console.log('Result from worker:', event.data);
    };
    
    this.worker.onerror = (error) => {
      console.error('Worker error:', error.message);
    };
  }
  
  compute(data) {
    this.worker.postMessage(data);
  }
  
  terminate() {
    this.worker.terminate();
  }
}

// Worker file (worker.js)
/*
self.onmessage = function(event) {
  const data = event.data;
  
  // Heavy computation
  const result = performComputation(data);
  
  // Send result back
  self.postMessage(result);
};

function performComputation(data) {
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += Math.sqrt(i) * data;
  }
  return result;
}
*/

// Usage:
/*
const manager = new WorkerManager('worker.js');
manager.compute(42);
*/

console.log('=== Basic Web Worker ===');
console.log('Offloads heavy computation to separate thread');
console.log('Prevents UI blocking');
```

### **Approach 2: Promise-Based Worker**
```javascript
/**
 * Worker with Promise interface
 */

class PromiseWorker {
  constructor(workerScript) {
    this.worker = new Worker(workerScript);
    this.taskId = 0;
    this.pendingTasks = new Map();
    
    this.worker.onmessage = (event) => {
      const { id, result, error } = event.data;
      
      const task = this.pendingTasks.get(id);
      
      if (task) {
        if (error) {
          task.reject(new Error(error));
        } else {
          task.resolve(result);
        }
        
        this.pendingTasks.delete(id);
      }
    };
    
    this.worker.onerror = (error) => {
      console.error('Worker error:', error);
    };
  }
  
  execute(action, data) {
    return new Promise((resolve, reject) => {
      const id = this.taskId++;
      
      this.pendingTasks.set(id, { resolve, reject });
      
      this.worker.postMessage({ id, action, data });
    });
  }
  
  terminate() {
    this.pendingTasks.forEach(task => {
      task.reject(new Error('Worker terminated'));
    });
    
    this.pendingTasks.clear();
    this.worker.terminate();
  }
}

// Worker file (promise-worker.js)
/*
self.onmessage = function(event) {
  const { id, action, data } = event.data;
  
  try {
    let result;
    
    switch (action) {
      case 'fibonacci':
        result = fibonacci(data);
        break;
      case 'factorial':
        result = factorial(data);
        break;
      case 'sort':
        result = data.sort((a, b) => a - b);
        break;
      default:
        throw new Error('Unknown action: ' + action);
    }
    
    self.postMessage({ id, result });
  } catch (error) {
    self.postMessage({ id, error: error.message });
  }
};

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
*/

// Usage:
/*
const worker = new PromiseWorker('promise-worker.js');

worker.execute('fibonacci', 40)
  .then(result => console.log('Fibonacci:', result))
  .catch(error => console.error('Error:', error));

worker.execute('factorial', 20)
  .then(result => console.log('Factorial:', result));
*/

console.log('\n=== Promise-Based Worker ===');
console.log('Returns promises for async operations');
console.log('Supports multiple concurrent tasks');
```

### **Approach 3: Worker Pool**
```javascript
/**
 * Pool of workers for parallel processing
 */

class WorkerPool {
  constructor(workerScript, poolSize = navigator.hardwareConcurrency || 4) {
    this.workerScript = workerScript;
    this.poolSize = poolSize;
    this.workers = [];
    this.taskQueue = [];
    this.busyWorkers = new Set();
    
    this.init();
  }
  
  init() {
    for (let i = 0; i < this.poolSize; i++) {
      const worker = new Worker(this.workerScript);
      worker.id = i;
      
      worker.onmessage = (event) => {
        this.handleWorkerMessage(worker, event);
      };
      
      worker.onerror = (error) => {
        console.error(`Worker ${worker.id} error:`, error);
      };
      
      this.workers.push(worker);
    }
  }
  
  execute(data) {
    return new Promise((resolve, reject) => {
      const task = { data, resolve, reject };
      
      const availableWorker = this.getAvailableWorker();
      
      if (availableWorker) {
        this.assignTask(availableWorker, task);
      } else {
        this.taskQueue.push(task);
      }
    });
  }
  
  getAvailableWorker() {
    return this.workers.find(w => !this.busyWorkers.has(w.id));
  }
  
  assignTask(worker, task) {
    this.busyWorkers.add(worker.id);
    
    worker.currentTask = task;
    worker.postMessage(task.data);
  }
  
  handleWorkerMessage(worker, event) {
    const task = worker.currentTask;
    
    if (task) {
      task.resolve(event.data);
      worker.currentTask = null;
    }
    
    this.busyWorkers.delete(worker.id);
    
    // Process next task if any
    if (this.taskQueue.length > 0) {
      const nextTask = this.taskQueue.shift();
      this.assignTask(worker, nextTask);
    }
  }
  
  terminate() {
    this.workers.forEach(worker => worker.terminate());
    this.workers = [];
    this.taskQueue = [];
    this.busyWorkers.clear();
  }
  
  getStatus() {
    return {
      poolSize: this.poolSize,
      busyWorkers: this.busyWorkers.size,
      queuedTasks: this.taskQueue.length,
      availableWorkers: this.poolSize - this.busyWorkers.size
    };
  }
}

// Worker file (pool-worker.js)
/*
self.onmessage = function(event) {
  const data = event.data;
  
  // Simulate heavy computation
  const result = heavyComputation(data);
  
  self.postMessage(result);
};

function heavyComputation(data) {
  // Heavy processing
  let result = 0;
  for (let i = 0; i < 10000000; i++) {
    result += Math.sqrt(i) * data;
  }
  return result;
}
*/

// Usage:
/*
const pool = new WorkerPool('pool-worker.js', 4);

// Execute multiple tasks in parallel
const tasks = Array.from({ length: 10 }, (_, i) => i + 1);

Promise.all(tasks.map(task => pool.execute(task)))
  .then(results => {
    console.log('All results:', results);
    console.log('Pool status:', pool.getStatus());
  });
*/

console.log('\n=== Worker Pool ===');
console.log('Manages multiple workers for parallel tasks');
console.log('Automatically distributes work');
```

### **Approach 4: Inline Worker**
```javascript
/**
 * Create worker from inline code (no separate file)
 */

class InlineWorker {
  constructor(workerFunction) {
    const code = `(${workerFunction.toString()})()`;
    const blob = new Blob([code], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    
    this.worker = new Worker(workerUrl);
    this.workerUrl = workerUrl;
  }
  
  postMessage(data) {
    this.worker.postMessage(data);
  }
  
  onMessage(callback) {
    this.worker.onmessage = (event) => callback(event.data);
  }
  
  onError(callback) {
    this.worker.onerror = (error) => callback(error);
  }
  
  terminate() {
    this.worker.terminate();
    URL.revokeObjectURL(this.workerUrl);
  }
}

// Usage:
/*
const worker = new InlineWorker(function() {
  self.onmessage = function(event) {
    const { numbers } = event.data;
    
    // Sort large array
    const sorted = numbers.sort((a, b) => a - b);
    
    self.postMessage({ sorted });
  };
});

worker.onMessage((data) => {
  console.log('Sorted:', data.sorted);
});

worker.onError((error) => {
  console.error('Error:', error);
});

// Send data to worker
const largeArray = Array.from({ length: 1000000 }, () => Math.random());
worker.postMessage({ numbers: largeArray });
*/

console.log('\n=== Inline Worker ===');
console.log('Creates worker from inline code');
console.log('No separate file needed');
```

### **Approach 5: Transferable Objects**
```javascript
/**
 * Use transferable objects for better performance
 */

class TransferableWorker {
  constructor(workerScript) {
    this.worker = new Worker(workerScript);
    this.setupListeners();
  }
  
  setupListeners() {
    this.worker.onmessage = (event) => {
      console.log('Result received:', event.data);
    };
  }
  
  processArrayBuffer(buffer) {
    // Transfer ownership of ArrayBuffer to worker
    // Main thread can no longer access it
    this.worker.postMessage({ buffer }, [buffer]);
    
    console.log('Buffer transferred, main thread cannot access it anymore');
  }
  
  processImageData(imageData) {
    // Transfer ImageData
    this.worker.postMessage({ imageData }, [imageData.data.buffer]);
  }
  
  terminate() {
    this.worker.terminate();
  }
}

// Worker file (transferable-worker.js)
/*
self.onmessage = function(event) {
  const { buffer, imageData } = event.data;
  
  if (buffer) {
    // Process ArrayBuffer
    const view = new Uint8Array(buffer);
    
    // Modify data
    for (let i = 0; i < view.length; i++) {
      view[i] = view[i] * 2;
    }
    
    // Transfer back
    self.postMessage({ buffer }, [buffer]);
  }
  
  if (imageData) {
    // Process image data
    const data = imageData.data;
    
    // Invert colors
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255 - data[i];       // R
      data[i + 1] = 255 - data[i + 1]; // G
      data[i + 2] = 255 - data[i + 2]; // B
      // data[i + 3] is alpha, keep as is
    }
    
    self.postMessage({ imageData }, [data.buffer]);
  }
};
*/

// Usage:
/*
const worker = new TransferableWorker('transferable-worker.js');

// Create large ArrayBuffer
const buffer = new ArrayBuffer(1024 * 1024 * 10); // 10MB
const view = new Uint8Array(buffer);
view.fill(42);

// Transfer to worker (zero-copy)
worker.processArrayBuffer(buffer);

// buffer is now unusable in main thread
console.log('Buffer byteLength:', buffer.byteLength); // 0
*/

console.log('\n=== Transferable Objects ===');
console.log('Zero-copy transfer of ArrayBuffers');
console.log('Much faster for large data');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical applications
 */

// 1. Image Processing
console.log('\n=== Image Processing ===');

class ImageProcessor {
  constructor() {
    this.worker = new InlineWorker(function() {
      self.onmessage = function(event) {
        const { imageData, filter } = event.data;
        const data = imageData.data;
        
        switch (filter) {
          case 'grayscale':
            for (let i = 0; i < data.length; i += 4) {
              const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
              data[i] = data[i + 1] = data[i + 2] = avg;
            }
            break;
            
          case 'sepia':
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
              data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
              data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
            }
            break;
            
          case 'invert':
            for (let i = 0; i < data.length; i += 4) {
              data[i] = 255 - data[i];
              data[i + 1] = 255 - data[i + 1];
              data[i + 2] = 255 - data[i + 2];
            }
            break;
        }
        
        self.postMessage({ imageData }, [imageData.data.buffer]);
      };
    });
  }
  
  applyFilter(canvas, filter) {
    return new Promise((resolve) => {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      this.worker.onMessage((data) => {
        ctx.putImageData(data.imageData, 0, 0);
        resolve();
      });
      
      this.worker.postMessage({ imageData, filter }, [imageData.data.buffer]);
    });
  }
}

/*
Usage:
const processor = new ImageProcessor();
const canvas = document.getElementById('myCanvas');

processor.applyFilter(canvas, 'grayscale')
  .then(() => console.log('Filter applied'));
*/

// 2. Data Processing/Sorting
console.log('\n=== Large Dataset Processing ===');

class DataProcessor {
  constructor() {
    this.pool = new WorkerPool('data-worker.js', 4);
  }
  
  async sortLargeDataset(data, chunkSize = 10000) {
    // Split data into chunks
    const chunks = [];
    for (let i = 0; i < data.length; i += chunkSize) {
      chunks.push(data.slice(i, i + chunkSize));
    }
    
    // Sort chunks in parallel
    const sortedChunks = await Promise.all(
      chunks.map(chunk => this.pool.execute({ action: 'sort', data: chunk }))
    );
    
    // Merge sorted chunks (in main thread for simplicity)
    return this.mergeSortedChunks(sortedChunks);
  }
  
  mergeSortedChunks(chunks) {
    // Simple merge sort of sorted arrays
    while (chunks.length > 1) {
      const merged = [];
      
      for (let i = 0; i < chunks.length; i += 2) {
        if (i + 1 < chunks.length) {
          merged.push(this.mergeTwoArrays(chunks[i], chunks[i + 1]));
        } else {
          merged.push(chunks[i]);
        }
      }
      
      chunks = merged;
    }
    
    return chunks[0];
  }
  
  mergeTwoArrays(arr1, arr2) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < arr1.length && j < arr2.length) {
      if (arr1[i] < arr2[j]) {
        result.push(arr1[i++]);
      } else {
        result.push(arr2[j++]);
      }
    }
    
    return result.concat(arr1.slice(i), arr2.slice(j));
  }
}

/*
Usage:
const processor = new DataProcessor();
const largeArray = Array.from({ length: 1000000 }, () => Math.random());

processor.sortLargeDataset(largeArray)
  .then(sorted => console.log('Sorted', sorted.length, 'items'));
*/

// 3. Cryptography
console.log('\n=== Cryptographic Operations ===');

class CryptoWorker {
  constructor() {
    this.worker = new PromiseWorker('crypto-worker.js');
  }
  
  async hashPassword(password) {
    return this.worker.execute('hash', { password });
  }
  
  async encrypt(text, key) {
    return this.worker.execute('encrypt', { text, key });
  }
  
  async decrypt(encrypted, key) {
    return this.worker.execute('decrypt', { encrypted, key });
  }
}

/*
Worker file (crypto-worker.js):
self.onmessage = async function(event) {
  const { id, action, data } = event.data;
  
  try {
    let result;
    
    switch (action) {
      case 'hash':
        result = await hashPassword(data.password);
        break;
      case 'encrypt':
        result = await encrypt(data.text, data.key);
        break;
      case 'decrypt':
        result = await decrypt(data.encrypted, data.key);
        break;
    }
    
    self.postMessage({ id, result });
  } catch (error) {
    self.postMessage({ id, error: error.message });
  }
};

async function hashPassword(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hash))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

Usage:
const cryptoWorker = new CryptoWorker();

cryptoWorker.hashPassword('mypassword')
  .then(hash => console.log('Hash:', hash));
*/

// 4. Real-time Analytics
console.log('\n=== Real-time Analytics ===');

class AnalyticsWorker {
  constructor() {
    this.worker = new InlineWorker(function() {
      let dataPoints = [];
      
      self.onmessage = function(event) {
        const { action, data } = event.data;
        
        switch (action) {
          case 'add':
            dataPoints.push(data);
            break;
            
          case 'calculate':
            const stats = {
              count: dataPoints.length,
              sum: dataPoints.reduce((a, b) => a + b, 0),
              avg: dataPoints.reduce((a, b) => a + b, 0) / dataPoints.length,
              min: Math.min(...dataPoints),
              max: Math.max(...dataPoints)
            };
            
            self.postMessage({ stats });
            break;
            
          case 'clear':
            dataPoints = [];
            break;
        }
      };
    });
  }
  
  addDataPoint(value) {
    this.worker.postMessage({ action: 'add', data: value });
  }
  
  calculateStats() {
    return new Promise((resolve) => {
      this.worker.onMessage((data) => {
        if (data.stats) {
          resolve(data.stats);
        }
      });
      
      this.worker.postMessage({ action: 'calculate' });
    });
  }
  
  clear() {
    this.worker.postMessage({ action: 'clear' });
  }
}

/*
Usage:
const analytics = new AnalyticsWorker();

// Add data points
for (let i = 0; i < 10000; i++) {
  analytics.addDataPoint(Math.random() * 100);
}

// Calculate stats
analytics.calculateStats()
  .then(stats => console.log('Statistics:', stats));
*/

// 5. Progress Reporting
console.log('\n=== With Progress Reporting ===');

class ProgressWorker {
  constructor(workerScript) {
    this.worker = new Worker(workerScript);
    this.onProgress = null;
    
    this.worker.onmessage = (event) => {
      const { type, progress, result } = event.data;
      
      if (type === 'progress' && this.onProgress) {
        this.onProgress(progress);
      } else if (type === 'complete' && this.onComplete) {
        this.onComplete(result);
      }
    };
  }
  
  execute(data, onProgress, onComplete) {
    this.onProgress = onProgress;
    this.onComplete = onComplete;
    
    this.worker.postMessage(data);
  }
}

/*
Worker file (progress-worker.js):
self.onmessage = function(event) {
  const data = event.data;
  const totalSteps = 100;
  
  for (let i = 0; i <= totalSteps; i++) {
    // Heavy computation
    performStep(i, data);
    
    // Report progress
    if (i % 10 === 0) {
      self.postMessage({
        type: 'progress',
        progress: (i / totalSteps) * 100
      });
    }
  }
  
  self.postMessage({
    type: 'complete',
    result: 'Done!'
  });
};

Usage:
const worker = new ProgressWorker('progress-worker.js');

worker.execute(
  { data: 'something' },
  (progress) => console.log(`Progress: ${progress}%`),
  (result) => console.log('Complete:', result)
);
*/
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Web Worker Concepts:
┌──────────────────────┬────────────────────────────────┐
│ Concept              │ Description                    │
├──────────────────────┼────────────────────────────────┤
│ Separate Thread      │ Runs in background, no UI block│
│ Message Passing      │ postMessage/onmessage          │
│ No DOM Access        │ Cannot manipulate DOM          │
│ Transferable Objects │ Zero-copy data transfer        │
│ Worker Pool          │ Manage multiple workers        │
│ Shared Workers       │ Shared across browser contexts │
└──────────────────────┴────────────────────────────────┘

When to Use Web Workers:
• Heavy computations (sorting, filtering)
• Image/video processing
• Cryptographic operations
• Data parsing (JSON, CSV)
• Complex algorithms
• Real-time data processing
• Background sync

Communication:
• postMessage(data, [transferables])
• onmessage = (event) => { event.data }
• onerror = (error) => { error.message }
• Structured clone algorithm (no functions)

Transferable Objects:
• ArrayBuffer, MessagePort, ImageBitmap
• Zero-copy transfer (much faster)
• Original becomes unusable
• Syntax: postMessage(data, [buffer])

Limitations:
• No DOM access
• No window object
• No document object
• Limited APIs available
• Cannot manipulate UI directly
• Communication overhead

Available APIs in Workers:
• navigator, location (limited)
• XMLHttpRequest, fetch
• WebSockets
• IndexedDB
• setTimeout, setInterval
• crypto (Web Crypto API)
• postMessage, close

Best Practices:
• Use for CPU-intensive tasks
• Minimize data transfer
• Use transferable objects for large data
• Implement worker pool for parallel tasks
• Handle errors gracefully
• Terminate workers when done
• Use inline workers for simple cases
• Report progress for long operations

Performance Tips:
• Pool size = CPU cores (navigator.hardwareConcurrency)
• Batch processing for multiple tasks
• Use transferable objects (ArrayBuffer)
• Avoid excessive message passing
• Cache workers when possible
• Use SharedArrayBuffer for shared memory

Common Patterns:
• Promise wrapper for clean API
• Worker pool for parallel processing
• Progress reporting for long tasks
• Retry logic for failures
• Queue management for tasks
• Graceful degradation (fallback)

Real-World Applications:
• Image filters (Instagram-like effects)
• Large dataset sorting/filtering
• PDF generation
• Excel parsing
• Compression/decompression
• Hash calculation
• Machine learning inference
• Audio processing

Testing:
• Mock postMessage for unit tests
• Test with different data sizes
• Test error handling
• Test termination
• Benchmark performance gain
• Test browser compatibility

Browser Support:
• Web Workers: 97%+
• Transferable Objects: 95%+
• SharedArrayBuffer: 92%+ (with headers)
• Good fallback: run in main thread
`);
```

**Interview Tips:**
- Web Worker: separate thread for JavaScript, doesn't block UI
- Communication: postMessage() to send, onmessage to receive
- No DOM access: workers can't manipulate UI
- Use cases: heavy computations, image processing, data parsing, crypto
- Structured clone: data is copied, not shared (no functions)
- Transferable objects: ArrayBuffer zero-copy transfer (much faster)
- Worker pool: manage multiple workers for parallel tasks
- Inline worker: create from string using Blob URL
- Promise wrapper: cleaner API than callbacks
- Pool size: use navigator.hardwareConcurrency (CPU cores)
- Limitations: no window, document, or DOM access
- Available APIs: fetch, WebSockets, IndexedDB, crypto, timers
- Error handling: onerror event for worker errors
- Terminate: worker.terminate() to stop worker
- Performance: significant for CPU-bound tasks (50-80% faster)
- Overhead: message passing has cost, not for trivial tasks
- Best for: operations taking >50ms on main thread
- Progress reporting: send periodic progress messages
- Real-world: image filters, sorting large arrays, cryptography
- Trade-offs: complexity vs performance gain, memory overhead
- Follow-ups: SharedArrayBuffer, service workers, transferable objects
- Clarify: task complexity? data size? parallel processing? browser support?

</details>

128. Implement request batching/deduplication

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Request Deduplication**
```javascript
/**
 * Deduplicate identical concurrent requests
 */

class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
  }
  
  async fetch(url, options = {}) {
    const key = this.generateKey(url, options);
    
    // Check if request is already pending
    if (this.pendingRequests.has(key)) {
      console.log('Deduplicating request:', url);
      return this.pendingRequests.get(key);
    }
    
    // Create new request
    const promise = fetch(url, options)
      .then(response => response.json())
      .finally(() => {
        // Remove from pending after completion
        this.pendingRequests.delete(key);
      });
    
    // Store pending request
    this.pendingRequests.set(key, promise);
    
    return promise;
  }
  
  generateKey(url, options) {
    // Simple key generation based on URL and method
    const method = options.method || 'GET';
    const body = options.body ? JSON.stringify(options.body) : '';
    return `${method}:${url}:${body}`;
  }
  
  clear() {
    this.pendingRequests.clear();
  }
}

// Usage:
const deduplicator = new RequestDeduplicator();

// These will result in only ONE actual HTTP request
Promise.all([
  deduplicator.fetch('https://api.example.com/users/1'),
  deduplicator.fetch('https://api.example.com/users/1'),
  deduplicator.fetch('https://api.example.com/users/1')
]).then(results => {
  console.log('All results:', results);
  // All three promises get the same result
});

console.log('=== Basic Request Deduplication ===');
console.log('Prevents duplicate concurrent requests');
console.log('Returns same promise for identical requests');
```

### **Approach 2: Request Batching with Time Window**
```javascript
/**
 * Batch multiple requests within a time window
 */

class RequestBatcher {
  constructor(options = {}) {
    this.batchWindow = options.batchWindow || 50; // ms
    this.maxBatchSize = options.maxBatchSize || 10;
    
    this.pendingRequests = [];
    this.batchTimer = null;
  }
  
  async request(endpoint, params = {}) {
    return new Promise((resolve, reject) => {
      // Add request to pending batch
      this.pendingRequests.push({
        endpoint,
        params,
        resolve,
        reject
      });
      
      // Schedule batch execution
      this.scheduleBatch();
    });
  }
  
  scheduleBatch() {
    // Clear existing timer
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
    }
    
    // Execute immediately if batch is full
    if (this.pendingRequests.length >= this.maxBatchSize) {
      this.executeBatch();
      return;
    }
    
    // Otherwise wait for more requests
    this.batchTimer = setTimeout(() => {
      this.executeBatch();
    }, this.batchWindow);
  }
  
  async executeBatch() {
    if (this.pendingRequests.length === 0) return;
    
    const batch = this.pendingRequests.splice(0);
    
    console.log(`Executing batch of ${batch.length} requests`);
    
    try {
      // Send batch request to server
      const response = await fetch('/api/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          requests: batch.map(req => ({
            endpoint: req.endpoint,
            params: req.params
          }))
        })
      });
      
      const results = await response.json();
      
      // Resolve individual promises
      batch.forEach((req, index) => {
        if (results[index].error) {
          req.reject(new Error(results[index].error));
        } else {
          req.resolve(results[index].data);
        }
      });
    } catch (error) {
      // Reject all promises on batch failure
      batch.forEach(req => req.reject(error));
    }
  }
}

// Usage:
const batcher = new RequestBatcher({
  batchWindow: 100,
  maxBatchSize: 20
});

// These requests will be batched together
async function loadUserData() {
  const [user1, user2, user3] = await Promise.all([
    batcher.request('/users', { id: 1 }),
    batcher.request('/users', { id: 2 }),
    batcher.request('/users', { id: 3 })
  ]);
  
  console.log('Users:', user1, user2, user3);
}

console.log('\n=== Request Batching ===');
console.log('Combines multiple requests into one');
console.log('Reduces network overhead');
```

### **Approach 3: DataLoader Pattern (Facebook)**
```javascript
/**
 * Advanced batching and caching (like GraphQL DataLoader)
 */

class DataLoader {
  constructor(batchLoadFn, options = {}) {
    this.batchLoadFn = batchLoadFn;
    this.maxBatchSize = options.maxBatchSize || 100;
    this.batchScheduleFn = options.batchScheduleFn || this.defaultBatchSchedule;
    
    this.cache = new Map();
    this.batch = [];
    this.scheduled = false;
  }
  
  load(key) {
    // Check cache first
    if (this.cache.has(key)) {
      return Promise.resolve(this.cache.get(key));
    }
    
    // Create promise for this key
    return new Promise((resolve, reject) => {
      this.batch.push({ key, resolve, reject });
      
      // Schedule batch if not already scheduled
      if (!this.scheduled) {
        this.scheduled = true;
        this.batchScheduleFn(() => this.dispatchBatch());
      }
    });
  }
  
  loadMany(keys) {
    return Promise.all(keys.map(key => this.load(key)));
  }
  
  defaultBatchSchedule(callback) {
    // Use process.nextTick in Node.js, setTimeout in browser
    if (typeof process !== 'undefined' && process.nextTick) {
      process.nextTick(callback);
    } else {
      setTimeout(callback, 0);
    }
  }
  
  async dispatchBatch() {
    this.scheduled = false;
    
    const batch = this.batch.splice(0);
    if (batch.length === 0) return;
    
    // Extract unique keys
    const keys = batch.map(item => item.key);
    const uniqueKeys = [...new Set(keys)];
    
    try {
      // Call batch load function
      const values = await this.batchLoadFn(uniqueKeys);
      
      if (values.length !== uniqueKeys.length) {
        throw new Error('BatchLoadFn must return same number of values as keys');
      }
      
      // Create key-value map
      const valueMap = new Map();
      uniqueKeys.forEach((key, index) => {
        const value = values[index];
        valueMap.set(key, value);
        
        // Cache the result
        this.cache.set(key, value);
      });
      
      // Resolve all promises
      batch.forEach(item => {
        const value = valueMap.get(item.key);
        item.resolve(value);
      });
    } catch (error) {
      // Reject all promises
      batch.forEach(item => item.reject(error));
    }
  }
  
  clear(key) {
    if (key) {
      this.cache.delete(key);
    } else {
      this.cache.clear();
    }
  }
  
  prime(key, value) {
    this.cache.set(key, value);
  }
}

// Usage:
async function batchLoadUsers(userIds) {
  console.log('Batch loading users:', userIds);
  
  const response = await fetch('/api/users/batch', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ ids: userIds })
  });
  
  return response.json();
}

const userLoader = new DataLoader(batchLoadUsers, {
  maxBatchSize: 50
});

// These will be batched automatically
async function loadData() {
  const user1 = await userLoader.load(1);
  const user2 = await userLoader.load(2);
  const user3 = await userLoader.load(1); // Cached, no request
  
  console.log('Users:', user1, user2, user3);
}

console.log('\n=== DataLoader Pattern ===');
console.log('Batching + caching combined');
console.log('Used by GraphQL servers');
```

### **Approach 4: Request Queue with Prioritization**
```javascript
/**
 * Queue requests with priority and deduplication
 */

class PriorityRequestQueue {
  constructor(options = {}) {
    this.concurrency = options.concurrency || 5;
    this.running = 0;
    
    this.queues = {
      high: [],
      normal: [],
      low: []
    };
    
    this.pendingRequests = new Map();
  }
  
  async request(url, options = {}, priority = 'normal') {
    const key = this.generateKey(url, options);
    
    // Deduplicate
    if (this.pendingRequests.has(key)) {
      console.log('Deduplicating:', url);
      return this.pendingRequests.get(key);
    }
    
    // Create promise
    const promise = new Promise((resolve, reject) => {
      this.queues[priority].push({
        url,
        options,
        key,
        resolve,
        reject
      });
    });
    
    this.pendingRequests.set(key, promise);
    
    // Process queue
    this.processQueue();
    
    return promise;
  }
  
  async processQueue() {
    if (this.running >= this.concurrency) return;
    
    // Get next request by priority
    const request = this.getNextRequest();
    if (!request) return;
    
    this.running++;
    
    try {
      const response = await fetch(request.url, request.options);
      const data = await response.json();
      
      request.resolve(data);
    } catch (error) {
      request.reject(error);
    } finally {
      this.running--;
      this.pendingRequests.delete(request.key);
      
      // Process next request
      this.processQueue();
    }
  }
  
  getNextRequest() {
    // Check high priority first
    if (this.queues.high.length > 0) {
      return this.queues.high.shift();
    }
    
    // Then normal
    if (this.queues.normal.length > 0) {
      return this.queues.normal.shift();
    }
    
    // Finally low
    if (this.queues.low.length > 0) {
      return this.queues.low.shift();
    }
    
    return null;
  }
  
  generateKey(url, options) {
    const method = options.method || 'GET';
    const body = options.body ? JSON.stringify(options.body) : '';
    return `${method}:${url}:${body}`;
  }
  
  getQueueStatus() {
    return {
      running: this.running,
      high: this.queues.high.length,
      normal: this.queues.normal.length,
      low: this.queues.low.length
    };
  }
}

// Usage:
const queue = new PriorityRequestQueue({ concurrency: 3 });

// High priority (user interaction)
queue.request('/api/user/profile', {}, 'high')
  .then(data => console.log('Profile:', data));

// Normal priority (content)
queue.request('/api/posts', {}, 'normal')
  .then(data => console.log('Posts:', data));

// Low priority (analytics)
queue.request('/api/analytics', {}, 'low')
  .then(data => console.log('Analytics:', data));

console.log('\n=== Priority Request Queue ===');
console.log('Prioritizes important requests');
console.log('Limits concurrent requests');
```

### **Approach 5: Debounced Request Manager**
```javascript
/**
 * Debounce and batch requests with caching
 */

class DebouncedRequestManager {
  constructor(options = {}) {
    this.debounceTime = options.debounceTime || 300;
    this.cacheTime = options.cacheTime || 60000; // 1 minute
    
    this.cache = new Map();
    this.pendingRequests = new Map();
    this.debounceTimers = new Map();
  }
  
  async request(url, options = {}) {
    const key = this.generateKey(url, options);
    
    // Check cache
    const cached = this.getFromCache(key);
    if (cached) {
      console.log('Returning cached result:', url);
      return Promise.resolve(cached);
    }
    
    // Check if request is pending
    if (this.pendingRequests.has(key)) {
      console.log('Request already pending:', url);
      return this.pendingRequests.get(key);
    }
    
    // Create debounced request
    return new Promise((resolve, reject) => {
      // Clear existing timer
      if (this.debounceTimers.has(key)) {
        clearTimeout(this.debounceTimers.get(key));
      }
      
      // Set new timer
      const timer = setTimeout(async () => {
        this.debounceTimers.delete(key);
        
        try {
          const response = await fetch(url, options);
          const data = await response.json();
          
          // Cache result
          this.setCache(key, data);
          
          this.pendingRequests.delete(key);
          resolve(data);
        } catch (error) {
          this.pendingRequests.delete(key);
          reject(error);
        }
      }, this.debounceTime);
      
      this.debounceTimers.set(key, timer);
    });
  }
  
  generateKey(url, options) {
    const method = options.method || 'GET';
    const body = options.body ? JSON.stringify(options.body) : '';
    return `${method}:${url}:${body}`;
  }
  
  getFromCache(key) {
    const cached = this.cache.get(key);
    
    if (!cached) return null;
    
    // Check if expired
    if (Date.now() - cached.timestamp > this.cacheTime) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.data;
  }
  
  setCache(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }
  
  clearCache(key) {
    if (key) {
      const fullKey = typeof key === 'string' ? key : this.generateKey(key.url, key.options);
      this.cache.delete(fullKey);
    } else {
      this.cache.clear();
    }
  }
}

// Usage:
const manager = new DebouncedRequestManager({
  debounceTime: 500,
  cacheTime: 30000
});

// Rapid calls - only last one executes after 500ms
for (let i = 0; i < 10; i++) {
  manager.request('/api/search', {
    method: 'POST',
    body: JSON.stringify({ query: 'test' })
  }).then(data => console.log('Search result:', data));
}

console.log('\n=== Debounced Request Manager ===');
console.log('Debounces rapid requests');
console.log('Caches results with TTL');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical implementations
 */

// 1. GraphQL-like Batch Loader
console.log('\n=== GraphQL Batch Loading ===');

class GraphQLBatcher {
  constructor(endpoint) {
    this.endpoint = endpoint;
    this.loaders = new Map();
  }
  
  getLoader(type, batchFn) {
    if (!this.loaders.has(type)) {
      this.loaders.set(type, new DataLoader(batchFn));
    }
    return this.loaders.get(type);
  }
  
  async loadUser(userId) {
    const loader = this.getLoader('user', async (ids) => {
      console.log('Batch loading users:', ids);
      
      const response = await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: `
            query BatchUsers($ids: [ID!]!) {
              users(ids: $ids) {
                id
                name
                email
              }
            }
          `,
          variables: { ids }
        })
      });
      
      const result = await response.json();
      return result.data.users;
    });
    
    return loader.load(userId);
  }
  
  async loadPost(postId) {
    const loader = this.getLoader('post', async (ids) => {
      console.log('Batch loading posts:', ids);
      
      const response = await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: `
            query BatchPosts($ids: [ID!]!) {
              posts(ids: $ids) {
                id
                title
                content
              }
            }
          `,
          variables: { ids }
        })
      });
      
      const result = await response.json();
      return result.data.posts;
    });
    
    return loader.load(postId);
  }
  
  clearCache() {
    this.loaders.forEach(loader => loader.clear());
  }
}

/*
Usage:
const batcher = new GraphQLBatcher('/graphql');

async function loadData() {
  // These will be batched into two requests
  const [user1, user2, post1, post2] = await Promise.all([
    batcher.loadUser(1),
    batcher.loadUser(2),
    batcher.loadPost(10),
    batcher.loadPost(20)
  ]);
  
  console.log('Loaded:', user1, user2, post1, post2);
}
*/

// 2. Search Request Deduplication
console.log('\n=== Search Request Deduplication ===');

class SearchManager {
  constructor(apiEndpoint) {
    this.apiEndpoint = apiEndpoint;
    this.pendingSearches = new Map();
    this.searchCache = new Map();
    this.debounceTimers = new Map();
  }
  
  search(query, options = {}) {
    return new Promise((resolve, reject) => {
      // Clear previous debounce timer for this query type
      const timerKey = options.category || 'default';
      if (this.debounceTimers.has(timerKey)) {
        clearTimeout(this.debounceTimers.get(timerKey));
      }
      
      // Debounce search
      const timer = setTimeout(async () => {
        this.debounceTimers.delete(timerKey);
        
        const cacheKey = `${query}:${JSON.stringify(options)}`;
        
        // Check cache
        if (this.searchCache.has(cacheKey)) {
          console.log('Returning cached search:', query);
          resolve(this.searchCache.get(cacheKey));
          return;
        }
        
        // Deduplicate
        if (this.pendingSearches.has(cacheKey)) {
          console.log('Deduplicating search:', query);
          const pending = await this.pendingSearches.get(cacheKey);
          resolve(pending);
          return;
        }
        
        // Execute search
        const searchPromise = this.executeSearch(query, options);
        this.pendingSearches.set(cacheKey, searchPromise);
        
        try {
          const results = await searchPromise;
          this.searchCache.set(cacheKey, results);
          resolve(results);
        } catch (error) {
          reject(error);
        } finally {
          this.pendingSearches.delete(cacheKey);
        }
      }, 300);
      
      this.debounceTimers.set(timerKey, timer);
    });
  }
  
  async executeSearch(query, options) {
    console.log('Executing search:', query);
    
    const response = await fetch(`${this.apiEndpoint}/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, ...options })
    });
    
    return response.json();
  }
  
  clearCache() {
    this.searchCache.clear();
  }
}

/*
Usage:
const searchManager = new SearchManager('/api');

// User typing rapidly
searchManager.search('java')
  .then(results => console.log('Results:', results));

searchManager.search('javasc')
  .then(results => console.log('Results:', results));

searchManager.search('javascript')
  .then(results => console.log('Results:', results));

// Only last search executes
*/

// 3. API Rate Limiter with Batching
console.log('\n=== Rate-Limited Batch Requests ===');

class RateLimitedBatcher {
  constructor(options = {}) {
    this.requestsPerSecond = options.requestsPerSecond || 10;
    this.batchSize = options.batchSize || 5;
    
    this.queue = [];
    this.requestsInWindow = 0;
    this.windowStart = Date.now();
  }
  
  async request(url, options = {}) {
    return new Promise((resolve, reject) => {
      this.queue.push({ url, options, resolve, reject });
      this.processQueue();
    });
  }
  
  async processQueue() {
    // Reset window if needed
    const now = Date.now();
    if (now - this.windowStart >= 1000) {
      this.requestsInWindow = 0;
      this.windowStart = now;
    }
    
    // Check rate limit
    if (this.requestsInWindow >= this.requestsPerSecond) {
      // Wait for next window
      const waitTime = 1000 - (now - this.windowStart);
      setTimeout(() => this.processQueue(), waitTime);
      return;
    }
    
    // Get batch
    const batchSize = Math.min(
      this.batchSize,
      this.requestsPerSecond - this.requestsInWindow,
      this.queue.length
    );
    
    if (batchSize === 0) return;
    
    const batch = this.queue.splice(0, batchSize);
    this.requestsInWindow += batch.length;
    
    console.log(`Processing batch of ${batch.length} requests`);
    
    // Execute batch
    const promises = batch.map(async (item) => {
      try {
        const response = await fetch(item.url, item.options);
        const data = await response.json();
        item.resolve(data);
      } catch (error) {
        item.reject(error);
      }
    });
    
    await Promise.all(promises);
    
    // Process remaining queue
    if (this.queue.length > 0) {
      setTimeout(() => this.processQueue(), 0);
    }
  }
}

/*
Usage:
const rateLimiter = new RateLimitedBatcher({
  requestsPerSecond: 5,
  batchSize: 3
});

// Make many requests
for (let i = 0; i < 20; i++) {
  rateLimiter.request(`/api/data/${i}`)
    .then(data => console.log(`Data ${i}:`, data));
}
*/

// 4. Multi-Source Data Aggregator
console.log('\n=== Multi-Source Aggregator ===');

class DataAggregator {
  constructor() {
    this.loaders = {
      users: new DataLoader(this.batchLoadUsers.bind(this)),
      posts: new DataLoader(this.batchLoadPosts.bind(this)),
      comments: new DataLoader(this.batchLoadComments.bind(this))
    };
  }
  
  async batchLoadUsers(userIds) {
    console.log('Batch loading users:', userIds);
    const response = await fetch('/api/users/batch', {
      method: 'POST',
      body: JSON.stringify({ ids: userIds })
    });
    return response.json();
  }
  
  async batchLoadPosts(postIds) {
    console.log('Batch loading posts:', postIds);
    const response = await fetch('/api/posts/batch', {
      method: 'POST',
      body: JSON.stringify({ ids: postIds })
    });
    return response.json();
  }
  
  async batchLoadComments(commentIds) {
    console.log('Batch loading comments:', commentIds);
    const response = await fetch('/api/comments/batch', {
      method: 'POST',
      body: JSON.stringify({ ids: commentIds })
    });
    return response.json();
  }
  
  async loadPostWithAuthor(postId) {
    const post = await this.loaders.posts.load(postId);
    const author = await this.loaders.users.load(post.authorId);
    
    return { ...post, author };
  }
  
  async loadPostWithComments(postId) {
    const post = await this.loaders.posts.load(postId);
    const comments = await this.loaders.comments.loadMany(post.commentIds);
    
    // Load comment authors
    const authorIds = [...new Set(comments.map(c => c.authorId))];
    const authors = await this.loaders.users.loadMany(authorIds);
    
    const authorMap = new Map(authors.map(a => [a.id, a]));
    const commentsWithAuthors = comments.map(c => ({
      ...c,
      author: authorMap.get(c.authorId)
    }));
    
    return { ...post, comments: commentsWithAuthors };
  }
  
  clearCache() {
    Object.values(this.loaders).forEach(loader => loader.clear());
  }
}

/*
Usage:
const aggregator = new DataAggregator();

// Load multiple posts with authors and comments
const posts = await Promise.all([
  aggregator.loadPostWithComments(1),
  aggregator.loadPostWithComments(2),
  aggregator.loadPostWithComments(3)
]);

// All data loaded with minimal requests due to batching
*/

// 5. Performance Monitoring
console.log('\n=== With Performance Monitoring ===');

class MonitoredBatcher {
  constructor(batchFn, options = {}) {
    this.dataLoader = new DataLoader(batchFn, options);
    
    this.metrics = {
      totalRequests: 0,
      batchedRequests: 0,
      cacheHits: 0,
      totalBatches: 0,
      averageBatchSize: 0
    };
  }
  
  async load(key) {
    this.metrics.totalRequests++;
    
    // Check if in cache
    if (this.dataLoader.cache.has(key)) {
      this.metrics.cacheHits++;
    }
    
    const result = await this.dataLoader.load(key);
    
    this.updateMetrics();
    
    return result;
  }
  
  updateMetrics() {
    const batchCount = this.metrics.totalRequests - this.metrics.cacheHits;
    this.metrics.batchedRequests = batchCount;
    
    if (batchCount > 0) {
      this.metrics.averageBatchSize = 
        this.metrics.totalRequests / batchCount;
    }
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      cacheHitRate: this.metrics.cacheHits / this.metrics.totalRequests,
      batchEfficiency: 1 - (this.metrics.batchedRequests / this.metrics.totalRequests)
    };
  }
  
  resetMetrics() {
    this.metrics = {
      totalRequests: 0,
      batchedRequests: 0,
      cacheHits: 0,
      totalBatches: 0,
      averageBatchSize: 0
    };
  }
}

/*
Usage:
const batcher = new MonitoredBatcher(
  async (ids) => {
    const response = await fetch('/api/batch', {
      method: 'POST',
      body: JSON.stringify({ ids })
    });
    return response.json();
  }
);

// Make requests
await Promise.all([
  batcher.load(1),
  batcher.load(2),
  batcher.load(1), // cache hit
  batcher.load(3)
]);

console.log('Metrics:', batcher.getMetrics());
// {
//   totalRequests: 4,
//   batchedRequests: 3,
//   cacheHits: 1,
//   cacheHitRate: 0.25,
//   batchEfficiency: 0.25
// }
*/
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Request Optimization Strategies:
┌──────────────────────┬────────────────────────────────┐
│ Strategy             │ Use Case                       │
├──────────────────────┼────────────────────────────────┤
│ Deduplication        │ Identical concurrent requests  │
│                      │ Prevents duplicate work        │
├──────────────────────┼────────────────────────────────┤
│ Batching             │ Multiple similar requests      │
│                      │ Combines into single request   │
├──────────────────────┼────────────────────────────────┤
│ DataLoader           │ GraphQL-style batch + cache    │
│                      │ Per-request caching            │
├──────────────────────┼────────────────────────────────┤
│ Debouncing           │ Rapid repeated requests        │
│                      │ Search, autocomplete           │
├──────────────────────┼────────────────────────────────┤
│ Priority Queue       │ Different importance levels    │
│                      │ Rate limiting                  │
└──────────────────────┴────────────────────────────────┘

Benefits:
• Reduced network requests (50-90%)
• Lower server load
• Faster response times
• Better user experience
• Reduced API costs
• Less bandwidth usage
• Improved scalability

Deduplication:
• Same request already pending
• Return same promise to all callers
• Clear after completion
• Key: method + URL + body
• No additional server load

Batching:
• Combine N requests into 1
• Time window or size threshold
• Server must support batch endpoint
• Reduces HTTP overhead
• GraphQL uses this heavily

DataLoader Pattern:
• Batching per event loop tick
• Built-in caching (per request)
• Prevents N+1 query problem
• Facebook's solution for GraphQL
• Automatic deduplication

Best Practices:
• Use deduplication for identical requests
• Batch similar requests together
• Cache results appropriately
• Set reasonable batch windows (10-50ms)
• Implement retry logic
• Monitor batch sizes
• Handle errors gracefully
• Clear cache strategically

Common Patterns:
• Search debouncing (300-500ms)
• DataLoader for GraphQL
• Priority queue for API limits
• Request pooling for HTTP/2
• Prefetching for predictable patterns

Server-Side Considerations:
• Support batch endpoints
• Return results in same order
• Handle partial failures
• Set reasonable limits
• Use proper status codes
• Document batch format

Performance Gains:
• 50-90% reduction in requests
• 30-70% faster page loads
• Significantly lower server load
• Better mobile experience
• Reduced API quota usage

Real-World Examples:
• GraphQL DataLoader
• Facebook's Relay
• Apollo Client
• React Query batching
• REST batch APIs

Trade-offs:
• Complexity vs performance
• Batch window vs latency
• Cache size vs memory
• Server support required
• Error handling complexity

When NOT to Use:
• Single, isolated requests
• Real-time critical updates
• Different authentication per request
• Requests with side effects
• Server doesn't support batching

Testing:
• Mock network layer
• Test deduplication logic
• Verify batch formation
• Test cache behavior
• Test error scenarios
• Measure performance improvement

Metrics to Track:
• Request count before/after
• Average batch size
• Cache hit rate
• Response time improvement
• Server load reduction
• Error rate

Browser Support:
• Map/Set: 97%+
• Promise: 98%+
• fetch API: 98%+
• setTimeout: 100%
• All major browsers supported
`);
```

**Interview Tips:**
- Request deduplication: prevent duplicate concurrent requests, return same promise
- Batching: combine multiple requests into one, reduces network overhead
- DataLoader pattern: Facebook's solution, batching + caching per request
- Time window: collect requests for N milliseconds, then execute batch
- Key generation: method + URL + body uniquely identifies request
- Benefits: 50-90% reduction in network requests, faster performance
- Cache: store results with TTL to avoid repeated requests
- Debouncing: delay request until user stops typing (search, autocomplete)
- Priority queue: handle important requests first, rate limiting
- GraphQL: heavily uses batching to solve N+1 problem
- N+1 problem: loading author for each post = N+1 queries, batching solves this
- Server support: needs batch endpoint that accepts multiple requests
- Batch size: balance between efficiency and latency (typically 10-100 items)
- Max batch size: prevent oversized requests, split if needed
- Error handling: partial failures should still return successes
- process.nextTick: batches requests in same event loop tick
- Real-world: DataLoader in GraphQL servers, search deduplication, API optimization
- Trade-offs: complexity vs performance, memory for cache
- When not to use: single requests, real-time updates, side effects
- Follow-ups: cache invalidation, batch endpoint design, error handling
- Clarify: server support? batch size? cache strategy? priority needs?

</details>

129. Build a simple service worker for caching

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Service Worker with Cache First Strategy**
```javascript
/**
 * Simple service worker for static asset caching
 */

// service-worker.js
const CACHE_NAME = 'my-app-cache-v1';
const urlsToCache = [
  '/',
  '/index.html',
  '/styles.css',
  '/script.js',
  '/logo.png'
];

// Install event - cache static assets
self.addEventListener('install', (event) => {
  console.log('[Service Worker] Installing...');
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('[Service Worker] Caching static assets');
        return cache.addAll(urlsToCache);
      })
      .then(() => {
        console.log('[Service Worker] Installation complete');
        return self.skipWaiting(); // Activate immediately
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activating...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              console.log('[Service Worker] Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        console.log('[Service Worker] Activation complete');
        return self.clients.claim(); // Take control immediately
      })
  );
});

// Fetch event - serve from cache first
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((cachedResponse) => {
        if (cachedResponse) {
          console.log('[Service Worker] Serving from cache:', event.request.url);
          return cachedResponse;
        }
        
        console.log('[Service Worker] Fetching from network:', event.request.url);
        return fetch(event.request)
          .then((response) => {
            // Cache successful responses
            if (response.status === 200) {
              const responseToCache = response.clone();
              
              caches.open(CACHE_NAME)
                .then((cache) => {
                  cache.put(event.request, responseToCache);
                });
            }
            
            return response;
          });
      })
      .catch((error) => {
        console.error('[Service Worker] Fetch failed:', error);
        
        // Return offline page if available
        return caches.match('/offline.html');
      })
  );
});

// Register service worker (in main.js)
/*
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then((registration) => {
        console.log('Service Worker registered:', registration.scope);
      })
      .catch((error) => {
        console.error('Service Worker registration failed:', error);
      });
  });
}
*/

console.log('=== Basic Service Worker ===');
console.log('Cache-first strategy');
console.log('Offline support');
```

### **Approach 2: Network First with Cache Fallback**
```javascript
/**
 * Network first strategy for dynamic content
 */

// service-worker.js
const CACHE_NAME = 'network-first-v1';
const STATIC_CACHE = 'static-v1';
const DYNAMIC_CACHE = 'dynamic-v1';

const staticAssets = [
  '/',
  '/index.html',
  '/offline.html',
  '/styles.css'
];

// Install
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => cache.addAll(staticAssets))
      .then(() => self.skipWaiting())
  );
});

// Activate
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then((keys) => {
        return Promise.all(
          keys
            .filter((key) => key !== STATIC_CACHE && key !== DYNAMIC_CACHE)
            .map((key) => caches.delete(key))
        );
      })
      .then(() => self.clients.claim())
  );
});

// Fetch - Network first strategy
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // Different strategies for different request types
  if (request.url.includes('/api/')) {
    // Network first for API calls
    event.respondWith(networkFirst(request));
  } else if (request.destination === 'image') {
    // Cache first for images
    event.respondWith(cacheFirst(request));
  } else {
    // Stale while revalidate for pages
    event.respondWith(staleWhileRevalidate(request));
  }
});

// Network first strategy
async function networkFirst(request) {
  try {
    const response = await fetch(request);
    
    // Cache successful API responses
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    // Fallback to cache
    const cached = await caches.match(request);
    
    if (cached) {
      return cached;
    }
    
    // Return error response
    return new Response(JSON.stringify({ error: 'Network failed' }), {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Cache first strategy
async function cacheFirst(request) {
  const cached = await caches.match(request);
  
  if (cached) {
    return cached;
  }
  
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    // Return placeholder image
    return caches.match('/placeholder.png');
  }
}

// Stale while revalidate
async function staleWhileRevalidate(request) {
  const cached = await caches.match(request);
  
  const fetchPromise = fetch(request)
    .then((response) => {
      if (response.ok) {
        const cache = caches.open(STATIC_CACHE);
        cache.then((c) => c.put(request, response.clone()));
      }
      return response;
    })
    .catch(() => cached);
  
  return cached || fetchPromise;
}

console.log('\n=== Network First Strategy ===');
console.log('Always tries network first');
console.log('Falls back to cache if offline');
```

### **Approach 3: Cache Strategies with Expiration**
```javascript
/**
 * Multiple caching strategies with TTL
 */

const CACHE_VERSION = 'v2';
const CACHES = {
  static: `static-${CACHE_VERSION}`,
  dynamic: `dynamic-${CACHE_VERSION}`,
  images: `images-${CACHE_VERSION}`
};

const CACHE_EXPIRATION = {
  static: Infinity,
  dynamic: 3600000,  // 1 hour
  images: 86400000   // 24 hours
};

const MAX_CACHE_SIZE = {
  dynamic: 50,
  images: 100
};

// Install
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHES.static)
      .then((cache) => {
        return cache.addAll([
          '/',
          '/index.html',
          '/app.css',
          '/app.js',
          '/offline.html'
        ]);
      })
      .then(() => self.skipWaiting())
  );
});

// Activate
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then((keys) => {
        return Promise.all(
          keys
            .filter((key) => !Object.values(CACHES).includes(key))
            .map((key) => caches.delete(key))
        );
      })
      .then(() => self.clients.claim())
  );
});

// Fetch
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }
  
  // Route to appropriate strategy
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirstWithExpiration(request, CACHES.dynamic));
  } else if (request.destination === 'image') {
    event.respondWith(cacheFirstWithExpiration(request, CACHES.images));
  } else {
    event.respondWith(cacheFirstWithExpiration(request, CACHES.static));
  }
});

// Network first with cache expiration
async function networkFirstWithExpiration(request, cacheName) {
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(cacheName);
      
      // Add timestamp to cached response
      const clonedResponse = response.clone();
      const body = await clonedResponse.blob();
      
      const headers = new Headers(clonedResponse.headers);
      headers.set('sw-cache-time', Date.now().toString());
      
      const cachedResponse = new Response(body, {
        status: clonedResponse.status,
        statusText: clonedResponse.statusText,
        headers: headers
      });
      
      await cache.put(request, cachedResponse);
      
      // Limit cache size
      await limitCacheSize(cacheName, MAX_CACHE_SIZE.dynamic);
    }
    
    return response;
  } catch (error) {
    const cached = await caches.match(request);
    
    if (cached) {
      // Check if expired
      const cacheTime = cached.headers.get('sw-cache-time');
      const expiration = CACHE_EXPIRATION.dynamic;
      
      if (cacheTime && Date.now() - parseInt(cacheTime) > expiration) {
        console.log('[SW] Cache expired:', request.url);
        // Could delete and return error, or still return stale data
      }
      
      return cached;
    }
    
    return new Response('Offline', { status: 503 });
  }
}

// Cache first with expiration
async function cacheFirstWithExpiration(request, cacheName) {
  const cached = await caches.match(request);
  
  if (cached) {
    // Check expiration
    const cacheTime = cached.headers.get('sw-cache-time');
    const expiration = CACHE_EXPIRATION[cacheName.split('-')[0]];
    
    if (cacheTime && Date.now() - parseInt(cacheTime) < expiration) {
      // Update in background
      updateCache(request, cacheName);
      return cached;
    }
  }
  
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(cacheName);
      
      const body = await response.clone().blob();
      const headers = new Headers(response.headers);
      headers.set('sw-cache-time', Date.now().toString());
      
      const cachedResponse = new Response(body, {
        status: response.status,
        statusText: response.statusText,
        headers: headers
      });
      
      await cache.put(request, cachedResponse);
      
      const maxSize = MAX_CACHE_SIZE[cacheName.split('-')[0]];
      if (maxSize) {
        await limitCacheSize(cacheName, maxSize);
      }
    }
    
    return response;
  } catch (error) {
    return cached || new Response('Offline', { status: 503 });
  }
}

// Update cache in background
async function updateCache(request, cacheName) {
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(cacheName);
      
      const body = await response.clone().blob();
      const headers = new Headers(response.headers);
      headers.set('sw-cache-time', Date.now().toString());
      
      const cachedResponse = new Response(body, {
        status: response.status,
        statusText: response.statusText,
        headers: headers
      });
      
      await cache.put(request, cachedResponse);
    }
  } catch (error) {
    // Silently fail
  }
}

// Limit cache size
async function limitCacheSize(cacheName, maxSize) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  
  if (keys.length > maxSize) {
    // Delete oldest entries
    const toDelete = keys.length - maxSize;
    
    for (let i = 0; i < toDelete; i++) {
      await cache.delete(keys[i]);
    }
  }
}

console.log('\n=== Cache with Expiration ===');
console.log('TTL-based cache invalidation');
console.log('Maximum cache size limits');
```

### **Approach 4: Background Sync**
```javascript
/**
 * Service worker with background sync
 */

const CACHE_NAME = 'sync-v1';
const QUEUE_NAME = 'sync-queue';

// Install
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(['/']))
      .then(() => self.skipWaiting())
  );
});

// Activate
self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim());
});

// Fetch
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // Handle POST requests with background sync
  if (request.method === 'POST') {
    event.respondWith(handlePostRequest(request));
    return;
  }
  
  // Regular GET requests
  event.respondWith(
    caches.match(request)
      .then((cached) => cached || fetch(request))
  );
});

// Handle POST requests
async function handlePostRequest(request) {
  try {
    const response = await fetch(request.clone());
    return response;
  } catch (error) {
    // Queue for background sync
    const requestData = {
      url: request.url,
      method: request.method,
      headers: Array.from(request.headers.entries()),
      body: await request.clone().text()
    };
    
    // Store in IndexedDB or cache
    await queueRequest(requestData);
    
    // Register sync
    await self.registration.sync.register(QUEUE_NAME);
    
    return new Response(
      JSON.stringify({ queued: true, message: 'Request queued for sync' }),
      { status: 202, headers: { 'Content-Type': 'application/json' } }
    );
  }
}

// Queue request
async function queueRequest(requestData) {
  const cache = await caches.open(QUEUE_NAME);
  const queuedRequests = await getQueuedRequests(cache);
  
  queuedRequests.push(requestData);
  
  await cache.put(
    '/queue',
    new Response(JSON.stringify(queuedRequests))
  );
}

// Get queued requests
async function getQueuedRequests(cache) {
  const response = await cache.match('/queue');
  
  if (!response) {
    return [];
  }
  
  return response.json();
}

// Background sync event
self.addEventListener('sync', (event) => {
  if (event.tag === QUEUE_NAME) {
    event.waitUntil(syncQueuedRequests());
  }
});

// Sync queued requests
async function syncQueuedRequests() {
  const cache = await caches.open(QUEUE_NAME);
  const queuedRequests = await getQueuedRequests(cache);
  
  if (queuedRequests.length === 0) {
    return;
  }
  
  console.log('[SW] Syncing queued requests:', queuedRequests.length);
  
  const results = await Promise.allSettled(
    queuedRequests.map(async (reqData) => {
      const response = await fetch(reqData.url, {
        method: reqData.method,
        headers: new Headers(reqData.headers),
        body: reqData.body
      });
      
      return response;
    })
  );
  
  // Remove successfully synced requests
  const remainingRequests = [];
  
  results.forEach((result, index) => {
    if (result.status === 'rejected') {
      remainingRequests.push(queuedRequests[index]);
    }
  });
  
  // Update queue
  if (remainingRequests.length > 0) {
    await cache.put(
      '/queue',
      new Response(JSON.stringify(remainingRequests))
    );
  } else {
    await cache.delete('/queue');
  }
  
  // Notify clients
  const clients = await self.clients.matchAll();
  clients.forEach((client) => {
    client.postMessage({
      type: 'sync-complete',
      synced: results.filter((r) => r.status === 'fulfilled').length,
      failed: remainingRequests.length
    });
  });
}

console.log('\n=== Background Sync ===');
console.log('Queues failed requests');
console.log('Syncs when connection restored');
```

### **Approach 5: Advanced Service Worker with Push Notifications**
```javascript
/**
 * Full-featured service worker
 */

const VERSION = 'v1';
const CACHES = {
  static: `static-${VERSION}`,
  dynamic: `dynamic-${VERSION}`,
  images: `images-${VERSION}`
};

// Install
self.addEventListener('install', (event) => {
  console.log('[SW] Installing version:', VERSION);
  
  event.waitUntil(
    Promise.all([
      caches.open(CACHES.static).then((cache) => {
        return cache.addAll([
          '/',
          '/index.html',
          '/styles.css',
          '/app.js',
          '/offline.html',
          '/manifest.json'
        ]);
      }),
      // Precache critical resources
      self.skipWaiting()
    ])
  );
});

// Activate
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating version:', VERSION);
  
  event.waitUntil(
    Promise.all([
      // Clean old caches
      caches.keys().then((keys) => {
        return Promise.all(
          keys
            .filter((key) => !Object.values(CACHES).includes(key))
            .map((key) => {
              console.log('[SW] Deleting old cache:', key);
              return caches.delete(key);
            })
        );
      }),
      // Take control
      self.clients.claim()
    ])
  );
});

// Fetch
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }
  
  // Skip cross-origin requests (except images)
  if (url.origin !== location.origin && request.destination !== 'image') {
    return;
  }
  
  // Route by request type
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirst(request, CACHES.dynamic));
  } else if (request.destination === 'image') {
    event.respondWith(cacheFirst(request, CACHES.images));
  } else {
    event.respondWith(staleWhileRevalidate(request, CACHES.static));
  }
});

// Cache strategies
async function networkFirst(request, cacheName) {
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(cacheName);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    return (await caches.match(request)) || 
      new Response('Offline', { status: 503 });
  }
}

async function cacheFirst(request, cacheName) {
  const cached = await caches.match(request);
  if (cached) return cached;
  
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(cacheName);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    return new Response('Offline', { status: 503 });
  }
}

async function staleWhileRevalidate(request, cacheName) {
  const cached = await caches.match(request);
  
  const fetchPromise = fetch(request)
    .then((response) => {
      if (response.ok) {
        caches.open(cacheName).then((cache) => {
          cache.put(request, response.clone());
        });
      }
      return response;
    })
    .catch(() => cached);
  
  return cached || fetchPromise;
}

// Push notification
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  
  const title = data.title || 'Notification';
  const options = {
    body: data.body || 'You have a new notification',
    icon: data.icon || '/icon.png',
    badge: data.badge || '/badge.png',
    data: data.data || {},
    actions: data.actions || []
  };
  
  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Notification click
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  const url = event.notification.data.url || '/';
  
  event.waitUntil(
    clients.matchAll({ type: 'window' })
      .then((clientList) => {
        // Focus existing window if available
        for (const client of clientList) {
          if (client.url === url && 'focus' in client) {
            return client.focus();
          }
        }
        
        // Open new window
        if (clients.openWindow) {
          return clients.openWindow(url);
        }
      })
  );
});

// Message from client
self.addEventListener('message', (event) => {
  if (event.data.action === 'skipWaiting') {
    self.skipWaiting();
  } else if (event.data.action === 'clearCache') {
    event.waitUntil(
      caches.keys().then((keys) => {
        return Promise.all(keys.map((key) => caches.delete(key)));
      })
    );
  }
});

console.log('\n=== Advanced Service Worker ===');
console.log('Multiple strategies');
console.log('Push notifications');
console.log('Client communication');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical service worker implementations
 */

// 1. Progressive Web App (PWA)
console.log('\n=== PWA Service Worker ===');

/*
// Main app (app.js)
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('SW registered:', registration.scope);
        
        // Check for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New version available
              showUpdateNotification();
            }
          });
        });
      })
      .catch((error) => {
        console.error('SW registration failed:', error);
      });
  });
  
  // Listen for messages from SW
  navigator.serviceWorker.addEventListener('message', (event) => {
    if (event.data.type === 'cache-updated') {
      console.log('Cache updated:', event.data.url);
    }
  });
}

function showUpdateNotification() {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <p>New version available!</p>
    <button onclick="updateServiceWorker()">Update</button>
  `;
  document.body.appendChild(notification);
}

function updateServiceWorker() {
  navigator.serviceWorker.getRegistration().then((reg) => {
    reg.waiting.postMessage({ action: 'skipWaiting' });
  });
  
  window.location.reload();
}
*/

// 2. Offline-First App
console.log('\n=== Offline-First App ===');

/*
// sw.js
const CACHE_NAME = 'offline-first-v1';

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/app.js',
        '/offline.html',
        '/data/initial.json'
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((cached) => {
        // Return cached immediately
        const fetchPromise = fetch(event.request)
          .then((response) => {
            // Update cache in background
            if (response.ok) {
              caches.open(CACHE_NAME).then((cache) => {
                cache.put(event.request, response.clone());
              });
            }
            return response;
          })
          .catch(() => cached);
        
        return cached || fetchPromise;
      })
  );
});
*/

// 3. API Response Caching with Refresh
console.log('\n=== API Caching with Refresh ===');

/*
// sw.js
const API_CACHE = 'api-cache-v1';
const API_CACHE_TIME = 5 * 60 * 1000; // 5 minutes

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleApiRequest(event.request));
  }
});

async function handleApiRequest(request) {
  const cache = await caches.open(API_CACHE);
  const cached = await cache.match(request);
  
  if (cached) {
    const cacheTime = cached.headers.get('sw-cache-time');
    
    if (cacheTime && Date.now() - parseInt(cacheTime) < API_CACHE_TIME) {
      // Serve from cache and update in background
      updateApiCache(request, cache);
      return cached;
    }
  }
  
  // Fetch fresh data
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cloned = response.clone();
      const body = await cloned.blob();
      
      const headers = new Headers(cloned.headers);
      headers.set('sw-cache-time', Date.now().toString());
      
      const cachedResponse = new Response(body, {
        status: cloned.status,
        statusText: cloned.statusText,
        headers: headers
      });
      
      await cache.put(request, cachedResponse);
    }
    
    return response;
  } catch (error) {
    // Return stale cache if available
    return cached || new Response('Offline', { status: 503 });
  }
}

async function updateApiCache(request, cache) {
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const body = await response.clone().blob();
      const headers = new Headers(response.headers);
      headers.set('sw-cache-time', Date.now().toString());
      
      const cachedResponse = new Response(body, {
        status: response.status,
        statusText: response.statusText,
        headers: headers
      });
      
      await cache.put(request, cachedResponse);
      
      // Notify clients about update
      const clients = await self.clients.matchAll();
      clients.forEach((client) => {
        client.postMessage({
          type: 'api-updated',
          url: request.url
        });
      });
    }
  } catch (error) {
    // Silently fail
  }
}
*/

// 4. Analytics Queueing
console.log('\n=== Analytics Queue ===');

/*
// sw.js
const ANALYTICS_QUEUE = 'analytics-queue-v1';

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  if (url.pathname.startsWith('/analytics')) {
    event.respondWith(handleAnalytics(event.request));
  }
});

async function handleAnalytics(request) {
  try {
    return await fetch(request);
  } catch (error) {
    // Queue analytics for later
    const data = await request.clone().text();
    await queueAnalytics(request.url, data);
    
    return new Response('Queued', { status: 202 });
  }
}

async function queueAnalytics(url, data) {
  const cache = await caches.open(ANALYTICS_QUEUE);
  const queue = await getQueue(cache);
  
  queue.push({ url, data, timestamp: Date.now() });
  
  await cache.put(
    '/queue',
    new Response(JSON.stringify(queue))
  );
  
  // Register background sync
  await self.registration.sync.register('analytics-sync');
}

async function getQueue(cache) {
  const response = await cache.match('/queue');
  return response ? response.json() : [];
}

self.addEventListener('sync', (event) => {
  if (event.tag === 'analytics-sync') {
    event.waitUntil(syncAnalytics());
  }
});

async function syncAnalytics() {
  const cache = await caches.open(ANALYTICS_QUEUE);
  const queue = await getQueue(cache);
  
  if (queue.length === 0) return;
  
  const results = await Promise.allSettled(
    queue.map((item) => {
      return fetch(item.url, {
        method: 'POST',
        body: item.data
      });
    })
  );
  
  // Remove successfully synced items
  const remaining = queue.filter((_, i) => results[i].status === 'rejected');
  
  if (remaining.length > 0) {
    await cache.put('/queue', new Response(JSON.stringify(remaining)));
  } else {
    await cache.delete('/queue');
  }
}
*/
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Service Worker Caching Strategies:
┌──────────────────────┬────────────────────────────────┐
│ Strategy             │ Use Case                       │
├──────────────────────┼────────────────────────────────┤
│ Cache First          │ Static assets (CSS, JS, images)│
│                      │ Fastest, best for immutables   │
├──────────────────────┼────────────────────────────────┤
│ Network First        │ Dynamic content, API responses │
│                      │ Fresh data, cache as fallback  │
├──────────────────────┼────────────────────────────────┤
│ Stale-While-         │ User-generated content         │
│ Revalidate           │ Instant load, update background│
├──────────────────────┼────────────────────────────────┤
│ Network Only         │ Real-time data, POST requests  │
│                      │ Never cached                   │
├──────────────────────┼────────────────────────────────┤
│ Cache Only           │ Pre-cached during install      │
│                      │ App shell pattern              │
└──────────────────────┴────────────────────────────────┘

Key Concepts:
• Install: One-time setup, precache assets
• Activate: Clean old caches, take control
• Fetch: Intercept network requests
• Cache API: Store responses by request
• Scope: SW controls URLs within its scope
• Update: Install new SW, activate on next load
• skipWaiting(): Activate immediately
• clients.claim(): Take control of pages

Benefits:
• Offline functionality
• Faster load times (cache)
• Reduced bandwidth
• Better reliability
• Progressive enhancement
• Background sync
• Push notifications

Best Practices:
• Version your caches
• Clean old caches in activate
• Don't cache authentication
• Set reasonable cache sizes
• Use appropriate strategy per resource
• Handle errors gracefully
• Provide offline fallback
• Test offline scenarios

Cache Versioning:
• Include version in cache name
• Delete old versions on activate
• Prevents stale data
• Example: 'my-app-v1', 'my-app-v2'

Lifecycle:
1. Register: navigator.serviceWorker.register()
2. Install: Download, cache assets
3. Activate: Clean up, take control
4. Fetch: Intercept requests
5. Update: New version available

Background Sync:
• Queue failed requests
• Sync when connection restored
• registration.sync.register()
• sync event listener
• Reliable data submission

Push Notifications:
• Engage users even when app closed
• push event listener
• showNotification()
• notificationclick event
• Requires user permission

Common Patterns:
• App Shell: Cache UI, network for content
• Offline Page: Fallback when offline
• Stale While Revalidate: Instant + fresh
• Cache Then Network: Best of both
• Network Then Cache: Fresh with fallback

Performance Metrics:
• First Load: Slower (SW registration)
• Subsequent Loads: 50-90% faster
• Offline Support: 100% functional
• Data Usage: 60-80% reduction
• Time to Interactive: Significantly faster

Debugging:
• Chrome DevTools > Application > Service Workers
• View cache contents
• Unregister for testing
• Update on reload option
• Console logging

Limitations:
• HTTPS only (or localhost)
• Same-origin policy
• No DOM access
• Async only (no sync XHR)
• Browser support (95%+)

Security:
• HTTPS required (except localhost)
• Cannot access cross-origin without CORS
• Content Security Policy applies
• Careful with cache poisoning

Testing:
• Test offline mode
• Test cache updates
• Test different strategies
• Test error scenarios
• Test on real devices

Real-World Impact:
• Twitter: 65% pages from cache
• Pinterest: 40% weekly users start offline
• Flipkart: 3x time on site
• Housing.com: 38% lower bounce rate
• Google I/O: Works offline completely

Browser Support:
• Chrome: Yes (since 2014)
• Firefox: Yes
• Safari: Yes (limited)
• Edge: Yes
• Mobile: 95%+ support
`);
```

**Interview Tips:**
- Service Worker: programmable network proxy, runs on separate thread
- Lifecycle: install → activate → fetch (then idle/terminated/fetch again)
- Install event: precache static assets, waitUntil ensures completion
- Activate event: clean old caches, clients.claim() takes control
- Fetch event: intercept requests, return cached or fetch from network
- Cache-first: check cache, fallback to network (static assets)
- Network-first: try network, fallback to cache (dynamic content)
- Stale-while-revalidate: serve cached, update in background
- HTTPS required: security requirement (except localhost)
- Scope: controls all pages under registration path
- skipWaiting(): activate new SW immediately, skip waiting phase
- clients.claim(): control pages immediately without reload
- Cache versioning: include version in cache name, delete old on activate
- caches.open(): access/create cache storage
- cache.addAll(): cache multiple URLs at once
- caches.match(): find cached response for request
- Background sync: queue failed requests, sync when online
- Push notifications: engage users when app closed
- event.waitUntil(): extend event lifetime, wait for async operations
- response.clone(): clone response to cache and return
- No DOM access: separate thread, can't manipulate UI
- Real-world: PWAs (Twitter, Pinterest), offline functionality, faster loads
- Benefits: offline support, 50-90% faster subsequent loads, reduced bandwidth
- Trade-offs: complexity, debugging difficulty, cache management
- Follow-ups: cache strategies, versioning, background sync, push notifications
- Clarify: offline requirements? cache strategy? update frequency?

</details>

130. Implement code splitting with dynamic imports

<details>
<summary><b>Solution</b></summary>

### **Approach 1: Basic Dynamic Import**
```javascript
/**
 * Simple dynamic import for code splitting
 */

// Traditional static import (bundles everything)
// import { heavyFunction } from './heavy-module.js';

// Dynamic import (loads on demand)
async function loadHeavyModule() {
  try {
    const module = await import('./heavy-module.js');
    
    console.log('Module loaded:', module);
    
    // Use the module
    const result = module.heavyFunction();
    console.log('Result:', result);
    
    return module;
  } catch (error) {
    console.error('Failed to load module:', error);
  }
}

// Load module when needed
document.getElementById('btn').addEventListener('click', async () => {
  const module = await loadHeavyModule();
  module.default(); // Default export
});

// Example heavy-module.js
/*
export function heavyFunction() {
  console.log('Heavy computation...');
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += Math.sqrt(i);
  }
  return result;
}

export default function() {
  console.log('Default export called');
}
*/

console.log('=== Basic Dynamic Import ===');
console.log('Loads code on demand');
console.log('Returns a promise');
```

### **Approach 2: Route-Based Code Splitting**
```javascript
/**
 * Split code by routes for SPA
 */

class Router {
  constructor() {
    this.routes = new Map();
    this.currentRoute = null;
    
    window.addEventListener('popstate', () => this.handleRoute());
  }
  
  // Register route with lazy-loaded component
  addRoute(path, componentLoader) {
    this.routes.set(path, {
      loader: componentLoader,
      component: null
    });
  }
  
  async navigate(path) {
    // Update browser history
    window.history.pushState({}, '', path);
    await this.handleRoute();
  }
  
  async handleRoute() {
    const path = window.location.pathname;
    const route = this.routes.get(path);
    
    if (!route) {
      console.error('Route not found:', path);
      return;
    }
    
    // Load component if not already loaded
    if (!route.component) {
      console.log('Loading component for:', path);
      
      try {
        const module = await route.loader();
        route.component = module.default;
      } catch (error) {
        console.error('Failed to load route:', error);
        return;
      }
    }
    
    // Render component
    this.currentRoute = path;
    this.render(route.component);
  }
  
  render(Component) {
    const app = document.getElementById('app');
    
    if (!app) return;
    
    // Clear previous content
    app.innerHTML = '';
    
    // Render new component
    if (typeof Component === 'function') {
      const content = Component();
      app.innerHTML = content;
    } else {
      app.innerHTML = Component;
    }
  }
  
  start() {
    this.handleRoute();
  }
}

// Usage:
const router = new Router();

// Register routes with dynamic imports
router.addRoute('/', () => import('./pages/Home.js'));
router.addRoute('/about', () => import('./pages/About.js'));
router.addRoute('/products', () => import('./pages/Products.js'));
router.addRoute('/contact', () => import('./pages/Contact.js'));

// Start router
router.start();

// Navigation
/*
<nav>
  <a href="/" onclick="router.navigate('/'); return false;">Home</a>
  <a href="/about" onclick="router.navigate('/about'); return false;">About</a>
  <a href="/products" onclick="router.navigate('/products'); return false;">Products</a>
</nav>
*/

// Example page component (pages/Home.js)
/*
export default function Home() {
  return `
    <div class="home">
      <h1>Home Page</h1>
      <p>Welcome to our website!</p>
    </div>
  `;
}
*/

console.log('\n=== Route-Based Code Splitting ===');
console.log('Load pages only when navigated to');
console.log('Reduces initial bundle size');
```

### **Approach 3: Component-Based Lazy Loading**
```javascript
/**
 * Lazy load components with loading states
 */

class LazyComponent {
  constructor(loader) {
    this.loader = loader;
    this.component = null;
    this.loading = false;
    this.error = null;
  }
  
  async load() {
    if (this.component) {
      return this.component;
    }
    
    if (this.loading) {
      // Wait for existing load
      return new Promise((resolve) => {
        const checkInterval = setInterval(() => {
          if (!this.loading) {
            clearInterval(checkInterval);
            resolve(this.component);
          }
        }, 100);
      });
    }
    
    this.loading = true;
    this.error = null;
    
    try {
      const module = await this.loader();
      this.component = module.default;
      return this.component;
    } catch (error) {
      this.error = error;
      throw error;
    } finally {
      this.loading = false;
    }
  }
  
  async render(container) {
    // Show loading state
    container.innerHTML = '<div class="loading">Loading...</div>';
    
    try {
      const Component = await this.load();
      
      // Render component
      if (typeof Component === 'function') {
        container.innerHTML = Component();
      } else {
        container.innerHTML = Component;
      }
    } catch (error) {
      // Show error state
      container.innerHTML = `
        <div class="error">
          <p>Failed to load component</p>
          <button onclick="this.parentElement.retry()">Retry</button>
        </div>
      `;
      
      container.querySelector('.error').retry = () => this.render(container);
    }
  }
}

// Usage:
const HeavyChart = new LazyComponent(() => import('./components/HeavyChart.js'));
const ImageGallery = new LazyComponent(() => import('./components/ImageGallery.js'));
const VideoPlayer = new LazyComponent(() => import('./components/VideoPlayer.js'));

// Load component when needed
document.getElementById('show-chart').addEventListener('click', () => {
  const container = document.getElementById('chart-container');
  HeavyChart.render(container);
});

document.getElementById('show-gallery').addEventListener('click', () => {
  const container = document.getElementById('gallery-container');
  ImageGallery.render(container);
});

console.log('\n=== Component-Based Lazy Loading ===');
console.log('Load components on demand');
console.log('With loading and error states');
```

### **Approach 4: Conditional Loading Based on Features**
```javascript
/**
 * Load features conditionally
 */

class FeatureLoader {
  constructor() {
    this.features = new Map();
    this.loaded = new Set();
  }
  
  register(featureName, loader, condition = () => true) {
    this.features.set(featureName, {
      loader,
      condition,
      module: null
    });
  }
  
  async load(featureName) {
    if (this.loaded.has(featureName)) {
      return this.features.get(featureName).module;
    }
    
    const feature = this.features.get(featureName);
    
    if (!feature) {
      throw new Error(`Feature not found: ${featureName}`);
    }
    
    // Check condition
    if (!feature.condition()) {
      console.log(`Feature ${featureName} condition not met`);
      return null;
    }
    
    console.log(`Loading feature: ${featureName}`);
    
    try {
      const module = await feature.loader();
      feature.module = module.default || module;
      this.loaded.add(featureName);
      
      return feature.module;
    } catch (error) {
      console.error(`Failed to load feature ${featureName}:`, error);
      throw error;
    }
  }
  
  async loadMultiple(featureNames) {
    return Promise.all(
      featureNames.map(name => this.load(name))
    );
  }
  
  isLoaded(featureName) {
    return this.loaded.has(featureName);
  }
}

// Usage:
const featureLoader = new FeatureLoader();

// Register features with conditions
featureLoader.register(
  'admin-panel',
  () => import('./features/AdminPanel.js'),
  () => user.isAdmin
);

featureLoader.register(
  'analytics',
  () => import('./features/Analytics.js'),
  () => user.hasPermission('analytics')
);

featureLoader.register(
  'advanced-editor',
  () => import('./features/AdvancedEditor.js'),
  () => user.isPremium
);

featureLoader.register(
  'mobile-features',
  () => import('./features/MobileFeatures.js'),
  () => window.innerWidth < 768
);

// Load feature when needed
async function showAdminPanel() {
  try {
    const AdminPanel = await featureLoader.load('admin-panel');
    
    if (AdminPanel) {
      AdminPanel.render();
    } else {
      alert('You do not have access to this feature');
    }
  } catch (error) {
    console.error('Failed to load admin panel:', error);
  }
}

// Preload features on idle
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => {
    featureLoader.load('analytics');
  });
}

console.log('\n=== Conditional Feature Loading ===');
console.log('Load features based on conditions');
console.log('Role-based, device-based, etc.');
```

### **Approach 5: Prefetching and Preloading**
```javascript
/**
 * Smart prefetching for better performance
 */

class SmartLoader {
  constructor() {
    this.modules = new Map();
    this.prefetching = new Set();
    this.loaded = new Set();
  }
  
  register(moduleName, loader, options = {}) {
    this.modules.set(moduleName, {
      loader,
      priority: options.priority || 'low',
      prefetch: options.prefetch !== false,
      preload: options.preload || false
    });
  }
  
  async load(moduleName) {
    if (this.loaded.has(moduleName)) {
      return this.modules.get(moduleName).module;
    }
    
    const moduleConfig = this.modules.get(moduleName);
    
    if (!moduleConfig) {
      throw new Error(`Module not found: ${moduleName}`);
    }
    
    console.log(`Loading module: ${moduleName}`);
    
    try {
      const module = await moduleConfig.loader();
      moduleConfig.module = module.default || module;
      this.loaded.add(moduleName);
      
      return moduleConfig.module;
    } catch (error) {
      console.error(`Failed to load module ${moduleName}:`, error);
      throw error;
    }
  }
  
  prefetch(moduleName) {
    if (this.loaded.has(moduleName) || this.prefetching.has(moduleName)) {
      return;
    }
    
    this.prefetching.add(moduleName);
    
    const moduleConfig = this.modules.get(moduleName);
    
    if (!moduleConfig || !moduleConfig.prefetch) {
      return;
    }
    
    console.log(`Prefetching module: ${moduleName}`);
    
    // Use link rel="prefetch" for browser optimization
    const link = document.createElement('link');
    link.rel = 'prefetch';
    link.as = 'script';
    link.href = this.getModulePath(moduleName);
    
    document.head.appendChild(link);
    
    // Actually load the module
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => {
        this.load(moduleName);
      });
    } else {
      setTimeout(() => {
        this.load(moduleName);
      }, 100);
    }
  }
  
  preload(moduleName) {
    if (this.loaded.has(moduleName)) {
      return;
    }
    
    const moduleConfig = this.modules.get(moduleName);
    
    if (!moduleConfig) {
      return;
    }
    
    console.log(`Preloading module: ${moduleName}`);
    
    // Use link rel="preload" for critical resources
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'script';
    link.href = this.getModulePath(moduleName);
    
    document.head.appendChild(link);
    
    // Load immediately
    this.load(moduleName);
  }
  
  prefetchOnHover(moduleName, element) {
    let hoverTimer;
    
    element.addEventListener('mouseenter', () => {
      hoverTimer = setTimeout(() => {
        this.prefetch(moduleName);
      }, 100);
    });
    
    element.addEventListener('mouseleave', () => {
      clearTimeout(hoverTimer);
    });
  }
  
  prefetchOnVisible(moduleName, element) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.prefetch(moduleName);
          observer.unobserve(element);
        }
      });
    }, { rootMargin: '50px' });
    
    observer.observe(element);
  }
  
  getModulePath(moduleName) {
    // This would need to match your build configuration
    return `/chunks/${moduleName}.js`;
  }
}

// Usage:
const smartLoader = new SmartLoader();

// Register modules
smartLoader.register('home', () => import('./pages/Home.js'), {
  preload: true,
  priority: 'high'
});

smartLoader.register('products', () => import('./pages/Products.js'), {
  prefetch: true,
  priority: 'medium'
});

smartLoader.register('checkout', () => import('./pages/Checkout.js'), {
  prefetch: true,
  priority: 'high'
});

smartLoader.register('admin', () => import('./pages/Admin.js'), {
  prefetch: false,
  priority: 'low'
});

// Preload critical module
smartLoader.preload('home');

// Prefetch on hover
const productsLink = document.querySelector('a[href="/products"]');
smartLoader.prefetchOnHover('products', productsLink);

// Prefetch when visible
const checkoutButton = document.querySelector('.checkout-button');
smartLoader.prefetchOnVisible('checkout', checkoutButton);

// Prefetch on idle
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => {
    smartLoader.prefetch('products');
    smartLoader.prefetch('checkout');
  });
}

console.log('\n=== Smart Prefetching ===');
console.log('Prefetch on hover, visible, idle');
console.log('Optimize loading performance');
```

### **Real-World Use Cases**
```javascript
/**
 * Practical code splitting implementations
 */

// 1. Modal Dialog Lazy Loading
console.log('\n=== Modal Dialog Lazy Loading ===');

class ModalManager {
  constructor() {
    this.modals = new Map();
  }
  
  register(modalName, loader) {
    this.modals.set(modalName, {
      loader,
      component: null,
      loading: false
    });
  }
  
  async show(modalName, props = {}) {
    const modal = this.modals.get(modalName);
    
    if (!modal) {
      throw new Error(`Modal not found: ${modalName}`);
    }
    
    // Load component if not loaded
    if (!modal.component && !modal.loading) {
      modal.loading = true;
      
      try {
        const module = await modal.loader();
        modal.component = module.default;
      } catch (error) {
        modal.loading = false;
        throw error;
      }
      
      modal.loading = false;
    }
    
    // Wait if loading
    while (modal.loading) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Show modal
    if (modal.component) {
      modal.component.show(props);
    }
  }
}

/*
// Usage:
const modalManager = new ModalManager();

modalManager.register('login', () => import('./modals/LoginModal.js'));
modalManager.register('settings', () => import('./modals/SettingsModal.js'));
modalManager.register('confirm', () => import('./modals/ConfirmModal.js'));

// Show modal
document.getElementById('login-btn').addEventListener('click', () => {
  modalManager.show('login');
});

document.getElementById('settings-btn').addEventListener('click', () => {
  modalManager.show('settings');
});
*/

// 2. Tab-Based Content Loading
console.log('\n=== Tab-Based Loading ===');

class TabManager {
  constructor(containerSelector) {
    this.container = document.querySelector(containerSelector);
    this.tabs = new Map();
    this.activeTab = null;
  }
  
  addTab(tabId, label, contentLoader) {
    this.tabs.set(tabId, {
      label,
      loader: contentLoader,
      content: null,
      loaded: false
    });
  }
  
  async showTab(tabId) {
    const tab = this.tabs.get(tabId);
    
    if (!tab) return;
    
    // Load content if not loaded
    if (!tab.loaded) {
      this.showLoading();
      
      try {
        const module = await tab.loader();
        tab.content = module.default;
        tab.loaded = true;
      } catch (error) {
        this.showError(error);
        return;
      }
    }
    
    // Render content
    this.activeTab = tabId;
    this.render(tab.content);
  }
  
  showLoading() {
    this.container.innerHTML = '<div class="loading">Loading...</div>';
  }
  
  showError(error) {
    this.container.innerHTML = `<div class="error">Error: ${error.message}</div>`;
  }
  
  render(content) {
    if (typeof content === 'function') {
      this.container.innerHTML = content();
    } else {
      this.container.innerHTML = content;
    }
  }
  
  renderTabs() {
    const tabsHtml = Array.from(this.tabs.entries())
      .map(([id, tab]) => {
        const active = id === this.activeTab ? 'active' : '';
        return `<button class="tab ${active}" data-tab="${id}">${tab.label}</button>`;
      })
      .join('');
    
    const tabBar = document.createElement('div');
    tabBar.className = 'tab-bar';
    tabBar.innerHTML = tabsHtml;
    
    tabBar.addEventListener('click', (e) => {
      if (e.target.classList.contains('tab')) {
        this.showTab(e.target.dataset.tab);
      }
    });
    
    this.container.parentElement.insertBefore(tabBar, this.container);
  }
}

/*
// Usage:
const tabManager = new TabManager('#tab-content');

tabManager.addTab('overview', 'Overview', () => import('./tabs/Overview.js'));
tabManager.addTab('analytics', 'Analytics', () => import('./tabs/Analytics.js'));
tabManager.addTab('settings', 'Settings', () => import('./tabs/Settings.js'));

tabManager.renderTabs();
tabManager.showTab('overview');
*/

// 3. Viewport-Based Loading
console.log('\n=== Viewport-Based Loading ===');

class ViewportLoader {
  constructor() {
    this.components = new Map();
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      { rootMargin: '100px' }
    );
  }
  
  register(element, loader) {
    this.components.set(element, {
      loader,
      loaded: false,
      loading: false
    });
    
    this.observer.observe(element);
  }
  
  handleIntersection(entries) {
    entries.forEach(async (entry) => {
      if (entry.isIntersecting) {
        const element = entry.target;
        const component = this.components.get(element);
        
        if (!component || component.loaded || component.loading) {
          return;
        }
        
        component.loading = true;
        element.innerHTML = '<div class="loading">Loading...</div>';
        
        try {
          const module = await component.loader();
          const content = module.default;
          
          element.innerHTML = typeof content === 'function' ? content() : content;
          
          component.loaded = true;
          this.observer.unobserve(element);
        } catch (error) {
          element.innerHTML = '<div class="error">Failed to load</div>';
        } finally {
          component.loading = false;
        }
      }
    });
  }
}

/*
// Usage:
const viewportLoader = new ViewportLoader();

// Register components to load when visible
const heavyCharts = document.querySelectorAll('.lazy-chart');
heavyCharts.forEach((chart) => {
  viewportLoader.register(chart, () => import('./components/Chart.js'));
});

const galleries = document.querySelectorAll('.lazy-gallery');
galleries.forEach((gallery) => {
  viewportLoader.register(gallery, () => import('./components/Gallery.js'));
});
*/

// 4. Bundle Analyzer / Size Tracker
console.log('\n=== Bundle Size Tracking ===');

class BundleTracker {
  constructor() {
    this.bundles = new Map();
    this.totalSize = 0;
    
    if (performance.getEntriesByType) {
      this.trackInitialBundles();
    }
  }
  
  trackInitialBundles() {
    const resources = performance.getEntriesByType('resource');
    
    resources
      .filter(r => r.initiatorType === 'script')
      .forEach(r => {
        this.recordBundle(r.name, r.transferSize);
      });
  }
  
  recordBundle(name, size) {
    this.bundles.set(name, {
      size,
      loadTime: performance.now()
    });
    
    this.totalSize += size;
    
    console.log(`Bundle loaded: ${name} (${this.formatSize(size)})`);
  }
  
  async trackDynamicImport(importFn) {
    const startTime = performance.now();
    
    const module = await importFn();
    
    const endTime = performance.now();
    const loadTime = endTime - startTime;
    
    // Try to find the resource
    const resources = performance.getEntriesByType('resource');
    const recentScript = resources
      .filter(r => r.initiatorType === 'script')
      .filter(r => r.startTime >= startTime)
      .pop();
    
    if (recentScript) {
      this.recordBundle(recentScript.name, recentScript.transferSize);
    }
    
    console.log(`Dynamic import completed in ${loadTime.toFixed(2)}ms`);
    
    return module;
  }
  
  formatSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
  }
  
  getReport() {
    return {
      totalBundles: this.bundles.size,
      totalSize: this.formatSize(this.totalSize),
      bundles: Array.from(this.bundles.entries()).map(([name, data]) => ({
        name,
        size: this.formatSize(data.size),
        loadTime: data.loadTime.toFixed(2) + 'ms'
      }))
    };
  }
  
  printReport() {
    const report = this.getReport();
    
    console.log('\n=== Bundle Report ===');
    console.log(`Total Bundles: ${report.totalBundles}`);
    console.log(`Total Size: ${report.totalSize}`);
    console.log('\nBundles:');
    
    report.bundles.forEach(bundle => {
      console.log(`  ${bundle.name}: ${bundle.size} (loaded at ${bundle.loadTime})`);
    });
  }
}

/*
// Usage:
const bundleTracker = new BundleTracker();

// Track dynamic imports
const module = await bundleTracker.trackDynamicImport(
  () => import('./heavy-module.js')
);

// Print report
setTimeout(() => {
  bundleTracker.printReport();
}, 5000);
*/

// 5. Progressive Enhancement with Code Splitting
console.log('\n=== Progressive Enhancement ===');

class ProgressiveApp {
  constructor() {
    this.features = {
      core: null,
      enhanced: null,
      advanced: null
    };
  }
  
  async init() {
    // Always load core features
    await this.loadCore();
    
    // Load enhanced features on capable devices
    if (this.isCapableDevice()) {
      await this.loadEnhanced();
    }
    
    // Load advanced features on high-end devices
    if (this.isHighEndDevice()) {
      await this.loadAdvanced();
    }
  }
  
  async loadCore() {
    console.log('Loading core features...');
    const module = await import('./features/core.js');
    this.features.core = module.default;
    this.features.core.init();
  }
  
  async loadEnhanced() {
    console.log('Loading enhanced features...');
    const module = await import('./features/enhanced.js');
    this.features.enhanced = module.default;
    this.features.enhanced.init();
  }
  
  async loadAdvanced() {
    console.log('Loading advanced features...');
    const module = await import('./features/advanced.js');
    this.features.advanced = module.default;
    this.features.advanced.init();
  }
  
  isCapableDevice() {
    return (
      'IntersectionObserver' in window &&
      'fetch' in window &&
      navigator.hardwareConcurrency >= 4
    );
  }
  
  isHighEndDevice() {
    return (
      navigator.hardwareConcurrency >= 8 &&
      navigator.deviceMemory >= 4
    );
  }
}

/*
// Usage:
const app = new ProgressiveApp();
app.init();
*/
```

### **Performance Comparison**
```javascript
console.log('\n=== Performance ===');

console.log(`
Code Splitting Strategies:
┌──────────────────────┬────────────────────────────────┐
│ Strategy             │ Use Case                       │
├──────────────────────┼────────────────────────────────┤
│ Route-Based          │ Load page components per route │
│                      │ Best for SPAs                  │
├──────────────────────┼────────────────────────────────┤
│ Component-Based      │ Load heavy components on demand│
│                      │ Modals, charts, editors        │
├──────────────────────┼────────────────────────────────┤
│ Feature-Based        │ Load features conditionally    │
│                      │ Admin panels, premium features │
├──────────────────────┼────────────────────────────────┤
│ Vendor Splitting     │ Separate vendor/library code   │
│                      │ Better caching                 │
├──────────────────────┼────────────────────────────────┤
│ Dynamic Imports      │ Load anything on demand        │
│                      │ Returns Promise<module>        │
└──────────────────────┴────────────────────────────────┘

Key Concepts:
• Dynamic import(): ES module syntax, returns Promise
• Code splitting: Break bundle into smaller chunks
• Lazy loading: Load code only when needed
• Webpack/Vite: Automatic chunk creation
• import() creates separate bundle chunk
• Tree shaking: Remove unused code

Benefits:
• Faster initial load (50-80% reduction)
• Smaller bundle size
• Better caching (vendor chunks)
• Improved TTI (Time to Interactive)
• Pay-for-what-you-use
• Better mobile experience

Dynamic Import Syntax:
• import('./module.js') - Returns Promise
• await import('./module.js') - Async/await
• .then(module => module.default)
• .catch(error => handle error)
• Named exports: module.namedExport
• Default export: module.default

Webpack Magic Comments:
• /* webpackChunkName: "my-chunk" */
• /* webpackPrefetch: true */
• /* webpackPreload: true */
• /* webpackMode: "lazy" */
• Example: import(/* webpackChunkName: "lodash" */ 'lodash')

Prefetch vs Preload:
• Prefetch: Low priority, load when idle
• Preload: High priority, load immediately
• <link rel="prefetch"> for future navigation
• <link rel="preload"> for current page

Best Practices:
• Split by routes (page level)
• Split heavy components (charts, editors)
• Keep common code in vendor bundle
• Use magic comments for chunk names
• Prefetch likely-needed modules
• Show loading states
• Handle errors gracefully
• Monitor bundle sizes

Route-Based Splitting:
• Each route = separate bundle
• Loaded when navigating
• Best initial load improvement
• Example: Home, About, Products pages

Component-Based Splitting:
• Heavy components loaded on demand
• Modals, dialogs, tooltips
• Charts, graphs, visualizations
• Video players, editors

Conditional Loading:
• Load based on user role
• Load based on device capabilities
• Load based on feature flags
• Progressive enhancement

Bundle Size Impact:
• Initial bundle: 70-90% smaller
• Total bandwidth: Same or slightly more
• User experience: Much better
• Time to Interactive: 50-80% faster

Common Patterns:
• React.lazy() + Suspense
• Vue async components
• Angular lazy modules
• Webpack splitChunks
• Dynamic import() everywhere

Loading States:
• Show spinner while loading
• Skeleton screens
• Progressive content reveal
• Error boundaries for failures

Error Handling:
• Try/catch for async imports
• Fallback UI for failures
• Retry logic
• Report errors to monitoring

Performance Metrics:
• Initial bundle size
• Time to Interactive (TTI)
• First Contentful Paint (FCP)
• Largest Contentful Paint (LCP)
• Total Blocking Time (TBT)

Build Configuration:
• Webpack: splitChunks optimization
• Vite: manualChunks configuration
• Rollup: output.manualChunks
• Configure chunk size limits

Caching Strategy:
• Vendor chunks: Long cache time
• App chunks: Version in filename
• Content hashing: [contenthash]
• Immutable chunks for better caching

Real-World Examples:
• Twitter: Route-based splitting
• Facebook: Aggressive code splitting
• Netflix: Component lazy loading
• Amazon: Feature-based splitting
• Google: Dynamic feature loading

Testing:
• Test with slow network
• Test bundle sizes
• Test loading states
• Test error scenarios
• Lighthouse audit

Common Pitfalls:
• Too many chunks (overhead)
• Not showing loading states
• Not handling errors
• Splitting too aggressively
• Forgetting to prefetch

Browser Support:
• Dynamic import(): 95%+
• Modern browsers only
• Fallback: bundle everything
• Babel transforms for older browsers

Optimization Tips:
• Group related code together
• Use vendor chunks for libraries
• Prefetch on hover/visible
• Lazy load below fold content
• Monitor with analytics

Tools:
• Webpack Bundle Analyzer
• Vite Bundle Visualizer
• Chrome Coverage tool
• Lighthouse performance audit
• bundlephobia.com for package sizes
`);
```

**Interview Tips:**
- Code splitting: break bundle into smaller chunks loaded on demand
- Dynamic import(): ES module syntax, import('./module.js') returns Promise
- Benefits: 50-80% faster initial load, smaller bundle size, better mobile experience
- Route-based: split by pages/routes, best for SPAs
- Component-based: lazy load heavy components (modals, charts, editors)
- Feature-based: conditional loading based on user role, device, permissions
- Vendor splitting: separate vendor/library code, better caching
- import() creates separate bundle chunk automatically (Webpack/Vite)
- await import('./module.js'): use with async/await
- module.default: access default export from dynamic import
- module.namedExport: access named exports
- Loading states: show spinner/skeleton while module loads
- Error handling: try/catch for failed imports, retry logic
- Webpack magic comments: /* webpackChunkName: "name" */
- Prefetch: load on idle (link rel="prefetch")
- Preload: load immediately (link rel="preload")
- Prefetch on hover: start loading when user hovers over link
- IntersectionObserver: load when component enters viewport
- React.lazy() + Suspense: React's built-in code splitting
- splitChunks: Webpack optimization for automatic splitting
- Content hashing: [contenthash] in filename for cache busting
- Bundle analyzer: visualize and optimize chunk sizes
- Real-world: Twitter routes, Facebook components, Netflix lazy loading
- Performance: measure with Lighthouse, Core Web Vitals, bundle size
- Trade-offs: more chunks = more HTTP requests, need balance
- Best practice: split by routes + heavy components + vendor
- Follow-ups: bundle optimization, caching strategy, error handling
- Clarify: framework used? build tool? performance targets?

</details>

---

## **Question Categories Overview**

### **By Topic:**
- **Arrays & Strings**: Questions 1-10, 31-50
- **Basic Algorithms**: Questions 11-20
- **Objects & Data Structures**: Questions 21-30, 61-65, 96-105
- **DOM & Browser**: Questions 51-60
- **Asynchronous Programming**: Questions 76-85
- **Advanced Functions**: Questions 86-95
- **Graph & Tree Algorithms**: Questions 96-109
- **Problem Solving**: Questions 106-115
- **Real-World Scenarios**: Questions 116-130

### **By Difficulty Distribution:**
- **Easy**: 30 questions (foundational concepts)
- **Medium**: 35 questions (practical applications)
- **Hard**: 30 questions (advanced concepts)
- **Extra Hard**: 25 questions (expert level)
- **Bonus**: 10 questions (framework-specific)

**Total: 130 Coding Questions**

---

## **Interview Preparation Tips**

1. **Start with Easy**: Master fundamentals before moving to complex problems
2. **Practice Daily**: Solve at least 2-3 problems every day
3. **Understand, Don't Memorize**: Focus on problem-solving patterns
4. **Time Yourself**: Practice under interview conditions (30-45 min per problem)
5. **Optimize**: First make it work, then make it efficient
6. **Test Your Code**: Always write test cases
7. **Explain Your Thinking**: Practice explaining your approach out loud
8. **Learn Multiple Approaches**: Know brute force and optimized solutions
9. **Review & Refactor**: Revisit problems and improve your solutions
10. **Mock Interviews**: Practice with peers or on platforms like Pramp

---

## **Common Patterns to Master**

- **Two Pointers**: Array/string problems
- **Sliding Window**: Substring/subarray problems
- **Fast & Slow Pointers**: Linked list cycle detection
- **Recursion & Backtracking**: Permutations, combinations
- **Dynamic Programming**: Optimization problems
- **Binary Search**: Sorted array problems
- **BFS/DFS**: Tree and graph traversal
- **Hash Tables**: Frequency counting, lookups
- **Stack/Queue**: Parentheses matching, level-order traversal
- **Divide & Conquer**: Sorting, searching

---

## **Resources for Practice**

- **LeetCode**: leetcode.com (Focus on Easy & Medium)
- **HackerRank**: hackerrank.com/domains/javascript
- **CodeWars**: codewars.com
- **Exercism**: exercism.io/tracks/javascript
- **JavaScript30**: javascript30.com (Practical projects)
- **Frontend Mentor**: frontendmentor.io (UI challenges)

---

**Good luck with your interviews! 🚀**
